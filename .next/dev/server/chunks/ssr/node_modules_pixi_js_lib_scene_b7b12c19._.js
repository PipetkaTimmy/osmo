module.exports = [
"[project]/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "definedProps",
    ()=>definedProps
]);
"use strict";
function definedProps(obj) {
    const result = {};
    for(const key in obj){
        if (obj[key] !== void 0) {
            result[key] = obj[key];
        }
    }
    return result;
}
;
 //# sourceMappingURL=definedProps.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Bounds",
    ()=>Bounds
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const defaultMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
class Bounds {
    /**
   * Creates a new Bounds object.
   * @param minX - The minimum X coordinate of the bounds.
   * @param minY - The minimum Y coordinate of the bounds.
   * @param maxX - The maximum X coordinate of the bounds.
   * @param maxY - The maximum Y coordinate of the bounds.
   */ constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity){
        /**
     * The minimum X coordinate of the bounds.
     * Represents the leftmost edge of the bounding box.
     * @example
     * ```ts
     * const bounds = new Bounds();
     * // Set left edge
     * bounds.minX = 100;
     * ```
     * @default Infinity
     */ this.minX = Infinity;
        /**
     * The minimum Y coordinate of the bounds.
     * Represents the topmost edge of the bounding box.
     * @example
     * ```ts
     * const bounds = new Bounds();
     * // Set top edge
     * bounds.minY = 100;
     * ```
     * @default Infinity
     */ this.minY = Infinity;
        /**
     * The maximum X coordinate of the bounds.
     * Represents the rightmost edge of the bounding box.
     * @example
     * ```ts
     * const bounds = new Bounds();
     * // Set right edge
     * bounds.maxX = 200;
     * // Get width
     * const width = bounds.maxX - bounds.minX;
     * ```
     * @default -Infinity
     */ this.maxX = -Infinity;
        /**
     * The maximum Y coordinate of the bounds.
     * Represents the bottommost edge of the bounding box.
     * @example
     * ```ts
     * const bounds = new Bounds();
     * // Set bottom edge
     * bounds.maxY = 200;
     * // Get height
     * const height = bounds.maxY - bounds.minY;
     * ```
     * @default -Infinity
     */ this.maxY = -Infinity;
        /**
     * The transformation matrix applied to this bounds object.
     * Used when calculating bounds with transforms.
     * @example
     * ```ts
     * const bounds = new Bounds();
     *
     * // Apply translation matrix
     * bounds.matrix = new Matrix()
     *     .translate(100, 100);
     *
     * // Combine transformations
     * bounds.matrix = new Matrix()
     *     .translate(50, 50)
     *     .rotate(Math.PI / 4)
     *     .scale(2, 2);
     *
     * // Use in bounds calculations
     * bounds.addFrame(0, 0, 100, 100); // Uses current matrix
     * bounds.addFrame(0, 0, 100, 100, customMatrix); // Override matrix
     * ```
     * @advanced
     */ this.matrix = defaultMatrix;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    /**
   * Checks if bounds are empty, meaning either width or height is zero or negative.
   * Empty bounds occur when min values exceed max values on either axis.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Check if newly created bounds are empty
   * console.log(bounds.isEmpty()); // true, default bounds are empty
   *
   * // Add frame and check again
   * bounds.addFrame(0, 0, 100, 100);
   * console.log(bounds.isEmpty()); // false, bounds now have area
   *
   * // Clear bounds
   * bounds.clear();
   * console.log(bounds.isEmpty()); // true, bounds are empty again
   * ```
   * @returns True if bounds are empty (have no area)
   * @see {@link Bounds#clear} For resetting bounds
   * @see {@link Bounds#isValid} For checking validity
   */ isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY;
    }
    /**
   * The bounding rectangle representation of these bounds.
   * Lazily creates and updates a Rectangle instance based on the current bounds.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Get rectangle representation
   * const rect = bounds.rectangle;
   * console.log(rect.x, rect.y, rect.width, rect.height);
   *
   * // Use for hit testing
   * if (bounds.rectangle.contains(mouseX, mouseY)) {
   *     console.log('Mouse is inside bounds!');
   * }
   * ```
   * @see {@link Rectangle} For rectangle methods
   * @see {@link Bounds.isEmpty} For bounds validation
   */ get rectangle() {
        if (!this._rectangle) {
            this._rectangle = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"]();
        }
        const rectangle = this._rectangle;
        if (this.minX > this.maxX || this.minY > this.maxY) {
            rectangle.x = 0;
            rectangle.y = 0;
            rectangle.width = 0;
            rectangle.height = 0;
        } else {
            rectangle.copyFromBounds(this);
        }
        return rectangle;
    }
    /**
   * Clears the bounds and resets all coordinates to their default values.
   * Resets the transformation matrix back to identity.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.isEmpty()); // false
   * // Clear the bounds
   * bounds.clear();
   * console.log(bounds.isEmpty()); // true
   * ```
   * @returns This bounds object for chaining
   */ clear() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.matrix = defaultMatrix;
        return this;
    }
    /**
   * Sets the bounds directly using coordinate values.
   * Provides a way to set all bounds values at once.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.set(0, 0, 100, 100);
   * ```
   * @param x0 - Left X coordinate of frame
   * @param y0 - Top Y coordinate of frame
   * @param x1 - Right X coordinate of frame
   * @param y1 - Bottom Y coordinate of frame
   * @see {@link Bounds#addFrame} For matrix-aware bounds setting
   * @see {@link Bounds#clear} For resetting bounds
   */ set(x0, y0, x1, y1) {
        this.minX = x0;
        this.minY = y0;
        this.maxX = x1;
        this.maxY = y1;
    }
    /**
   * Adds a rectangular frame to the bounds, optionally transformed by a matrix.
   * Updates the bounds to encompass the new frame coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.addFrame(0, 0, 100, 100);
   *
   * // Add transformed frame
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addFrame(0, 0, 100, 100, matrix);
   * ```
   * @param x0 - Left X coordinate of frame
   * @param y0 - Top Y coordinate of frame
   * @param x1 - Right X coordinate of frame
   * @param y1 - Bottom Y coordinate of frame
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addRect} For adding Rectangle objects
   * @see {@link Bounds#addBounds} For adding other Bounds
   */ addFrame(x0, y0, x1, y1, matrix) {
        matrix || (matrix = this.matrix);
        const a = matrix.a;
        const b = matrix.b;
        const c = matrix.c;
        const d = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        let x = a * x0 + c * y0 + tx;
        let y = b * x0 + d * y0 + ty;
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
        x = a * x1 + c * y0 + tx;
        y = b * x1 + d * y0 + ty;
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
        x = a * x0 + c * y1 + tx;
        y = b * x0 + d * y1 + ty;
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
        x = a * x1 + c * y1 + tx;
        y = b * x1 + d * y1 + ty;
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    /**
   * Adds a rectangle to the bounds, optionally transformed by a matrix.
   * Updates the bounds to encompass the given rectangle.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * // Add simple rectangle
   * const rect = new Rectangle(0, 0, 100, 100);
   * bounds.addRect(rect);
   *
   * // Add transformed rectangle
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addRect(rect, matrix);
   * ```
   * @param rect - The rectangle to be added
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding raw coordinates
   * @see {@link Bounds#addBounds} For adding other bounds
   */ addRect(rect, matrix) {
        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
    }
    /**
   * Adds another bounds object to this one, optionally transformed by a matrix.
   * Expands the bounds to include the given bounds' area.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Add child bounds
   * const childBounds = sprite.getBounds();
   * bounds.addBounds(childBounds);
   *
   * // Add transformed bounds
   * const matrix = new Matrix()
   *     .scale(2, 2);
   * bounds.addBounds(childBounds, matrix);
   * ```
   * @param bounds - The bounds to be added
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding raw coordinates
   * @see {@link Bounds#addRect} For adding rectangles
   */ addBounds(bounds, matrix) {
        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
    }
    /**
   * Adds other Bounds as a mask, creating an intersection of the two bounds.
   * Only keeps the overlapping region between current bounds and mask bounds.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Create mask bounds
   * const mask = new Bounds();
   * mask.addFrame(50, 50, 150, 150);
   * // Apply mask - results in bounds of (50,50,100,100)
   * bounds.addBoundsMask(mask);
   * ```
   * @param mask - The Bounds to use as a mask
   * @see {@link Bounds#addBounds} For union operation
   * @see {@link Bounds#fit} For fitting to rectangle
   */ addBoundsMask(mask) {
        this.minX = this.minX > mask.minX ? this.minX : mask.minX;
        this.minY = this.minY > mask.minY ? this.minY : mask.minY;
        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
    }
    /**
   * Applies a transformation matrix to the bounds, updating its coordinates.
   * Transforms all corners of the bounds using the given matrix.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Apply translation
   * const translateMatrix = new Matrix()
   *     .translate(50, 50);
   * bounds.applyMatrix(translateMatrix);
   * ```
   * @param matrix - The matrix to apply to the bounds
   * @see {@link Matrix} For matrix operations
   * @see {@link Bounds#addFrame} For adding transformed frames
   */ applyMatrix(matrix) {
        const minX = this.minX;
        const minY = this.minY;
        const maxX = this.maxX;
        const maxY = this.maxY;
        const { a, b, c, d, tx, ty } = matrix;
        let x = a * minX + c * minY + tx;
        let y = b * minX + d * minY + ty;
        this.minX = x;
        this.minY = y;
        this.maxX = x;
        this.maxY = y;
        x = a * maxX + c * minY + tx;
        y = b * maxX + d * minY + ty;
        this.minX = x < this.minX ? x : this.minX;
        this.minY = y < this.minY ? y : this.minY;
        this.maxX = x > this.maxX ? x : this.maxX;
        this.maxY = y > this.maxY ? y : this.maxY;
        x = a * minX + c * maxY + tx;
        y = b * minX + d * maxY + ty;
        this.minX = x < this.minX ? x : this.minX;
        this.minY = y < this.minY ? y : this.minY;
        this.maxX = x > this.maxX ? x : this.maxX;
        this.maxY = y > this.maxY ? y : this.maxY;
        x = a * maxX + c * maxY + tx;
        y = b * maxX + d * maxY + ty;
        this.minX = x < this.minX ? x : this.minX;
        this.minY = y < this.minY ? y : this.minY;
        this.maxX = x > this.maxX ? x : this.maxX;
        this.maxY = y > this.maxY ? y : this.maxY;
    }
    /**
   * Resizes the bounds object to fit within the given rectangle.
   * Clips the bounds if they extend beyond the rectangle's edges.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 200, 200);
   * // Fit within viewport
   * const viewport = new Rectangle(50, 50, 100, 100);
   * bounds.fit(viewport);
   * // bounds are now (50, 50, 150, 150)
   * ```
   * @param rect - The rectangle to fit within
   * @returns This bounds object for chaining
   * @see {@link Bounds#addBoundsMask} For intersection
   * @see {@link Bounds#pad} For expanding bounds
   */ fit(rect) {
        if (this.minX < rect.left) this.minX = rect.left;
        if (this.maxX > rect.right) this.maxX = rect.right;
        if (this.minY < rect.top) this.minY = rect.top;
        if (this.maxY > rect.bottom) this.maxY = rect.bottom;
        return this;
    }
    /**
   * Resizes the bounds object to include the given bounds.
   * Similar to fit() but works with raw coordinate values instead of a Rectangle.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 200, 200);
   * // Fit to specific coordinates
   * bounds.fitBounds(50, 150, 50, 150);
   * // bounds are now (50, 50, 150, 150)
   * ```
   * @param left - The left value of the bounds
   * @param right - The right value of the bounds
   * @param top - The top value of the bounds
   * @param bottom - The bottom value of the bounds
   * @returns This bounds object for chaining
   * @see {@link Bounds#fit} For fitting to Rectangle
   * @see {@link Bounds#addBoundsMask} For intersection
   */ fitBounds(left, right, top, bottom) {
        if (this.minX < left) this.minX = left;
        if (this.maxX > right) this.maxX = right;
        if (this.minY < top) this.minY = top;
        if (this.maxY > bottom) this.maxY = bottom;
        return this;
    }
    /**
   * Pads bounds object, making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Add equal padding
   * bounds.pad(10);
   * // bounds are now (-10, -10, 110, 110)
   *
   * // Add different padding for x and y
   * bounds.pad(20, 10);
   * // bounds are now (-30, -20, 130, 120)
   * ```
   * @param paddingX - The horizontal padding amount
   * @param paddingY - The vertical padding amount
   * @returns This bounds object for chaining
   * @see {@link Bounds#fit} For constraining bounds
   * @see {@link Bounds#scale} For uniform scaling
   */ pad(paddingX, paddingY = paddingX) {
        this.minX -= paddingX;
        this.maxX += paddingX;
        this.minY -= paddingY;
        this.maxY += paddingY;
        return this;
    }
    /**
   * Ceils the bounds by rounding up max values and rounding down min values.
   * Useful for pixel-perfect calculations and avoiding fractional pixels.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.set(10.2, 10.9, 50.1, 50.8);
   *
   * // Round to whole pixels
   * bounds.ceil();
   * // bounds are now (10, 10, 51, 51)
   * ```
   * @returns This bounds object for chaining
   * @see {@link Bounds#scale} For size adjustments
   * @see {@link Bounds#fit} For constraining bounds
   */ ceil() {
        this.minX = Math.floor(this.minX);
        this.minY = Math.floor(this.minY);
        this.maxX = Math.ceil(this.maxX);
        this.maxY = Math.ceil(this.maxY);
        return this;
    }
    /**
   * Creates a new Bounds instance with the same values.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Create a copy
   * const copy = bounds.clone();
   *
   * // Original and copy are independent
   * bounds.pad(10);
   * console.log(copy.width === bounds.width); // false
   * ```
   * @returns A new Bounds instance with the same values
   * @see {@link Bounds#copyFrom} For reusing existing bounds
   */ clone() {
        return new Bounds(this.minX, this.minY, this.maxX, this.maxY);
    }
    /**
   * Scales the bounds by the given values, adjusting all edges proportionally.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Scale uniformly
   * bounds.scale(2);
   * // bounds are now (0, 0, 200, 200)
   *
   * // Scale non-uniformly
   * bounds.scale(0.5, 2);
   * // bounds are now (0, 0, 100, 400)
   * ```
   * @param x - The X value to scale by
   * @param y - The Y value to scale by (defaults to x)
   * @returns This bounds object for chaining
   * @see {@link Bounds#pad} For adding padding
   * @see {@link Bounds#fit} For constraining size
   */ scale(x, y = x) {
        this.minX *= x;
        this.minY *= y;
        this.maxX *= x;
        this.maxY *= y;
        return this;
    }
    /**
   * The x position of the bounds in local space.
   * Setting this value will move the bounds while maintaining its width.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get x position
   * console.log(bounds.x); // 0
   *
   * // Move bounds horizontally
   * bounds.x = 50;
   * console.log(bounds.minX, bounds.maxX); // 50, 150
   *
   * // Width stays the same
   * console.log(bounds.width); // Still 100
   * ```
   */ get x() {
        return this.minX;
    }
    set x(value) {
        const width = this.maxX - this.minX;
        this.minX = value;
        this.maxX = value + width;
    }
    /**
   * The y position of the bounds in local space.
   * Setting this value will move the bounds while maintaining its height.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get y position
   * console.log(bounds.y); // 0
   *
   * // Move bounds vertically
   * bounds.y = 50;
   * console.log(bounds.minY, bounds.maxY); // 50, 150
   *
   * // Height stays the same
   * console.log(bounds.height); // Still 100
   * ```
   */ get y() {
        return this.minY;
    }
    set y(value) {
        const height = this.maxY - this.minY;
        this.minY = value;
        this.maxY = value + height;
    }
    /**
   * The width value of the bounds.
   * Represents the distance between minX and maxX coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get width
   * console.log(bounds.width); // 100
   * // Resize width
   * bounds.width = 200;
   * console.log(bounds.maxX - bounds.minX); // 200
   * ```
   */ get width() {
        return this.maxX - this.minX;
    }
    set width(value) {
        this.maxX = this.minX + value;
    }
    /**
   * The height value of the bounds.
   * Represents the distance between minY and maxY coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get height
   * console.log(bounds.height); // 100
   * // Resize height
   * bounds.height = 150;
   * console.log(bounds.maxY - bounds.minY); // 150
   * ```
   */ get height() {
        return this.maxY - this.minY;
    }
    set height(value) {
        this.maxY = this.minY + value;
    }
    /**
   * The left edge coordinate of the bounds.
   * Alias for minX.
   * @example
   * ```ts
   * const bounds = new Bounds(50, 0, 150, 100);
   * console.log(bounds.left); // 50
   * console.log(bounds.left === bounds.minX); // true
   * ```
   * @readonly
   */ get left() {
        return this.minX;
    }
    /**
   * The right edge coordinate of the bounds.
   * Alias for maxX.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.right); // 100
   * console.log(bounds.right === bounds.maxX); // true
   * ```
   * @readonly
   */ get right() {
        return this.maxX;
    }
    /**
   * The top edge coordinate of the bounds.
   * Alias for minY.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 25, 100, 125);
   * console.log(bounds.top); // 25
   * console.log(bounds.top === bounds.minY); // true
   * ```
   * @readonly
   */ get top() {
        return this.minY;
    }
    /**
   * The bottom edge coordinate of the bounds.
   * Alias for maxY.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 200);
   * console.log(bounds.bottom); // 200
   * console.log(bounds.bottom === bounds.maxY); // true
   * ```
   * @readonly
   */ get bottom() {
        return this.maxY;
    }
    /**
   * Whether the bounds has positive width and height.
   * Checks if both dimensions are greater than zero.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Check if bounds are positive
   * console.log(bounds.isPositive); // true
   *
   * // Negative bounds
   * bounds.maxX = bounds.minX;
   * console.log(bounds.isPositive); // false, width is 0
   * ```
   * @readonly
   * @see {@link Bounds#isEmpty} For checking empty state
   * @see {@link Bounds#isValid} For checking validity
   */ get isPositive() {
        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
    }
    /**
   * Whether the bounds has valid coordinates.
   * Checks if the bounds has been initialized with real values.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * console.log(bounds.isValid); // false, default state
   *
   * // Set valid bounds
   * bounds.addFrame(0, 0, 100, 100);
   * console.log(bounds.isValid); // true
   * ```
   * @readonly
   * @see {@link Bounds#isEmpty} For checking empty state
   * @see {@link Bounds#isPositive} For checking dimensions
   */ get isValid() {
        return this.minX + this.minY !== Infinity;
    }
    /**
   * Adds vertices from a Float32Array to the bounds, optionally transformed by a matrix.
   * Used for efficiently updating bounds from raw vertex data.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Add vertices from geometry
   * const vertices = new Float32Array([
   *     0, 0,    // Vertex 1
   *     100, 0,  // Vertex 2
   *     100, 100 // Vertex 3
   * ]);
   * bounds.addVertexData(vertices, 0, 6);
   *
   * // Add transformed vertices
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addVertexData(vertices, 0, 6, matrix);
   *
   * // Add subset of vertices
   * bounds.addVertexData(vertices, 2, 4); // Only second vertex
   * ```
   * @param vertexData - The array of vertices to add
   * @param beginOffset - Starting index in the vertex array
   * @param endOffset - Ending index in the vertex array (excluded)
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding rectangular frames
   * @see {@link Matrix} For transformation details
   */ addVertexData(vertexData, beginOffset, endOffset, matrix) {
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        matrix || (matrix = this.matrix);
        const a = matrix.a;
        const b = matrix.b;
        const c = matrix.c;
        const d = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        for(let i = beginOffset; i < endOffset; i += 2){
            const localX = vertexData[i];
            const localY = vertexData[i + 1];
            const x = a * localX + c * localY + tx;
            const y = b * localX + d * localY + ty;
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    /**
   * Checks if a point is contained within the bounds.
   * Returns true if the point's coordinates fall within the bounds' area.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Basic point check
   * console.log(bounds.containsPoint(50, 50)); // true
   * console.log(bounds.containsPoint(150, 150)); // false
   *
   * // Check edges
   * console.log(bounds.containsPoint(0, 0));   // true, includes edges
   * console.log(bounds.containsPoint(100, 100)); // true, includes edges
   * ```
   * @param x - x coordinate to check
   * @param y - y coordinate to check
   * @returns True if the point is inside the bounds
   * @see {@link Bounds#isPositive} For valid bounds check
   * @see {@link Bounds#rectangle} For Rectangle representation
   */ containsPoint(x, y) {
        if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {
            return true;
        }
        return false;
    }
    /**
   * Returns a string representation of the bounds.
   * Useful for debugging and logging bounds information.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.toString()); // "[pixi.js:Bounds minX=0 minY=0 maxX=100 maxY=100 width=100 height=100]"
   * ```
   * @returns A string describing the bounds
   * @see {@link Bounds#copyFrom} For copying bounds
   * @see {@link Bounds#clone} For creating a new instance
   */ toString() {
        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
    }
    /**
   * Copies the bounds from another bounds object.
   * Useful for reusing bounds objects and avoiding allocations.
   * @example
   * ```ts
   * const sourceBounds = new Bounds(0, 0, 100, 100);
   * // Copy bounds
   * const targetBounds = new Bounds();
   * targetBounds.copyFrom(sourceBounds);
   * ```
   * @param bounds - The bounds to copy from
   * @returns This bounds object for chaining
   * @see {@link Bounds#clone} For creating new instances
   */ copyFrom(bounds) {
        this.minX = bounds.minX;
        this.minY = bounds.minY;
        this.maxX = bounds.maxX;
        this.maxY = bounds.maxY;
        return this;
    }
}
;
 //# sourceMappingURL=Bounds.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cacheAsTextureMixin",
    ()=>cacheAsTextureMixin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
;
"use strict";
const cacheAsTextureMixin = {
    get isCachedAsTexture () {
        return !!this.renderGroup?.isCachedAsTexture;
    },
    cacheAsTexture (val1) {
        if (typeof val1 === "boolean" && val1 === false) {
            this.disableRenderGroup();
        } else {
            this.enableRenderGroup();
            this.renderGroup.enableCacheAsTexture(val1 === true ? {} : val1);
        }
    },
    updateCacheTexture () {
        this.renderGroup?.updateCacheTexture();
    },
    get cacheAsBitmap () {
        return this.isCachedAsTexture;
    },
    set cacheAsBitmap (val){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead.");
        this.cacheAsTexture(val);
    }
};
;
 //# sourceMappingURL=cacheAsTextureMixin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "childrenHelperMixin",
    ()=>childrenHelperMixin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$removeItems$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/removeItems.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const childrenHelperMixin = {
    allowChildren: true,
    removeChildren (beginIndex = 0, endIndex) {
        const end = endIndex ?? this.children.length;
        const range = end - beginIndex;
        const removed = [];
        if (range > 0 && range <= end) {
            for(let i = end - 1; i >= beginIndex; i--){
                const child = this.children[i];
                if (!child) continue;
                removed.push(child);
                child.parent = null;
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$removeItems$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["removeItems"])(this.children, beginIndex, end);
            const renderGroup = this.renderGroup || this.parentRenderGroup;
            if (renderGroup) {
                renderGroup.removeChildren(removed);
            }
            for(let i = 0; i < removed.length; ++i){
                const child = removed[i];
                child.parentRenderLayer?.detach(child);
                this.emit("childRemoved", child, this, i);
                removed[i].emit("removed", this);
            }
            if (removed.length > 0) {
                this._didViewChangeTick++;
            }
            return removed;
        } else if (range === 0 && this.children.length === 0) {
            return removed;
        }
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    },
    removeChildAt (index) {
        const child = this.getChildAt(index);
        return this.removeChild(child);
    },
    getChildAt (index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error(`getChildAt: Index (${index}) does not exist.`);
        }
        return this.children[index];
    },
    setChildIndex (child, index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
        }
        this.getChildIndex(child);
        this.addChildAt(child, index);
    },
    getChildIndex (child) {
        const index = this.children.indexOf(child);
        if (index === -1) {
            throw new Error("The supplied Container must be a child of the caller");
        }
        return index;
    },
    addChildAt (child, index) {
        if (!this.allowChildren) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "addChildAt: Only Containers will be allowed to add children in v8.0.0");
        }
        const { children } = this;
        if (index < 0 || index > children.length) {
            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
        }
        if (child.parent) {
            const currentIndex = child.parent.children.indexOf(child);
            if (child.parent === this && currentIndex === index) {
                return child;
            }
            if (currentIndex !== -1) {
                child.parent.children.splice(currentIndex, 1);
            }
        }
        if (index === children.length) {
            children.push(child);
        } else {
            children.splice(index, 0, child);
        }
        child.parent = this;
        child.didChange = true;
        child._updateFlags = 15;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
            renderGroup.addChild(child);
        }
        if (this.sortableChildren) this.sortDirty = true;
        this.emit("childAdded", child, this, index);
        child.emit("added", this);
        return child;
    },
    swapChildren (child, child2) {
        if (child === child2) {
            return;
        }
        const index1 = this.getChildIndex(child);
        const index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
            renderGroup.structureDidChange = true;
        }
        this._didContainerChangeTick++;
    },
    removeFromParent () {
        this.parent?.removeChild(this);
    },
    reparentChild (...child) {
        if (child.length === 1) {
            return this.reparentChildAt(child[0], this.children.length);
        }
        child.forEach((c)=>this.reparentChildAt(c, this.children.length));
        return child[0];
    },
    reparentChildAt (child, index) {
        if (child.parent === this) {
            this.setChildIndex(child, index);
            return child;
        }
        const childMat = child.worldTransform.clone();
        child.removeFromParent();
        this.addChildAt(child, index);
        const newMatrix = this.worldTransform.clone();
        newMatrix.invert();
        childMat.prepend(newMatrix);
        child.setFromMatrix(childMat);
        return child;
    },
    replaceChild (oldChild, newChild) {
        oldChild.updateLocalTransform();
        this.addChildAt(newChild, this.getChildIndex(oldChild));
        newChild.setFromMatrix(oldChild.localTransform);
        newChild.updateLocalTransform();
        this.removeChild(oldChild);
    }
};
;
 //# sourceMappingURL=childrenHelperMixin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "collectRenderablesMixin",
    ()=>collectRenderablesMixin
]);
"use strict";
const collectRenderablesMixin = {
    collectRenderables (instructionSet, renderer, currentLayer) {
        if (this.parentRenderLayer && this.parentRenderLayer !== currentLayer || this.globalDisplayStatus < 7 || !this.includeInBuild) return;
        if (this.sortableChildren) {
            this.sortChildren();
        }
        if (this.isSimple) {
            this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
        } else if (this.renderGroup) {
            renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);
        } else {
            this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);
        }
    },
    collectRenderablesSimple (instructionSet, renderer, currentLayer) {
        const children = this.children;
        const length = children.length;
        for(let i = 0; i < length; i++){
            children[i].collectRenderables(instructionSet, renderer, currentLayer);
        }
    },
    collectRenderablesWithEffects (instructionSet, renderer, currentLayer) {
        const { renderPipes } = renderer;
        for(let i = 0; i < this.effects.length; i++){
            const effect = this.effects[i];
            const pipe = renderPipes[effect.pipe];
            pipe.push(effect, this, instructionSet);
        }
        this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
        for(let i = this.effects.length - 1; i >= 0; i--){
            const effect = this.effects[i];
            const pipe = renderPipes[effect.pipe];
            pipe.pop(effect, this, instructionSet);
        }
    }
};
;
 //# sourceMappingURL=collectRenderablesMixin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "effectsMixin",
    ()=>effectsMixin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$FilterEffect$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/FilterEffect.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$mask$2f$MaskEffectManager$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const effectsMixin = {
    _maskEffect: null,
    _maskOptions: {
        inverse: false
    },
    _filterEffect: null,
    effects: [],
    _markStructureAsChanged () {
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
            renderGroup.structureDidChange = true;
        }
    },
    addEffect (effect) {
        const index = this.effects.indexOf(effect);
        if (index !== -1) return;
        this.effects.push(effect);
        this.effects.sort((a, b)=>a.priority - b.priority);
        this._markStructureAsChanged();
        this._updateIsSimple();
    },
    removeEffect (effect) {
        const index = this.effects.indexOf(effect);
        if (index === -1) return;
        this.effects.splice(index, 1);
        this._markStructureAsChanged();
        this._updateIsSimple();
    },
    set mask (value){
        const effect = this._maskEffect;
        if (effect?.mask === value) return;
        if (effect) {
            this.removeEffect(effect);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$mask$2f$MaskEffectManager$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MaskEffectManager"].returnMaskEffect(effect);
            this._maskEffect = null;
        }
        if (value === null || value === void 0) return;
        this._maskEffect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$mask$2f$MaskEffectManager$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MaskEffectManager"].getMaskEffect(value);
        this.addEffect(this._maskEffect);
    },
    get mask () {
        return this._maskEffect?.mask;
    },
    setMask (options) {
        this._maskOptions = {
            ...this._maskOptions,
            ...options
        };
        if (options.mask) {
            this.mask = options.mask;
        }
        this._markStructureAsChanged();
    },
    set filters (value){
        if (!Array.isArray(value) && value) value = [
            value
        ];
        const effect = this._filterEffect || (this._filterEffect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$FilterEffect$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FilterEffect"]());
        value = value;
        const hasFilters = value?.length > 0;
        const hadFilters = effect.filters?.length > 0;
        const didChange = hasFilters !== hadFilters;
        value = Array.isArray(value) ? value.slice(0) : value;
        effect.filters = Object.freeze(value);
        if (didChange) {
            if (hasFilters) {
                this.addEffect(effect);
            } else {
                this.removeEffect(effect);
                effect.filters = value ?? null;
            }
        }
    },
    get filters () {
        return this._filterEffect?.filters;
    },
    set filterArea (value){
        this._filterEffect || (this._filterEffect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$FilterEffect$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FilterEffect"]());
        this._filterEffect.filterArea = value;
    },
    get filterArea () {
        return this._filterEffect?.filterArea;
    }
};
;
 //# sourceMappingURL=effectsMixin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "findMixin",
    ()=>findMixin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
;
"use strict";
const findMixin = {
    label: null,
    get name () {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "Container.name property has been removed, use Container.label instead");
        return this.label;
    },
    set name (value){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "Container.name property has been removed, use Container.label instead");
        this.label = value;
    },
    getChildByName (name, deep = false) {
        return this.getChildByLabel(name, deep);
    },
    getChildByLabel (label, deep = false) {
        const children = this.children;
        for(let i = 0; i < children.length; i++){
            const child = children[i];
            if (child.label === label || label instanceof RegExp && label.test(child.label)) return child;
        }
        if (deep) {
            for(let i = 0; i < children.length; i++){
                const child = children[i];
                const found = child.getChildByLabel(label, true);
                if (found) {
                    return found;
                }
            }
        }
        return null;
    },
    getChildrenByLabel (label, deep = false, out = []) {
        const children = this.children;
        for(let i = 0; i < children.length; i++){
            const child = children[i];
            if (child.label === label || label instanceof RegExp && label.test(child.label)) {
                out.push(child);
            }
        }
        if (deep) {
            for(let i = 0; i < children.length; i++){
                children[i].getChildrenByLabel(label, true, out);
            }
        }
        return out;
    }
};
;
 //# sourceMappingURL=findMixin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "boundsPool",
    ()=>boundsPool,
    "matrixPool",
    ()=>matrixPool
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
const matrixPool = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].getPool(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]);
const boundsPool = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].getPool(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bounds"]);
;
 //# sourceMappingURL=matrixAndBoundsPool.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getFastGlobalBoundsMixin",
    ()=>getFastGlobalBoundsMixin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
const tempMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
const getFastGlobalBoundsMixin = {
    getFastGlobalBounds (factorRenderLayers, bounds) {
        bounds || (bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bounds"]());
        bounds.clear();
        this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);
        if (!bounds.isValid) {
            bounds.set(0, 0, 0, 0);
        }
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        bounds.applyMatrix(renderGroup.worldTransform);
        return bounds;
    },
    _getGlobalBoundsRecursive (factorRenderLayers, bounds, currentLayer) {
        let localBounds = bounds;
        if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer) return;
        if (this.localDisplayStatus !== 7 || !this.measurable) {
            return;
        }
        const manageEffects = !!this.effects.length;
        if (this.renderGroup || manageEffects) {
            localBounds = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["boundsPool"].get().clear();
        }
        if (this.boundsArea) {
            bounds.addRect(this.boundsArea, this.worldTransform);
        } else {
            if (this.renderPipeId) {
                const viewBounds = this.bounds;
                localBounds.addFrame(viewBounds.minX, viewBounds.minY, viewBounds.maxX, viewBounds.maxY, this.groupTransform);
            }
            const children = this.children;
            for(let i = 0; i < children.length; i++){
                children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);
            }
        }
        if (manageEffects) {
            let advanced = false;
            const renderGroup = this.renderGroup || this.parentRenderGroup;
            for(let i = 0; i < this.effects.length; i++){
                if (this.effects[i].addBounds) {
                    if (!advanced) {
                        advanced = true;
                        localBounds.applyMatrix(renderGroup.worldTransform);
                    }
                    this.effects[i].addBounds(localBounds, true);
                }
            }
            if (advanced) {
                localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix).invert());
            }
            bounds.addBounds(localBounds);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["boundsPool"].return(localBounds);
        } else if (this.renderGroup) {
            bounds.addBounds(localBounds, this.relativeGroupTransform);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["boundsPool"].return(localBounds);
        }
    }
};
;
 //# sourceMappingURL=getFastGlobalBoundsMixin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getGlobalBounds",
    ()=>getGlobalBounds,
    "updateTransformBackwards",
    ()=>updateTransformBackwards
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
function getGlobalBounds(target, skipUpdateTransform, bounds) {
    bounds.clear();
    let parentTransform;
    let pooledMatrix;
    if (target.parent) {
        if (!skipUpdateTransform) {
            pooledMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["matrixPool"].get().identity();
            parentTransform = updateTransformBackwards(target, pooledMatrix);
        } else {
            parentTransform = target.parent.worldTransform;
        }
    } else {
        parentTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"].IDENTITY;
    }
    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
    if (pooledMatrix) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["matrixPool"].return(pooledMatrix);
    }
    if (!bounds.isValid) {
        bounds.set(0, 0, 0, 0);
    }
    return bounds;
}
function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
    if (!target.visible || !target.measurable) return;
    let worldTransform;
    if (!skipUpdateTransform) {
        target.updateLocalTransform();
        worldTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["matrixPool"].get();
        worldTransform.appendFrom(target.localTransform, parentTransform);
    } else {
        worldTransform = target.worldTransform;
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
        bounds = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["boundsPool"].get().clear();
    }
    if (target.boundsArea) {
        bounds.addRect(target.boundsArea, worldTransform);
    } else {
        const renderableBounds = target.bounds;
        if (renderableBounds && !renderableBounds.isEmpty()) {
            bounds.matrix = worldTransform;
            bounds.addBounds(renderableBounds);
        }
        for(let i = 0; i < target.children.length; i++){
            _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);
        }
    }
    if (preserveBounds) {
        for(let i = 0; i < target.effects.length; i++){
            target.effects[i].addBounds?.(bounds);
        }
        parentBounds.addBounds(bounds, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"].IDENTITY);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["boundsPool"].return(bounds);
    }
    if (!skipUpdateTransform) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["matrixPool"].return(worldTransform);
    }
}
function updateTransformBackwards(target, parentTransform) {
    const parent = target.parent;
    if (parent) {
        updateTransformBackwards(parent, parentTransform);
        parent.updateLocalTransform();
        parentTransform.append(parent.localTransform);
    }
    return parentTransform;
}
;
 //# sourceMappingURL=getGlobalBounds.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "multiplyHexColors",
    ()=>multiplyHexColors
]);
"use strict";
function multiplyHexColors(color1, color2) {
    if (color1 === 16777215 || !color2) return color2;
    if (color2 === 16777215 || !color1) return color1;
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color2 >> 16 & 255;
    const g2 = color2 >> 8 & 255;
    const b2 = color2 & 255;
    const r = r1 * r2 / 255 | 0;
    const g = g1 * g2 / 255 | 0;
    const b = b1 * b2 / 255 | 0;
    return (r << 16) + (g << 8) + b;
}
;
 //# sourceMappingURL=multiplyHexColors.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "multiplyColors",
    ()=>multiplyColors
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$multiplyHexColors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs [app-ssr] (ecmascript)");
;
"use strict";
const WHITE_BGR = 16777215;
function multiplyColors(localBGRColor, parentBGRColor) {
    if (localBGRColor === WHITE_BGR) {
        return parentBGRColor;
    }
    if (parentBGRColor === WHITE_BGR) {
        return localBGRColor;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$multiplyHexColors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiplyHexColors"])(localBGRColor, parentBGRColor);
}
;
 //# sourceMappingURL=multiplyColors.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bgr2rgb",
    ()=>bgr2rgb,
    "getGlobalMixin",
    ()=>getGlobalMixin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$getGlobalBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$multiplyColors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
function bgr2rgb(color) {
    return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);
}
const getGlobalMixin = {
    getGlobalAlpha (skipUpdate) {
        if (skipUpdate) {
            if (this.renderGroup) {
                return this.renderGroup.worldAlpha;
            }
            if (this.parentRenderGroup) {
                return this.parentRenderGroup.worldAlpha * this.alpha;
            }
            return this.alpha;
        }
        let alpha = this.alpha;
        let current = this.parent;
        while(current){
            alpha *= current.alpha;
            current = current.parent;
        }
        return alpha;
    },
    getGlobalTransform (matrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"](), skipUpdate) {
        if (skipUpdate) {
            return matrix.copyFrom(this.worldTransform);
        }
        this.updateLocalTransform();
        const parentTransform = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$getGlobalBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["updateTransformBackwards"])(this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["matrixPool"].get().identity());
        matrix.appendFrom(this.localTransform, parentTransform);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["matrixPool"].return(parentTransform);
        return matrix;
    },
    getGlobalTint (skipUpdate) {
        if (skipUpdate) {
            if (this.renderGroup) {
                return bgr2rgb(this.renderGroup.worldColor);
            }
            if (this.parentRenderGroup) {
                return bgr2rgb((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$multiplyColors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiplyColors"])(this.localColor, this.parentRenderGroup.worldColor));
            }
            return this.tint;
        }
        let color = this.localColor;
        let parent = this.parent;
        while(parent){
            color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$multiplyColors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiplyColors"])(color, parent.localColor);
            parent = parent.parent;
        }
        return bgr2rgb(color);
    }
};
;
 //# sourceMappingURL=getGlobalMixin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getLocalBounds",
    ()=>getLocalBounds
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
function getLocalBounds(target, bounds, relativeMatrix) {
    bounds.clear();
    relativeMatrix || (relativeMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"].IDENTITY);
    _getLocalBounds(target, bounds, relativeMatrix, target, true);
    if (!bounds.isValid) {
        bounds.set(0, 0, 0, 0);
    }
    return bounds;
}
function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
    let relativeTransform;
    if (!isRoot) {
        if (!target.visible || !target.measurable) return;
        target.updateLocalTransform();
        const localTransform = target.localTransform;
        relativeTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["matrixPool"].get();
        relativeTransform.appendFrom(localTransform, parentTransform);
    } else {
        relativeTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["matrixPool"].get();
        relativeTransform = parentTransform.copyTo(relativeTransform);
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
        bounds = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["boundsPool"].get().clear();
    }
    if (target.boundsArea) {
        bounds.addRect(target.boundsArea, relativeTransform);
    } else {
        if (target.renderPipeId) {
            bounds.matrix = relativeTransform;
            bounds.addBounds(target.bounds);
        }
        const children = target.children;
        for(let i = 0; i < children.length; i++){
            _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);
        }
    }
    if (preserveBounds) {
        for(let i = 0; i < target.effects.length; i++){
            target.effects[i].addLocalBounds?.(bounds, rootContainer);
        }
        parentBounds.addBounds(bounds, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"].IDENTITY);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["boundsPool"].return(bounds);
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["matrixPool"].return(relativeTransform);
}
;
 //# sourceMappingURL=getLocalBounds.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "checkChildrenDidChange",
    ()=>checkChildrenDidChange
]);
"use strict";
function checkChildrenDidChange(container, previousData) {
    const children = container.children;
    for(let i = 0; i < children.length; i++){
        const child = children[i];
        const uid = child.uid;
        const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
        const index = previousData.index;
        if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange) {
            previousData.data[previousData.index] = uid;
            previousData.data[previousData.index + 1] = didChange;
            previousData.didChange = true;
        }
        previousData.index = index + 2;
        if (child.children.length) {
            checkChildrenDidChange(child, previousData);
        }
    }
    return previousData.didChange;
}
;
 //# sourceMappingURL=checkChildrenDidChange.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "measureMixin",
    ()=>measureMixin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$getGlobalBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$getLocalBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$checkChildrenDidChange$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
"use strict";
const tempMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
const measureMixin = {
    _localBoundsCacheId: -1,
    _localBoundsCacheData: null,
    _setWidth (value, localWidth) {
        const sign = Math.sign(this.scale.x) || 1;
        if (localWidth !== 0) {
            this.scale.x = value / localWidth * sign;
        } else {
            this.scale.x = sign;
        }
    },
    _setHeight (value, localHeight) {
        const sign = Math.sign(this.scale.y) || 1;
        if (localHeight !== 0) {
            this.scale.y = value / localHeight * sign;
        } else {
            this.scale.y = sign;
        }
    },
    getLocalBounds () {
        if (!this._localBoundsCacheData) {
            this._localBoundsCacheData = {
                data: [],
                index: 1,
                didChange: false,
                localBounds: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bounds"]()
            };
        }
        const localBoundsCacheData = this._localBoundsCacheData;
        localBoundsCacheData.index = 1;
        localBoundsCacheData.didChange = false;
        if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
            localBoundsCacheData.didChange = true;
            localBoundsCacheData.data[0] = this._didViewChangeTick;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$checkChildrenDidChange$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["checkChildrenDidChange"])(this, localBoundsCacheData);
        if (localBoundsCacheData.didChange) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$getLocalBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getLocalBounds"])(this, localBoundsCacheData.localBounds, tempMatrix);
        }
        return localBoundsCacheData.localBounds;
    },
    getBounds (skipUpdate, bounds) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$getGlobalBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGlobalBounds"])(this, skipUpdate, bounds || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bounds"]());
    }
};
;
 //# sourceMappingURL=measureMixin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "onRenderMixin",
    ()=>onRenderMixin
]);
"use strict";
const onRenderMixin = {
    _onRender: null,
    set onRender (func){
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (!func) {
            if (this._onRender) {
                renderGroup?.removeOnRender(this);
            }
            this._onRender = null;
            return;
        }
        if (!this._onRender) {
            renderGroup?.addOnRender(this);
        }
        this._onRender = func;
    },
    get onRender () {
        return this._onRender;
    }
};
;
 //# sourceMappingURL=onRenderMixin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sortMixin",
    ()=>sortMixin
]);
"use strict";
const sortMixin = {
    _zIndex: 0,
    sortDirty: false,
    sortableChildren: false,
    get zIndex () {
        return this._zIndex;
    },
    set zIndex (value){
        if (this._zIndex === value) return;
        this._zIndex = value;
        this.depthOfChildModified();
    },
    depthOfChildModified () {
        if (this.parent) {
            this.parent.sortableChildren = true;
            this.parent.sortDirty = true;
        }
        if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
        }
    },
    sortChildren () {
        if (!this.sortDirty) return;
        this.sortDirty = false;
        this.children.sort(sortChildren);
    }
};
function sortChildren(a, b) {
    return a._zIndex - b._zIndex;
}
;
 //# sourceMappingURL=sortMixin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "toLocalGlobalMixin",
    ()=>toLocalGlobalMixin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const toLocalGlobalMixin = {
    getGlobalPosition (point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"](), skipUpdate = false) {
        if (this.parent) {
            this.parent.toGlobal(this._position, point, skipUpdate);
        } else {
            point.x = this._position.x;
            point.y = this._position.y;
        }
        return point;
    },
    toGlobal (position, point, skipUpdate = false) {
        const globalMatrix = this.getGlobalTransform(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["matrixPool"].get(), skipUpdate);
        point = globalMatrix.apply(position, point);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["matrixPool"].return(globalMatrix);
        return point;
    },
    toLocal (position, from, point, skipUpdate) {
        if (from) {
            position = from.toGlobal(position, point, skipUpdate);
        }
        const globalMatrix = this.getGlobalTransform(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["matrixPool"].get(), skipUpdate);
        point = globalMatrix.applyInverse(position, point);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$utils$2f$matrixAndBoundsPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["matrixPool"].return(globalMatrix);
        return point;
    }
};
;
 //# sourceMappingURL=toLocalGlobalMixin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/RenderGroup.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RenderGroup",
    ()=>RenderGroup
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$instructions$2f$InstructionSet$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
class RenderGroup {
    constructor(){
        this.renderPipeId = "renderGroup";
        this.root = null;
        this.canBundle = false;
        this.renderGroupParent = null;
        this.renderGroupChildren = [];
        this.worldTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
        this.worldColorAlpha = 4294967295;
        this.worldColor = 16777215;
        this.worldAlpha = 1;
        // these updates are transform changes..
        this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
        this.updateTick = 0;
        this.gcTick = 0;
        // these update are renderable changes..
        this.childrenRenderablesToUpdate = {
            list: [],
            index: 0
        };
        // other
        this.structureDidChange = true;
        this.instructionSet = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$instructions$2f$InstructionSet$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InstructionSet"]();
        this._onRenderContainers = [];
        /**
     * Indicates if the cached texture needs to be updated.
     * @default true
     */ this.textureNeedsUpdate = true;
        /**
     * Indicates if the container should be cached as a texture.
     * @default false
     */ this.isCachedAsTexture = false;
        this._matrixDirty = 7;
    }
    init(root) {
        this.root = root;
        if (root._onRender) this.addOnRender(root);
        root.didChange = true;
        const children = root.children;
        for(let i = 0; i < children.length; i++){
            const child = children[i];
            child._updateFlags = 15;
            this.addChild(child);
        }
    }
    enableCacheAsTexture(options = {}) {
        this.textureOptions = options;
        this.isCachedAsTexture = true;
        this.textureNeedsUpdate = true;
    }
    disableCacheAsTexture() {
        this.isCachedAsTexture = false;
        if (this.texture) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].returnTexture(this.texture, true);
            this.texture = null;
        }
    }
    updateCacheTexture() {
        this.textureNeedsUpdate = true;
        const cachedParent = this._parentCacheAsTextureRenderGroup;
        if (cachedParent && !cachedParent.textureNeedsUpdate) {
            cachedParent.updateCacheTexture();
        }
    }
    reset() {
        this.renderGroupChildren.length = 0;
        for(const i in this.childrenToUpdate){
            const childrenAtDepth = this.childrenToUpdate[i];
            childrenAtDepth.list.fill(null);
            childrenAtDepth.index = 0;
        }
        this.childrenRenderablesToUpdate.index = 0;
        this.childrenRenderablesToUpdate.list.fill(null);
        this.root = null;
        this.updateTick = 0;
        this.structureDidChange = true;
        this._onRenderContainers.length = 0;
        this.renderGroupParent = null;
        this.disableCacheAsTexture();
    }
    get localTransform() {
        return this.root.localTransform;
    }
    addRenderGroupChild(renderGroupChild) {
        if (renderGroupChild.renderGroupParent) {
            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
        }
        renderGroupChild.renderGroupParent = this;
        this.renderGroupChildren.push(renderGroupChild);
    }
    _removeRenderGroupChild(renderGroupChild) {
        const index = this.renderGroupChildren.indexOf(renderGroupChild);
        if (index > -1) {
            this.renderGroupChildren.splice(index, 1);
        }
        renderGroupChild.renderGroupParent = null;
    }
    addChild(child) {
        this.structureDidChange = true;
        child.parentRenderGroup = this;
        child.updateTick = -1;
        if (child.parent === this.root) {
            child.relativeRenderGroupDepth = 1;
        } else {
            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
        }
        child.didChange = true;
        this.onChildUpdate(child);
        if (child.renderGroup) {
            this.addRenderGroupChild(child.renderGroup);
            return;
        }
        if (child._onRender) this.addOnRender(child);
        const children = child.children;
        for(let i = 0; i < children.length; i++){
            this.addChild(children[i]);
        }
    }
    removeChild(child) {
        this.structureDidChange = true;
        if (child._onRender) {
            if (!child.renderGroup) {
                this.removeOnRender(child);
            }
        }
        child.parentRenderGroup = null;
        if (child.renderGroup) {
            this._removeRenderGroupChild(child.renderGroup);
            return;
        }
        const children = child.children;
        for(let i = 0; i < children.length; i++){
            this.removeChild(children[i]);
        }
    }
    removeChildren(children) {
        for(let i = 0; i < children.length; i++){
            this.removeChild(children[i]);
        }
    }
    onChildUpdate(child) {
        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
        if (!childrenToUpdate) {
            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
                index: 0,
                list: []
            };
        }
        childrenToUpdate.list[childrenToUpdate.index++] = child;
    }
    updateRenderable(renderable) {
        if (renderable.globalDisplayStatus < 7) return;
        this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);
        renderable.didViewUpdate = false;
    }
    onChildViewUpdate(child) {
        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
    }
    get isRenderable() {
        return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
    }
    /**
   * adding a container to the onRender list will make sure the user function
   * passed in to the user defined 'onRender` callBack
   * @param container - the container to add to the onRender list
   */ addOnRender(container) {
        this._onRenderContainers.push(container);
    }
    removeOnRender(container) {
        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
    }
    runOnRender(renderer) {
        for(let i = 0; i < this._onRenderContainers.length; i++){
            this._onRenderContainers[i]._onRender(renderer);
        }
    }
    destroy() {
        this.disableCacheAsTexture();
        this.renderGroupParent = null;
        this.root = null;
        this.childrenRenderablesToUpdate = null;
        this.childrenToUpdate = null;
        this.renderGroupChildren = null;
        this._onRenderContainers = null;
        this.instructionSet = null;
    }
    getChildren(out = []) {
        const children = this.root.children;
        for(let i = 0; i < children.length; i++){
            this._getChildren(children[i], out);
        }
        return out;
    }
    _getChildren(container, out = []) {
        out.push(container);
        if (container.renderGroup) return out;
        const children = container.children;
        for(let i = 0; i < children.length; i++){
            this._getChildren(children[i], out);
        }
        return out;
    }
    invalidateMatrices() {
        this._matrixDirty = 7;
    }
    /**
   * Returns the inverse of the world transform matrix.
   * @returns {Matrix} The inverse of the world transform matrix.
   */ get inverseWorldTransform() {
        if ((this._matrixDirty & 1) === 0) return this._inverseWorldTransform;
        this._matrixDirty &= ~1;
        this._inverseWorldTransform || (this._inverseWorldTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]());
        return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();
    }
    /**
   * Returns the inverse of the texture offset transform matrix.
   * @returns {Matrix} The inverse of the texture offset transform matrix.
   */ get textureOffsetInverseTransform() {
        if ((this._matrixDirty & 2) === 0) return this._textureOffsetInverseTransform;
        this._matrixDirty &= ~2;
        this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]());
        return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y);
    }
    /**
   * Returns the inverse of the parent texture transform matrix.
   * This is used to properly transform coordinates when rendering into cached textures.
   * @returns {Matrix} The inverse of the parent texture transform matrix.
   */ get inverseParentTextureTransform() {
        if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform;
        this._matrixDirty &= ~4;
        const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;
        if (parentCacheAsTexture) {
            this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]());
            return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(-parentCacheAsTexture._textureBounds.x, -parentCacheAsTexture._textureBounds.y);
        }
        return this.worldTransform;
    }
    /**
   * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.
   * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.
   * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,
   * or null if no parent is cached as texture.
   */ get cacheToLocalTransform() {
        if (this.isCachedAsTexture) {
            return this.textureOffsetInverseTransform;
        }
        if (!this._parentCacheAsTextureRenderGroup) return null;
        return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;
    }
}
;
 //# sourceMappingURL=RenderGroup.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "assignWithIgnore",
    ()=>assignWithIgnore
]);
"use strict";
function assignWithIgnore(target, options, ignore = {}) {
    for(const key in options){
        if (!ignore[key] && options[key] !== void 0) {
            target[key] = options[key];
        }
    }
}
;
 //# sourceMappingURL=assignWithIgnore.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/Container.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Container",
    ()=>Container,
    "UPDATE_BLEND",
    ()=>UPDATE_BLEND,
    "UPDATE_COLOR",
    ()=>UPDATE_COLOR,
    "UPDATE_TRANSFORM",
    ()=>UPDATE_TRANSFORM,
    "UPDATE_VISIBLE",
    ()=>UPDATE_VISIBLE
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$culling$2f$cullingMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/culling/cullingMixin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$misc$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/misc/const.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$uid$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/uid.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$cacheAsTextureMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$childrenHelperMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$collectRenderablesMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$effectsMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$findMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$getFastGlobalBoundsMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$getGlobalMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$measureMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$onRenderMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$sortMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$toLocalGlobalMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$RenderGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/RenderGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$assignWithIgnore$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
"use strict";
const defaultSkew = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"](null);
const defaultPivot = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"](null);
const defaultScale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"](null, 1, 1);
const defaultOrigin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"](null);
const UPDATE_COLOR = 1;
const UPDATE_BLEND = 2;
const UPDATE_VISIBLE = 4;
const UPDATE_TRANSFORM = 8;
class Container extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"] {
    constructor(options = {}){
        super();
        /**
     * unique id for this container
     * @internal
     */ this.uid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$uid$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uid"])("renderable");
        /** @private */ this._updateFlags = 15;
        // the render group this container owns
        /** @private */ this.renderGroup = null;
        // the render group this container belongs to
        /** @private */ this.parentRenderGroup = null;
        // the index of the container in the render group
        /** @private */ this.parentRenderGroupIndex = 0;
        // set to true if the container has changed. It is reset once the changes have been applied
        // by the transform system
        // its here to stop ensure that when things change, only one update gets registers with the transform system
        /** @private */ this.didChange = false;
        // same as above, but for the renderable
        /** @private */ this.didViewUpdate = false;
        // how deep is the container relative to its render group..
        // unless the element is the root render group - it will be relative to its parent
        /** @private */ this.relativeRenderGroupDepth = 0;
        /**
     * The array of children of this container. Each child must be a Container or extend from it.
     *
     * The array is read-only, but its contents can be modified using Container methods.
     * @example
     * ```ts
     * // Access children
     * const firstChild = container.children[0];
     * const lastChild = container.children[container.children.length - 1];
     * ```
     * @readonly
     * @see {@link Container#addChild} For adding children
     * @see {@link Container#removeChild} For removing children
     */ this.children = [];
        /**
     * The display object container that contains this display object.
     * This represents the parent-child relationship in the display tree.
     * @example
     * ```ts
     * // Basic parent access
     * const parent = sprite.parent;
     *
     * // Walk up the tree
     * let current = sprite;
     * while (current.parent) {
     *     console.log('Level up:', current.parent.constructor.name);
     *     current = current.parent;
     * }
     * ```
     * @readonly
     * @see {@link Container#addChild} For adding to a parent
     * @see {@link Container#removeChild} For removing from parent
     */ this.parent = null;
        // used internally for changing up the render order.. mainly for masks and filters
        // TODO setting this should cause a rebuild??
        /** @private */ this.includeInBuild = true;
        /** @private */ this.measurable = true;
        /** @private */ this.isSimple = true;
        /**
     * The RenderLayer this container belongs to, if any.
     * If it belongs to a RenderLayer, it will be rendered from the RenderLayer's position in the scene.
     * @readonly
     * @advanced
     */ this.parentRenderLayer = null;
        // / /////////////Transform related props//////////////
        // used by the transform system to check if a container needs to be updated that frame
        // if the tick matches the current transform system tick, it is not updated again
        /** @internal */ this.updateTick = -1;
        /**
     * Current transform of the object based on local factors: position, scale, other stuff.
     * This matrix represents the local transformation without any parent influence.
     * @example
     * ```ts
     * // Basic transform access
     * const localMatrix = sprite.localTransform;
     * console.log(localMatrix.toString());
     * ```
     * @readonly
     * @see {@link Container#worldTransform} For global transform
     * @see {@link Container#groupTransform} For render group transform
     */ this.localTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
        /**
     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent
     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).
     * If this container is is self a render group matrix will be relative to its parent render group
     * @readonly
     * @advanced
     */ this.relativeGroupTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
        /**
     * The group transform is a transform relative to the render group it belongs too.
     * If this container is render group then this will be an identity matrix. other wise it
     * will be the same as the relativeGroupTransform.
     * Use this value when actually rendering things to the screen
     * @readonly
     * @advanced
     */ this.groupTransform = this.relativeGroupTransform;
        /**
     * Whether this object has been destroyed. If true, the object should no longer be used.
     * After an object is destroyed, all of its functionality is disabled and references are removed.
     * @example
     * ```ts
     * // Cleanup with destroy
     * sprite.destroy();
     * console.log(sprite.destroyed); // true
     * ```
     * @default false
     * @see {@link Container#destroy} For destroying objects
     */ this.destroyed = false;
        // transform data..
        /**
     * The coordinate of the object relative to the local coordinates of the parent.
     * @internal
     */ this._position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"](this, 0, 0);
        /**
     * The scale factor of the object.
     * @internal
     */ this._scale = defaultScale;
        /**
     * The pivot point of the container that it rotates around.
     * @internal
     */ this._pivot = defaultPivot;
        /**
     * The origin point around which the container rotates and scales.
     * Unlike pivot, changing origin will not move the container's position.
     * @private
     */ this._origin = defaultOrigin;
        /**
     * The skew amount, on the x and y axis.
     * @internal
     */ this._skew = defaultSkew;
        /**
     * The X-coordinate value of the normalized local X axis,
     * the first column of the local transformation matrix without a scale.
     * @internal
     */ this._cx = 1;
        /**
     * The Y-coordinate value of the normalized local X axis,
     * the first column of the local transformation matrix without a scale.
     * @internal
     */ this._sx = 0;
        /**
     * The X-coordinate value of the normalized local Y axis,
     * the second column of the local transformation matrix without a scale.
     * @internal
     */ this._cy = 0;
        /**
     * The Y-coordinate value of the normalized local Y axis,
     * the second column of the local transformation matrix without a scale.
     * @internal
     */ this._sy = 1;
        /**
     * The rotation amount.
     * @internal
     */ this._rotation = 0;
        // / COLOR related props //////////////
        // color stored as ABGR
        /** @internal */ this.localColor = 16777215;
        /** @internal */ this.localAlpha = 1;
        /** @internal */ this.groupAlpha = 1;
        // A
        /** @internal */ this.groupColor = 16777215;
        // BGR
        /** @internal */ this.groupColorAlpha = 4294967295;
        // ABGR
        // / BLEND related props //////////////
        /** @internal */ this.localBlendMode = "inherit";
        /** @internal */ this.groupBlendMode = "normal";
        // / VISIBILITY related props //////////////
        // visibility
        // 0b11
        // first bit is visible, second bit is renderable
        /**
     * This property holds three bits: culled, visible, renderable
     * the third bit represents culling (0 = culled, 1 = not culled) 0b100
     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010
     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001
     * @internal
     */ this.localDisplayStatus = 7;
        // 0b11 | 0b10 | 0b01 | 0b00
        /** @internal */ this.globalDisplayStatus = 7;
        /**
     * A value that increments each time the containe is modified
     * eg children added, removed etc
     * @ignore
     */ this._didContainerChangeTick = 0;
        /**
     * A value that increments each time the container view is modified
     * eg texture swap, geometry change etc
     * @ignore
     */ this._didViewChangeTick = 0;
        /**
     * property that tracks if the container transform has changed
     * @ignore
     */ this._didLocalTransformChangeId = -1;
        this.effects = [];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$assignWithIgnore$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assignWithIgnore"])(this, options, {
            children: true,
            parent: true,
            effects: true
        });
        options.children?.forEach((child)=>this.addChild(child));
        options.parent?.addChild(this);
    }
    /**
   * Mixes all enumerable properties and methods from a source object to Container.
   * @param source - The source of properties and methods to mix in.
   * @deprecated since 8.8.0
   */ static mixin(source) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead.");
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extensions"].mixin(Container, source);
    }
    // = 'default';
    /**
   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
   * @deprecated since 8.2.6
   * @ignore
   */ set _didChangeId(value) {
        this._didViewChangeTick = value >> 12 & 4095;
        this._didContainerChangeTick = value & 4095;
    }
    /** @ignore */ get _didChangeId() {
        return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
    }
    /**
   * Adds one or more children to the container.
   * The children will be rendered as part of this container's display list.
   * @example
   * ```ts
   * // Add a single child
   * container.addChild(sprite);
   *
   * // Add multiple children
   * container.addChild(background, player, foreground);
   *
   * // Add with type checking
   * const sprite = container.addChild<Sprite>(new Sprite(texture));
   * sprite.tint = 'red';
   * ```
   * @param children - The Container(s) to add to the container
   * @returns The first child that was added
   * @see {@link Container#removeChild} For removing children
   * @see {@link Container#addChildAt} For adding at specific index
   */ addChild(...children) {
        if (!this.allowChildren) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "addChild: Only Containers will be allowed to add children in v8.0.0");
        }
        if (children.length > 1) {
            for(let i = 0; i < children.length; i++){
                this.addChild(children[i]);
            }
            return children[0];
        }
        const child = children[0];
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (child.parent === this) {
            this.children.splice(this.children.indexOf(child), 1);
            this.children.push(child);
            if (renderGroup) {
                renderGroup.structureDidChange = true;
            }
            return child;
        }
        if (child.parent) {
            child.parent.removeChild(child);
        }
        this.children.push(child);
        if (this.sortableChildren) this.sortDirty = true;
        child.parent = this;
        child.didChange = true;
        child._updateFlags = 15;
        if (renderGroup) {
            renderGroup.addChild(child);
        }
        this.emit("childAdded", child, this, this.children.length - 1);
        child.emit("added", this);
        this._didViewChangeTick++;
        if (child._zIndex !== 0) {
            child.depthOfChildModified();
        }
        return child;
    }
    /**
   * Removes one or more children from the container.
   * When removing multiple children, events will be triggered for each child in sequence.
   * @example
   * ```ts
   * // Remove a single child
   * const removed = container.removeChild(sprite);
   *
   * // Remove multiple children
   * const bg = container.removeChild(background, player, userInterface);
   *
   * // Remove with type checking
   * const sprite = container.removeChild<Sprite>(childSprite);
   * sprite.texture = newTexture;
   * ```
   * @param children - The Container(s) to remove
   * @returns The first child that was removed
   * @see {@link Container#addChild} For adding children
   * @see {@link Container#removeChildren} For removing multiple children
   */ removeChild(...children) {
        if (children.length > 1) {
            for(let i = 0; i < children.length; i++){
                this.removeChild(children[i]);
            }
            return children[0];
        }
        const child = children[0];
        const index = this.children.indexOf(child);
        if (index > -1) {
            this._didViewChangeTick++;
            this.children.splice(index, 1);
            if (this.renderGroup) {
                this.renderGroup.removeChild(child);
            } else if (this.parentRenderGroup) {
                this.parentRenderGroup.removeChild(child);
            }
            if (child.parentRenderLayer) {
                child.parentRenderLayer.detach(child);
            }
            child.parent = null;
            this.emit("childRemoved", child, this, index);
            child.emit("removed", this);
        }
        return child;
    }
    /** @ignore */ _onUpdate(point) {
        if (point) {
            if (point === this._skew) {
                this._updateSkew();
            }
        }
        this._didContainerChangeTick++;
        if (this.didChange) return;
        this.didChange = true;
        if (this.parentRenderGroup) {
            this.parentRenderGroup.onChildUpdate(this);
        }
    }
    set isRenderGroup(value) {
        if (!!this.renderGroup === value) return;
        if (value) {
            this.enableRenderGroup();
        } else {
            this.disableRenderGroup();
        }
    }
    /**
   * Returns true if this container is a render group.
   * This means that it will be rendered as a separate pass, with its own set of instructions
   * @advanced
   */ get isRenderGroup() {
        return !!this.renderGroup;
    }
    /**
   * Calling this enables a render group for this container.
   * This means it will be rendered as a separate set of instructions.
   * The transform of the container will also be handled on the GPU rather than the CPU.
   * @advanced
   */ enableRenderGroup() {
        if (this.renderGroup) return;
        const parentRenderGroup = this.parentRenderGroup;
        parentRenderGroup?.removeChild(this);
        this.renderGroup = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$RenderGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RenderGroup"], this);
        this.groupTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"].IDENTITY;
        parentRenderGroup?.addChild(this);
        this._updateIsSimple();
    }
    /**
   * This will disable the render group for this container.
   * @advanced
   */ disableRenderGroup() {
        if (!this.renderGroup) return;
        const parentRenderGroup = this.parentRenderGroup;
        parentRenderGroup?.removeChild(this);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].return(this.renderGroup);
        this.renderGroup = null;
        this.groupTransform = this.relativeGroupTransform;
        parentRenderGroup?.addChild(this);
        this._updateIsSimple();
    }
    /** @ignore */ _updateIsSimple() {
        this.isSimple = !this.renderGroup && this.effects.length === 0;
    }
    /**
   * Current transform of the object based on world (parent) factors.
   *
   * This matrix represents the absolute transformation in the scene graph.
   * @example
   * ```ts
   * // Get world position
   * const worldPos = container.worldTransform;
   * console.log(`World position: (${worldPos.tx}, ${worldPos.ty})`);
   * ```
   * @readonly
   * @see {@link Container#localTransform} For local space transform
   */ get worldTransform() {
        this._worldTransform || (this._worldTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]());
        if (this.renderGroup) {
            this._worldTransform.copyFrom(this.renderGroup.worldTransform);
        } else if (this.parentRenderGroup) {
            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
        }
        return this._worldTransform;
    }
    /**
   * The position of the container on the x axis relative to the local coordinates of the parent.
   *
   * An alias to position.x
   * @example
   * ```ts
   * // Basic position
   * container.x = 100;
   * ```
   */ get x() {
        return this._position.x;
    }
    set x(value) {
        this._position.x = value;
    }
    /**
   * The position of the container on the y axis relative to the local coordinates of the parent.
   *
   * An alias to position.y
   * @example
   * ```ts
   * // Basic position
   * container.y = 200;
   * ```
   */ get y() {
        return this._position.y;
    }
    set y(value) {
        this._position.y = value;
    }
    /**
   * The coordinate of the object relative to the local coordinates of the parent.
   * @example
   * ```ts
   * // Basic position setting
   * container.position.set(100, 200);
   * container.position.set(100); // Sets both x and y to 100
   * // Using point data
   * container.position = { x: 50, y: 75 };
   * ```
   * @since 4.0.0
   */ get position() {
        return this._position;
    }
    set position(value) {
        this._position.copyFrom(value);
    }
    /**
   * The rotation of the object in radians.
   *
   * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
   * > rotation is in radians, angle is in degrees.
   * @example
   * ```ts
   * // Basic rotation
   * container.rotation = Math.PI / 4; // 45 degrees
   *
   * // Convert from degrees
   * const degrees = 45;
   * container.rotation = degrees * Math.PI / 180;
   *
   * // Rotate around center
   * container.pivot.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // 180 degrees
   *
   * // Rotate around center with origin
   * container.origin.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // 180 degrees
   * ```
   */ get rotation() {
        return this._rotation;
    }
    set rotation(value) {
        if (this._rotation !== value) {
            this._rotation = value;
            this._onUpdate(this._skew);
        }
    }
    /**
   * The angle of the object in degrees.
   *
   * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
   * > rotation is in radians, angle is in degrees.
   * @example
   * ```ts
   * // Basic angle rotation
   * sprite.angle = 45; // 45 degrees
   *
   * // Rotate around center
   * sprite.pivot.set(sprite.width / 2, sprite.height / 2);
   * sprite.angle = 180; // Half rotation
   *
   * // Rotate around center with origin
   * sprite.origin.set(sprite.width / 2, sprite.height / 2);
   * sprite.angle = 180; // Half rotation
   *
   * // Reset rotation
   * sprite.angle = 0;
   * ```
   */ get angle() {
        return this.rotation * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$misc$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RAD_TO_DEG"];
    }
    set angle(value) {
        this.rotation = value * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$misc$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEG_TO_RAD"];
    }
    /**
   * The center of rotation, scaling, and skewing for this display object in its local space.
   * The `position` is the projection of `pivot` in the parent's local space.
   *
   * By default, the pivot is the origin (0, 0).
   * @example
   * ```ts
   * // Rotate around center
   * container.pivot.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // Rotates around center
   * ```
   * @since 4.0.0
   */ get pivot() {
        if (this._pivot === defaultPivot) {
            this._pivot = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"](this, 0, 0);
        }
        return this._pivot;
    }
    set pivot(value) {
        if (this._pivot === defaultPivot) {
            this._pivot = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"](this, 0, 0);
            if (this._origin !== defaultOrigin) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
            }
        }
        typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);
    }
    /**
   * The skew factor for the object in radians. Skewing is a transformation that distorts
   * the object by rotating it differently at each point, creating a non-uniform shape.
   * @example
   * ```ts
   * // Basic skewing
   * container.skew.set(0.5, 0); // Skew horizontally
   * container.skew.set(0, 0.5); // Skew vertically
   *
   * // Skew with point data
   * container.skew = { x: 0.3, y: 0.3 }; // Diagonal skew
   *
   * // Reset skew
   * container.skew.set(0, 0);
   *
   * // Animate skew
   * app.ticker.add(() => {
   *     // Create wave effect
   *     container.skew.x = Math.sin(Date.now() / 1000) * 0.3;
   * });
   *
   * // Combine with rotation
   * container.rotation = Math.PI / 4; // 45 degrees
   * container.skew.set(0.2, 0.2); // Skew the rotated object
   * ```
   * @since 4.0.0
   * @type {ObservablePoint} Point-like object with x/y properties in radians
   * @default {x: 0, y: 0}
   */ get skew() {
        if (this._skew === defaultSkew) {
            this._skew = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"](this, 0, 0);
        }
        return this._skew;
    }
    set skew(value) {
        if (this._skew === defaultSkew) {
            this._skew = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"](this, 0, 0);
        }
        this._skew.copyFrom(value);
    }
    /**
   * The scale factors of this object along the local coordinate axes.
   *
   * The default scale is (1, 1).
   * @example
   * ```ts
   * // Basic scaling
   * container.scale.set(2, 2); // Scales to double size
   * container.scale.set(2); // Scales uniformly to double size
   * container.scale = 2; // Scales uniformly to double size
   * // Scale to a specific width and height
   * container.setSize(200, 100); // Sets width to 200 and height to 100
   * ```
   * @since 4.0.0
   */ get scale() {
        if (this._scale === defaultScale) {
            this._scale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"](this, 1, 1);
        }
        return this._scale;
    }
    set scale(value) {
        if (this._scale === defaultScale) {
            this._scale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"](this, 0, 0);
        }
        if (typeof value === "string") {
            value = parseFloat(value);
        }
        typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);
    }
    /**
   * @experimental
   * The origin point around which the container rotates and scales without affecting its position.
   * Unlike pivot, changing the origin will not move the container's position.
   * @example
   * ```ts
   * // Rotate around center point
   * container.origin.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // Rotates around center
   *
   * // Reset origin
   * container.origin.set(0, 0);
   * ```
   */ get origin() {
        if (this._origin === defaultOrigin) {
            this._origin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"](this, 0, 0);
        }
        return this._origin;
    }
    set origin(value) {
        if (this._origin === defaultOrigin) {
            this._origin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"](this, 0, 0);
            if (this._pivot !== defaultPivot) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
            }
        }
        typeof value === "number" ? this._origin.set(value) : this._origin.copyFrom(value);
    }
    /**
   * The width of the Container, setting this will actually modify the scale to achieve the value set.
   * > [!NOTE] Changing the width will adjust the scale.x property of the container while maintaining its aspect ratio.
   * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
   * as it is more optimized by not recalculating the local bounds twice.
   * @example
   * ```ts
   * // Basic width setting
   * container.width = 100;
   * // Optimized width setting
   * container.setSize(100, 100);
   * ```
   */ get width() {
        return Math.abs(this.scale.x * this.getLocalBounds().width);
    }
    set width(value) {
        const localWidth = this.getLocalBounds().width;
        this._setWidth(value, localWidth);
    }
    /**
   * The height of the Container,
   * > [!NOTE] Changing the height will adjust the scale.y property of the container while maintaining its aspect ratio.
   * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
   * as it is more optimized by not recalculating the local bounds twice.
   * @example
   * ```ts
   * // Basic height setting
   * container.height = 200;
   * // Optimized height setting
   * container.setSize(100, 200);
   * ```
   */ get height() {
        return Math.abs(this.scale.y * this.getLocalBounds().height);
    }
    set height(value) {
        const localHeight = this.getLocalBounds().height;
        this._setHeight(value, localHeight);
    }
    /**
   * Retrieves the size of the container as a [Size]{@link Size} object.
   *
   * This is faster than get the width and height separately.
   * @example
   * ```ts
   * // Basic size retrieval
   * const size = container.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * container.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in.
   * @returns The size of the container.
   */ getSize(out) {
        if (!out) {
            out = {};
        }
        const bounds = this.getLocalBounds();
        out.width = Math.abs(this.scale.x * bounds.width);
        out.height = Math.abs(this.scale.y * bounds.height);
        return out;
    }
    /**
   * Sets the size of the container to the specified width and height.
   * This is more efficient than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * container.setSize(100, 200);
   *
   * // Set uniform size
   * container.setSize(100); // Sets both width and height to 100
   * ```
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */ setSize(value, height) {
        const size = this.getLocalBounds();
        if (typeof value === "object") {
            height = value.height ?? value.width;
            value = value.width;
        } else {
            height ?? (height = value);
        }
        value !== void 0 && this._setWidth(value, size.width);
        height !== void 0 && this._setHeight(height, size.height);
    }
    /** Called when the skew or the rotation changes. */ _updateSkew() {
        const rotation = this._rotation;
        const skew = this._skew;
        this._cx = Math.cos(rotation + skew._y);
        this._sx = Math.sin(rotation + skew._y);
        this._cy = -Math.sin(rotation - skew._x);
        this._sy = Math.cos(rotation - skew._x);
    }
    /**
   * Updates the transform properties of the container.
   * Allows partial updates of transform properties for optimized manipulation.
   * @example
   * ```ts
   * // Basic transform update
   * container.updateTransform({
   *     x: 100,
   *     y: 200,
   *     rotation: Math.PI / 4
   * });
   *
   * // Scale and rotate around center
   * sprite.updateTransform({
   *     pivotX: sprite.width / 2,
   *     pivotY: sprite.height / 2,
   *     scaleX: 2,
   *     scaleY: 2,
   *     rotation: Math.PI
   * });
   *
   * // Update position only
   * button.updateTransform({
   *     x: button.x + 10, // Move right
   *     y: button.y      // Keep same y
   * });
   * ```
   * @param opts - Transform options to update
   * @param opts.x - The x position
   * @param opts.y - The y position
   * @param opts.scaleX - The x-axis scale factor
   * @param opts.scaleY - The y-axis scale factor
   * @param opts.rotation - The rotation in radians
   * @param opts.skewX - The x-axis skew factor
   * @param opts.skewY - The y-axis skew factor
   * @param opts.pivotX - The x-axis pivot point
   * @param opts.pivotY - The y-axis pivot point
   * @returns This container, for chaining
   * @see {@link Container#setFromMatrix} For matrix-based transforms
   * @see {@link Container#position} For direct position access
   */ updateTransform(opts) {
        this.position.set(typeof opts.x === "number" ? opts.x : this.position.x, typeof opts.y === "number" ? opts.y : this.position.y);
        this.scale.set(typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x, typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y);
        this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
        this.skew.set(typeof opts.skewX === "number" ? opts.skewX : this.skew.x, typeof opts.skewY === "number" ? opts.skewY : this.skew.y);
        this.pivot.set(typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x, typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y);
        this.origin.set(typeof opts.originX === "number" ? opts.originX : this.origin.x, typeof opts.originY === "number" ? opts.originY : this.origin.y);
        return this;
    }
    /**
   * Updates the local transform properties by decomposing the given matrix.
   * Extracts position, scale, rotation, and skew from a transformation matrix.
   * @example
   * ```ts
   * // Basic matrix transform
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4)
   *     .scale(2, 2);
   *
   * container.setFromMatrix(matrix);
   *
   * // Copy transform from another container
   * const source = new Container();
   * source.position.set(100, 100);
   * source.rotation = Math.PI / 2;
   *
   * target.setFromMatrix(source.localTransform);
   *
   * // Reset transform
   * container.setFromMatrix(Matrix.IDENTITY);
   * ```
   * @param matrix - The matrix to use for updating the transform
   * @see {@link Container#updateTransform} For property-based updates
   * @see {@link Matrix#decompose} For matrix decomposition details
   */ setFromMatrix(matrix) {
        matrix.decompose(this);
    }
    /** Updates the local transform. */ updateLocalTransform() {
        const localTransformChangeId = this._didContainerChangeTick;
        if (this._didLocalTransformChangeId === localTransformChangeId) return;
        this._didLocalTransformChangeId = localTransformChangeId;
        const lt = this.localTransform;
        const scale = this._scale;
        const pivot = this._pivot;
        const origin = this._origin;
        const position = this._position;
        const sx = scale._x;
        const sy = scale._y;
        const px = pivot._x;
        const py = pivot._y;
        const ox = -origin._x;
        const oy = -origin._y;
        lt.a = this._cx * sx;
        lt.b = this._sx * sx;
        lt.c = this._cy * sy;
        lt.d = this._sy * sy;
        lt.tx = position._x - (px * lt.a + py * lt.c) + (ox * lt.a + oy * lt.c) - ox;
        lt.ty = position._y - (px * lt.b + py * lt.d) + (ox * lt.b + oy * lt.d) - oy;
    }
    // / ///// color related stuff
    set alpha(value) {
        if (value === this.localAlpha) return;
        this.localAlpha = value;
        this._updateFlags |= UPDATE_COLOR;
        this._onUpdate();
    }
    /**
   * The opacity of the object relative to its parent's opacity.
   * Value ranges from 0 (fully transparent) to 1 (fully opaque).
   * @example
   * ```ts
   * // Basic transparency
   * sprite.alpha = 0.5; // 50% opacity
   *
   * // Inherited opacity
   * container.alpha = 0.5;
   * const child = new Sprite(texture);
   * child.alpha = 0.5;
   * container.addChild(child);
   * // child's effective opacity is 0.25 (0.5 * 0.5)
   * ```
   * @default 1
   * @see {@link Container#visible} For toggling visibility
   * @see {@link Container#renderable} For render control
   */ get alpha() {
        return this.localAlpha;
    }
    set tint(value) {
        const tempColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(value ?? 16777215);
        const bgr = tempColor.toBgrNumber();
        if (bgr === this.localColor) return;
        this.localColor = bgr;
        this._updateFlags |= UPDATE_COLOR;
        this._onUpdate();
    }
    /**
   * The tint applied to the sprite.
   *
   * This can be any valid {@link ColorSource}.
   * @example
   * ```ts
   * // Basic color tinting
   * container.tint = 0xff0000; // Red tint
   * container.tint = 'red';    // Same as above
   * container.tint = '#00ff00'; // Green
   * container.tint = 'rgb(0,0,255)'; // Blue
   *
   * // Remove tint
   * container.tint = 0xffffff; // White = no tint
   * container.tint = null;     // Also removes tint
   * ```
   * @default 0xFFFFFF
   * @see {@link Container#alpha} For transparency
   * @see {@link Container#visible} For visibility control
   */ get tint() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$getGlobalMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bgr2rgb"])(this.localColor);
    }
    // / //////////////// blend related stuff
    set blendMode(value) {
        if (this.localBlendMode === value) return;
        if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_BLEND;
        this.localBlendMode = value;
        this._onUpdate();
    }
    /**
   * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.
   *
   * Setting to 'normal' will reset to default blending.
   * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.
   * @example
   * ```ts
   * // Basic blend modes
   * sprite.blendMode = 'add';        // Additive blending
   * sprite.blendMode = 'multiply';   // Multiply colors
   * sprite.blendMode = 'screen';     // Screen blend
   *
   * // Reset blend mode
   * sprite.blendMode = 'normal';     // Normal blending
   * ```
   * @default 'normal'
   * @see {@link Container#alpha} For transparency
   * @see {@link Container#tint} For color adjustments
   */ get blendMode() {
        return this.localBlendMode;
    }
    // / ///////// VISIBILITY / RENDERABLE /////////////////
    /**
   * The visibility of the object. If false the object will not be drawn,
   * and the transform will not be updated.
   * @example
   * ```ts
   * // Basic visibility toggle
   * sprite.visible = false; // Hide sprite
   * sprite.visible = true;  // Show sprite
   * ```
   * @default true
   * @see {@link Container#renderable} For render-only control
   * @see {@link Container#alpha} For transparency
   */ get visible() {
        return !!(this.localDisplayStatus & 2);
    }
    set visible(value) {
        const valueNumber = value ? 2 : 0;
        if ((this.localDisplayStatus & 2) === valueNumber) return;
        if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_VISIBLE;
        this.localDisplayStatus ^= 2;
        this._onUpdate();
    }
    /** @ignore */ get culled() {
        return !(this.localDisplayStatus & 4);
    }
    /** @ignore */ set culled(value) {
        const valueNumber = value ? 0 : 4;
        if ((this.localDisplayStatus & 4) === valueNumber) return;
        if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_VISIBLE;
        this.localDisplayStatus ^= 4;
        this._onUpdate();
    }
    /**
   * Controls whether this object can be rendered. If false the object will not be drawn,
   * but the transform will still be updated. This is different from visible, which skips
   * transform updates.
   * @example
   * ```ts
   * // Basic render control
   * sprite.renderable = false; // Skip rendering
   * sprite.renderable = true;  // Enable rendering
   * ```
   * @default true
   * @see {@link Container#visible} For skipping transform updates
   * @see {@link Container#alpha} For transparency
   */ get renderable() {
        return !!(this.localDisplayStatus & 1);
    }
    set renderable(value) {
        const valueNumber = value ? 1 : 0;
        if ((this.localDisplayStatus & 1) === valueNumber) return;
        this._updateFlags |= UPDATE_VISIBLE;
        this.localDisplayStatus ^= 1;
        if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
        }
        this._onUpdate();
    }
    /**
   * Whether or not the object should be rendered.
   * @advanced
   */ get isRenderable() {
        return this.localDisplayStatus === 7 && this.groupAlpha > 0;
    }
    /**
   * Removes all internal references and listeners as well as removes children from the display list.
   * Do not use a Container after calling `destroy`.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * ```ts
   * container.destroy();
   * container.destroy(true);
   * container.destroy({ children: true });
   * container.destroy({ children: true, texture: true, textureSource: true });
   * ```
   */ destroy(options = false) {
        if (this.destroyed) return;
        this.destroyed = true;
        let oldChildren;
        if (this.children.length) {
            oldChildren = this.removeChildren(0, this.children.length);
        }
        this.removeFromParent();
        this.parent = null;
        this._maskEffect = null;
        this._filterEffect = null;
        this.effects = null;
        this._position = null;
        this._scale = null;
        this._pivot = null;
        this._origin = null;
        this._skew = null;
        this.emit("destroyed", this);
        this.removeAllListeners();
        const destroyChildren = typeof options === "boolean" ? options : options?.children;
        if (destroyChildren && oldChildren) {
            for(let i = 0; i < oldChildren.length; ++i){
                oldChildren[i].destroy(options);
            }
        }
        this.renderGroup?.destroy();
        this.renderGroup = null;
    }
}
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extensions"].mixin(Container, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$childrenHelperMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["childrenHelperMixin"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$getFastGlobalBoundsMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFastGlobalBoundsMixin"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$toLocalGlobalMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toLocalGlobalMixin"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$onRenderMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["onRenderMixin"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$measureMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["measureMixin"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$effectsMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["effectsMixin"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$findMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["findMixin"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$sortMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sortMixin"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$culling$2f$cullingMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cullingMixin"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$cacheAsTextureMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cacheAsTextureMixin"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$getGlobalMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGlobalMixin"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$collectRenderablesMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["collectRenderablesMixin"]);
;
 //# sourceMappingURL=Container.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/view/ViewContainer.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ViewContainer",
    ()=>ViewContainer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/Container.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
class ViewContainer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Container"] {
    constructor(options){
        super(options);
        /** @internal */ this.canBundle = true;
        /** @internal */ this.allowChildren = false;
        /** @internal */ this._roundPixels = 0;
        /** @internal */ this._lastUsed = -1;
        /** @internal */ this._gpuData = /* @__PURE__ */ Object.create(null);
        /** If set to true, the resource will be garbage collected automatically when it is not used. */ this.autoGarbageCollect = true;
        /** @internal */ this._gcLastUsed = -1;
        this._bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bounds"](0, 1, 0, 0);
        this._boundsDirty = true;
        this.autoGarbageCollect = options.autoGarbageCollect ?? true;
    }
    /**
   * The local bounds of the view in its own coordinate space.
   * Bounds are automatically updated when the view's content changes.
   * @example
   * ```ts
   * // Get bounds dimensions
   * const bounds = view.bounds;
   * console.log(`Width: ${bounds.maxX - bounds.minX}`);
   * console.log(`Height: ${bounds.maxY - bounds.minY}`);
   * ```
   * @returns The rectangular bounds of the view
   * @see {@link Bounds} For bounds operations
   */ get bounds() {
        if (!this._boundsDirty) return this._bounds;
        this.updateBounds();
        this._boundsDirty = false;
        return this._bounds;
    }
    /**
   * Whether or not to round the x/y position of the sprite.
   * @example
   * ```ts
   * // Enable pixel rounding for crisp rendering
   * view.roundPixels = true;
   * ```
   * @default false
   */ get roundPixels() {
        return !!this._roundPixels;
    }
    set roundPixels(value) {
        this._roundPixels = value ? 1 : 0;
    }
    /**
   * Checks if the object contains the given point in local coordinates.
   * Uses the view's bounds for hit testing.
   * @example
   * ```ts
   * // Basic point check
   * const localPoint = { x: 50, y: 25 };
   * const contains = view.containsPoint(localPoint);
   * console.log('Point is inside:', contains);
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is within the view's bounds
   * @see {@link ViewContainer#bounds} For the bounds used in hit testing
   * @see {@link Container#toLocal} For converting global coordinates to local
   */ containsPoint(point) {
        const bounds = this.bounds;
        const { x, y } = point;
        return x >= bounds.minX && x <= bounds.maxX && y >= bounds.minY && y <= bounds.maxY;
    }
    /** @private */ onViewUpdate() {
        this._didViewChangeTick++;
        this._boundsDirty = true;
        if (this.didViewUpdate) return;
        this.didViewUpdate = true;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
            renderGroup.onChildViewUpdate(this);
        }
    }
    /** Unloads the GPU data from the view. */ unload() {
        this.emit("unload", this);
        for(const key in this._gpuData){
            this._gpuData[key]?.destroy();
        }
        this._gpuData = /* @__PURE__ */ Object.create(null);
        this.onViewUpdate();
    }
    destroy(options) {
        this.unload();
        super.destroy(options);
        this._bounds = null;
    }
    /**
   * Collects renderables for the view container.
   * @param instructionSet - The instruction set to collect renderables for.
   * @param renderer - The renderer to collect renderables for.
   * @param currentLayer - The current render layer.
   * @internal
   */ collectRenderablesSimple(instructionSet, renderer, currentLayer) {
        const { renderPipes } = renderer;
        renderPipes.blendMode.pushBlendMode(this, this.groupBlendMode, instructionSet);
        const rp = renderPipes;
        rp[this.renderPipeId].addRenderable(this, instructionSet);
        this.didViewUpdate = false;
        const children = this.children;
        const length = children.length;
        for(let i = 0; i < length; i++){
            children[i].collectRenderables(instructionSet, renderer, currentLayer);
        }
        renderPipes.blendMode.popBlendMode(instructionSet);
    }
}
;
 //# sourceMappingURL=ViewContainer.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Sprite",
    ()=>Sprite
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$updateQuadBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/view/ViewContainer.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
"use strict";
class Sprite extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ViewContainer"] {
    /**
   * @param options - The options for creating the sprite.
   */ constructor(options = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY){
        if (options instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]) {
            options = {
                texture: options
            };
        }
        const { texture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY, anchor, roundPixels, width, height, ...rest } = options;
        super({
            label: "Sprite",
            ...rest
        });
        /** @internal */ this.renderPipeId = "sprite";
        /** @internal */ this.batched = true;
        this._visualBounds = {
            minX: 0,
            maxX: 1,
            minY: 0,
            maxY: 0
        };
        this._anchor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"]({
            _onUpdate: ()=>{
                this.onViewUpdate();
            }
        });
        if (anchor) {
            this.anchor = anchor;
        } else if (texture.defaultAnchor) {
            this.anchor = texture.defaultAnchor;
        }
        this.texture = texture;
        this.allowChildren = false;
        this.roundPixels = roundPixels ?? false;
        if (width !== void 0) this.width = width;
        if (height !== void 0) this.height = height;
    }
    /**
   * Creates a new sprite based on a source texture, image, video, or canvas element.
   * This is a convenience method that automatically creates and manages textures.
   * @example
   * ```ts
   * // Create from path or URL
   * const sprite = Sprite.from('assets/image.png');
   *
   * // Create from existing texture
   * const sprite = Sprite.from(texture);
   *
   * // Create from canvas
   * const canvas = document.createElement('canvas');
   * const sprite = Sprite.from(canvas, true); // Skip caching new texture
   * ```
   * @param source - The source to create the sprite from. Can be a path to an image, a texture,
   * or any valid texture source (canvas, video, etc.)
   * @param skipCache - Whether to skip adding to the texture cache when creating a new texture
   * @returns A new sprite based on the source
   * @see {@link Texture.from} For texture creation details
   * @see {@link Assets} For asset loading and management
   */ static from(source, skipCache = false) {
        if (source instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]) {
            return new Sprite(source);
        }
        return new Sprite(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].from(source, skipCache));
    }
    set texture(value) {
        value || (value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY);
        const currentTexture = this._texture;
        if (currentTexture === value) return;
        if (currentTexture && currentTexture.dynamic) currentTexture.off("update", this.onViewUpdate, this);
        if (value.dynamic) value.on("update", this.onViewUpdate, this);
        this._texture = value;
        if (this._width) {
            this._setWidth(this._width, this._texture.orig.width);
        }
        if (this._height) {
            this._setHeight(this._height, this._texture.orig.height);
        }
        this.onViewUpdate();
    }
    /**
   * The texture that is displayed by the sprite. When changed, automatically updates
   * the sprite dimensions and manages texture event listeners.
   * @example
   * ```ts
   * // Create sprite with texture
   * const sprite = new Sprite({
   *     texture: Texture.from('sprite.png')
   * });
   *
   * // Update texture
   * sprite.texture = Texture.from('newSprite.png');
   *
   * // Use texture from spritesheet
   * const sheet = await Assets.load('spritesheet.json');
   * sprite.texture = sheet.textures['frame1.png'];
   *
   * // Reset to empty texture
   * sprite.texture = Texture.EMPTY;
   * ```
   * @see {@link Texture} For texture creation and management
   * @see {@link Assets} For asset loading
   */ get texture() {
        return this._texture;
    }
    /**
   * The bounds of the sprite, taking into account the texture's trim area.
   * @example
   * ```ts
   * const texture = new Texture({
   *     source: new TextureSource({ width: 300, height: 300 }),
   *     frame: new Rectangle(196, 66, 58, 56),
   *     trim: new Rectangle(4, 4, 58, 56),
   *     orig: new Rectangle(0, 0, 64, 64),
   *     rotate: 2,
   * });
   * const sprite = new Sprite(texture);
   * const visualBounds = sprite.visualBounds;
   * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }
   */ get visualBounds() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$updateQuadBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["updateQuadBounds"])(this._visualBounds, this._anchor, this._texture);
        return this._visualBounds;
    }
    /**
   * @deprecated
   * @ignore
   */ get sourceBounds() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead.");
        return this.visualBounds;
    }
    /** @private */ updateBounds() {
        const anchor = this._anchor;
        const texture = this._texture;
        const bounds = this._bounds;
        const { width, height } = texture.orig;
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * height;
        bounds.maxY = bounds.minY + height;
    }
    /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * sprite.destroy();
   * sprite.destroy(true);
   * sprite.destroy({ texture: true, textureSource: true });
   */ destroy(options = false) {
        super.destroy(options);
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
        this._visualBounds = null;
        this._bounds = null;
        this._anchor = null;
    }
    /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * - The default is `(0,0)`, this means the sprite's origin is the top left.
   * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * ```ts
   * // Center the anchor point
   * sprite.anchor = 0.5; // Sets both x and y to 0.5
   * sprite.position.set(400, 300); // Sprite will be centered at this position
   *
   * // Set specific x/y anchor points
   * sprite.anchor = {
   *     x: 1, // Right edge
   *     y: 0  // Top edge
   * };
   *
   * // Using individual coordinates
   * sprite.anchor.set(0.5, 1); // Center-bottom
   *
   * // For rotation around center
   * sprite.anchor.set(0.5);
   * sprite.rotation = Math.PI / 4; // 45 degrees around center
   *
   * // For scaling from center
   * sprite.anchor.set(0.5);
   * sprite.scale.set(2); // Scales from center point
   * ```
   */ get anchor() {
        return this._anchor;
    }
    set anchor(value) {
        typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    /**
   * The width of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set width directly
   * sprite.width = 200;
   * console.log(sprite.scale.x); // Scale adjusted to match width
   *
   * // Set width while preserving aspect ratio
   * const ratio = sprite.height / sprite.width;
   * sprite.width = 300;
   * sprite.height = 300 * ratio;
   *
   * // For better performance when setting both width and height
   * sprite.setSize(300, 400); // Avoids recalculating bounds twice
   *
   * // Reset to original texture size
   * sprite.width = sprite.texture.orig.width;
   * ```
   */ get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(value) {
        this._setWidth(value, this._texture.orig.width);
        this._width = value;
    }
    /**
   * The height of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set height directly
   * sprite.height = 150;
   * console.log(sprite.scale.y); // Scale adjusted to match height
   *
   * // Set height while preserving aspect ratio
   * const ratio = sprite.width / sprite.height;
   * sprite.height = 200;
   * sprite.width = 200 * ratio;
   *
   * // For better performance when setting both width and height
   * sprite.setSize(300, 400); // Avoids recalculating bounds twice
   *
   * // Reset to original texture size
   * sprite.height = sprite.texture.orig.height;
   * ```
   */ get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(value) {
        this._setHeight(value, this._texture.orig.height);
        this._height = value;
    }
    /**
   * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.
   * This is faster than getting width and height separately as it only calculates the bounds once.
   * @example
   * ```ts
   * // Basic size retrieval
   * const sprite = new Sprite(Texture.from('sprite.png'));
   * const size = sprite.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * sprite.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in, to avoid allocating a new object
   * @returns The size of the Sprite
   * @see {@link Sprite#width} For getting just the width
   * @see {@link Sprite#height} For getting just the height
   * @see {@link Sprite#setSize} For setting both width and height
   */ getSize(out) {
        out || (out = {});
        out.width = Math.abs(this.scale.x) * this._texture.orig.width;
        out.height = Math.abs(this.scale.y) * this._texture.orig.height;
        return out;
    }
    /**
   * Sets the size of the Sprite to the specified width and height.
   * This is faster than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * const sprite = new Sprite(Texture.from('sprite.png'));
   * sprite.setSize(100, 200); // Width: 100, Height: 200
   *
   * // Set uniform size
   * sprite.setSize(100); // Sets both width and height to 100
   *
   * // Set size with object
   * sprite.setSize({
   *     width: 200,
   *     height: 300
   * });
   *
   * // Reset to texture size
   * sprite.setSize(
   *     sprite.texture.orig.width,
   *     sprite.texture.orig.height
   * );
   * ```
   * @param value - This can be either a number or a {@link Size} object
   * @param height - The height to set. Defaults to the value of `width` if not provided
   * @see {@link Sprite#width} For setting width only
   * @see {@link Sprite#height} For setting height only
   * @see {@link Sprite#texture} For the source dimensions
   */ setSize(value, height) {
        if (typeof value === "object") {
            height = value.height ?? value.width;
            value = value.width;
        } else {
            height ?? (height = value);
        }
        value !== void 0 && this._setWidth(value, this._texture.orig.width);
        height !== void 0 && this._setHeight(height, this._texture.orig.height);
    }
}
;
 //# sourceMappingURL=Sprite.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbstractBitmapFont",
    ()=>AbstractBitmapFont
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
class AbstractBitmapFont extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"] {
    constructor(){
        super(...arguments);
        /** The map of characters by character code. */ this.chars = /* @__PURE__ */ Object.create(null);
        /**
     * The line-height of the font face in pixels.
     * @type {number}
     */ this.lineHeight = 0;
        /**
     * The name of the font face
     * @type {string}
     */ this.fontFamily = "";
        /** The metrics of the font face. */ this.fontMetrics = {
            fontSize: 0,
            ascent: 0,
            descent: 0
        };
        /**
     * The offset of the font face from the baseline.
     * @type {number}
     */ this.baseLineOffset = 0;
        /** The range and type of the distance field for this font. */ this.distanceField = {
            type: "none",
            range: 0
        };
        /** The map of base page textures (i.e., sheets of glyphs). */ this.pages = [];
        /** should the fill for this font be applied as a tint to the text. */ this.applyFillAsTint = true;
        /** The size of the font face in pixels. */ this.baseMeasurementFontSize = 100;
        this.baseRenderedFontSize = 100;
    }
    /**
   * The name of the font face.
   * @deprecated since 8.0.0 Use `fontFamily` instead.
   */ get font() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
        return this.fontFamily;
    }
    /**
   * The map of base page textures (i.e., sheets of glyphs).
   * @deprecated since 8.0.0 Use `pages` instead.
   */ get pageTextures() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
        return this.pages;
    }
    /**
   * The size of the font face in pixels.
   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
   */ get size() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
        return this.fontMetrics.fontSize;
    }
    /**
   * The kind of distance field for this font or "none".
   * @deprecated since 8.0.0 Use `distanceField.type` instead.
   */ get distanceFieldRange() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
        return this.distanceField.range;
    }
    /**
   * The range of the distance field in pixels.
   * @deprecated since 8.0.0 Use `distanceField.range` instead.
   */ get distanceFieldType() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
        return this.distanceField.type;
    }
    destroy(destroyTextures = false) {
        this.emit("destroy", this);
        this.removeAllListeners();
        for(const i in this.chars){
            this.chars[i].texture?.destroy();
        }
        this.chars = null;
        if (destroyTextures) {
            this.pages.forEach((page)=>page.texture.destroy(true));
            this.pages = null;
        }
    }
}
;
 //# sourceMappingURL=AbstractBitmapFont.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fontStringFromTextStyle",
    ()=>fontStringFromTextStyle
]);
"use strict";
const genericFontFamilies = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
];
function fontStringFromTextStyle(style) {
    const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
    let fontFamilies = style.fontFamily;
    if (!Array.isArray(style.fontFamily)) {
        fontFamilies = style.fontFamily.split(",");
    }
    for(let i = fontFamilies.length - 1; i >= 0; i--){
        let fontFamily = fontFamilies[i].trim();
        if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
            fontFamily = `"${fontFamily}"`;
        }
        fontFamilies[i] = fontFamily;
    }
    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
}
;
 //# sourceMappingURL=fontStringFromTextStyle.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CanvasTextMetrics",
    ()=>CanvasTextMetrics
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$lru$2f$dist$2f$tiny$2d$lru$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tiny-lru/dist/tiny-lru.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$utils$2f$fontStringFromTextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
const contextSettings = {
    // TextMetrics requires getImageData readback for measuring fonts.
    willReadFrequently: true
};
const _CanvasTextMetrics = class _CanvasTextMetrics {
    /**
   * Checking that we can use modern canvas 2D API.
   *
   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
   * @see TextMetrics.experimentalLetterSpacing
   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
   */ static get experimentalLetterSpacingSupported() {
        let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;
        if (result === void 0) {
            const proto = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DOMAdapter"].get().getCanvasRenderingContext2D().prototype;
            result = _CanvasTextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
        }
        return result;
    }
    /**
   * @param text - the text that was measured
   * @param style - the style that was measured
   * @param width - the measured width of the text
   * @param height - the measured height of the text
   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
   * @param lineWidths - an array of the line widths for each line matched to `lines`
   * @param lineHeight - the measured line height for this style
   * @param maxLineWidth - the maximum line width for all measured lines
   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
   */ constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties){
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
    }
    /**
   * Measures the supplied string of text and returns a Rectangle.
   * @param text - The text to measure.
   * @param style - The text style to use for measuring
   * @param canvas - optional specification of the canvas to use for measuring.
   * @param wordWrap
   * @returns Measured width and height of the text.
   */ static measureText(text = " ", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {
        const textKey = `${text}-${style.styleKey}-wordWrap-${wordWrap}`;
        if (_CanvasTextMetrics._measurementCache.has(textKey)) {
            return _CanvasTextMetrics._measurementCache.get(textKey);
        }
        const font = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$utils$2f$fontStringFromTextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fontStringFromTextStyle"])(style);
        const fontProperties = _CanvasTextMetrics.measureFont(font);
        if (fontProperties.fontSize === 0) {
            fontProperties.fontSize = style.fontSize;
            fontProperties.ascent = style.fontSize;
        }
        const context = _CanvasTextMetrics.__context;
        context.font = font;
        const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;
        const lines = outputText.split(/(?:\r\n|\r|\n)/);
        const lineWidths = new Array(lines.length);
        let maxLineWidth = 0;
        for(let i = 0; i < lines.length; i++){
            const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);
            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        const strokeWidth = style._stroke?.width || 0;
        let width = maxLineWidth + strokeWidth;
        if (style.dropShadow) {
            width += style.dropShadow.distance;
        }
        const lineHeight = style.lineHeight || fontProperties.fontSize;
        let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);
        if (style.dropShadow) {
            height += style.dropShadow.distance;
        }
        const measurements = new _CanvasTextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
        _CanvasTextMetrics._measurementCache.set(textKey, measurements);
        return measurements;
    }
    static _measureText(text, letterSpacing, context) {
        let useExperimentalLetterSpacing = false;
        if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {
            if (_CanvasTextMetrics.experimentalLetterSpacing) {
                context.letterSpacing = `${letterSpacing}px`;
                context.textLetterSpacing = `${letterSpacing}px`;
                useExperimentalLetterSpacing = true;
            } else {
                context.letterSpacing = "0px";
                context.textLetterSpacing = "0px";
            }
        }
        const metrics = context.measureText(text);
        let metricWidth = metrics.width;
        const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;
        const actualBoundingBoxRight = metrics.actualBoundingBoxRight;
        let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;
        if (metricWidth > 0) {
            if (useExperimentalLetterSpacing) {
                metricWidth -= letterSpacing;
                boundsWidth -= letterSpacing;
            } else {
                const val = (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
                metricWidth += val;
                boundsWidth += val;
            }
        }
        return Math.max(metricWidth, boundsWidth);
    }
    /**
   * Applies newlines to a string to have it optimally fit into the horizontal
   * bounds set by the Text object's wordWrapWidth property.
   * @param text - String to apply word wrapping to
   * @param style - the style to use when wrapping
   * @param canvas - optional specification of the canvas to use for measuring.
   * @returns New string with new lines applied where required
   */ static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {
        const context = canvas.getContext("2d", contextSettings);
        let width = 0;
        let line = "";
        let lines = "";
        const cache = /* @__PURE__ */ Object.create(null);
        const { letterSpacing, whiteSpace } = style;
        const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);
        const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);
        let canPrependSpaces = !collapseSpaces;
        const wordWrapWidth = style.wordWrapWidth + letterSpacing;
        const tokens = _CanvasTextMetrics._tokenize(text);
        for(let i = 0; i < tokens.length; i++){
            let token = tokens[i];
            if (_CanvasTextMetrics._isNewline(token)) {
                if (!collapseNewlines) {
                    lines += _CanvasTextMetrics._addLine(line);
                    canPrependSpaces = !collapseSpaces;
                    line = "";
                    width = 0;
                    continue;
                }
                token = " ";
            }
            if (collapseSpaces) {
                const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);
                const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);
                if (currIsBreakingSpace && lastIsBreakingSpace) {
                    continue;
                }
            }
            const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);
            if (tokenWidth > wordWrapWidth) {
                if (line !== "") {
                    lines += _CanvasTextMetrics._addLine(line);
                    line = "";
                    width = 0;
                }
                if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {
                    const characters = _CanvasTextMetrics.wordWrapSplit(token);
                    for(let j = 0; j < characters.length; j++){
                        let char = characters[j];
                        let lastChar = char;
                        let k = 1;
                        while(characters[j + k]){
                            const nextChar = characters[j + k];
                            if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                                char += nextChar;
                            } else {
                                break;
                            }
                            lastChar = nextChar;
                            k++;
                        }
                        j += k - 1;
                        const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);
                        if (characterWidth + width > wordWrapWidth) {
                            lines += _CanvasTextMetrics._addLine(line);
                            canPrependSpaces = false;
                            line = "";
                            width = 0;
                        }
                        line += char;
                        width += characterWidth;
                    }
                } else {
                    if (line.length > 0) {
                        lines += _CanvasTextMetrics._addLine(line);
                        line = "";
                        width = 0;
                    }
                    const isLastToken = i === tokens.length - 1;
                    lines += _CanvasTextMetrics._addLine(token, !isLastToken);
                    canPrependSpaces = false;
                    line = "";
                    width = 0;
                }
            } else {
                if (tokenWidth + width > wordWrapWidth) {
                    canPrependSpaces = false;
                    lines += _CanvasTextMetrics._addLine(line);
                    line = "";
                    width = 0;
                }
                if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {
                    line += token;
                    width += tokenWidth;
                }
            }
        }
        lines += _CanvasTextMetrics._addLine(line, false);
        return lines;
    }
    /**
   * Convenience function for logging each line added during the wordWrap method.
   * @param line    - The line of text to add
   * @param newLine - Add new line character to end
   * @returns A formatted line
   */ static _addLine(line, newLine = true) {
        line = _CanvasTextMetrics._trimRight(line);
        line = newLine ? `${line}
` : line;
        return line;
    }
    /**
   * Gets & sets the widths of calculated characters in a cache object
   * @param key            - The key
   * @param letterSpacing  - The letter spacing
   * @param cache          - The cache
   * @param context        - The canvas context
   * @returns The from cache.
   */ static _getFromCache(key, letterSpacing, cache, context) {
        let width = cache[key];
        if (typeof width !== "number") {
            width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;
            cache[key] = width;
        }
        return width;
    }
    /**
   * Determines whether we should collapse breaking spaces.
   * @param whiteSpace - The TextStyle property whiteSpace
   * @returns Should collapse
   */ static _collapseSpaces(whiteSpace) {
        return whiteSpace === "normal" || whiteSpace === "pre-line";
    }
    /**
   * Determines whether we should collapse newLine chars.
   * @param whiteSpace - The white space
   * @returns should collapse
   */ static _collapseNewlines(whiteSpace) {
        return whiteSpace === "normal";
    }
    /**
   * Trims breaking whitespaces from string.
   * @param text - The text
   * @returns Trimmed string
   */ static _trimRight(text) {
        if (typeof text !== "string") {
            return "";
        }
        for(let i = text.length - 1; i >= 0; i--){
            const char = text[i];
            if (!_CanvasTextMetrics.isBreakingSpace(char)) {
                break;
            }
            text = text.slice(0, -1);
        }
        return text;
    }
    /**
   * Determines if char is a newline.
   * @param char - The character
   * @returns True if newline, False otherwise.
   */ static _isNewline(char) {
        if (typeof char !== "string") {
            return false;
        }
        return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));
    }
    /**
   * Determines if char is a breaking whitespace.
   *
   * It allows one to determine whether char should be a breaking whitespace
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param char - The character
   * @param [_nextChar] - The next character
   * @returns True if whitespace, False otherwise.
   */ static isBreakingSpace(char, _nextChar) {
        if (typeof char !== "string") {
            return false;
        }
        return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));
    }
    /**
   * Splits a string into words, breaking-spaces and newLine characters
   * @param text - The text
   * @returns A tokenized array
   */ static _tokenize(text) {
        const tokens = [];
        let token = "";
        if (typeof text !== "string") {
            return tokens;
        }
        for(let i = 0; i < text.length; i++){
            const char = text[i];
            const nextChar = text[i + 1];
            if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {
                if (token !== "") {
                    tokens.push(token);
                    token = "";
                }
                if (char === "\r" && nextChar === "\n") {
                    tokens.push("\r\n");
                    i++;
                } else {
                    tokens.push(char);
                }
                continue;
            }
            token += char;
        }
        if (token !== "") {
            tokens.push(token);
        }
        return tokens;
    }
    /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to customise which words should break
   * Examples are if the token is CJK or numbers.
   * It must return a boolean.
   * @param _token - The token
   * @param breakWords - The style attr break words
   * @returns Whether to break word or not
   */ static canBreakWords(_token, breakWords) {
        return breakWords;
    }
    /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to determine whether a pair of characters
   * should be broken by newlines
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param _char - The character
   * @param _nextChar - The next character
   * @param _token - The token/word the characters are from
   * @param _index - The index in the token of the char
   * @param _breakWords - The style attr break words
   * @returns whether to break word or not
   */ static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
        return true;
    }
    /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It is called when a token (usually a word) has to be split into separate pieces
   * in order to determine the point to break a word.
   * It must return an array of characters.
   * @param token - The token to split
   * @returns The characters of the token
   * @see CanvasTextMetrics.graphemeSegmenter
   */ static wordWrapSplit(token) {
        return _CanvasTextMetrics.graphemeSegmenter(token);
    }
    /**
   * Calculates the ascent, descent and fontSize of a given font-style
   * @param font - String representing the style of the font
   * @returns Font properties object
   */ static measureFont(font) {
        if (_CanvasTextMetrics._fonts[font]) {
            return _CanvasTextMetrics._fonts[font];
        }
        const context = _CanvasTextMetrics._context;
        context.font = font;
        const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);
        const properties = {
            ascent: metrics.actualBoundingBoxAscent,
            descent: metrics.actualBoundingBoxDescent,
            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
        };
        _CanvasTextMetrics._fonts[font] = properties;
        return properties;
    }
    /**
   * Clear font metrics in metrics cache.
   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
   */ static clearMetrics(font = "") {
        if (font) {
            delete _CanvasTextMetrics._fonts[font];
        } else {
            _CanvasTextMetrics._fonts = {};
        }
    }
    /**
   * Cached canvas element for measuring text
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */ static get _canvas() {
        if (!_CanvasTextMetrics.__canvas) {
            let canvas;
            try {
                const c = new OffscreenCanvas(0, 0);
                const context = c.getContext("2d", contextSettings);
                if (context?.measureText) {
                    _CanvasTextMetrics.__canvas = c;
                    return c;
                }
                canvas = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DOMAdapter"].get().createCanvas();
            } catch (_cx) {
                canvas = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DOMAdapter"].get().createCanvas();
            }
            canvas.width = canvas.height = 10;
            _CanvasTextMetrics.__canvas = canvas;
        }
        return _CanvasTextMetrics.__canvas;
    }
    /**
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */ static get _context() {
        if (!_CanvasTextMetrics.__context) {
            _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext("2d", contextSettings);
        }
        return _CanvasTextMetrics.__context;
    }
};
/**
 * String used for calculate font metrics.
 * These characters are all tall to help calculate the height required for text.
 */ _CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
/** Baseline symbol for calculate font metrics. */ _CanvasTextMetrics.BASELINE_SYMBOL = "M";
/** Baseline multiplier for calculate font metrics. */ _CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
/** Height multiplier for setting height of canvas to calculate font metrics. */ _CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
/**
 * A Unicode "character", or "grapheme cluster", can be composed of multiple Unicode code points,
 * such as letters with diacritical marks (e.g. `'\u0065\u0301'`, letter e with acute)
 * or emojis with modifiers (e.g. `'\uD83E\uDDD1\u200D\uD83D\uDCBB'`, technologist).
 * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,
 * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.
 * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),
 * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}
 * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be
 * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.
 */ _CanvasTextMetrics.graphemeSegmenter = (()=>{
    if (typeof Intl?.Segmenter === "function") {
        const segmenter = new Intl.Segmenter();
        return (s)=>{
            const segments = segmenter.segment(s);
            const result = [];
            let i = 0;
            for (const segment of segments){
                result[i++] = segment.segment;
            }
            return result;
        };
    }
    return (s)=>[
            ...s
        ];
})();
/**
 * New rendering behavior for letter-spacing which uses Chrome's new native API. This will
 * lead to more accurate letter-spacing results because it does not try to manually draw
 * each character. However, this Chrome API is experimental and may not serve all cases yet.
 * @see TextMetrics.experimentalLetterSpacingSupported
 */ _CanvasTextMetrics.experimentalLetterSpacing = false;
/** Cache of {@link TextMetrics.FontMetrics} objects. */ _CanvasTextMetrics._fonts = {};
/** Cache of new line chars. */ _CanvasTextMetrics._newlines = [
    10,
    // line feed
    13
];
/** Cache of breaking spaces. */ _CanvasTextMetrics._breakingSpaces = [
    9,
    // character tabulation
    32,
    // space
    8192,
    // en quad
    8193,
    // em quad
    8194,
    // en space
    8195,
    // em space
    8196,
    // three-per-em space
    8197,
    // four-per-em space
    8198,
    // six-per-em space
    8200,
    // punctuation space
    8201,
    // thin space
    8202,
    // hair space
    8287,
    // medium mathematical space
    12288
];
/** Cache for measured text metrics */ _CanvasTextMetrics._measurementCache = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$lru$2f$dist$2f$tiny$2d$lru$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lru"])(1e3);
let CanvasTextMetrics = _CanvasTextMetrics;
;
 //# sourceMappingURL=CanvasTextMetrics.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FillGradient",
    ()=>FillGradient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$ImageSource$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$uid$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/uid.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
"use strict";
const emptyColorStops = [
    {
        offset: 0,
        color: "white"
    },
    {
        offset: 1,
        color: "black"
    }
];
const _FillGradient = class _FillGradient {
    constructor(...args){
        /**
     * Unique identifier for this gradient instance
     * @internal
     */ this.uid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$uid$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uid"])("fillGradient");
        /**
     * Internal tick counter to track changes in the gradient.
     * This is used to invalidate the gradient when the texture changes.
     * @internal
     */ this._tick = 0;
        /** Type of gradient - currently only supports 'linear' */ this.type = "linear";
        /** Array of color stops defining the gradient */ this.colorStops = [];
        let options = ensureGradientOptions(args);
        const defaults = options.type === "radial" ? _FillGradient.defaultRadialOptions : _FillGradient.defaultLinearOptions;
        options = {
            ...defaults,
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["definedProps"])(options)
        };
        this._textureSize = options.textureSize;
        this._wrapMode = options.wrapMode;
        if (options.type === "radial") {
            this.center = options.center;
            this.outerCenter = options.outerCenter ?? this.center;
            this.innerRadius = options.innerRadius;
            this.outerRadius = options.outerRadius;
            this.scale = options.scale;
            this.rotation = options.rotation;
        } else {
            this.start = options.start;
            this.end = options.end;
        }
        this.textureSpace = options.textureSpace;
        this.type = options.type;
        options.colorStops.forEach((stop)=>{
            this.addColorStop(stop.offset, stop.color);
        });
    }
    /**
   * Adds a color stop to the gradient
   * @param offset - Position of the stop (0-1)
   * @param color - Color of the stop
   * @returns This gradient instance for chaining
   */ addColorStop(offset, color) {
        this.colorStops.push({
            offset,
            color: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(color).toHexa()
        });
        return this;
    }
    /**
   * Builds the internal texture and transform for the gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */ buildLinearGradient() {
        if (this.texture) return;
        let { x: x0, y: y0 } = this.start;
        let { x: x1, y: y1 } = this.end;
        let dx = x1 - x0;
        let dy = y1 - y0;
        const flip = dx < 0 || dy < 0;
        if (this._wrapMode === "clamp-to-edge") {
            if (dx < 0) {
                const temp = x0;
                x0 = x1;
                x1 = temp;
                dx *= -1;
            }
            if (dy < 0) {
                const temp = y0;
                y0 = y1;
                y1 = temp;
                dy *= -1;
            }
        }
        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
        const defaultSize = this._textureSize;
        const { canvas, context } = getCanvas(defaultSize, 1);
        const gradient = !flip ? context.createLinearGradient(0, 0, this._textureSize, 0) : context.createLinearGradient(this._textureSize, 0, 0, 0);
        addColorStops(gradient, colorStops);
        context.fillStyle = gradient;
        context.fillRect(0, 0, defaultSize, 1);
        this.texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]({
            source: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$ImageSource$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ImageSource"]({
                resource: canvas,
                addressMode: this._wrapMode
            })
        });
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        const m = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
        m.scale(dist / defaultSize, 1);
        m.rotate(angle);
        m.translate(x0, y0);
        if (this.textureSpace === "local") {
            m.scale(defaultSize, defaultSize);
        }
        this.transform = m;
    }
    /**
   * Builds the internal texture and transform for the gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */ buildGradient() {
        if (!this.texture) this._tick++;
        if (this.type === "linear") {
            this.buildLinearGradient();
        } else {
            this.buildRadialGradient();
        }
    }
    /**
   * Builds the internal texture and transform for the radial gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */ buildRadialGradient() {
        if (this.texture) return;
        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
        const defaultSize = this._textureSize;
        const { canvas, context } = getCanvas(defaultSize, defaultSize);
        const { x: x0, y: y0 } = this.center;
        const { x: x1, y: y1 } = this.outerCenter;
        const r0 = this.innerRadius;
        const r1 = this.outerRadius;
        const ox = x1 - r1;
        const oy = y1 - r1;
        const scale = defaultSize / (r1 * 2);
        const cx = (x0 - ox) * scale;
        const cy = (y0 - oy) * scale;
        const gradient = context.createRadialGradient(cx, cy, r0 * scale, (x1 - ox) * scale, (y1 - oy) * scale, r1 * scale);
        addColorStops(gradient, colorStops);
        context.fillStyle = colorStops[colorStops.length - 1].color;
        context.fillRect(0, 0, defaultSize, defaultSize);
        context.fillStyle = gradient;
        context.translate(cx, cy);
        context.rotate(this.rotation);
        context.scale(1, this.scale);
        context.translate(-cx, -cy);
        context.fillRect(0, 0, defaultSize, defaultSize);
        this.texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]({
            source: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$ImageSource$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ImageSource"]({
                resource: canvas,
                addressMode: this._wrapMode
            })
        });
        const m = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
        m.scale(1 / scale, 1 / scale);
        m.translate(ox, oy);
        if (this.textureSpace === "local") {
            m.scale(defaultSize, defaultSize);
        }
        this.transform = m;
    }
    /** Destroys the gradient, releasing resources. This will also destroy the internal texture. */ destroy() {
        this.texture?.destroy(true);
        this.texture = null;
        this.transform = null;
        this.colorStops = [];
        this.start = null;
        this.end = null;
        this.center = null;
        this.outerCenter = null;
    }
    /**
   * Returns a unique key for this gradient instance.
   * This key is used for caching and texture management.
   * @returns {string} Unique key for the gradient
   */ get styleKey() {
        return `fill-gradient-${this.uid}-${this._tick}`;
    }
};
/** Default options for creating a gradient fill */ _FillGradient.defaultLinearOptions = {
    start: {
        x: 0,
        y: 0
    },
    end: {
        x: 0,
        y: 1
    },
    colorStops: [],
    textureSpace: "local",
    type: "linear",
    textureSize: 256,
    wrapMode: "clamp-to-edge"
};
/** Default options for creating a radial gradient fill */ _FillGradient.defaultRadialOptions = {
    center: {
        x: 0.5,
        y: 0.5
    },
    innerRadius: 0,
    outerRadius: 0.5,
    colorStops: [],
    scale: 1,
    textureSpace: "local",
    type: "radial",
    textureSize: 256,
    wrapMode: "clamp-to-edge"
};
let FillGradient = _FillGradient;
function addColorStops(gradient, colorStops) {
    for(let i = 0; i < colorStops.length; i++){
        const stop = colorStops[i];
        gradient.addColorStop(stop.offset, stop.color);
    }
}
function getCanvas(width, height) {
    const canvas = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DOMAdapter"].get().createCanvas(width, height);
    const context = canvas.getContext("2d");
    return {
        canvas,
        context
    };
}
function ensureGradientOptions(args) {
    let options = args[0] ?? {};
    if (typeof options === "number" || args[1]) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])("8.5.2", `use options object instead`);
        options = {
            type: "linear",
            start: {
                x: args[0],
                y: args[1]
            },
            end: {
                x: args[2],
                y: args[3]
            },
            textureSpace: args[4],
            textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize
        };
    }
    return options;
}
;
 //# sourceMappingURL=FillGradient.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FillPattern",
    ()=>FillPattern
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$uid$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/uid.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const repetitionMap = {
    repeat: {
        addressModeU: "repeat",
        addressModeV: "repeat"
    },
    "repeat-x": {
        addressModeU: "repeat",
        addressModeV: "clamp-to-edge"
    },
    "repeat-y": {
        addressModeU: "clamp-to-edge",
        addressModeV: "repeat"
    },
    "no-repeat": {
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
    }
};
class FillPattern {
    constructor(texture, repetition){
        /**
     * unique id for this fill pattern
     * @internal
     */ this.uid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$uid$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uid"])("fillPattern");
        /**
     * Internal tick counter to track changes in the pattern.
     * This is used to invalidate the pattern when the texture or transform changes.
     * @internal
     */ this._tick = 0;
        /** The transform matrix applied to the pattern */ this.transform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
        this.texture = texture;
        this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);
        if (repetition) {
            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
        }
    }
    /**
   * Sets the transform for the pattern
   * @param transform - The transform matrix to apply to the pattern.
   * If not provided, the pattern will use the default transform.
   */ setTransform(transform) {
        const texture = this.texture;
        this.transform.copyFrom(transform);
        this.transform.invert();
        this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);
        this._tick++;
    }
    /** Internal texture used to render the gradient */ get texture() {
        return this._texture;
    }
    set texture(value) {
        if (this._texture === value) return;
        this._texture = value;
        this._tick++;
    }
    /**
   * Returns a unique key for this instance.
   * This key is used for caching.
   * @returns {string} Unique key for the instance
   */ get styleKey() {
        return `fill-pattern-${this.uid}-${this._tick}`;
    }
    /** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */ destroy() {
        this.texture.destroy(true);
        this.texture = null;
    }
}
;
 //# sourceMappingURL=FillPattern.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseSVGPath",
    ()=>parseSVGPath
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parse$2d$svg$2d$path$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/parse-svg-path/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
function parseSVGPath(svgPath, path) {
    const commands = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parse$2d$svg$2d$path$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(svgPath);
    const subpaths = [];
    let currentSubPath = null;
    let lastX = 0;
    let lastY = 0;
    for(let i = 0; i < commands.length; i++){
        const command = commands[i];
        const type = command[0];
        const data = command;
        switch(type){
            case "M":
                lastX = data[1];
                lastY = data[2];
                path.moveTo(lastX, lastY);
                break;
            case "m":
                lastX += data[1];
                lastY += data[2];
                path.moveTo(lastX, lastY);
                break;
            case "H":
                lastX = data[1];
                path.lineTo(lastX, lastY);
                break;
            case "h":
                lastX += data[1];
                path.lineTo(lastX, lastY);
                break;
            case "V":
                lastY = data[1];
                path.lineTo(lastX, lastY);
                break;
            case "v":
                lastY += data[1];
                path.lineTo(lastX, lastY);
                break;
            case "L":
                lastX = data[1];
                lastY = data[2];
                path.lineTo(lastX, lastY);
                break;
            case "l":
                lastX += data[1];
                lastY += data[2];
                path.lineTo(lastX, lastY);
                break;
            case "C":
                lastX = data[5];
                lastY = data[6];
                path.bezierCurveTo(data[1], data[2], // First control point
                data[3], data[4], // Second control point
                lastX, lastY);
                break;
            case "c":
                path.bezierCurveTo(lastX + data[1], lastY + data[2], // First control point
                lastX + data[3], lastY + data[4], // Second control point
                lastX + data[5], lastY + data[6]);
                lastX += data[5];
                lastY += data[6];
                break;
            case "S":
                lastX = data[3];
                lastY = data[4];
                path.bezierCurveToShort(data[1], data[2], // Control point
                lastX, lastY);
                break;
            case "s":
                path.bezierCurveToShort(lastX + data[1], lastY + data[2], // Control point
                lastX + data[3], lastY + data[4]);
                lastX += data[3];
                lastY += data[4];
                break;
            case "Q":
                lastX = data[3];
                lastY = data[4];
                path.quadraticCurveTo(data[1], data[2], // Control point
                lastX, lastY);
                break;
            case "q":
                path.quadraticCurveTo(lastX + data[1], lastY + data[2], // Control point
                lastX + data[3], lastY + data[4]);
                lastX += data[3];
                lastY += data[4];
                break;
            case "T":
                lastX = data[1];
                lastY = data[2];
                path.quadraticCurveToShort(lastX, lastY);
                break;
            case "t":
                lastX += data[1];
                lastY += data[2];
                path.quadraticCurveToShort(lastX, lastY);
                break;
            case "A":
                lastX = data[6];
                lastY = data[7];
                path.arcToSvg(data[1], // rx
                data[2], // ry
                data[3], // x-axis-rotation
                data[4], // large-arc-flag
                data[5], // sweep-flag
                lastX, lastY);
                break;
            case "a":
                lastX += data[6];
                lastY += data[7];
                path.arcToSvg(data[1], // rx
                data[2], // ry
                data[3], // x-axis-rotation
                data[4], // large-arc-flag
                data[5], // sweep-flag
                lastX, lastY);
                break;
            case "Z":
            case "z":
                path.closePath();
                if (subpaths.length > 0) {
                    currentSubPath = subpaths.pop();
                    if (currentSubPath) {
                        lastX = currentSubPath.startX;
                        lastY = currentSubPath.startY;
                    } else {
                        lastX = 0;
                        lastY = 0;
                    }
                }
                currentSubPath = null;
                break;
            default:
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])(`Unknown SVG path command: ${type}`);
        }
        if (type !== "Z" && type !== "z") {
            if (currentSubPath === null) {
                currentSubPath = {
                    startX: lastX,
                    startY: lastY
                };
                subpaths.push(currentSubPath);
            }
        }
    }
    return path;
}
;
 //# sourceMappingURL=parseSVGPath.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BatchableGraphics",
    ()=>BatchableGraphics
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$multiplyHexColors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const identityMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
class BatchableGraphics {
    constructor(){
        this.packAsQuad = false;
        this.batcherName = "default";
        this.topology = "triangle-list";
        this.applyTransform = true;
        this.roundPixels = 0;
        this._batcher = null;
        this._batch = null;
    }
    get uvs() {
        return this.geometryData.uvs;
    }
    get positions() {
        return this.geometryData.vertices;
    }
    get indices() {
        return this.geometryData.indices;
    }
    get blendMode() {
        if (this.renderable && this.applyTransform) {
            return this.renderable.groupBlendMode;
        }
        return "normal";
    }
    get color() {
        const rgb = this.baseColor;
        const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
        const renderable = this.renderable;
        if (renderable) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$multiplyHexColors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiplyHexColors"])(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);
        }
        return bgr + (this.alpha * 255 << 24);
    }
    get transform() {
        return this.renderable?.groupTransform || identityMatrix;
    }
    copyTo(gpuBuffer) {
        gpuBuffer.indexOffset = this.indexOffset;
        gpuBuffer.indexSize = this.indexSize;
        gpuBuffer.attributeOffset = this.attributeOffset;
        gpuBuffer.attributeSize = this.attributeSize;
        gpuBuffer.baseColor = this.baseColor;
        gpuBuffer.alpha = this.alpha;
        gpuBuffer.texture = this.texture;
        gpuBuffer.geometryData = this.geometryData;
        gpuBuffer.topology = this.topology;
    }
    reset() {
        this.applyTransform = true;
        this.renderable = null;
        this.topology = "triangle-list";
    }
    destroy() {
        this.renderable = null;
        this.texture = null;
        this.geometryData = null;
        this._batcher = null;
        this._batch = null;
    }
}
;
 //# sourceMappingURL=BatchableGraphics.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildCircle",
    ()=>buildCircle,
    "buildEllipse",
    ()=>buildEllipse,
    "buildRoundedRectangle",
    ()=>buildRoundedRectangle
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
;
"use strict";
const buildCircle = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].ShapeBuilder,
        name: "circle"
    },
    build (shape, points) {
        let x;
        let y;
        let dx;
        let dy;
        let rx;
        let ry;
        if (shape.type === "circle") {
            const circle = shape;
            rx = ry = circle.radius;
            if (rx <= 0) {
                return false;
            }
            x = circle.x;
            y = circle.y;
            dx = dy = 0;
        } else if (shape.type === "ellipse") {
            const ellipse = shape;
            rx = ellipse.halfWidth;
            ry = ellipse.halfHeight;
            if (rx <= 0 || ry <= 0) {
                return false;
            }
            x = ellipse.x;
            y = ellipse.y;
            dx = dy = 0;
        } else {
            const roundedRect = shape;
            const halfWidth = roundedRect.width / 2;
            const halfHeight = roundedRect.height / 2;
            x = roundedRect.x + halfWidth;
            y = roundedRect.y + halfHeight;
            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
            dx = halfWidth - rx;
            dy = halfHeight - ry;
        }
        if (dx < 0 || dy < 0) {
            return false;
        }
        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));
        const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
        if (m === 0) {
            return false;
        }
        if (n === 0) {
            points[0] = points[6] = x + dx;
            points[1] = points[3] = y + dy;
            points[2] = points[4] = x - dx;
            points[5] = points[7] = y - dy;
            return true;
        }
        let j1 = 0;
        let j2 = n * 4 + (dx ? 2 : 0) + 2;
        let j3 = j2;
        let j4 = m;
        let x0 = dx + rx;
        let y0 = dy;
        let x1 = x + x0;
        let x2 = x - x0;
        let y1 = y + y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j2] = y1;
        points[--j2] = x2;
        if (dy) {
            const y22 = y - y0;
            points[j3++] = x2;
            points[j3++] = y22;
            points[--j4] = y22;
            points[--j4] = x1;
        }
        for(let i = 1; i < n; i++){
            const a = Math.PI / 2 * (i / n);
            const x02 = dx + Math.cos(a) * rx;
            const y02 = dy + Math.sin(a) * ry;
            const x12 = x + x02;
            const x22 = x - x02;
            const y12 = y + y02;
            const y22 = y - y02;
            points[j1++] = x12;
            points[j1++] = y12;
            points[--j2] = y12;
            points[--j2] = x22;
            points[j3++] = x22;
            points[j3++] = y22;
            points[--j4] = y22;
            points[--j4] = x12;
        }
        x0 = dx;
        y0 = dy + ry;
        x1 = x + x0;
        x2 = x - x0;
        y1 = y + y0;
        const y2 = y - y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j4] = y2;
        points[--j4] = x1;
        if (dx) {
            points[j1++] = x2;
            points[j1++] = y1;
            points[--j4] = y2;
            points[--j4] = x2;
        }
        return true;
    },
    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        if (points.length === 0) {
            return;
        }
        let centerX = 0;
        let centerY = 0;
        for(let i = 0; i < points.length; i += 2){
            centerX += points[i];
            centerY += points[i + 1];
        }
        centerX /= points.length / 2;
        centerY /= points.length / 2;
        let count = verticesOffset;
        vertices[count * verticesStride] = centerX;
        vertices[count * verticesStride + 1] = centerY;
        const centerIndex = count++;
        for(let i = 0; i < points.length; i += 2){
            vertices[count * verticesStride] = points[i];
            vertices[count * verticesStride + 1] = points[i + 1];
            if (i > 0) {
                indices[indicesOffset++] = count;
                indices[indicesOffset++] = centerIndex;
                indices[indicesOffset++] = count - 1;
            }
            count++;
        }
        indices[indicesOffset++] = centerIndex + 1;
        indices[indicesOffset++] = centerIndex;
        indices[indicesOffset++] = count - 1;
    }
};
const buildEllipse = {
    ...buildCircle,
    extension: {
        ...buildCircle.extension,
        name: "ellipse"
    }
};
const buildRoundedRectangle = {
    ...buildCircle,
    extension: {
        ...buildCircle.extension,
        name: "roundedRectangle"
    }
};
;
 //# sourceMappingURL=buildCircle.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/const.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "closePointEps",
    ()=>closePointEps,
    "curveEps",
    ()=>curveEps
]);
"use strict";
const closePointEps = 1e-4;
const curveEps = 1e-4;
;
 //# sourceMappingURL=const.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getOrientationOfPoints",
    ()=>getOrientationOfPoints
]);
"use strict";
function getOrientationOfPoints(points) {
    const m = points.length;
    if (m < 6) {
        return 1;
    }
    let area = 0;
    for(let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2){
        const x2 = points[i];
        const y2 = points[i + 1];
        area += (x2 - x1) * (y2 + y1);
        x1 = x2;
        y1 = y2;
    }
    if (area < 0) {
        return -1;
    }
    return 1;
}
;
 //# sourceMappingURL=getOrientationOfPoints.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildLine",
    ()=>buildLine
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/const.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$getOrientationOfPoints$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    const ix = x - nx * innerWeight;
    const iy = y - ny * innerWeight;
    const ox = x + nx * outerWeight;
    const oy = y + ny * outerWeight;
    let exx;
    let eyy;
    if (clockwise) {
        exx = ny;
        eyy = -nx;
    } else {
        exx = -ny;
        eyy = nx;
    }
    const eix = ix + exx;
    const eiy = iy + eyy;
    const eox = ox + exx;
    const eoy = oy + eyy;
    verts.push(eix, eiy);
    verts.push(eox, eoy);
    return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    const cx2p0x = sx - cx;
    const cy2p0y = sy - cy;
    let angle0 = Math.atan2(cx2p0x, cy2p0y);
    let angle1 = Math.atan2(ex - cx, ey - cy);
    if (clockwise && angle0 < angle1) {
        angle0 += Math.PI * 2;
    } else if (!clockwise && angle0 > angle1) {
        angle1 += Math.PI * 2;
    }
    let startAngle = angle0;
    const angleDiff = angle1 - angle0;
    const absAngleDiff = Math.abs(angleDiff);
    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
    const angleInc = angleDiff / segCount;
    startAngle += angleInc;
    if (clockwise) {
        verts.push(cx, cy);
        verts.push(sx, sy);
        for(let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc){
            verts.push(cx, cy);
            verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
        }
        verts.push(cx, cy);
        verts.push(ex, ey);
    } else {
        verts.push(sx, sy);
        verts.push(cx, cy);
        for(let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc){
            verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
            verts.push(cx, cy);
        }
        verts.push(ex, ey);
        verts.push(cx, cy);
    }
    return segCount * 2;
}
function buildLine(points, lineStyle, flipAlignment, closed, vertices, indices) {
    const eps = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["closePointEps"];
    if (points.length === 0) {
        return;
    }
    const style = lineStyle;
    let alignment = style.alignment;
    if (lineStyle.alignment !== 0.5) {
        let orientation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$getOrientationOfPoints$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrientationOfPoints"])(points);
        if (flipAlignment) orientation *= -1;
        alignment = (alignment - 0.5) * orientation + 0.5;
    }
    const firstPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"](points[0], points[1]);
    const lastPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"](points[points.length - 2], points[points.length - 1]);
    const closedShape = closed;
    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
    if (closedShape) {
        points = points.slice();
        if (closedPath) {
            points.pop();
            points.pop();
            lastPoint.set(points[points.length - 2], points[points.length - 1]);
        }
        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
    }
    const verts = vertices;
    const length = points.length / 2;
    let indexCount = points.length;
    const indexStart = verts.length / 2;
    const width = style.width / 2;
    const widthSquared = width * width;
    const miterLimitSquared = style.miterLimit * style.miterLimit;
    let x0 = points[0];
    let y0 = points[1];
    let x1 = points[2];
    let y1 = points[3];
    let x2 = 0;
    let y2 = 0;
    let perpX = -(y0 - y1);
    let perpY = x0 - x1;
    let perp1x = 0;
    let perp1y = 0;
    let dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    const ratio = alignment;
    const innerWeight = (1 - ratio) * 2;
    const outerWeight = ratio * 2;
    if (!closedShape) {
        if (style.cap === "round") {
            indexCount += round(x0 - perpX * (innerWeight - outerWeight) * 0.5, y0 - perpY * (innerWeight - outerWeight) * 0.5, x0 - perpX * innerWeight, y0 - perpY * innerWeight, x0 + perpX * outerWeight, y0 + perpY * outerWeight, verts, true) + 2;
        } else if (style.cap === "square") {
            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
        }
    }
    verts.push(x0 - perpX * innerWeight, y0 - perpY * innerWeight);
    verts.push(x0 + perpX * outerWeight, y0 + perpY * outerWeight);
    for(let i = 1; i < length - 1; ++i){
        x0 = points[(i - 1) * 2];
        y0 = points[(i - 1) * 2 + 1];
        x1 = points[i * 2];
        y1 = points[i * 2 + 1];
        x2 = points[(i + 1) * 2];
        y2 = points[(i + 1) * 2 + 1];
        perpX = -(y0 - y1);
        perpY = x0 - x1;
        dist = Math.sqrt(perpX * perpX + perpY * perpY);
        perpX /= dist;
        perpY /= dist;
        perpX *= width;
        perpY *= width;
        perp1x = -(y1 - y2);
        perp1y = x1 - x2;
        dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
        perp1x /= dist;
        perp1y /= dist;
        perp1x *= width;
        perp1y *= width;
        const dx0 = x1 - x0;
        const dy0 = y0 - y1;
        const dx1 = x1 - x2;
        const dy1 = y2 - y1;
        const dot = dx0 * dx1 + dy0 * dy1;
        const cross = dy0 * dx1 - dy1 * dx0;
        const clockwise = cross < 0;
        if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            if (dot >= 0) {
                if (style.join === "round") {
                    indexCount += round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
                } else {
                    indexCount += 2;
                }
                verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);
                verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
            }
            continue;
        }
        const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
        const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
        const px = (dx0 * c2 - dx1 * c1) / cross;
        const py = (dy1 * c1 - dy0 * c2) / cross;
        const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
        const imx = x1 + (px - x1) * innerWeight;
        const imy = y1 + (py - y1) * innerWeight;
        const omx = x1 - (px - x1) * outerWeight;
        const omy = y1 - (py - y1) * outerWeight;
        const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
        const insideWeight = clockwise ? innerWeight : outerWeight;
        const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
        const insideMiterOk = pDist <= smallerInsideDiagonalSq;
        if (insideMiterOk) {
            if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
                if (clockwise) {
                    verts.push(imx, imy);
                    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
                    verts.push(imx, imy);
                    verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
                } else {
                    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
                    verts.push(omx, omy);
                    verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
                    verts.push(omx, omy);
                }
                indexCount += 2;
            } else if (style.join === "round") {
                if (clockwise) {
                    verts.push(imx, imy);
                    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
                    indexCount += round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
                    verts.push(imx, imy);
                    verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
                } else {
                    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
                    verts.push(omx, omy);
                    indexCount += round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
                    verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
                    verts.push(omx, omy);
                }
            } else {
                verts.push(imx, imy);
                verts.push(omx, omy);
            }
        } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            if (style.join === "round") {
                if (clockwise) {
                    indexCount += round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
                } else {
                    indexCount += round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
                }
            } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
                if (clockwise) {
                    verts.push(omx, omy);
                    verts.push(omx, omy);
                } else {
                    verts.push(imx, imy);
                    verts.push(imx, imy);
                }
                indexCount += 2;
            }
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
            indexCount += 2;
        }
    }
    x0 = points[(length - 2) * 2];
    y0 = points[(length - 2) * 2 + 1];
    x1 = points[(length - 1) * 2];
    y1 = points[(length - 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
    if (!closedShape) {
        if (style.cap === "round") {
            indexCount += round(x1 - perpX * (innerWeight - outerWeight) * 0.5, y1 - perpY * (innerWeight - outerWeight) * 0.5, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 + perpX * outerWeight, y1 + perpY * outerWeight, verts, false) + 2;
        } else if (style.cap === "square") {
            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
        }
    }
    const eps2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["curveEps"] * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["curveEps"];
    for(let i = indexStart; i < indexCount + indexStart - 2; ++i){
        x0 = verts[i * 2];
        y0 = verts[i * 2 + 1];
        x1 = verts[(i + 1) * 2];
        y1 = verts[(i + 1) * 2 + 1];
        x2 = verts[(i + 2) * 2];
        y2 = verts[(i + 2) * 2 + 1];
        if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
            continue;
        }
        indices.push(i, i + 1, i + 2);
    }
}
;
 //# sourceMappingURL=buildLine.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildPixelLine",
    ()=>buildPixelLine
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/const.mjs [app-ssr] (ecmascript)");
;
"use strict";
function buildPixelLine(points, closed, vertices, indices) {
    const eps = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["closePointEps"];
    if (points.length === 0) {
        return;
    }
    const fx = points[0];
    const fy = points[1];
    const lx = points[points.length - 2];
    const ly = points[points.length - 1];
    const closePath = closed || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;
    const verts = vertices;
    const length = points.length / 2;
    const indexStart = verts.length / 2;
    for(let i = 0; i < length; i++){
        verts.push(points[i * 2]);
        verts.push(points[i * 2 + 1]);
    }
    for(let i = 0; i < length - 1; i++){
        indices.push(indexStart + i, indexStart + i + 1);
    }
    if (closePath) {
        indices.push(indexStart + length - 1, indexStart);
    }
}
;
 //# sourceMappingURL=buildPixelLine.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "triangulateWithHoles",
    ()=>triangulateWithHoles
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/utils.mjs [app-ssr] (ecmascript) <locals>");
;
"use strict";
function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    const triangles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["earcut"])(points, holes, 2);
    if (!triangles) {
        return;
    }
    for(let i = 0; i < triangles.length; i += 3){
        indices[indicesOffset++] = triangles[i] + verticesOffset;
        indices[indicesOffset++] = triangles[i + 1] + verticesOffset;
        indices[indicesOffset++] = triangles[i + 2] + verticesOffset;
    }
    let index = verticesOffset * verticesStride;
    for(let i = 0; i < points.length; i += 2){
        vertices[index] = points[i];
        vertices[index + 1] = points[i + 1];
        index += verticesStride;
    }
}
;
 //# sourceMappingURL=triangulateWithHoles.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildPolygon",
    ()=>buildPolygon
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$triangulateWithHoles$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const emptyArray = [];
const buildPolygon = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].ShapeBuilder,
        name: "polygon"
    },
    build (shape, points) {
        for(let i = 0; i < shape.points.length; i++){
            points[i] = shape.points[i];
        }
        return true;
    },
    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$triangulateWithHoles$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["triangulateWithHoles"])(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
    }
};
;
 //# sourceMappingURL=buildPolygon.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildRectangle",
    ()=>buildRectangle
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
;
"use strict";
const buildRectangle = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].ShapeBuilder,
        name: "rectangle"
    },
    build (shape, points) {
        const rectData = shape;
        const x = rectData.x;
        const y = rectData.y;
        const width = rectData.width;
        const height = rectData.height;
        if (!(width > 0 && height > 0)) {
            return false;
        }
        points[0] = x;
        points[1] = y;
        points[2] = x + width;
        points[3] = y;
        points[4] = x + width;
        points[5] = y + height;
        points[6] = x;
        points[7] = y + height;
        return true;
    },
    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count] = points[0];
        vertices[verticesOffset + count + 1] = points[1];
        count += verticesStride;
        vertices[verticesOffset + count] = points[2];
        vertices[verticesOffset + count + 1] = points[3];
        count += verticesStride;
        vertices[verticesOffset + count] = points[6];
        vertices[verticesOffset + count + 1] = points[7];
        count += verticesStride;
        vertices[verticesOffset + count] = points[4];
        vertices[verticesOffset + count + 1] = points[5];
        count += verticesStride;
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 3;
        indices[indicesOffset++] = verticesIndex + 2;
    }
};
;
 //# sourceMappingURL=buildRectangle.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildTriangle",
    ()=>buildTriangle
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
;
"use strict";
const buildTriangle = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].ShapeBuilder,
        name: "triangle"
    },
    build (shape, points) {
        points[0] = shape.x;
        points[1] = shape.y;
        points[2] = shape.x2;
        points[3] = shape.y2;
        points[4] = shape.x3;
        points[5] = shape.y3;
        return true;
    },
    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count] = points[0];
        vertices[verticesOffset + count + 1] = points[1];
        count += verticesStride;
        vertices[verticesOffset + count] = points[2];
        vertices[verticesOffset + count + 1] = points[3];
        count += verticesStride;
        vertices[verticesOffset + count] = points[4];
        vertices[verticesOffset + count + 1] = points[5];
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
    }
};
;
 //# sourceMappingURL=buildTriangle.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generateTextureMatrix",
    ()=>generateTextureMatrix
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillGradient$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
const tempTextureMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
const tempRect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"]();
function generateTextureMatrix(out, style, shape, matrix) {
    const textureMatrix = style.matrix ? out.copyFrom(style.matrix).invert() : out.identity();
    if (style.textureSpace === "local") {
        const bounds = shape.getBounds(tempRect);
        if (style.width) {
            bounds.pad(style.width);
        }
        const { x: tx, y: ty } = bounds;
        const sx = 1 / bounds.width;
        const sy = 1 / bounds.height;
        const mTx = -tx * sx;
        const mTy = -ty * sy;
        const a1 = textureMatrix.a;
        const b1 = textureMatrix.b;
        const c1 = textureMatrix.c;
        const d1 = textureMatrix.d;
        textureMatrix.a *= sx;
        textureMatrix.b *= sx;
        textureMatrix.c *= sy;
        textureMatrix.d *= sy;
        textureMatrix.tx = mTx * a1 + mTy * c1 + textureMatrix.tx;
        textureMatrix.ty = mTx * b1 + mTy * d1 + textureMatrix.ty;
    } else {
        textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);
        textureMatrix.scale(1 / style.texture.source.width, 1 / style.texture.source.height);
    }
    const sourceStyle = style.texture.source.style;
    if (!(style.fill instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillGradient$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FillGradient"]) && sourceStyle.addressMode === "clamp-to-edge") {
        sourceStyle.addressMode = "repeat";
        sourceStyle.update();
    }
    if (matrix) {
        textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());
    }
    return textureMatrix;
}
;
 //# sourceMappingURL=generateTextureFillMatrix.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildContextBatches",
    ()=>buildContextBatches,
    "shapeBuilders",
    ()=>shapeBuilders
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$buildUvs$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$transformVertices$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$BatchableGraphics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildCircle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildLine$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildPixelLine$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildPolygon$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildRectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildTriangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$generateTextureFillMatrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$triangulateWithHoles$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
"use strict";
const shapeBuilders = {};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extensions"].handleByMap(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].ShapeBuilder, shapeBuilders);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extensions"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildRectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildRectangle"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildPolygon$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildPolygon"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildTriangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildTriangle"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildCircle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildCircle"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildCircle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildEllipse"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildCircle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildRoundedRectangle"]);
const tempRect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"]();
const tempTextureMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
function buildContextBatches(context, gpuContext) {
    const { geometryData, batches } = gpuContext;
    batches.length = 0;
    geometryData.indices.length = 0;
    geometryData.vertices.length = 0;
    geometryData.uvs.length = 0;
    for(let i = 0; i < context.instructions.length; i++){
        const instruction = context.instructions[i];
        if (instruction.action === "texture") {
            addTextureToGeometryData(instruction.data, batches, geometryData);
        } else if (instruction.action === "fill" || instruction.action === "stroke") {
            const isStroke = instruction.action === "stroke";
            const shapePath = instruction.data.path.shapePath;
            const style = instruction.data.style;
            const hole = instruction.data.hole;
            if (isStroke && hole) {
                addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);
            }
            if (hole) {
                shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;
            }
            addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);
        }
    }
}
function addTextureToGeometryData(data, batches, geometryData) {
    const points = [];
    const build = shapeBuilders.rectangle;
    const rect = tempRect;
    rect.x = data.dx;
    rect.y = data.dy;
    rect.width = data.dw;
    rect.height = data.dh;
    const matrix = data.transform;
    if (!build.build(rect, points)) {
        return;
    }
    const { vertices, uvs, indices } = geometryData;
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    if (matrix) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$transformVertices$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformVertices"])(points, matrix);
    }
    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
    const texture = data.image;
    const textureUvs = texture.uvs;
    uvs.push(textureUvs.x0, textureUvs.y0, textureUvs.x1, textureUvs.y1, textureUvs.x3, textureUvs.y3, textureUvs.x2, textureUvs.y2);
    const graphicsBatch = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$BatchableGraphics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BatchableGraphics"]);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.attributeOffset = vertOffset;
    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
    graphicsBatch.baseColor = data.style;
    graphicsBatch.alpha = data.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    batches.push(graphicsBatch);
}
function addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData) {
    const { vertices, uvs, indices } = geometryData;
    shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes })=>{
        const points = [];
        const build = shapeBuilders[shape.type];
        if (!build.build(shape, points)) {
            return;
        }
        const indexOffset = indices.length;
        const vertOffset = vertices.length / 2;
        let topology = "triangle-list";
        if (matrix) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$transformVertices$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformVertices"])(points, matrix);
        }
        if (!isStroke) {
            if (holes) {
                const holeIndices = [];
                const otherPoints = points.slice();
                const holeArrays = getHoleArrays(holes);
                holeArrays.forEach((holePoints)=>{
                    holeIndices.push(otherPoints.length / 2);
                    otherPoints.push(...holePoints);
                });
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$triangulateWithHoles$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["triangulateWithHoles"])(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
            } else {
                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
            }
        } else {
            const close = shape.closePath ?? true;
            const lineStyle = style;
            if (!lineStyle.pixelLine) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildLine$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildLine"])(points, lineStyle, false, close, vertices, indices);
            } else {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildPixelLine$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildPixelLine"])(points, close, vertices, indices);
                topology = "line-list";
            }
        }
        const uvsOffset = uvs.length / 2;
        const texture = style.texture;
        if (texture !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].WHITE) {
            const textureMatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$generateTextureFillMatrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generateTextureMatrix"])(tempTextureMatrix, style, shape, matrix);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$buildUvs$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildUvs"])(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$buildUvs$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildSimpleUvs"])(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
        }
        const graphicsBatch = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$BatchableGraphics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BatchableGraphics"]);
        graphicsBatch.indexOffset = indexOffset;
        graphicsBatch.indexSize = indices.length - indexOffset;
        graphicsBatch.attributeOffset = vertOffset;
        graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
        graphicsBatch.baseColor = style.color;
        graphicsBatch.alpha = style.alpha;
        graphicsBatch.texture = texture;
        graphicsBatch.geometryData = geometryData;
        graphicsBatch.topology = topology;
        batches.push(graphicsBatch);
    });
}
function getHoleArrays(holePrimitives) {
    const holeArrays = [];
    for(let k = 0; k < holePrimitives.length; k++){
        const holePrimitive = holePrimitives[k].shape;
        const holePoints = [];
        const holeBuilder = shapeBuilders[holePrimitive.type];
        if (holeBuilder.build(holePrimitive, holePoints)) {
            holeArrays.push(holePoints);
        }
    }
    return holeArrays;
}
;
 //# sourceMappingURL=buildContextBatches.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GpuGraphicsContext",
    ()=>GpuGraphicsContext,
    "GraphicsContextRenderData",
    ()=>GraphicsContextRenderData,
    "GraphicsContextSystem",
    ()=>GraphicsContextSystem
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$batcher$2f$gpu$2f$getTextureBatchBindGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$batcher$2f$shared$2f$DefaultBatcher$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$instructions$2f$InstructionSet$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/GCManagedHash.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$buildContextBatches$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
"use strict";
class GpuGraphicsContext {
    constructor(){
        this.batches = [];
        this.geometryData = {
            vertices: [],
            uvs: [],
            indices: []
        };
    }
    reset() {
        if (this.batches) {
            this.batches.forEach((batch)=>{
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].return(batch);
            });
        }
        if (this.graphicsData) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].return(this.graphicsData);
        }
        this.isBatchable = false;
        this.context = null;
        this.batches.length = 0;
        this.geometryData.indices.length = 0;
        this.geometryData.vertices.length = 0;
        this.geometryData.uvs.length = 0;
        this.graphicsData = null;
    }
    destroy() {
        this.reset();
        this.batches = null;
        this.geometryData = null;
    }
}
class GraphicsContextRenderData {
    constructor(){
        this.instructions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$instructions$2f$InstructionSet$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InstructionSet"]();
    }
    init(options) {
        const maxTextures = options.maxTextures;
        this.batcher ? this.batcher._updateMaxTextures(maxTextures) : this.batcher = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$batcher$2f$shared$2f$DefaultBatcher$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DefaultBatcher"]({
            maxTextures
        });
        this.instructions.reset();
    }
    /**
   * @deprecated since version 8.0.0
   * Use `batcher.geometry` instead.
   * @see {Batcher#geometry}
   */ get geometry() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_3_4"], "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
        return this.batcher.geometry;
    }
    destroy() {
        this.batcher.destroy();
        this.instructions.destroy();
        this.batcher = null;
        this.instructions = null;
    }
}
const _GraphicsContextSystem = class _GraphicsContextSystem {
    constructor(renderer){
        this._renderer = renderer;
        this._managedContexts = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GCManagedHash"]({
            renderer,
            type: "resource",
            name: "graphicsContext"
        });
    }
    /**
   * Runner init called, update the default options
   * @ignore
   */ init(options) {
        _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;
    }
    /**
   * Returns the render data for a given GraphicsContext.
   * @param context - The GraphicsContext to get the render data for.
   * @internal
   */ getContextRenderData(context) {
        return context._gpuData[this._renderer.uid].graphicsData || this._initContextRenderData(context);
    }
    /**
   * Updates the GPU context for a given GraphicsContext.
   * If the context is dirty, it will rebuild the batches and geometry data.
   * @param context - The GraphicsContext to update.
   * @returns The updated GpuGraphicsContext.
   * @internal
   */ updateGpuContext(context) {
        const hasContext = !!context._gpuData[this._renderer.uid];
        const gpuContext = context._gpuData[this._renderer.uid] || this._initContext(context);
        if (context.dirty || !hasContext) {
            if (hasContext) {
                gpuContext.reset();
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$buildContextBatches$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildContextBatches"])(context, gpuContext);
            const batchMode = context.batchMode;
            if (context.customShader || batchMode === "no-batch") {
                gpuContext.isBatchable = false;
            } else if (batchMode === "auto") {
                gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
            } else {
                gpuContext.isBatchable = true;
            }
            context.dirty = false;
        }
        return gpuContext;
    }
    /**
   * Returns the GpuGraphicsContext for a given GraphicsContext.
   * If it does not exist, it will initialize a new one.
   * @param context - The GraphicsContext to get the GpuGraphicsContext for.
   * @returns The GpuGraphicsContext for the given GraphicsContext.
   * @internal
   */ getGpuContext(context) {
        return context._gpuData[this._renderer.uid] || this._initContext(context);
    }
    _initContextRenderData(context) {
        const graphicsData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].get(GraphicsContextRenderData, {
            maxTextures: this._renderer.limits.maxBatchableTextures
        });
        const gpuContext = context._gpuData[this._renderer.uid];
        const { batches, geometryData } = gpuContext;
        gpuContext.graphicsData = graphicsData;
        const vertexSize = geometryData.vertices.length;
        const indexSize = geometryData.indices.length;
        for(let i = 0; i < batches.length; i++){
            batches[i].applyTransform = false;
        }
        const batcher = graphicsData.batcher;
        batcher.ensureAttributeBuffer(vertexSize);
        batcher.ensureIndexBuffer(indexSize);
        batcher.begin();
        for(let i = 0; i < batches.length; i++){
            const batch = batches[i];
            batcher.add(batch);
        }
        batcher.finish(graphicsData.instructions);
        const geometry = batcher.geometry;
        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
        const drawBatches = batcher.batches;
        for(let i = 0; i < drawBatches.length; i++){
            const batch = drawBatches[i];
            batch.bindGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$batcher$2f$gpu$2f$getTextureBatchBindGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getTextureBatchBindGroup"])(batch.textures.textures, batch.textures.count, this._renderer.limits.maxBatchableTextures);
        }
        return graphicsData;
    }
    _initContext(context) {
        const gpuContext = new GpuGraphicsContext();
        gpuContext.context = context;
        context._gpuData[this._renderer.uid] = gpuContext;
        this._managedContexts.add(context);
        return gpuContext;
    }
    destroy() {
        this._managedContexts.destroy();
        this._renderer = null;
    }
};
/** @ignore */ _GraphicsContextSystem.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasSystem
    ],
    name: "graphicsContext"
};
/** The default options for the GraphicsContextSystem. */ _GraphicsContextSystem.defaultOptions = {
    /**
   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
   * @default 0.5
   */ bezierSmoothness: 0.5
};
let GraphicsContextSystem = _GraphicsContextSystem;
;
 //# sourceMappingURL=GraphicsContextSystem.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildAdaptiveBezier",
    ()=>buildAdaptiveBezier
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContextSystem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs [app-ssr] (ecmascript)");
;
"use strict";
const RECURSION_LIMIT = 8;
const FLT_EPSILON = 11920929e-14;
const PATH_DISTANCE_EPSILON = 1;
const curveAngleToleranceEpsilon = 0.01;
const mAngleTolerance = 0;
const mCuspLimit = 0;
function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContextSystem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsContextSystem"].defaultOptions.bezierSmoothness));
    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
    return points;
}
function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
    points.push(eX, eY);
}
function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
    if (level > RECURSION_LIMIT) {
        return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x34 = (x3 + x4) / 2;
    const y34 = (y3 + y4) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    const x234 = (x23 + x34) / 2;
    const y234 = (y23 + y34) / 2;
    const x1234 = (x123 + x234) / 2;
    const y1234 = (y123 + y234) / 2;
    if (level > 0) {
        let dx = x4 - x1;
        let dy = y4 - y1;
        const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
        const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
        let da1;
        let da2;
        if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
                if (mAngleTolerance < curveAngleToleranceEpsilon) {
                    points.push(x1234, y1234);
                    return;
                }
                const a23 = Math.atan2(y3 - y2, x3 - x2);
                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
                if (da1 >= pi) da1 = 2 * pi - da1;
                if (da2 >= pi) da2 = 2 * pi - da2;
                if (da1 + da2 < mAngleTolerance) {
                    points.push(x1234, y1234);
                    return;
                }
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
            }
        } else if (d2 > FLT_EPSILON) {
            if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
                if (mAngleTolerance < curveAngleToleranceEpsilon) {
                    points.push(x1234, y1234);
                    return;
                }
                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
                if (da1 >= pi) da1 = 2 * pi - da1;
                if (da1 < mAngleTolerance) {
                    points.push(x2, y2);
                    points.push(x3, y3);
                    return;
                }
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
            }
        } else if (d3 > FLT_EPSILON) {
            if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
                if (mAngleTolerance < curveAngleToleranceEpsilon) {
                    points.push(x1234, y1234);
                    return;
                }
                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
                if (da1 >= pi) da1 = 2 * pi - da1;
                if (da1 < mAngleTolerance) {
                    points.push(x2, y2);
                    points.push(x3, y3);
                    return;
                }
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
            }
        } else {
            dx = x1234 - (x1 + x4) / 2;
            dy = y1234 - (y1 + y4) / 2;
            if (dx * dx + dy * dy <= distanceTolerance) {
                points.push(x1234, y1234);
                return;
            }
        }
    }
    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
}
;
 //# sourceMappingURL=buildAdaptiveBezier.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildAdaptiveQuadratic",
    ()=>buildAdaptiveQuadratic
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContextSystem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs [app-ssr] (ecmascript)");
;
"use strict";
const RECURSION_LIMIT = 8;
const FLT_EPSILON = 11920929e-14;
const PATH_DISTANCE_EPSILON = 1;
const curveAngleToleranceEpsilon = 0.01;
const mAngleTolerance = 0;
function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContextSystem$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsContextSystem"].defaultOptions.bezierSmoothness));
    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
    return points;
}
function begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
    points.push(eX, eY);
}
function recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
    if (level > RECURSION_LIMIT) {
        return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    let dx = x3 - x1;
    let dy = y3 - y1;
    const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
    if (d > FLT_EPSILON) {
        if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {
            if (mAngleTolerance < curveAngleToleranceEpsilon) {
                points.push(x123, y123);
                return;
            }
            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
            if (da >= pi) da = 2 * pi - da;
            if (da < mAngleTolerance) {
                points.push(x123, y123);
                return;
            }
        }
    } else {
        dx = x123 - (x1 + x3) / 2;
        dy = y123 - (y1 + y3) / 2;
        if (dx * dx + dy * dy <= distanceTolerance) {
            points.push(x123, y123);
            return;
        }
    }
    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
}
;
 //# sourceMappingURL=buildAdaptiveQuadratic.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildArc",
    ()=>buildArc
]);
"use strict";
function buildArc(points, x, y, radius, start, end, clockwise, steps) {
    let dist = Math.abs(start - end);
    if (!clockwise && start > end) {
        dist = 2 * Math.PI - dist;
    } else if (clockwise && end > start) {
        dist = 2 * Math.PI - dist;
    }
    steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI))));
    steps = Math.max(steps, 3);
    let f = dist / steps;
    let t = start;
    f *= clockwise ? -1 : 1;
    for(let i = 0; i < steps + 1; i++){
        const cs = Math.cos(t);
        const sn = Math.sin(t);
        const nx = x + cs * radius;
        const ny = y + sn * radius;
        points.push(nx, ny);
        t += f;
    }
}
;
 //# sourceMappingURL=buildArc.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildArcTo",
    ()=>buildArcTo
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildArc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs [app-ssr] (ecmascript)");
;
"use strict";
function buildArcTo(points, x1, y1, x2, y2, radius) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a2 = y2 - y1;
    const b2 = x2 - x1;
    const mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
            points.push(x1, y1);
        }
        return;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc = a2 * a2 + b2 * b2;
    const tt = a1 * a2 + b1 * b2;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k2 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt / dd;
    const j2 = k2 * tt / cc;
    const cx = k1 * b2 + k2 * b1;
    const cy = k1 * a2 + k2 * a1;
    const px = b1 * (k2 + j1);
    const py = a1 * (k2 + j1);
    const qx = b2 * (k1 + j2);
    const qy = a2 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildArc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildArc"])(points, cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
}
;
 //# sourceMappingURL=buildArcTo.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildArcToSvg",
    ()=>buildArcToSvg
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildAdaptiveBezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs [app-ssr] (ecmascript)");
;
"use strict";
const TAU = Math.PI * 2;
const out = {
    centerX: 0,
    centerY: 0,
    ang1: 0,
    ang2: 0
};
const mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2)=>{
    x *= rx;
    y *= ry;
    const xp = cosPhi * x - sinPhi * y;
    const yp = sinPhi * x + cosPhi * y;
    out2.x = xp + centerX;
    out2.y = yp + centerY;
    return out2;
};
function approxUnitArc(ang1, ang2) {
    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
    const x1 = Math.cos(ang1);
    const y1 = Math.sin(ang1);
    const x2 = Math.cos(ang1 + ang2);
    const y2 = Math.sin(ang1 + ang2);
    return [
        {
            x: x1 - y1 * a,
            y: y1 + x1 * a
        },
        {
            x: x2 + y2 * a,
            y: y2 - x2 * a
        },
        {
            x: x2,
            y: y2
        }
    ];
}
const vectorAngle = (ux, uy, vx, vy)=>{
    const sign = ux * vy - uy * vx < 0 ? -1 : 1;
    let dot = ux * vx + uy * vy;
    if (dot > 1) {
        dot = 1;
    }
    if (dot < -1) {
        dot = -1;
    }
    return sign * Math.acos(dot);
};
const getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2)=>{
    const rxSq = Math.pow(rx, 2);
    const rySq = Math.pow(ry, 2);
    const pxpSq = Math.pow(pxp, 2);
    const pypSq = Math.pow(pyp, 2);
    let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
    if (radicant < 0) {
        radicant = 0;
    }
    radicant /= rxSq * pypSq + rySq * pxpSq;
    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
    const centerXp = radicant * rx / ry * pyp;
    const centerYp = radicant * -ry / rx * pxp;
    const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
    const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
    const vx1 = (pxp - centerXp) / rx;
    const vy1 = (pyp - centerYp) / ry;
    const vx2 = (-pxp - centerXp) / rx;
    const vy2 = (-pyp - centerYp) / ry;
    const ang1 = vectorAngle(1, 0, vx1, vy1);
    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
    if (sweepFlag === 0 && ang2 > 0) {
        ang2 -= TAU;
    }
    if (sweepFlag === 1 && ang2 < 0) {
        ang2 += TAU;
    }
    out2.centerX = centerX;
    out2.centerY = centerY;
    out2.ang1 = ang1;
    out2.ang2 = ang2;
};
function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
    if (rx === 0 || ry === 0) {
        return;
    }
    const sinPhi = Math.sin(xAxisRotation * TAU / 360);
    const cosPhi = Math.cos(xAxisRotation * TAU / 360);
    const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
    const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
        return;
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
        rx *= Math.sqrt(lambda);
        ry *= Math.sqrt(lambda);
    }
    getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out);
    let { ang1, ang2 } = out;
    const { centerX, centerY } = out;
    let ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1 - ratio) < 1e-7) {
        ratio = 1;
    }
    const segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    let lastX = points[points.length - 2];
    let lastY = points[points.length - 1];
    const outCurvePoint = {
        x: 0,
        y: 0
    };
    for(let i = 0; i < segments; i++){
        const curve = approxUnitArc(ang1, ang2);
        const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
        const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
        const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildAdaptiveBezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildAdaptiveBezier"])(points, lastX, lastY, x1, y1, x2, y2, x, y);
        lastX = x;
        lastY = y;
        ang1 += ang2;
    }
}
;
 //# sourceMappingURL=buildArcToSvg.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "roundedShapeArc",
    ()=>roundedShapeArc,
    "roundedShapeQuadraticCurve",
    ()=>roundedShapeQuadraticCurve
]);
"use strict";
function roundedShapeArc(g, points, radius) {
    const vecFrom = (p, pp)=>{
        const x = pp.x - p.x;
        const y = pp.y - p.y;
        const len = Math.sqrt(x * x + y * y);
        const nx = x / len;
        const ny = y / len;
        return {
            len,
            nx,
            ny
        };
    };
    const sharpCorner = (i, p)=>{
        if (i === 0) {
            g.moveTo(p.x, p.y);
        } else {
            g.lineTo(p.x, p.y);
        }
    };
    let p1 = points[points.length - 1];
    for(let i = 0; i < points.length; i++){
        const p2 = points[i % points.length];
        const pRadius = p2.radius ?? radius;
        if (pRadius <= 0) {
            sharpCorner(i, p2);
            p1 = p2;
            continue;
        }
        const p3 = points[(i + 1) % points.length];
        const v1 = vecFrom(p2, p1);
        const v2 = vecFrom(p2, p3);
        if (v1.len < 1e-4 || v2.len < 1e-4) {
            sharpCorner(i, p2);
            p1 = p2;
            continue;
        }
        let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
        let radDirection = 1;
        let drawDirection = false;
        if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
            if (angle < 0) {
                angle = Math.PI + angle;
            } else {
                angle = Math.PI - angle;
                radDirection = -1;
                drawDirection = true;
            }
        } else if (angle > 0) {
            radDirection = -1;
            drawDirection = true;
        }
        const halfAngle = angle / 2;
        let cRadius;
        let lenOut = Math.abs(Math.cos(halfAngle) * pRadius / Math.sin(halfAngle));
        if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
            lenOut = Math.min(v1.len / 2, v2.len / 2);
            cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
        } else {
            cRadius = pRadius;
        }
        const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
        const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
        const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
        const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
        if (i === 0) {
            g.moveTo(cX + Math.cos(startAngle) * cRadius, cY + Math.sin(startAngle) * cRadius);
        }
        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
        p1 = p2;
    }
}
function roundedShapeQuadraticCurve(g, points, radius, smoothness) {
    const distance = (p1, p2)=>Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
    const pointLerp = (p1, p2, t)=>({
            x: p1.x + (p2.x - p1.x) * t,
            y: p1.y + (p2.y - p1.y) * t
        });
    const numPoints = points.length;
    for(let i = 0; i < numPoints; i++){
        const thisPoint = points[(i + 1) % numPoints];
        const pRadius = thisPoint.radius ?? radius;
        if (pRadius <= 0) {
            if (i === 0) {
                g.moveTo(thisPoint.x, thisPoint.y);
            } else {
                g.lineTo(thisPoint.x, thisPoint.y);
            }
            continue;
        }
        const lastPoint = points[i];
        const nextPoint = points[(i + 2) % numPoints];
        const lastEdgeLength = distance(lastPoint, thisPoint);
        let start;
        if (lastEdgeLength < 1e-4) {
            start = thisPoint;
        } else {
            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
            start = pointLerp(thisPoint, lastPoint, lastOffsetDistance / lastEdgeLength);
        }
        const nextEdgeLength = distance(nextPoint, thisPoint);
        let end;
        if (nextEdgeLength < 1e-4) {
            end = thisPoint;
        } else {
            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
            end = pointLerp(thisPoint, nextPoint, nextOffsetDistance / nextEdgeLength);
        }
        if (i === 0) {
            g.moveTo(start.x, start.y);
        } else {
            g.lineTo(start.x, start.y);
        }
        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
    }
}
;
 //# sourceMappingURL=roundShape.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ShapePath",
    ()=>ShapePath
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Circle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/shapes/Circle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Ellipse$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Polygon$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$RoundedRectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildAdaptiveBezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildAdaptiveQuadratic$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildArc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildArcTo$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildArcToSvg$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$roundShape$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
"use strict";
const tempRectangle = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"]();
class ShapePath {
    constructor(graphicsPath2D){
        /** The list of shape primitives that make up the path. */ this.shapePrimitives = [];
        this._currentPoly = null;
        this._bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bounds"]();
        this._graphicsPath2D = graphicsPath2D;
        this.signed = graphicsPath2D.checkForHoles;
    }
    /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */ moveTo(x, y) {
        this.startPoly(x, y);
        return this;
    }
    /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */ lineTo(x, y) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        const fromX = points[points.length - 2];
        const fromY = points[points.length - 1];
        if (fromX !== x || fromY !== y) {
            points.push(x, y);
        }
        return this;
    }
    /**
   * Adds an arc to the path. The arc is centered at (x, y)
   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The radius of the arc.
   * @param startAngle - The starting angle of the arc, in radians.
   * @param endAngle - The ending angle of the arc, in radians.
   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
   * @returns The instance of the current object for chaining.
   */ arc(x, y, radius, startAngle, endAngle, counterclockwise) {
        this._ensurePoly(false);
        const points = this._currentPoly.points;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildArc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildArc"])(points, x, y, radius, startAngle, endAngle, counterclockwise);
        return this;
    }
    /**
   * Adds an arc to the path with the arc tangent to the line joining two specified points.
   * The arc radius is specified by `radius`.
   * @param x1 - The x-coordinate of the first point.
   * @param y1 - The y-coordinate of the first point.
   * @param x2 - The x-coordinate of the second point.
   * @param y2 - The y-coordinate of the second point.
   * @param radius - The radius of the arc.
   * @returns The instance of the current object for chaining.
   */ arcTo(x1, y1, x2, y2, radius) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildArcTo$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildArcTo"])(points, x1, y1, x2, y2, radius);
        return this;
    }
    /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */ arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
        const points = this._currentPoly.points;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildArcToSvg$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildArcToSvg"])(points, this._currentPoly.lastX, this._currentPoly.lastY, x, y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag);
        return this;
    }
    /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */ bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildAdaptiveBezier$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildAdaptiveBezier"])(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, cp2x, cp2y, x, y, smoothness);
        return this;
    }
    /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the control point.
   * @param cp1y - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothing - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */ quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$buildCommands$2f$buildAdaptiveQuadratic$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildAdaptiveQuadratic"])(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, x, y, smoothing);
        return this;
    }
    /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */ closePath() {
        this.endPoly(true);
        return this;
    }
    /**
   * Adds another path to the current path. This method allows for the combination of multiple paths into one.
   * @param path - The `GraphicsPath` object representing the path to add.
   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
   * @returns The instance of the current object for chaining.
   */ addPath(path, transform) {
        this.endPoly();
        if (transform && !transform.isIdentity()) {
            path = path.clone(true);
            path.transform(transform);
        }
        const shapePrimitives = this.shapePrimitives;
        const start = shapePrimitives.length;
        for(let i = 0; i < path.instructions.length; i++){
            const instruction = path.instructions[i];
            this[instruction.action](...instruction.data);
        }
        if (path.checkForHoles && shapePrimitives.length - start > 1) {
            let mainShape = null;
            for(let i = start; i < shapePrimitives.length; i++){
                const shapePrimitive = shapePrimitives[i];
                if (shapePrimitive.shape.type === "polygon") {
                    const polygon = shapePrimitive.shape;
                    const mainPolygon = mainShape?.shape;
                    if (mainPolygon && mainPolygon.containsPolygon(polygon)) {
                        mainShape.holes || (mainShape.holes = []);
                        mainShape.holes.push(shapePrimitive);
                        shapePrimitives.copyWithin(i, i + 1);
                        shapePrimitives.length--;
                        i--;
                    } else {
                        mainShape = shapePrimitive;
                    }
                }
            }
        }
        return this;
    }
    /**
   * Finalizes the drawing of the current path. Optionally, it can close the path.
   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
   */ finish(closePath = false) {
        this.endPoly(closePath);
    }
    /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */ rect(x, y, w, h, transform) {
        this.drawShape(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"](x, y, w, h), transform);
        return this;
    }
    /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */ circle(x, y, radius, transform) {
        this.drawShape(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Circle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Circle"](x, y, radius), transform);
        return this;
    }
    /**
   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */ poly(points, close, transform) {
        const polygon = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Polygon$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Polygon"](points);
        polygon.closePath = close;
        this.drawShape(polygon, transform);
        return this;
    }
    /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */ regularPoly(x, y, radius, sides, rotation = 0, transform) {
        sides = Math.max(sides | 0, 3);
        const startAngle = -1 * Math.PI / 2 + rotation;
        const delta = Math.PI * 2 / sides;
        const polygon = [];
        for(let i = 0; i < sides; i++){
            const angle = startAngle - i * delta;
            polygon.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
        }
        this.poly(polygon, true, transform);
        return this;
    }
    /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
   * @returns The instance of the current object for chaining.
   */ roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {
        sides = Math.max(sides | 0, 3);
        if (corner <= 0) {
            return this.regularPoly(x, y, radius, sides, rotation);
        }
        const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
        corner = Math.min(corner, sideLength);
        const startAngle = -1 * Math.PI / 2 + rotation;
        const delta = Math.PI * 2 / sides;
        const internalAngle = (sides - 2) * Math.PI / sides / 2;
        for(let i = 0; i < sides; i++){
            const angle = i * delta + startAngle;
            const x0 = x + radius * Math.cos(angle);
            const y0 = y + radius * Math.sin(angle);
            const a1 = angle + Math.PI + internalAngle;
            const a2 = angle - Math.PI - internalAngle;
            const x1 = x0 + corner * Math.cos(a1);
            const y1 = y0 + corner * Math.sin(a1);
            const x3 = x0 + corner * Math.cos(a2);
            const y3 = y0 + corner * Math.sin(a2);
            if (i === 0) {
                this.moveTo(x1, y1);
            } else {
                this.lineTo(x1, y1);
            }
            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
        }
        return this.closePath();
    }
    /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */ roundShape(points, radius, useQuadratic = false, smoothness) {
        if (points.length < 3) {
            return this;
        }
        if (useQuadratic) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$roundShape$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundedShapeQuadraticCurve"])(this, points, radius, smoothness);
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$roundShape$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundedShapeArc"])(this, points, radius);
        }
        return this.closePath();
    }
    /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */ filletRect(x, y, width, height, fillet) {
        if (fillet === 0) {
            return this.rect(x, y, width, height);
        }
        const maxFillet = Math.min(width, height) / 2;
        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
        const right = x + width;
        const bottom = y + height;
        const dir = inset < 0 ? -inset : 0;
        const size = Math.abs(inset);
        return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();
    }
    /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */ chamferRect(x, y, width, height, chamfer, transform) {
        if (chamfer <= 0) {
            return this.rect(x, y, width, height);
        }
        const inset = Math.min(chamfer, Math.min(width, height) / 2);
        const right = x + width;
        const bottom = y + height;
        const points = [
            x + inset,
            y,
            right - inset,
            y,
            right,
            y + inset,
            right,
            bottom - inset,
            right - inset,
            bottom,
            x + inset,
            bottom,
            x,
            bottom - inset,
            x,
            y + inset
        ];
        for(let i = points.length - 1; i >= 2; i -= 2){
            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {
                points.splice(i - 1, 2);
            }
        }
        return this.poly(points, true, transform);
    }
    /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
   * @returns The instance of the current object for chaining.
   */ ellipse(x, y, radiusX, radiusY, transform) {
        this.drawShape(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Ellipse$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ellipse"](x, y, radiusX, radiusY), transform);
        return this;
    }
    /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */ roundRect(x, y, w, h, radius, transform) {
        this.drawShape(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$RoundedRectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RoundedRectangle"](x, y, w, h, radius), transform);
        return this;
    }
    /**
   * Draws a given shape on the canvas.
   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
   * scaling, and translations.
   * @returns The instance of the current object for chaining.
   */ drawShape(shape, matrix) {
        this.endPoly();
        this.shapePrimitives.push({
            shape,
            transform: matrix
        });
        return this;
    }
    /**
   * Starts a new polygon path from the specified starting point.
   * This method initializes a new polygon or ends the current one if it exists.
   * @param x - The x-coordinate of the starting point of the new polygon.
   * @param y - The y-coordinate of the starting point of the new polygon.
   * @returns The instance of the current object for chaining.
   */ startPoly(x, y) {
        let currentPoly = this._currentPoly;
        if (currentPoly) {
            this.endPoly();
        }
        currentPoly = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Polygon$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Polygon"]();
        currentPoly.points.push(x, y);
        this._currentPoly = currentPoly;
        return this;
    }
    /**
   * Ends the current polygon path. If `closePath` is set to true,
   * the path is closed by connecting the last point to the first one.
   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
   *  back to the starting point. False by default.
   * @returns The instance of the current object for chaining.
   */ endPoly(closePath = false) {
        const shape = this._currentPoly;
        if (shape && shape.points.length > 2) {
            shape.closePath = closePath;
            this.shapePrimitives.push({
                shape
            });
        }
        this._currentPoly = null;
        return this;
    }
    _ensurePoly(start = true) {
        if (this._currentPoly) return;
        this._currentPoly = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Polygon$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Polygon"]();
        if (start) {
            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
            if (lastShape) {
                let lx = lastShape.shape.x;
                let ly = lastShape.shape.y;
                if (lastShape.transform && !lastShape.transform.isIdentity()) {
                    const t = lastShape.transform;
                    const tempX = lx;
                    lx = t.a * lx + t.c * ly + t.tx;
                    ly = t.b * tempX + t.d * ly + t.ty;
                }
                this._currentPoly.points.push(lx, ly);
            } else {
                this._currentPoly.points.push(0, 0);
            }
        }
    }
    /** Builds the path. */ buildPath() {
        const path = this._graphicsPath2D;
        this.shapePrimitives.length = 0;
        this._currentPoly = null;
        for(let i = 0; i < path.instructions.length; i++){
            const instruction = path.instructions[i];
            this[instruction.action](...instruction.data);
        }
        this.finish();
    }
    /** Gets the bounds of the path. */ get bounds() {
        const bounds = this._bounds;
        bounds.clear();
        const shapePrimitives = this.shapePrimitives;
        for(let i = 0; i < shapePrimitives.length; i++){
            const shapePrimitive = shapePrimitives[i];
            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
            if (shapePrimitive.transform) {
                bounds.addRect(boundsRect, shapePrimitive.transform);
            } else {
                bounds.addRect(boundsRect);
            }
        }
        return bounds;
    }
}
;
 //# sourceMappingURL=ShapePath.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GraphicsPath",
    ()=>GraphicsPath
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$uid$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/uid.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$ShapePath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
"use strict";
class GraphicsPath {
    /**
   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
   * @param instructions - An SVG path string or an array of `PathInstruction` objects.
   * @param signed
   */ constructor(instructions, signed = false){
        this.instructions = [];
        /** unique id for this graphics path */ this.uid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$uid$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uid"])("graphicsPath");
        this._dirty = true;
        this.checkForHoles = signed;
        if (typeof instructions === "string") {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGPath"])(instructions, this);
        } else {
            this.instructions = instructions?.slice() ?? [];
        }
    }
    /**
   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
   * @returns The `ShapePath` instance associated with this `GraphicsPath`.
   */ get shapePath() {
        if (!this._shapePath) {
            this._shapePath = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$ShapePath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ShapePath"](this);
        }
        if (this._dirty) {
            this._dirty = false;
            this._shapePath.buildPath();
        }
        return this._shapePath;
    }
    /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @param transform - An optional transformation to apply to the added path.
   * @returns The instance of the current object for chaining.
   */ addPath(path, transform) {
        path = path.clone();
        this.instructions.push({
            action: "addPath",
            data: [
                path,
                transform
            ]
        });
        this._dirty = true;
        return this;
    }
    arc(...args) {
        this.instructions.push({
            action: "arc",
            data: args
        });
        this._dirty = true;
        return this;
    }
    arcTo(...args) {
        this.instructions.push({
            action: "arcTo",
            data: args
        });
        this._dirty = true;
        return this;
    }
    arcToSvg(...args) {
        this.instructions.push({
            action: "arcToSvg",
            data: args
        });
        this._dirty = true;
        return this;
    }
    bezierCurveTo(...args) {
        this.instructions.push({
            action: "bezierCurveTo",
            data: args
        });
        this._dirty = true;
        return this;
    }
    /**
   * Adds a cubic Bezier curve to the path.
   * It requires two points: the second control point and the end point. The first control point is assumed to be
   * The starting point is the last point in the current path.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */ bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this.getLastPoint(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"].shared);
        let cp1x = 0;
        let cp1y = 0;
        if (!last || last.action !== "bezierCurveTo") {
            cp1x = lastPoint.x;
            cp1y = lastPoint.y;
        } else {
            cp1x = last.data[2];
            cp1y = last.data[3];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cp1x = currentX + (currentX - cp1x);
            cp1y = currentY + (currentY - cp1y);
        }
        this.instructions.push({
            action: "bezierCurveTo",
            data: [
                cp1x,
                cp1y,
                cp2x,
                cp2y,
                x,
                y,
                smoothness
            ]
        });
        this._dirty = true;
        return this;
    }
    /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */ closePath() {
        this.instructions.push({
            action: "closePath",
            data: []
        });
        this._dirty = true;
        return this;
    }
    ellipse(...args) {
        this.instructions.push({
            action: "ellipse",
            data: args
        });
        this._dirty = true;
        return this;
    }
    lineTo(...args) {
        this.instructions.push({
            action: "lineTo",
            data: args
        });
        this._dirty = true;
        return this;
    }
    moveTo(...args) {
        this.instructions.push({
            action: "moveTo",
            data: args
        });
        return this;
    }
    quadraticCurveTo(...args) {
        this.instructions.push({
            action: "quadraticCurveTo",
            data: args
        });
        this._dirty = true;
        return this;
    }
    /**
   * Adds a quadratic curve to the path. It uses the previous point as the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */ quadraticCurveToShort(x, y, smoothness) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this.getLastPoint(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"].shared);
        let cpx1 = 0;
        let cpy1 = 0;
        if (!last || last.action !== "quadraticCurveTo") {
            cpx1 = lastPoint.x;
            cpy1 = lastPoint.y;
        } else {
            cpx1 = last.data[0];
            cpy1 = last.data[1];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cpx1 = currentX + (currentX - cpx1);
            cpy1 = currentY + (currentY - cpy1);
        }
        this.instructions.push({
            action: "quadraticCurveTo",
            data: [
                cpx1,
                cpy1,
                x,
                y,
                smoothness
            ]
        });
        this._dirty = true;
        return this;
    }
    /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */ rect(x, y, w, h, transform) {
        this.instructions.push({
            action: "rect",
            data: [
                x,
                y,
                w,
                h,
                transform
            ]
        });
        this._dirty = true;
        return this;
    }
    /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */ circle(x, y, radius, transform) {
        this.instructions.push({
            action: "circle",
            data: [
                x,
                y,
                radius,
                transform
            ]
        });
        this._dirty = true;
        return this;
    }
    roundRect(...args) {
        this.instructions.push({
            action: "roundRect",
            data: args
        });
        this._dirty = true;
        return this;
    }
    poly(...args) {
        this.instructions.push({
            action: "poly",
            data: args
        });
        this._dirty = true;
        return this;
    }
    regularPoly(...args) {
        this.instructions.push({
            action: "regularPoly",
            data: args
        });
        this._dirty = true;
        return this;
    }
    roundPoly(...args) {
        this.instructions.push({
            action: "roundPoly",
            data: args
        });
        this._dirty = true;
        return this;
    }
    roundShape(...args) {
        this.instructions.push({
            action: "roundShape",
            data: args
        });
        this._dirty = true;
        return this;
    }
    filletRect(...args) {
        this.instructions.push({
            action: "filletRect",
            data: args
        });
        this._dirty = true;
        return this;
    }
    chamferRect(...args) {
        this.instructions.push({
            action: "chamferRect",
            data: args
        });
        this._dirty = true;
        return this;
    }
    /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @param transform - An optional `Matrix` object to apply a transformation to the star.
   * This can include rotations, scaling, and translations.
   * @returns The instance of the current object for chaining further drawing commands.
   */ // eslint-disable-next-line max-len
    star(x, y, points, radius, innerRadius, rotation, transform) {
        innerRadius || (innerRadius = radius / 2);
        const startAngle = -1 * Math.PI / 2 + rotation;
        const len = points * 2;
        const delta = Math.PI * 2 / len;
        const polygon = [];
        for(let i = 0; i < len; i++){
            const r = i % 2 ? innerRadius : radius;
            const angle = i * delta + startAngle;
            polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));
        }
        this.poly(polygon, true, transform);
        return this;
    }
    /**
   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
   * do not affect the original `GraphicsPath` and vice versa.
   * @param deep - A boolean flag indicating whether the clone should be deep.
   * @returns A new `GraphicsPath` instance that is a clone of the current instance.
   */ clone(deep = false) {
        const newGraphicsPath2D = new GraphicsPath();
        newGraphicsPath2D.checkForHoles = this.checkForHoles;
        if (!deep) {
            newGraphicsPath2D.instructions = this.instructions.slice();
        } else {
            for(let i = 0; i < this.instructions.length; i++){
                const instruction = this.instructions[i];
                newGraphicsPath2D.instructions.push({
                    action: instruction.action,
                    data: instruction.data.slice()
                });
            }
        }
        return newGraphicsPath2D;
    }
    clear() {
        this.instructions.length = 0;
        this._dirty = true;
        return this;
    }
    /**
   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
   * This method enables the modification of the path's geometry according to the provided
   * transformation matrix, which can include translations, rotations, scaling, and skewing.
   *
   * Each drawing instruction in the path is updated to reflect the transformation,
   * ensuring the visual representation of the path is consistent with the applied matrix.
   *
   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
   * allowing for fine-grained control over the path's appearance.
   * @param matrix - A `Matrix` object representing the transformation to apply.
   * @returns The instance of the current object for chaining further operations.
   */ transform(matrix) {
        if (matrix.isIdentity()) return this;
        const a = matrix.a;
        const b = matrix.b;
        const c = matrix.c;
        const d = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let x = 0;
        let y = 0;
        let cpx1 = 0;
        let cpy1 = 0;
        let cpx2 = 0;
        let cpy2 = 0;
        let rx = 0;
        let ry = 0;
        for(let i = 0; i < this.instructions.length; i++){
            const instruction = this.instructions[i];
            const data = instruction.data;
            switch(instruction.action){
                case "moveTo":
                case "lineTo":
                    x = data[0];
                    y = data[1];
                    data[0] = a * x + c * y + tx;
                    data[1] = b * x + d * y + ty;
                    break;
                case "bezierCurveTo":
                    cpx1 = data[0];
                    cpy1 = data[1];
                    cpx2 = data[2];
                    cpy2 = data[3];
                    x = data[4];
                    y = data[5];
                    data[0] = a * cpx1 + c * cpy1 + tx;
                    data[1] = b * cpx1 + d * cpy1 + ty;
                    data[2] = a * cpx2 + c * cpy2 + tx;
                    data[3] = b * cpx2 + d * cpy2 + ty;
                    data[4] = a * x + c * y + tx;
                    data[5] = b * x + d * y + ty;
                    break;
                case "quadraticCurveTo":
                    cpx1 = data[0];
                    cpy1 = data[1];
                    x = data[2];
                    y = data[3];
                    data[0] = a * cpx1 + c * cpy1 + tx;
                    data[1] = b * cpx1 + d * cpy1 + ty;
                    data[2] = a * x + c * y + tx;
                    data[3] = b * x + d * y + ty;
                    break;
                case "arcToSvg":
                    x = data[5];
                    y = data[6];
                    rx = data[0];
                    ry = data[1];
                    data[0] = a * rx + c * ry;
                    data[1] = b * rx + d * ry;
                    data[5] = a * x + c * y + tx;
                    data[6] = b * x + d * y + ty;
                    break;
                case "circle":
                    data[4] = adjustTransform(data[3], matrix);
                    break;
                case "rect":
                    data[4] = adjustTransform(data[4], matrix);
                    break;
                case "ellipse":
                    data[8] = adjustTransform(data[8], matrix);
                    break;
                case "roundRect":
                    data[5] = adjustTransform(data[5], matrix);
                    break;
                case "addPath":
                    data[0].transform(matrix);
                    break;
                case "poly":
                    data[2] = adjustTransform(data[2], matrix);
                    break;
                default:
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("unknown transform action", instruction.action);
                    break;
            }
        }
        this._dirty = true;
        return this;
    }
    get bounds() {
        return this.shapePath.bounds;
    }
    /**
   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
   * This method is useful for operations that depend on the path's current endpoint,
   * such as connecting subsequent shapes or paths. It supports various drawing instructions,
   * ensuring the last point's position is accurately determined regardless of the path's complexity.
   *
   * If the last instruction is a `closePath`, the method iterates backward through the instructions
   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
   * the last point from the nested path.
   * @param out - A `Point` object where the last point's coordinates will be stored.
   * This object is modified directly to contain the result.
   * @returns The `Point` object containing the last point's coordinates.
   */ getLastPoint(out) {
        let index = this.instructions.length - 1;
        let lastInstruction = this.instructions[index];
        if (!lastInstruction) {
            out.x = 0;
            out.y = 0;
            return out;
        }
        while(lastInstruction.action === "closePath"){
            index--;
            if (index < 0) {
                out.x = 0;
                out.y = 0;
                return out;
            }
            lastInstruction = this.instructions[index];
        }
        switch(lastInstruction.action){
            case "moveTo":
            case "lineTo":
                out.x = lastInstruction.data[0];
                out.y = lastInstruction.data[1];
                break;
            case "quadraticCurveTo":
                out.x = lastInstruction.data[2];
                out.y = lastInstruction.data[3];
                break;
            case "bezierCurveTo":
                out.x = lastInstruction.data[4];
                out.y = lastInstruction.data[5];
                break;
            case "arc":
            case "arcToSvg":
                out.x = lastInstruction.data[5];
                out.y = lastInstruction.data[6];
                break;
            case "addPath":
                lastInstruction.data[0].getLastPoint(out);
                break;
        }
        return out;
    }
}
function adjustTransform(currentMatrix, transform) {
    if (currentMatrix) {
        return currentMatrix.prepend(transform);
    }
    return transform.clone();
}
;
 //# sourceMappingURL=GraphicsPath.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseSVGFloatAttribute",
    ()=>parseSVGFloatAttribute
]);
"use strict";
function parseSVGFloatAttribute(svg, id, defaultValue) {
    const value = svg.getAttribute(id);
    return value ? Number(value) : defaultValue;
}
;
 //# sourceMappingURL=parseSVGFloatAttribute.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseSVGDefinitions",
    ()=>parseSVGDefinitions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillGradient$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
function parseSVGDefinitions(svg, session) {
    const definitions = svg.querySelectorAll("defs");
    for(let i = 0; i < definitions.length; i++){
        const definition = definitions[i];
        for(let j = 0; j < definition.children.length; j++){
            const child = definition.children[j];
            switch(child.nodeName.toLowerCase()){
                case "lineargradient":
                    session.defs[child.id] = parseLinearGradient(child);
                    break;
                case "radialgradient":
                    session.defs[child.id] = parseRadialGradient(child);
                    break;
                default:
                    break;
            }
        }
    }
}
function parseLinearGradient(child) {
    const x0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(child, "x1", 0);
    const y0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(child, "y1", 0);
    const x1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(child, "x2", 1);
    const y1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(child, "y2", 0);
    const gradientUnit = child.getAttribute("gradientUnits") || "objectBoundingBox";
    const gradient = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillGradient$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FillGradient"](x0, y0, x1, y1, gradientUnit === "objectBoundingBox" ? "local" : "global");
    for(let k = 0; k < child.children.length; k++){
        const stop = child.children[k];
        const offset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(stop, "offset", 0);
        const color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(stop.getAttribute("stop-color")).toNumber();
        gradient.addColorStop(offset, color);
    }
    return gradient;
}
function parseRadialGradient(_child) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("[SVG Parser] Radial gradients are not yet supported");
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillGradient$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FillGradient"](0, 0, 1, 0);
}
;
 //# sourceMappingURL=parseSVGDefinitions.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "extractSvgUrlId",
    ()=>extractSvgUrlId
]);
"use strict";
function extractSvgUrlId(url) {
    const match = url.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
    return match ? match[1] : "";
}
;
 //# sourceMappingURL=extractSvgUrlId.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseSVGStyle",
    ()=>parseSVGStyle,
    "styleAttributes",
    ()=>styleAttributes
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$utils$2f$extractSvgUrlId$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const styleAttributes = {
    // Fill properties
    fill: {
        type: "paint",
        default: 0
    },
    // Fill color/gradient
    "fill-opacity": {
        type: "number",
        default: 1
    },
    // Fill transparency
    // Stroke properties
    stroke: {
        type: "paint",
        default: 0
    },
    // Stroke color/gradient
    "stroke-width": {
        type: "number",
        default: 1
    },
    // Width of stroke
    "stroke-opacity": {
        type: "number",
        default: 1
    },
    // Stroke transparency
    "stroke-linecap": {
        type: "string",
        default: "butt"
    },
    // End cap style: butt, round, square
    "stroke-linejoin": {
        type: "string",
        default: "miter"
    },
    // Join style: miter, round, bevel
    "stroke-miterlimit": {
        type: "number",
        default: 10
    },
    // Limit on miter join sharpness
    "stroke-dasharray": {
        type: "string",
        default: "none"
    },
    // Dash pattern
    "stroke-dashoffset": {
        type: "number",
        default: 0
    },
    // Offset for dash pattern
    // Global properties
    opacity: {
        type: "number",
        default: 1
    }
};
function parseSVGStyle(svg, session) {
    const style = svg.getAttribute("style");
    const strokeStyle = {};
    const fillStyle = {};
    const result = {
        strokeStyle,
        fillStyle,
        useFill: false,
        useStroke: false
    };
    for(const key in styleAttributes){
        const attribute = svg.getAttribute(key);
        if (attribute) {
            parseAttribute(session, result, key, attribute.trim());
        }
    }
    if (style) {
        const styleParts = style.split(";");
        for(let i = 0; i < styleParts.length; i++){
            const stylePart = styleParts[i].trim();
            const [key, value] = stylePart.split(":");
            if (styleAttributes[key]) {
                parseAttribute(session, result, key, value.trim());
            }
        }
    }
    return {
        strokeStyle: result.useStroke ? strokeStyle : null,
        fillStyle: result.useFill ? fillStyle : null,
        useFill: result.useFill,
        useStroke: result.useStroke
    };
}
function parseAttribute(session, result, id, value) {
    switch(id){
        case "stroke":
            if (value !== "none") {
                if (value.startsWith("url(")) {
                    const id2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$utils$2f$extractSvgUrlId$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractSvgUrlId"])(value);
                    result.strokeStyle.fill = session.defs[id2];
                } else {
                    result.strokeStyle.color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(value).toNumber();
                }
                result.useStroke = true;
            }
            break;
        case "stroke-width":
            result.strokeStyle.width = Number(value);
            break;
        case "fill":
            if (value !== "none") {
                if (value.startsWith("url(")) {
                    const id2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$utils$2f$extractSvgUrlId$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractSvgUrlId"])(value);
                    result.fillStyle.fill = session.defs[id2];
                } else {
                    result.fillStyle.color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(value).toNumber();
                }
                result.useFill = true;
            }
            break;
        case "fill-opacity":
            result.fillStyle.alpha = Number(value);
            break;
        case "stroke-opacity":
            result.strokeStyle.alpha = Number(value);
            break;
        case "opacity":
            result.fillStyle.alpha = Number(value);
            result.strokeStyle.alpha = Number(value);
            break;
    }
}
;
 //# sourceMappingURL=parseSVGStyle.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/fillOperations.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "checkForNestedPattern",
    ()=>checkForNestedPattern,
    "getFillInstructionData",
    ()=>getFillInstructionData
]);
"use strict";
function checkForNestedPattern(subpathsWithArea) {
    if (subpathsWithArea.length <= 2) {
        return true;
    }
    const areas = subpathsWithArea.map((s)=>s.area).sort((a, b)=>b - a);
    const [largestArea, secondArea] = areas;
    const smallestArea = areas[areas.length - 1];
    const largestToSecondRatio = largestArea / secondArea;
    const secondToSmallestRatio = secondArea / smallestArea;
    if (largestToSecondRatio > 3 && secondToSmallestRatio < 2) {
        return false;
    }
    return true;
}
function getFillInstructionData(context, index = 0) {
    const instruction = context.instructions[index];
    if (!instruction || instruction.action !== "fill") {
        throw new Error(`Expected fill instruction at index ${index}, got ${instruction?.action || "undefined"}`);
    }
    return instruction.data;
}
;
 //# sourceMappingURL=fillOperations.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/pathOperations.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "appendSVGPath",
    ()=>appendSVGPath,
    "calculatePathArea",
    ()=>calculatePathArea,
    "extractSubpaths",
    ()=>extractSubpaths
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$GraphicsPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs [app-ssr] (ecmascript)");
;
"use strict";
function extractSubpaths(pathData) {
    const parts = pathData.split(/(?=[Mm])/);
    const subpaths = parts.filter((part)=>part.trim().length > 0);
    return subpaths;
}
function calculatePathArea(pathData) {
    const coords = pathData.match(/[-+]?[0-9]*\.?[0-9]+/g);
    if (!coords || coords.length < 4) return 0;
    const numbers = coords.map(Number);
    const xs = [];
    const ys = [];
    for(let i = 0; i < numbers.length; i += 2){
        if (i + 1 < numbers.length) {
            xs.push(numbers[i]);
            ys.push(numbers[i + 1]);
        }
    }
    if (xs.length === 0 || ys.length === 0) return 0;
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    const area = (maxX - minX) * (maxY - minY);
    return area;
}
function appendSVGPath(pathData, graphicsPath) {
    const tempPath = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$GraphicsPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsPath"](pathData, false);
    for (const instruction of tempPath.instructions){
        graphicsPath.instructions.push(instruction);
    }
}
;
 //# sourceMappingURL=pathOperations.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SVGParser",
    ()=>SVGParser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$GraphicsPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGDefinitions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$utils$2f$fillOperations$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/fillOperations.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$utils$2f$pathOperations$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/pathOperations.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
function SVGParser(svg, graphicsContext) {
    if (typeof svg === "string") {
        const div = document.createElement("div");
        div.innerHTML = svg.trim();
        svg = div.querySelector("svg");
    }
    const session = {
        context: graphicsContext,
        defs: {},
        path: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$GraphicsPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsPath"]()
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGDefinitions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGDefinitions"])(svg, session);
    const children = svg.children;
    const { fillStyle, strokeStyle } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGStyle"])(svg, session);
    for(let i = 0; i < children.length; i++){
        const child = children[i];
        if (child.nodeName.toLowerCase() === "defs") continue;
        renderChildren(child, session, fillStyle, strokeStyle);
    }
    return graphicsContext;
}
function renderChildren(svg, session, fillStyle, strokeStyle) {
    const children = svg.children;
    const { fillStyle: f1, strokeStyle: s1 } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGStyle"])(svg, session);
    if (f1 && fillStyle) {
        fillStyle = {
            ...fillStyle,
            ...f1
        };
    } else if (f1) {
        fillStyle = f1;
    }
    if (s1 && strokeStyle) {
        strokeStyle = {
            ...strokeStyle,
            ...s1
        };
    } else if (s1) {
        strokeStyle = s1;
    }
    const noStyle = !fillStyle && !strokeStyle;
    if (noStyle) {
        fillStyle = {
            color: 0
        };
    }
    let x;
    let y;
    let x1;
    let y1;
    let x2;
    let y2;
    let cx;
    let cy;
    let r;
    let rx;
    let ry;
    let points;
    let pointsString;
    let d;
    let graphicsPath;
    let width;
    let height;
    switch(svg.nodeName.toLowerCase()){
        case "path":
            {
                d = svg.getAttribute("d");
                const fillRule = svg.getAttribute("fill-rule");
                const subpaths = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$utils$2f$pathOperations$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractSubpaths"])(d);
                const hasExplicitEvenodd = fillRule === "evenodd";
                const hasMultipleSubpaths = subpaths.length > 1;
                const shouldProcessHoles = hasExplicitEvenodd && hasMultipleSubpaths;
                if (shouldProcessHoles) {
                    const subpathsWithArea = subpaths.map((subpath)=>({
                            path: subpath,
                            area: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$utils$2f$pathOperations$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculatePathArea"])(subpath)
                        }));
                    subpathsWithArea.sort((a, b)=>b.area - a.area);
                    const useMultipleHolesApproach = subpaths.length > 3 || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$utils$2f$fillOperations$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["checkForNestedPattern"])(subpathsWithArea);
                    if (useMultipleHolesApproach) {
                        for(let i = 0; i < subpathsWithArea.length; i++){
                            const subpath = subpathsWithArea[i];
                            const isMainShape = i === 0;
                            session.context.beginPath();
                            const newPath = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$GraphicsPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsPath"](void 0, true);
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$utils$2f$pathOperations$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["appendSVGPath"])(subpath.path, newPath);
                            session.context.path(newPath);
                            if (isMainShape) {
                                if (fillStyle) session.context.fill(fillStyle);
                                if (strokeStyle) session.context.stroke(strokeStyle);
                            } else {
                                session.context.cut();
                            }
                        }
                    } else {
                        for(let i = 0; i < subpathsWithArea.length; i++){
                            const subpath = subpathsWithArea[i];
                            const isHole = i % 2 === 1;
                            session.context.beginPath();
                            const newPath = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$GraphicsPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsPath"](void 0, true);
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$utils$2f$pathOperations$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["appendSVGPath"])(subpath.path, newPath);
                            session.context.path(newPath);
                            if (isHole) {
                                session.context.cut();
                            } else {
                                if (fillStyle) session.context.fill(fillStyle);
                                if (strokeStyle) session.context.stroke(strokeStyle);
                            }
                        }
                    }
                } else {
                    const useEvenoddForGraphicsPath = fillRule ? fillRule === "evenodd" : true;
                    graphicsPath = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$GraphicsPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsPath"](d, useEvenoddForGraphicsPath);
                    session.context.path(graphicsPath);
                    if (fillStyle) session.context.fill(fillStyle);
                    if (strokeStyle) session.context.stroke(strokeStyle);
                }
                break;
            }
        case "circle":
            cx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "cx", 0);
            cy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "cy", 0);
            r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "r", 0);
            session.context.ellipse(cx, cy, r, r);
            if (fillStyle) session.context.fill(fillStyle);
            if (strokeStyle) session.context.stroke(strokeStyle);
            break;
        case "rect":
            x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "x", 0);
            y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "y", 0);
            width = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "width", 0);
            height = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "height", 0);
            rx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "rx", 0);
            ry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "ry", 0);
            if (rx || ry) {
                session.context.roundRect(x, y, width, height, rx || ry);
            } else {
                session.context.rect(x, y, width, height);
            }
            if (fillStyle) session.context.fill(fillStyle);
            if (strokeStyle) session.context.stroke(strokeStyle);
            break;
        case "ellipse":
            cx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "cx", 0);
            cy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "cy", 0);
            rx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "rx", 0);
            ry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "ry", 0);
            session.context.beginPath();
            session.context.ellipse(cx, cy, rx, ry);
            if (fillStyle) session.context.fill(fillStyle);
            if (strokeStyle) session.context.stroke(strokeStyle);
            break;
        case "line":
            x1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "x1", 0);
            y1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "y1", 0);
            x2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "x2", 0);
            y2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$parseSVGFloatAttribute$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSVGFloatAttribute"])(svg, "y2", 0);
            session.context.beginPath();
            session.context.moveTo(x1, y1);
            session.context.lineTo(x2, y2);
            if (strokeStyle) session.context.stroke(strokeStyle);
            break;
        case "polygon":
            pointsString = svg.getAttribute("points");
            points = pointsString.match(/-?\d+/g).map((n)=>parseInt(n, 10));
            session.context.poly(points, true);
            if (fillStyle) session.context.fill(fillStyle);
            if (strokeStyle) session.context.stroke(strokeStyle);
            break;
        case "polyline":
            pointsString = svg.getAttribute("points");
            points = pointsString.match(/-?\d+/g).map((n)=>parseInt(n, 10));
            session.context.poly(points, false);
            if (strokeStyle) session.context.stroke(strokeStyle);
            break;
        case "g":
        case "svg":
            break;
        default:
            {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])(`[SVG parser] <${svg.nodeName}> elements unsupported`);
                break;
            }
    }
    if (noStyle) {
        fillStyle = null;
    }
    for(let i = 0; i < children.length; i++){
        renderChildren(children[i], session, fillStyle, strokeStyle);
    }
}
;
 //# sourceMappingURL=SVGParser.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "toFillStyle",
    ()=>toFillStyle,
    "toStrokeStyle",
    ()=>toStrokeStyle
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillGradient$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillPattern$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
function isColorLike(value) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].isColorLike(value);
}
function isFillPattern(value) {
    return value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillPattern$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FillPattern"];
}
function isFillGradient(value) {
    return value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillGradient$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FillGradient"];
}
function isTexture(value) {
    return value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"];
}
function handleColorLike(fill, value, defaultStyle) {
    const temp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(value ?? 0);
    fill.color = temp.toNumber();
    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
    fill.texture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].WHITE;
    return {
        ...defaultStyle,
        ...fill
    };
}
function handleTexture(fill, value, defaultStyle) {
    fill.texture = value;
    return {
        ...defaultStyle,
        ...fill
    };
}
function handleFillPattern(fill, value, defaultStyle) {
    fill.fill = value;
    fill.color = 16777215;
    fill.texture = value.texture;
    fill.matrix = value.transform;
    return {
        ...defaultStyle,
        ...fill
    };
}
function handleFillGradient(fill, value, defaultStyle) {
    value.buildGradient();
    fill.fill = value;
    fill.color = 16777215;
    fill.texture = value.texture;
    fill.matrix = value.transform;
    fill.textureSpace = value.textureSpace;
    return {
        ...defaultStyle,
        ...fill
    };
}
function handleFillObject(value, defaultStyle) {
    const style = {
        ...defaultStyle,
        ...value
    };
    const color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(style.color);
    style.alpha *= color.alpha;
    style.color = color.toNumber();
    return style;
}
function toFillStyle(value, defaultStyle) {
    if (value === void 0 || value === null) {
        return null;
    }
    const fill = {};
    const objectStyle = value;
    if (isColorLike(value)) {
        return handleColorLike(fill, value, defaultStyle);
    } else if (isTexture(value)) {
        return handleTexture(fill, value, defaultStyle);
    } else if (isFillPattern(value)) {
        return handleFillPattern(fill, value, defaultStyle);
    } else if (isFillGradient(value)) {
        return handleFillGradient(fill, value, defaultStyle);
    } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
        return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
    } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
        return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
    }
    return handleFillObject(objectStyle, defaultStyle);
}
function toStrokeStyle(value, defaultStyle) {
    const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;
    const fill = toFillStyle(value, rest);
    if (!fill) {
        return null;
    }
    return {
        width,
        alignment,
        miterLimit,
        cap,
        join,
        pixelLine,
        ...fill
    };
}
;
 //# sourceMappingURL=convertFillInputToFillStyle.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GraphicsContext",
    ()=>GraphicsContext
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$uid$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/uid.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$GraphicsPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$SVGParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$convertFillInputToFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
"use strict";
const tmpPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"]();
const tempMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
const _GraphicsContext = class _GraphicsContext extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"] {
    constructor(){
        super(...arguments);
        /** @internal */ this._gpuData = /* @__PURE__ */ Object.create(null);
        /** If set to true, the resource will be garbage collected automatically when it is not used. */ this.autoGarbageCollect = true;
        /** @internal */ this._gcLastUsed = -1;
        /**
     * unique id for this graphics context
     * @internal
     */ this.uid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$uid$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uid"])("graphicsContext");
        /**
     * Indicates whether content is updated and have to be re-rendered.
     * @internal
     */ this.dirty = true;
        /** The batch mode for this graphics context. It can be 'auto', 'batch', or 'no-batch'. */ this.batchMode = "auto";
        /** @internal */ this.instructions = [];
        /** Whether the graphics context has been destroyed. */ this.destroyed = false;
        this._activePath = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$GraphicsPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsPath"]();
        this._transform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
        this._fillStyle = {
            ..._GraphicsContext.defaultFillStyle
        };
        this._strokeStyle = {
            ..._GraphicsContext.defaultStrokeStyle
        };
        this._stateStack = [];
        this._tick = 0;
        this._bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bounds"]();
        this._boundsDirty = true;
    }
    /**
   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
   * including the current drawing state, transformations, styles, and instructions.
   * @returns A new GraphicsContext instance with the same properties and state as this one.
   */ clone() {
        const clone = new _GraphicsContext();
        clone.batchMode = this.batchMode;
        clone.instructions = this.instructions.slice();
        clone._activePath = this._activePath.clone();
        clone._transform = this._transform.clone();
        clone._fillStyle = {
            ...this._fillStyle
        };
        clone._strokeStyle = {
            ...this._strokeStyle
        };
        clone._stateStack = this._stateStack.slice();
        clone._bounds = this._bounds.clone();
        clone._boundsDirty = true;
        return clone;
    }
    /**
   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
   */ get fillStyle() {
        return this._fillStyle;
    }
    set fillStyle(value) {
        this._fillStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$convertFillInputToFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFillStyle"])(value, _GraphicsContext.defaultFillStyle);
    }
    /**
   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   */ get strokeStyle() {
        return this._strokeStyle;
    }
    set strokeStyle(value) {
        this._strokeStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$convertFillInputToFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toStrokeStyle"])(value, _GraphicsContext.defaultStrokeStyle);
    }
    /**
   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
   * pattern, or a more complex style defined by a FillStyle object.
   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
   *                or a FillStyle or ConvertedFillStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */ setFillStyle(style) {
        this._fillStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$convertFillInputToFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFillStyle"])(style, _GraphicsContext.defaultFillStyle);
        return this;
    }
    /**
   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
   *                or a StrokeStyle or ConvertedStrokeStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */ setStrokeStyle(style) {
        this._strokeStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$convertFillInputToFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFillStyle"])(style, _GraphicsContext.defaultStrokeStyle);
        return this;
    }
    texture(texture, tint, dx, dy, dw, dh) {
        this.instructions.push({
            action: "texture",
            data: {
                image: texture,
                dx: dx || 0,
                dy: dy || 0,
                dw: dw || texture.frame.width,
                dh: dh || texture.frame.height,
                transform: this._transform.clone(),
                alpha: this._fillStyle.alpha,
                style: tint ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(tint).toNumber() : 16777215
            }
        });
        this.onUpdate();
        return this;
    }
    /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @returns The instance of the current GraphicsContext for method chaining.
   */ beginPath() {
        this._activePath = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$GraphicsPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsPath"]();
        return this;
    }
    fill(style, alpha) {
        let path;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction?.action === "stroke") {
            path = lastInstruction.data.path;
        } else {
            path = this._activePath.clone();
        }
        if (!path) return this;
        if (style != null) {
            if (alpha !== void 0 && typeof style === "number") {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
                style = {
                    color: style,
                    alpha
                };
            }
            this._fillStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$convertFillInputToFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFillStyle"])(style, _GraphicsContext.defaultFillStyle);
        }
        this.instructions.push({
            action: "fill",
            // TODO copy fill style!
            data: {
                style: this.fillStyle,
                path
            }
        });
        this.onUpdate();
        this._initNextPathLocation();
        this._tick = 0;
        return this;
    }
    _initNextPathLocation() {
        const { x, y } = this._activePath.getLastPoint(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Point"].shared);
        this._activePath.clear();
        this._activePath.moveTo(x, y);
    }
    /**
   * Strokes the current path with the current stroke style. This method can take an optional
   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
   * @returns The instance of the current GraphicsContext for method chaining.
   */ stroke(style) {
        let path;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction?.action === "fill") {
            path = lastInstruction.data.path;
        } else {
            path = this._activePath.clone();
        }
        if (!path) return this;
        if (style != null) {
            this._strokeStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$convertFillInputToFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toStrokeStyle"])(style, _GraphicsContext.defaultStrokeStyle);
        }
        this.instructions.push({
            action: "stroke",
            // TODO copy fill style!
            data: {
                style: this.strokeStyle,
                path
            }
        });
        this.onUpdate();
        this._initNextPathLocation();
        this._tick = 0;
        return this;
    }
    /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
   * fail to cut correctly!
   * @returns The instance of the current GraphicsContext for method chaining.
   */ cut() {
        for(let i = 0; i < 2; i++){
            const lastInstruction = this.instructions[this.instructions.length - 1 - i];
            const holePath = this._activePath.clone();
            if (lastInstruction) {
                if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
                    if (lastInstruction.data.hole) {
                        lastInstruction.data.hole.addPath(holePath);
                    } else {
                        lastInstruction.data.hole = holePath;
                        break;
                    }
                }
            }
        }
        this._initNextPathLocation();
        return this;
    }
    /**
   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
   * starting and ending angles, and direction.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The arc's radius.
   * @param startAngle - The starting angle, in radians.
   * @param endAngle - The ending angle, in radians.
   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
   * @returns The instance of the current GraphicsContext for method chaining.
   */ arc(x, y, radius, startAngle, endAngle, counterclockwise) {
        this._tick++;
        const t = this._transform;
        this._activePath.arc(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, radius, startAngle, endAngle, counterclockwise);
        return this;
    }
    /**
   * Adds an arc to the current path with the given control points and radius, connected to the previous point
   * by a straight line if necessary.
   * @param x1 - The x-coordinate of the first control point.
   * @param y1 - The y-coordinate of the first control point.
   * @param x2 - The x-coordinate of the second control point.
   * @param y2 - The y-coordinate of the second control point.
   * @param radius - The arc's radius.
   * @returns The instance of the current GraphicsContext for method chaining.
   */ arcTo(x1, y1, x2, y2, radius) {
        this._tick++;
        const t = this._transform;
        this._activePath.arcTo(t.a * x1 + t.c * y1 + t.tx, t.b * x1 + t.d * y1 + t.ty, t.a * x2 + t.c * y2 + t.tx, t.b * x2 + t.d * y2 + t.ty, radius);
        return this;
    }
    /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */ arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
        this._tick++;
        const t = this._transform;
        this._activePath.arcToSvg(rx, ry, xAxisRotation, // should we rotate this with transform??
        largeArcFlag, sweepFlag, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);
        return this;
    }
    /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */ bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {
        this._tick++;
        const t = this._transform;
        this._activePath.bezierCurveTo(t.a * cp1x + t.c * cp1y + t.tx, t.b * cp1x + t.d * cp1y + t.ty, t.a * cp2x + t.c * cp2y + t.tx, t.b * cp2x + t.d * cp2y + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);
        return this;
    }
    /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */ closePath() {
        this._tick++;
        this._activePath?.closePath();
        return this;
    }
    /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @returns The instance of the current object for chaining.
   */ ellipse(x, y, radiusX, radiusY) {
        this._tick++;
        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());
        return this;
    }
    /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @returns The instance of the current object for chaining.
   */ circle(x, y, radius) {
        this._tick++;
        this._activePath.circle(x, y, radius, this._transform.clone());
        return this;
    }
    /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @returns The instance of the current object for chaining.
   */ path(path) {
        this._tick++;
        this._activePath.addPath(path, this._transform.clone());
        return this;
    }
    /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */ lineTo(x, y) {
        this._tick++;
        const t = this._transform;
        this._activePath.lineTo(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);
        return this;
    }
    /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */ moveTo(x, y) {
        this._tick++;
        const t = this._transform;
        const instructions = this._activePath.instructions;
        const transformedX = t.a * x + t.c * y + t.tx;
        const transformedY = t.b * x + t.d * y + t.ty;
        if (instructions.length === 1 && instructions[0].action === "moveTo") {
            instructions[0].data[0] = transformedX;
            instructions[0].data[1] = transformedY;
            return this;
        }
        this._activePath.moveTo(transformedX, transformedY);
        return this;
    }
    /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cpx - The x-coordinate of the control point.
   * @param cpy - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */ quadraticCurveTo(cpx, cpy, x, y, smoothness) {
        this._tick++;
        const t = this._transform;
        this._activePath.quadraticCurveTo(t.a * cpx + t.c * cpy + t.tx, t.b * cpx + t.d * cpy + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);
        return this;
    }
    /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @returns The instance of the current object for chaining.
   */ rect(x, y, w, h) {
        this._tick++;
        this._activePath.rect(x, y, w, h, this._transform.clone());
        return this;
    }
    /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @returns The instance of the current object for chaining.
   */ roundRect(x, y, w, h, radius) {
        this._tick++;
        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());
        return this;
    }
    /**
   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
   * rotated, or translated as needed.
   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates, of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   */ poly(points, close) {
        this._tick++;
        this._activePath.poly(points, close, this._transform.clone());
        return this;
    }
    /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */ regularPoly(x, y, radius, sides, rotation = 0, transform) {
        this._tick++;
        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);
        return this;
    }
    /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @returns The instance of the current object for chaining.
   */ roundPoly(x, y, radius, sides, corner, rotation) {
        this._tick++;
        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);
        return this;
    }
    /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */ roundShape(points, radius, useQuadratic, smoothness) {
        this._tick++;
        this._activePath.roundShape(points, radius, useQuadratic, smoothness);
        return this;
    }
    /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */ filletRect(x, y, width, height, fillet) {
        this._tick++;
        this._activePath.filletRect(x, y, width, height, fillet);
        return this;
    }
    /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */ chamferRect(x, y, width, height, chamfer, transform) {
        this._tick++;
        this._activePath.chamferRect(x, y, width, height, chamfer, transform);
        return this;
    }
    /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @returns The instance of the current object for chaining further drawing commands.
   */ star(x, y, points, radius, innerRadius = 0, rotation = 0) {
        this._tick++;
        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());
        return this;
    }
    /**
   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
   * defined in SVG format to be drawn within the graphics context.
   * @param svg - The SVG string to be parsed and rendered.
   */ svg(svg) {
        this._tick++;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$svg$2f$SVGParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SVGParser"])(svg, this);
        return this;
    }
    /**
   * Restores the most recently saved graphics state by popping the top of the graphics state stack.
   * This includes transformations, fill styles, and stroke styles.
   */ restore() {
        const state = this._stateStack.pop();
        if (state) {
            this._transform = state.transform;
            this._fillStyle = state.fillStyle;
            this._strokeStyle = state.strokeStyle;
        }
        return this;
    }
    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */ save() {
        this._stateStack.push({
            transform: this._transform.clone(),
            fillStyle: {
                ...this._fillStyle
            },
            strokeStyle: {
                ...this._strokeStyle
            }
        });
        return this;
    }
    /**
   * Returns the current transformation matrix of the graphics context.
   * @returns The current transformation matrix.
   */ getTransform() {
        return this._transform;
    }
    /**
   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
   * @returns The instance of the current GraphicsContext for method chaining.
   */ resetTransform() {
        this._transform.identity();
        return this;
    }
    /**
   * Applies a rotation transformation to the graphics context around the current origin.
   * @param angle - The angle of rotation in radians.
   * @returns The instance of the current GraphicsContext for method chaining.
   */ rotate(angle) {
        this._transform.rotate(angle);
        return this;
    }
    /**
   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
   * @param x - The scale factor in the horizontal direction.
   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */ scale(x, y = x) {
        this._transform.scale(x, y);
        return this;
    }
    setTransform(a, b, c, d, dx, dy) {
        if (a instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]) {
            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);
            return this;
        }
        this._transform.set(a, b, c, d, dx, dy);
        return this;
    }
    transform(a, b, c, d, dx, dy) {
        if (a instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]) {
            this._transform.append(a);
            return this;
        }
        tempMatrix.set(a, b, c, d, dx, dy);
        this._transform.append(tempMatrix);
        return this;
    }
    /**
   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
   * @param x - The amount to translate in the horizontal direction.
   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */ translate(x, y = x) {
        this._transform.translate(x, y);
        return this;
    }
    /**
   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
   * and optionally resetting transformations to the identity matrix.
   * @returns The instance of the current GraphicsContext for method chaining.
   */ clear() {
        this._activePath.clear();
        this.instructions.length = 0;
        this.resetTransform();
        this.onUpdate();
        return this;
    }
    onUpdate() {
        this._boundsDirty = true;
        if (this.dirty) return;
        this.emit("update", this, 16);
        this.dirty = true;
    }
    /** The bounds of the graphic shape. */ get bounds() {
        if (!this._boundsDirty) return this._bounds;
        this._boundsDirty = false;
        const bounds = this._bounds;
        bounds.clear();
        for(let i = 0; i < this.instructions.length; i++){
            const instruction = this.instructions[i];
            const action = instruction.action;
            if (action === "fill") {
                const data = instruction.data;
                bounds.addBounds(data.path.bounds);
            } else if (action === "texture") {
                const data = instruction.data;
                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
            }
            if (action === "stroke") {
                const data = instruction.data;
                const alignment = data.style.alignment;
                const outerPadding = data.style.width * (1 - alignment);
                const _bounds = data.path.bounds;
                bounds.addFrame(_bounds.minX - outerPadding, _bounds.minY - outerPadding, _bounds.maxX + outerPadding, _bounds.maxY + outerPadding);
            }
        }
        return bounds;
    }
    /**
   * Check to see if a point is contained within this geometry.
   * @param point - Point to check if it's contained.
   * @returns {boolean} `true` if the point is contained within geometry.
   */ containsPoint(point) {
        if (!this.bounds.containsPoint(point.x, point.y)) return false;
        const instructions = this.instructions;
        let hasHit = false;
        for(let k = 0; k < instructions.length; k++){
            const instruction = instructions[k];
            const data = instruction.data;
            const path = data.path;
            if (!instruction.action || !path) continue;
            const style = data.style;
            const shapes = path.shapePath.shapePrimitives;
            for(let i = 0; i < shapes.length; i++){
                const shape = shapes[i].shape;
                if (!style || !shape) continue;
                const transform = shapes[i].transform;
                const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;
                if (instruction.action === "fill") {
                    hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
                } else {
                    const strokeStyle = style;
                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);
                }
                const holes = data.hole;
                if (holes) {
                    const holeShapes = holes.shapePath?.shapePrimitives;
                    if (holeShapes) {
                        for(let j = 0; j < holeShapes.length; j++){
                            if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {
                                hasHit = false;
                            }
                        }
                    }
                }
                if (hasHit) {
                    return true;
                }
            }
        }
        return hasHit;
    }
    /** Unloads the GPU data from the graphics context. */ unload() {
        this.emit("unload", this);
        for(const key in this._gpuData){
            this._gpuData[key]?.destroy();
        }
        this._gpuData = /* @__PURE__ */ Object.create(null);
    }
    /**
   * Destroys the GraphicsData object.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * context.destroy();
   * context.destroy(true);
   * context.destroy({ texture: true, textureSource: true });
   */ destroy(options = false) {
        if (this.destroyed) return;
        this.destroyed = true;
        this._stateStack.length = 0;
        this._transform = null;
        this.unload();
        this.emit("destroy", this);
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            if (this._fillStyle.texture) {
                this._fillStyle.fill && "uid" in this._fillStyle.fill ? this._fillStyle.fill.destroy() : this._fillStyle.texture.destroy(destroyTextureSource);
            }
            if (this._strokeStyle.texture) {
                this._strokeStyle.fill && "uid" in this._strokeStyle.fill ? this._strokeStyle.fill.destroy() : this._strokeStyle.texture.destroy(destroyTextureSource);
            }
        }
        this._fillStyle = null;
        this._strokeStyle = null;
        this.instructions = null;
        this._activePath = null;
        this._bounds = null;
        this._stateStack = null;
        this.customShader = null;
        this._transform = null;
    }
};
/** The default fill style to use when none is provided. */ _GraphicsContext.defaultFillStyle = {
    /** The color to use for the fill. */ color: 16777215,
    /** The alpha value to use for the fill. */ alpha: 1,
    /** The texture to use for the fill. */ texture: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].WHITE,
    /** The matrix to apply. */ matrix: null,
    /** The fill pattern to use. */ fill: null,
    /** Whether coordinates are 'global' or 'local' */ textureSpace: "local"
};
/** The default stroke style to use when none is provided. */ _GraphicsContext.defaultStrokeStyle = {
    /** The width of the stroke. */ width: 1,
    /** The color to use for the stroke. */ color: 16777215,
    /** The alpha value to use for the stroke. */ alpha: 1,
    /** The alignment of the stroke. */ alignment: 0.5,
    /** The miter limit to use. */ miterLimit: 10,
    /** The line cap style to use. */ cap: "butt",
    /** The line join style to use. */ join: "miter",
    /** The texture to use for the fill. */ texture: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].WHITE,
    /** The matrix to apply. */ matrix: null,
    /** The fill pattern to use. */ fill: null,
    /** Whether coordinates are 'global' or 'local' */ textureSpace: "local",
    /** If the stroke is a pixel line. */ pixelLine: false
};
let GraphicsContext = _GraphicsContext;
;
 //# sourceMappingURL=GraphicsContext.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/TextStyle.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TextStyle",
    ()=>TextStyle
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$uid$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/uid.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillGradient$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillPattern$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$convertFillInputToFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
"use strict";
const _TextStyle = class _TextStyle extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"] {
    constructor(style = {}){
        super();
        /**
     * Unique identifier for the TextStyle class.
     * This is used to track instances and ensure uniqueness.
     * @internal
     */ this.uid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$uid$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uid"])("textStyle");
        /**
     * Internal tick counter used to track updates and changes.
     * This is incremented whenever the style is modified, allowing for efficient change detection.
     * @internal
     */ this._tick = 0;
        convertV7Tov8Style(style);
        const fullStyle = {
            ..._TextStyle.defaultTextStyle,
            ...style
        };
        for(const key in fullStyle){
            const thisKey = key;
            this[thisKey] = fullStyle[key];
        }
        this.update();
        this._tick = 0;
    }
    /**
   * Alignment for multiline text, does not affect single line text.
   * @type {'left'|'center'|'right'|'justify'}
   */ get align() {
        return this._align;
    }
    set align(value) {
        if (this._align === value) return;
        this._align = value;
        this.update();
    }
    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */ get breakWords() {
        return this._breakWords;
    }
    set breakWords(value) {
        if (this._breakWords === value) return;
        this._breakWords = value;
        this.update();
    }
    /** Set a drop shadow for the text. */ get dropShadow() {
        return this._dropShadow;
    }
    set dropShadow(value) {
        if (this._dropShadow === value) return;
        if (value !== null && typeof value === "object") {
            this._dropShadow = this._createProxy({
                ..._TextStyle.defaultDropShadow,
                ...value
            });
        } else {
            this._dropShadow = value ? this._createProxy({
                ..._TextStyle.defaultDropShadow
            }) : null;
        }
        this.update();
    }
    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */ get fontFamily() {
        return this._fontFamily;
    }
    set fontFamily(value) {
        if (this._fontFamily === value) return;
        this._fontFamily = value;
        this.update();
    }
    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */ get fontSize() {
        return this._fontSize;
    }
    set fontSize(value) {
        if (this._fontSize === value) return;
        if (typeof value === "string") {
            this._fontSize = parseInt(value, 10);
        } else {
            this._fontSize = value;
        }
        this.update();
    }
    /**
   * The font style.
   * @type {'normal'|'italic'|'oblique'}
   */ get fontStyle() {
        return this._fontStyle;
    }
    set fontStyle(value) {
        if (this._fontStyle === value) return;
        this._fontStyle = value.toLowerCase();
        this.update();
    }
    /**
   * The font variant.
   * @type {'normal'|'small-caps'}
   */ get fontVariant() {
        return this._fontVariant;
    }
    set fontVariant(value) {
        if (this._fontVariant === value) return;
        this._fontVariant = value;
        this.update();
    }
    /**
   * The font weight.
   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */ get fontWeight() {
        return this._fontWeight;
    }
    set fontWeight(value) {
        if (this._fontWeight === value) return;
        this._fontWeight = value;
        this.update();
    }
    /** The space between lines. */ get leading() {
        return this._leading;
    }
    set leading(value) {
        if (this._leading === value) return;
        this._leading = value;
        this.update();
    }
    /** The amount of spacing between letters, default is 0. */ get letterSpacing() {
        return this._letterSpacing;
    }
    set letterSpacing(value) {
        if (this._letterSpacing === value) return;
        this._letterSpacing = value;
        this.update();
    }
    /** The line height, a number that represents the vertical space that a letter uses. */ get lineHeight() {
        return this._lineHeight;
    }
    set lineHeight(value) {
        if (this._lineHeight === value) return;
        this._lineHeight = value;
        this.update();
    }
    /**
   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
   * by adding padding to all sides of the text.
   * > [!NOTE] This will NOT affect the positioning or bounds of the text.
   */ get padding() {
        return this._padding;
    }
    set padding(value) {
        if (this._padding === value) return;
        this._padding = value;
        this.update();
    }
    /**
   * An optional filter or array of filters to apply to the text, allowing for advanced visual effects.
   * These filters will be applied to the text as it is created, resulting in faster rendering for static text
   * compared to applying the filter directly to the text object (which would be applied at run time).
   * @default null
   */ get filters() {
        return this._filters;
    }
    set filters(value) {
        if (this._filters === value) return;
        this._filters = Object.freeze(value);
        this.update();
    }
    /**
   * Trim transparent borders from the text texture.
   * > [!IMPORTANT] PERFORMANCE WARNING:
   * > This is a costly operation as it requires scanning pixel alpha values.
   * > Avoid using `trim: true` for dynamic text, as it could significantly impact performance.
   */ get trim() {
        return this._trim;
    }
    set trim(value) {
        if (this._trim === value) return;
        this._trim = value;
        this.update();
    }
    /**
   * The baseline of the text that is rendered.
   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */ get textBaseline() {
        return this._textBaseline;
    }
    set textBaseline(value) {
        if (this._textBaseline === value) return;
        this._textBaseline = value;
        this.update();
    }
    /**
   * How newlines and spaces should be handled.
   * Default is 'pre' (preserve, preserve).
   *
   *  value       | New lines     |   Spaces
   *  ---         | ---           |   ---
   * 'normal'     | Collapse      |   Collapse
   * 'pre'        | Preserve      |   Preserve
   * 'pre-line'   | Preserve      |   Collapse
   * @type {'normal'|'pre'|'pre-line'}
   */ get whiteSpace() {
        return this._whiteSpace;
    }
    set whiteSpace(value) {
        if (this._whiteSpace === value) return;
        this._whiteSpace = value;
        this.update();
    }
    /** Indicates if word wrap should be used. */ get wordWrap() {
        return this._wordWrap;
    }
    set wordWrap(value) {
        if (this._wordWrap === value) return;
        this._wordWrap = value;
        this.update();
    }
    /** The width at which text will wrap, it needs wordWrap to be set to true. */ get wordWrapWidth() {
        return this._wordWrapWidth;
    }
    set wordWrapWidth(value) {
        if (this._wordWrapWidth === value) return;
        this._wordWrapWidth = value;
        this.update();
    }
    /**
   * The fill style that will be used to color the text.
   * This can be:
   * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'
   * - A hex number like 0xff0000 for red
   * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }
   * - A FillGradient for gradient fills
   * - A FillPattern for pattern/texture fills
   *
   * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,
   * while gradients at any other angle are spread across the entire text body as a whole.
   * @example
   * // Vertical gradient applied per line
   * const verticalGradient = new FillGradient(0, 0, 0, 1)
   *     .addColorStop(0, 0xff0000)
   *     .addColorStop(1, 0x0000ff);
   *
   * const text = new Text({
   *     text: 'Line 1\nLine 2',
   *     style: { fill: verticalGradient }
   * });
   *
   * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.
   * @type {string|number|FillStyle|FillGradient|FillPattern}
   */ get fill() {
        return this._originalFill;
    }
    set fill(value) {
        if (value === this._originalFill) return;
        this._originalFill = value;
        if (this._isFillStyle(value)) {
            this._originalFill = this._createProxy({
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsContext"].defaultFillStyle,
                ...value
            }, ()=>{
                this._fill = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$convertFillInputToFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFillStyle"])({
                    ...this._originalFill
                }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsContext"].defaultFillStyle);
            });
        }
        this._fill = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$convertFillInputToFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFillStyle"])(value === 0 ? "black" : value, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsContext"].defaultFillStyle);
        this.update();
    }
    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */ get stroke() {
        return this._originalStroke;
    }
    set stroke(value) {
        if (value === this._originalStroke) return;
        this._originalStroke = value;
        if (this._isFillStyle(value)) {
            this._originalStroke = this._createProxy({
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsContext"].defaultStrokeStyle,
                ...value
            }, ()=>{
                this._stroke = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$convertFillInputToFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toStrokeStyle"])({
                    ...this._originalStroke
                }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsContext"].defaultStrokeStyle);
            });
        }
        this._stroke = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$convertFillInputToFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toStrokeStyle"])(value, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsContext"].defaultStrokeStyle);
        this.update();
    }
    update() {
        this._tick++;
        this.emit("update", this);
    }
    /** Resets all properties to the default values */ reset() {
        const defaultStyle = _TextStyle.defaultTextStyle;
        for(const key in defaultStyle){
            this[key] = defaultStyle[key];
        }
    }
    /**
   * Returns a unique key for this instance.
   * This key is used for caching.
   * @returns {string} Unique key for the instance
   */ get styleKey() {
        return `${this.uid}-${this._tick}`;
    }
    /**
   * Creates a new TextStyle object with the same values as this one.
   * @returns New cloned TextStyle object
   */ clone() {
        return new _TextStyle({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this._dropShadow ? {
                ...this._dropShadow
            } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            leading: this.leading,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            textBaseline: this.textBaseline,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            filters: this._filters ? [
                ...this._filters
            ] : void 0
        });
    }
    /**
   * Returns the final padding for the text style, taking into account any filters applied.
   * Used internally for correct measurements
   * @internal
   * @returns {number} The final padding for the text style.
   */ _getFinalPadding() {
        let filterPadding = 0;
        if (this._filters) {
            for(let i = 0; i < this._filters.length; i++){
                filterPadding += this._filters[i].padding;
            }
        }
        return Math.max(this._padding, filterPadding);
    }
    /**
   * Destroys this text style.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * // Destroy the text style and its textures
   * textStyle.destroy({ texture: true, textureSource: true });
   * textStyle.destroy(true);
   */ destroy(options = false) {
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            if (this._fill?.texture) {
                this._fill.texture.destroy(destroyTextureSource);
            }
            if (this._originalFill?.texture) {
                this._originalFill.texture.destroy(destroyTextureSource);
            }
            if (this._stroke?.texture) {
                this._stroke.texture.destroy(destroyTextureSource);
            }
            if (this._originalStroke?.texture) {
                this._originalStroke.texture.destroy(destroyTextureSource);
            }
        }
        this._fill = null;
        this._stroke = null;
        this.dropShadow = null;
        this._originalStroke = null;
        this._originalFill = null;
    }
    _createProxy(value, cb) {
        return new Proxy(value, {
            set: (target, property, newValue)=>{
                if (target[property] === newValue) return true;
                target[property] = newValue;
                cb?.(property, newValue);
                this.update();
                return true;
            }
        });
    }
    _isFillStyle(value) {
        return (value ?? null) !== null && !(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].isColorLike(value) || value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillGradient$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FillGradient"] || value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillPattern$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FillPattern"]);
    }
};
/**
 * Default drop shadow settings used when enabling drop shadows on text.
 * These values are used as the base configuration when drop shadows are enabled without specific settings.
 * @example
 * ```ts
 * // Customize default settings globally
 * TextStyle.defaultDropShadow.alpha = 0.5;    // 50% opacity for all shadows
 * TextStyle.defaultDropShadow.blur = 2;       // 2px blur for all shadows
 * TextStyle.defaultDropShadow.color = 'blue'; // Blue shadows by default
 * ```
 */ _TextStyle.defaultDropShadow = {
    alpha: 1,
    angle: Math.PI / 6,
    blur: 0,
    color: "black",
    distance: 5
};
/**
 * Default text style settings used when creating new text objects.
 * These values serve as the base configuration and can be customized globally.
 * @example
 * ```ts
 * // Customize default text style globally
 * TextStyle.defaultTextStyle.fontSize = 16;
 * TextStyle.defaultTextStyle.fill = 0x333333;
 * TextStyle.defaultTextStyle.fontFamily = ['Arial', 'Helvetica', 'sans-serif'];
 * ```
 */ _TextStyle.defaultTextStyle = {
    align: "left",
    breakWords: false,
    dropShadow: null,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: null,
    textBaseline: "alphabetic",
    trim: false,
    whiteSpace: "pre",
    wordWrap: false,
    wordWrapWidth: 100
};
let TextStyle = _TextStyle;
function convertV7Tov8Style(style) {
    const oldStyle = style;
    if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {
        const defaults = TextStyle.defaultDropShadow;
        style.dropShadow = {
            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,
            angle: oldStyle.dropShadowAngle ?? defaults.angle,
            blur: oldStyle.dropShadowBlur ?? defaults.blur,
            color: oldStyle.dropShadowColor ?? defaults.color,
            distance: oldStyle.dropShadowDistance ?? defaults.distance
        };
    }
    if (oldStyle.strokeThickness !== void 0) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "strokeThickness is now a part of stroke");
        const color = oldStyle.stroke;
        let obj = {};
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].isColorLike(color)) {
            obj.color = color;
        } else if (color instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillGradient$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FillGradient"] || color instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillPattern$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FillPattern"]) {
            obj.fill = color;
        } else if (Object.hasOwnProperty.call(color, "color") || Object.hasOwnProperty.call(color, "fill")) {
            obj = color;
        } else {
            throw new Error("Invalid stroke value.");
        }
        style.stroke = {
            ...obj,
            width: oldStyle.strokeThickness
        };
    }
    if (Array.isArray(oldStyle.fillGradientStops)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "gradient fill is now a fill pattern: `new FillGradient(...)`");
        if (!Array.isArray(oldStyle.fill) || oldStyle.fill.length === 0) {
            throw new Error("Invalid fill value. Expected an array of colors for gradient fill.");
        }
        if (oldStyle.fill.length !== oldStyle.fillGradientStops.length) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("The number of fill colors must match the number of fill gradient stops.");
        }
        const gradientFill = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillGradient$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FillGradient"]({
            start: {
                x: 0,
                y: 0
            },
            end: {
                x: 0,
                y: 1
            },
            textureSpace: "local"
        });
        const fillGradientStops = oldStyle.fillGradientStops.slice();
        const fills = oldStyle.fill.map((color)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(color).toNumber());
        fillGradientStops.forEach((stop, index)=>{
            gradientFill.addColorStop(stop, fills[index]);
        });
        style.fill = {
            fill: gradientFill
        };
    }
}
;
 //# sourceMappingURL=TextStyle.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getCanvasFillStyle",
    ()=>getCanvasFillStyle
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillGradient$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillPattern$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
"use strict";
const PRECISION = 1e5;
function getCanvasFillStyle(fillStyle, context, textMetrics, padding = 0) {
    if (fillStyle.texture === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].WHITE && !fillStyle.fill) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();
    } else if (!fillStyle.fill) {
        const pattern = context.createPattern(fillStyle.texture.source.resource, "repeat");
        const tempMatrix = fillStyle.matrix.copyTo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"].shared);
        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);
        pattern.setTransform(tempMatrix);
        return pattern;
    } else if (fillStyle.fill instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillPattern$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FillPattern"]) {
        const fillPattern = fillStyle.fill;
        const pattern = context.createPattern(fillPattern.texture.source.resource, "repeat");
        const tempMatrix = fillPattern.transform.copyTo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"].shared);
        tempMatrix.scale(fillPattern.texture.frame.width, fillPattern.texture.frame.height);
        pattern.setTransform(tempMatrix);
        return pattern;
    } else if (fillStyle.fill instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$fill$2f$FillGradient$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FillGradient"]) {
        const fillGradient = fillStyle.fill;
        const isLinear = fillGradient.type === "linear";
        const isLocal = fillGradient.textureSpace === "local";
        let width = 1;
        let height = 1;
        if (isLocal && textMetrics) {
            width = textMetrics.width + padding;
            height = textMetrics.height + padding;
        }
        let gradient;
        let isNearlyVertical = false;
        if (isLinear) {
            const { start, end } = fillGradient;
            gradient = context.createLinearGradient(start.x * width, start.y * height, end.x * width, end.y * height);
            isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);
        } else {
            const { center, innerRadius, outerCenter, outerRadius } = fillGradient;
            gradient = context.createRadialGradient(center.x * width, center.y * height, innerRadius * width, outerCenter.x * width, outerCenter.y * height, outerRadius * width);
        }
        if (isNearlyVertical && isLocal && textMetrics) {
            const ratio = textMetrics.lineHeight / height;
            for(let i = 0; i < textMetrics.lines.length; i++){
                const start = (i * textMetrics.lineHeight + padding / 2) / height;
                fillGradient.colorStops.forEach((stop)=>{
                    const globalStop = start + stop.offset * ratio;
                    gradient.addColorStop(// fix to 5 decimal places to avoid floating point precision issues
                    Math.floor(globalStop * PRECISION) / PRECISION, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(stop.color).toHex());
                });
            }
        } else {
            fillGradient.colorStops.forEach((stop)=>{
                gradient.addColorStop(stop.offset, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(stop.color).toHex());
            });
        }
        return gradient;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("FillStyle not recognised", fillStyle);
    return "red";
}
;
 //# sourceMappingURL=getCanvasFillStyle.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DynamicBitmapFont",
    ()=>DynamicBitmapFont
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$CanvasPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$ImageSource$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$utils$2f$fontStringFromTextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$utils$2f$getCanvasFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/TextStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$AbstractBitmapFont$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
"use strict";
const _DynamicBitmapFont = class _DynamicBitmapFont extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$AbstractBitmapFont$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AbstractBitmapFont"] {
    /**
   * @param options - The options for the dynamic bitmap font.
   */ constructor(options){
        super();
        /**
     * this is a resolution modifier for the font size..
     * texture resolution will also be used to scale texture according to its font size also
     */ this.resolution = 1;
        /** The pages of the font. */ this.pages = [];
        this._padding = 0;
        this._measureCache = /* @__PURE__ */ Object.create(null);
        this._currentChars = [];
        this._currentX = 0;
        this._currentY = 0;
        this._currentMaxCharHeight = 0;
        this._currentPageIndex = -1;
        this._skipKerning = false;
        const dynamicOptions = {
            ..._DynamicBitmapFont.defaultOptions,
            ...options
        };
        this._textureSize = dynamicOptions.textureSize;
        this._mipmap = dynamicOptions.mipmap;
        const style = dynamicOptions.style.clone();
        if (dynamicOptions.overrideFill) {
            style._fill.color = 16777215;
            style._fill.alpha = 1;
            style._fill.texture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].WHITE;
            style._fill.fill = null;
        }
        this.applyFillAsTint = dynamicOptions.overrideFill;
        const requestedFontSize = style.fontSize;
        style.fontSize = this.baseMeasurementFontSize;
        const font = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$utils$2f$fontStringFromTextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fontStringFromTextStyle"])(style);
        if (dynamicOptions.overrideSize) {
            if (style._stroke) {
                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;
            }
        } else {
            style.fontSize = this.baseRenderedFontSize = requestedFontSize;
        }
        this._style = style;
        this._skipKerning = dynamicOptions.skipKerning ?? false;
        this.resolution = dynamicOptions.resolution ?? 1;
        this._padding = dynamicOptions.padding ?? 4;
        if (dynamicOptions.textureStyle) {
            this._textureStyle = dynamicOptions.textureStyle instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextureStyle"] ? dynamicOptions.textureStyle : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextureStyle"](dynamicOptions.textureStyle);
        }
        this.fontMetrics = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].measureFont(font);
        this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
    }
    ensureCharacters(chars) {
        const charList = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].graphemeSegmenter(chars).filter((char)=>!this._currentChars.includes(char)).filter((char, index, self)=>self.indexOf(char) === index);
        if (!charList.length) return;
        this._currentChars = [
            ...this._currentChars,
            ...charList
        ];
        let pageData;
        if (this._currentPageIndex === -1) {
            pageData = this._nextPage();
        } else {
            pageData = this.pages[this._currentPageIndex];
        }
        let { canvas, context } = pageData.canvasAndContext;
        let textureSource = pageData.texture.source;
        const style = this._style;
        let currentX = this._currentX;
        let currentY = this._currentY;
        let currentMaxCharHeight = this._currentMaxCharHeight;
        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
        const padding = this._padding * fontScale;
        let skipTexture = false;
        const maxTextureWidth = canvas.width / this.resolution;
        const maxTextureHeight = canvas.height / this.resolution;
        for(let i = 0; i < charList.length; i++){
            const char = charList[i];
            const metrics = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].measureText(char, style, canvas, false);
            metrics.lineHeight = metrics.height;
            const width = metrics.width * fontScale;
            const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
            const height = metrics.height * fontScale;
            const paddedWidth = textureGlyphWidth + padding * 2;
            const paddedHeight = height + padding * 2;
            skipTexture = false;
            if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
                skipTexture = true;
                currentMaxCharHeight = Math.ceil(Math.max(paddedHeight, currentMaxCharHeight));
            }
            if (currentX + paddedWidth > maxTextureWidth) {
                currentY += currentMaxCharHeight;
                currentMaxCharHeight = paddedHeight;
                currentX = 0;
                if (currentY + currentMaxCharHeight > maxTextureHeight) {
                    textureSource.update();
                    const pageData2 = this._nextPage();
                    canvas = pageData2.canvasAndContext.canvas;
                    context = pageData2.canvasAndContext.context;
                    textureSource = pageData2.texture.source;
                    currentX = 0;
                    currentY = 0;
                    currentMaxCharHeight = 0;
                }
            }
            const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
            this.chars[char] = {
                id: char.codePointAt(0),
                xOffset: -this._padding,
                yOffset: -this._padding,
                xAdvance,
                kerning: {}
            };
            if (skipTexture) {
                this._drawGlyph(context, metrics, currentX + padding, currentY + padding, fontScale, style);
                const px = textureSource.width * fontScale;
                const py = textureSource.height * fontScale;
                const frame = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"](currentX / px * textureSource.width, currentY / py * textureSource.height, paddedWidth / px * textureSource.width, paddedHeight / py * textureSource.height);
                this.chars[char].texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]({
                    source: textureSource,
                    frame
                });
                currentX += Math.ceil(paddedWidth);
            }
        }
        textureSource.update();
        this._currentX = currentX;
        this._currentY = currentY;
        this._currentMaxCharHeight = currentMaxCharHeight;
        this._skipKerning && this._applyKerning(charList, context);
    }
    /**
   * @deprecated since 8.0.0
   * The map of base page textures (i.e., sheets of glyphs).
   */ get pageTextures() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
        return this.pages;
    }
    _applyKerning(newChars, context) {
        const measureCache = this._measureCache;
        for(let i = 0; i < newChars.length; i++){
            const first = newChars[i];
            for(let j = 0; j < this._currentChars.length; j++){
                const second = this._currentChars[j];
                let c1 = measureCache[first];
                if (!c1) c1 = measureCache[first] = context.measureText(first).width;
                let c2 = measureCache[second];
                if (!c2) c2 = measureCache[second] = context.measureText(second).width;
                let total = context.measureText(first + second).width;
                let amount = total - (c1 + c2);
                if (amount) {
                    this.chars[first].kerning[second] = amount;
                }
                total = context.measureText(first + second).width;
                amount = total - (c1 + c2);
                if (amount) {
                    this.chars[second].kerning[first] = amount;
                }
            }
        }
    }
    _nextPage() {
        this._currentPageIndex++;
        const textureResolution = this.resolution;
        const canvasAndContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$CanvasPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasPool"].getOptimalCanvasAndContext(this._textureSize, this._textureSize, textureResolution);
        this._setupContext(canvasAndContext.context, this._style, textureResolution);
        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
        const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]({
            source: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$ImageSource$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ImageSource"]({
                resource: canvasAndContext.canvas,
                resolution,
                alphaMode: "premultiply-alpha-on-upload",
                autoGenerateMipmaps: this._mipmap
            })
        });
        if (this._textureStyle) {
            texture.source.style = this._textureStyle;
        }
        const pageData = {
            canvasAndContext,
            texture
        };
        this.pages[this._currentPageIndex] = pageData;
        return pageData;
    }
    // canvas style!
    _setupContext(context, style, resolution) {
        style.fontSize = this.baseRenderedFontSize;
        context.scale(resolution, resolution);
        context.font = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$utils$2f$fontStringFromTextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fontStringFromTextStyle"])(style);
        style.fontSize = this.baseMeasurementFontSize;
        context.textBaseline = style.textBaseline;
        const stroke = style._stroke;
        const strokeThickness = stroke?.width ?? 0;
        if (stroke) {
            context.lineWidth = strokeThickness;
            context.lineJoin = stroke.join;
            context.miterLimit = stroke.miterLimit;
            context.strokeStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$utils$2f$getCanvasFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCanvasFillStyle"])(stroke, context);
        }
        if (style._fill) {
            context.fillStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$utils$2f$getCanvasFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCanvasFillStyle"])(style._fill, context);
        }
        if (style.dropShadow) {
            const shadowOptions = style.dropShadow;
            const rgb = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(shadowOptions.color).toArray();
            const dropShadowBlur = shadowOptions.blur * resolution;
            const dropShadowDistance = shadowOptions.distance * resolution;
            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
            context.shadowBlur = dropShadowBlur;
            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
        } else {
            context.shadowColor = "black";
            context.shadowBlur = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
        }
    }
    _drawGlyph(context, metrics, x, y, fontScale, style) {
        const char = metrics.text;
        const fontProperties = metrics.fontProperties;
        const stroke = style._stroke;
        const strokeThickness = (stroke?.width ?? 0) * fontScale;
        const tx = x + strokeThickness / 2;
        const ty = y - strokeThickness / 2;
        const descent = fontProperties.descent * fontScale;
        const lineHeight = metrics.lineHeight * fontScale;
        let removeShadow = false;
        if (style.stroke && strokeThickness) {
            removeShadow = true;
            context.strokeText(char, tx, ty + lineHeight - descent);
        }
        const { shadowBlur, shadowOffsetX, shadowOffsetY } = context;
        if (style._fill) {
            if (removeShadow) {
                context.shadowBlur = 0;
                context.shadowOffsetX = 0;
                context.shadowOffsetY = 0;
            }
            context.fillText(char, tx, ty + lineHeight - descent);
        }
        if (removeShadow) {
            context.shadowBlur = shadowBlur;
            context.shadowOffsetX = shadowOffsetX;
            context.shadowOffsetY = shadowOffsetY;
        }
    }
    destroy() {
        super.destroy();
        for(let i = 0; i < this.pages.length; i++){
            const { canvasAndContext, texture } = this.pages[i];
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$CanvasPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasPool"].returnCanvasAndContext(canvasAndContext);
            texture.destroy(true);
        }
        this.pages = null;
    }
};
_DynamicBitmapFont.defaultOptions = {
    textureSize: 512,
    style: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextStyle"](),
    mipmap: true
};
let DynamicBitmapFont = _DynamicBitmapFont;
;
 //# sourceMappingURL=DynamicBitmapFont.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getBitmapTextLayout",
    ()=>getBitmapTextLayout
]);
"use strict";
function getBitmapTextLayout(chars, style, font, trimEnd) {
    const layoutData = {
        width: 0,
        height: 0,
        offsetY: 0,
        scale: style.fontSize / font.baseMeasurementFontSize,
        lines: [
            {
                width: 0,
                charPositions: [],
                spaceWidth: 0,
                spacesIndex: [],
                chars: []
            }
        ]
    };
    layoutData.offsetY = font.baseLineOffset;
    let currentLine = layoutData.lines[0];
    let previousChar = null;
    let firstWord = true;
    const currentWord = {
        spaceWord: false,
        width: 0,
        start: 0,
        index: 0,
        // use index to not modify the array as we use it a lot!
        positions: [],
        chars: []
    };
    const scale = font.baseMeasurementFontSize / style.fontSize;
    const adjustedLetterSpacing = style.letterSpacing * scale;
    const adjustedWordWrapWidth = style.wordWrapWidth * scale;
    const adjustedLineHeight = style.lineHeight ? style.lineHeight * scale : font.lineHeight;
    const breakWords = style.wordWrap && style.breakWords;
    const nextWord = (word)=>{
        const start = currentLine.width;
        for(let j = 0; j < currentWord.index; j++){
            const position = word.positions[j];
            currentLine.chars.push(word.chars[j]);
            currentLine.charPositions.push(position + start);
        }
        currentLine.width += word.width;
        firstWord = false;
        currentWord.width = 0;
        currentWord.index = 0;
        currentWord.chars.length = 0;
    };
    const nextLine = ()=>{
        let index = currentLine.chars.length - 1;
        if (trimEnd) {
            let lastChar = currentLine.chars[index];
            while(lastChar === " "){
                currentLine.width -= font.chars[lastChar].xAdvance;
                lastChar = currentLine.chars[--index];
            }
        }
        layoutData.width = Math.max(layoutData.width, currentLine.width);
        currentLine = {
            width: 0,
            charPositions: [],
            chars: [],
            spaceWidth: 0,
            spacesIndex: []
        };
        firstWord = true;
        layoutData.lines.push(currentLine);
        layoutData.height += adjustedLineHeight;
    };
    const checkIsOverflow = (lineWidth)=>lineWidth - adjustedLetterSpacing > adjustedWordWrapWidth;
    for(let i = 0; i < chars.length + 1; i++){
        let char;
        const isEnd = i === chars.length;
        if (!isEnd) {
            char = chars[i];
        }
        const charData = font.chars[char] || font.chars[" "];
        const isSpace = /(?:\s)/.test(char);
        const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
        if (isWordBreak) {
            const addWordToNextLine = !firstWord && style.wordWrap && checkIsOverflow(currentLine.width + currentWord.width);
            if (addWordToNextLine) {
                nextLine();
                nextWord(currentWord);
                if (!isEnd) {
                    currentLine.charPositions.push(0);
                }
            } else {
                currentWord.start = currentLine.width;
                nextWord(currentWord);
                if (!isEnd) {
                    currentLine.charPositions.push(0);
                }
            }
            if (char === "\r" || char === "\n") {
                nextLine();
            } else if (!isEnd) {
                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
                currentLine.width += spaceWidth;
                currentLine.spaceWidth = spaceWidth;
                currentLine.spacesIndex.push(currentLine.charPositions.length);
                currentLine.chars.push(char);
            }
        } else {
            const kerning = charData.kerning[previousChar] || 0;
            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
            const addWordToNextLine = breakWords && checkIsOverflow(currentLine.width + currentWord.width + nextCharWidth);
            if (addWordToNextLine) {
                nextWord(currentWord);
                nextLine();
            }
            currentWord.positions[currentWord.index++] = currentWord.width + kerning;
            currentWord.chars.push(char);
            currentWord.width += nextCharWidth;
        }
        previousChar = char;
    }
    nextLine();
    if (style.align === "center") {
        alignCenter(layoutData);
    } else if (style.align === "right") {
        alignRight(layoutData);
    } else if (style.align === "justify") {
        alignJustify(layoutData);
    }
    return layoutData;
}
function alignCenter(measurementData) {
    for(let i = 0; i < measurementData.lines.length; i++){
        const line = measurementData.lines[i];
        const offset = measurementData.width / 2 - line.width / 2;
        for(let j = 0; j < line.charPositions.length; j++){
            line.charPositions[j] += offset;
        }
    }
}
function alignRight(measurementData) {
    for(let i = 0; i < measurementData.lines.length; i++){
        const line = measurementData.lines[i];
        const offset = measurementData.width - line.width;
        for(let j = 0; j < line.charPositions.length; j++){
            line.charPositions[j] += offset;
        }
    }
}
function alignJustify(measurementData) {
    const width = measurementData.width;
    for(let i = 0; i < measurementData.lines.length; i++){
        const line = measurementData.lines[i];
        let indy = 0;
        let spaceIndex = line.spacesIndex[indy++];
        let offset = 0;
        const totalSpaces = line.spacesIndex.length;
        const newSpaceWidth = (width - line.width) / totalSpaces;
        const spaceWidth = newSpaceWidth;
        for(let j = 0; j < line.charPositions.length; j++){
            if (j === spaceIndex) {
                spaceIndex = line.spacesIndex[indy++];
                offset += spaceWidth;
            }
            line.charPositions[j] += offset;
        }
    }
}
;
 //# sourceMappingURL=getBitmapTextLayout.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "resolveCharacters",
    ()=>resolveCharacters
]);
"use strict";
function resolveCharacters(chars) {
    if (chars === "") {
        return [];
    }
    if (typeof chars === "string") {
        chars = [
            chars
        ];
    }
    const result = [];
    for(let i = 0, j = chars.length; i < j; i++){
        const item = chars[i];
        if (Array.isArray(item)) {
            if (item.length !== 2) {
                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
            }
            if (item[0].length === 0 || item[1].length === 0) {
                throw new Error("[BitmapFont]: Invalid character delimiter.");
            }
            const startCode = item[0].charCodeAt(0);
            const endCode = item[1].charCodeAt(0);
            if (endCode < startCode) {
                throw new Error("[BitmapFont]: Invalid character range.");
            }
            for(let i2 = startCode, j2 = endCode; i2 <= j2; i2++){
                result.push(String.fromCharCode(i2));
            }
        } else {
            result.push(...Array.from(item));
        }
    }
    if (result.length === 0) {
        throw new Error("[BitmapFont]: Empty set when resolving characters.");
    }
    return result;
}
;
 //# sourceMappingURL=resolveCharacters.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BitmapFontManager",
    ()=>BitmapFontManager
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$lru$2f$dist$2f$tiny$2d$lru$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tiny-lru/dist/tiny-lru.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/cache/Cache.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/TextStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$DynamicBitmapFont$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$utils$2f$getBitmapTextLayout$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$utils$2f$resolveCharacters$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
"use strict";
let fontCount = 0;
class BitmapFontManagerClass {
    constructor(){
        /**
     * This character set includes all the letters in the alphabet (both lower- and upper- case).
     * @type {string[][]}
     * @example
     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })
     */ this.ALPHA = [
            [
                "a",
                "z"
            ],
            [
                "A",
                "Z"
            ],
            " "
        ];
        /**
     * This character set includes all decimal digits (from 0 to 9).
     * @type {string[][]}
     * @example
     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })
     */ this.NUMERIC = [
            [
                "0",
                "9"
            ]
        ];
        /**
     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.
     * @type {string[][]}
     */ this.ALPHANUMERIC = [
            [
                "a",
                "z"
            ],
            [
                "A",
                "Z"
            ],
            [
                "0",
                "9"
            ],
            " "
        ];
        /**
     * This character set consists of all the ASCII table.
     * @type {string[][]}
     * @see http://www.asciitable.com/
     */ this.ASCII = [
            [
                " ",
                "~"
            ]
        ];
        /** Default options for installing a new BitmapFont. */ this.defaultOptions = {
            chars: this.ALPHANUMERIC,
            resolution: 1,
            padding: 4,
            skipKerning: false,
            textureStyle: null
        };
        /** Cache for measured text layouts to avoid recalculating them multiple times. */ this.measureCache = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$lru$2f$dist$2f$tiny$2d$lru$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lru"])(1e3);
    }
    /**
   * Get a font for the specified text and style.
   * @param text - The text to get the font for
   * @param style - The style to use
   */ getFont(text, style) {
        let fontFamilyKey = `${style.fontFamily}-bitmap`;
        let overrideFill = true;
        if (style._fill.fill && !style._stroke) {
            fontFamilyKey += style._fill.fill.styleKey;
            overrideFill = false;
        } else if (style._stroke || style.dropShadow) {
            fontFamilyKey = `${style.styleKey}-bitmap`;
            overrideFill = false;
        }
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Cache"].has(fontFamilyKey)) {
            const styleCopy = Object.create(style);
            styleCopy.lineHeight = 0;
            const fnt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$DynamicBitmapFont$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DynamicBitmapFont"]({
                style: styleCopy,
                overrideFill,
                overrideSize: true,
                ...this.defaultOptions
            });
            fontCount++;
            if (fontCount > 50) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``);
            }
            fnt.once("destroy", ()=>{
                fontCount--;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Cache"].remove(fontFamilyKey);
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Cache"].set(fontFamilyKey, fnt);
        }
        const dynamicFont = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Cache"].get(fontFamilyKey);
        dynamicFont.ensureCharacters?.(text);
        return dynamicFont;
    }
    /**
   * Get the layout of a text for the specified style.
   * @param text - The text to get the layout for
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */ getLayout(text, style, trimEnd = true) {
        const bitmapFont = this.getFont(text, style);
        const id = `${text}-${style.styleKey}-${trimEnd}`;
        if (this.measureCache.has(id)) {
            return this.measureCache.get(id);
        }
        const segments = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].graphemeSegmenter(text);
        const layoutData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$utils$2f$getBitmapTextLayout$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getBitmapTextLayout"])(segments, style, bitmapFont, trimEnd);
        this.measureCache.set(id, layoutData);
        return layoutData;
    }
    /**
   * Measure the text using the specified style.
   * @param text - The text to measure
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */ measureText(text, style, trimEnd = true) {
        return this.getLayout(text, style, trimEnd);
    }
    // eslint-disable-next-line max-len
    install(...args) {
        let options = args[0];
        if (typeof options === "string") {
            options = {
                name: options,
                style: args[1],
                chars: args[2]?.chars,
                resolution: args[2]?.resolution,
                padding: args[2]?.padding,
                skipKerning: args[2]?.skipKerning
            };
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");
        }
        const name = options?.name;
        if (!name) {
            throw new Error("[BitmapFontManager] Property `name` is required.");
        }
        options = {
            ...this.defaultOptions,
            ...options
        };
        const textStyle = options.style;
        const style = textStyle instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextStyle"] ? textStyle : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextStyle"](textStyle);
        const overrideFill = options.dynamicFill ?? this._canUseTintForStyle(style);
        const font = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$DynamicBitmapFont$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DynamicBitmapFont"]({
            style,
            overrideFill,
            skipKerning: options.skipKerning,
            padding: options.padding,
            resolution: options.resolution,
            overrideSize: false,
            textureStyle: options.textureStyle
        });
        const flatChars = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$utils$2f$resolveCharacters$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resolveCharacters"])(options.chars);
        font.ensureCharacters(flatChars.join(""));
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Cache"].set(`${name}-bitmap`, font);
        font.once("destroy", ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Cache"].remove(`${name}-bitmap`));
        return font;
    }
    /**
   * Uninstalls a bitmap font from the cache.
   * @param {string} name - The name of the bitmap font to uninstall.
   */ uninstall(name) {
        const cacheKey = `${name}-bitmap`;
        const font = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Cache"].get(cacheKey);
        if (font) {
            font.destroy();
        }
    }
    /**
   * Determines if a style can use tinting instead of baking colors into the bitmap.
   * Tinting is more efficient as it allows reusing the same bitmap with different colors.
   * @param style - The text style to evaluate
   * @returns true if the style can use tinting, false if colors must be baked in
   * @private
   */ _canUseTintForStyle(style) {
        return !style._stroke && (!style.dropShadow || style.dropShadow.color === 0) && !style._fill.fill && style._fill.color === 16777215;
    }
}
const BitmapFontManager = new BitmapFontManagerClass();
;
 //# sourceMappingURL=BitmapFontManager.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BitmapFont",
    ()=>BitmapFont
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$groupD8$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/groupD8.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$AbstractBitmapFont$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapFontManager$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
"use strict";
class BitmapFont extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$AbstractBitmapFont$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AbstractBitmapFont"] {
    constructor(options, url){
        super();
        const { textures, data } = options;
        Object.keys(data.pages).forEach((key)=>{
            const pageData = data.pages[parseInt(key, 10)];
            const texture = textures[pageData.id];
            this.pages.push({
                texture
            });
        });
        Object.keys(data.chars).forEach((key)=>{
            const charData = data.chars[key];
            const { frame: textureFrame, source: textureSource, rotate: textureRotate } = textures[charData.page];
            const frame = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$groupD8$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["groupD8"].transformRectCoords(charData, textureFrame, textureRotate, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"]());
            const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]({
                frame,
                orig: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"](0, 0, charData.width, charData.height),
                source: textureSource,
                rotate: textureRotate
            });
            this.chars[key] = {
                id: key.codePointAt(0),
                xOffset: charData.xOffset,
                yOffset: charData.yOffset,
                xAdvance: charData.xAdvance,
                kerning: charData.kerning ?? {},
                texture
            };
        });
        this.baseRenderedFontSize = data.fontSize;
        this.baseMeasurementFontSize = data.fontSize;
        this.fontMetrics = {
            ascent: 0,
            descent: 0,
            fontSize: data.fontSize
        };
        this.baseLineOffset = data.baseLineOffset;
        this.lineHeight = data.lineHeight;
        this.fontFamily = data.fontFamily;
        this.distanceField = data.distanceField ?? {
            type: "none",
            range: 0
        };
        this.url = url;
    }
    /** Destroys the BitmapFont object. */ destroy() {
        super.destroy();
        for(let i = 0; i < this.pages.length; i++){
            const { texture } = this.pages[i];
            texture.destroy(true);
        }
        this.pages = null;
    }
    /**
   * Generates and installs a bitmap font with the specified options.
   * The font will be cached and available for use in BitmapText objects.
   * @param options - Setup options for font generation
   * @returns Installed font instance
   * @example
   * ```ts
   * // Install a basic font
   * BitmapFont.install({
   *     name: 'Title',
   *     style: {
   *         fontFamily: 'Arial',
   *         fontSize: 32,
   *         fill: '#ffffff'
   *     }
   * });
   *
   * // Install with advanced options
   * BitmapFont.install({
   *     name: 'Custom',
   *     style: {
   *         fontFamily: 'Arial',
   *         fontSize: 24,
   *         fill: '#00ff00',
   *         stroke: { color: '#000000', width: 2 }
   *     },
   *     chars: [['a', 'z'], ['A', 'Z'], ['0', '9']],
   *     resolution: 2,
   *     padding: 4,
   *     textureStyle: {
   *         scaleMode: 'nearest'
   *     }
   * });
   * ```
   */ static install(options) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapFontManager$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BitmapFontManager"].install(options);
    }
    /**
   * Uninstalls a bitmap font from the cache.
   * This frees up memory and resources associated with the font.
   * @param name - The name of the bitmap font to uninstall
   * @example
   * ```ts
   * // Remove a font when it's no longer needed
   * BitmapFont.uninstall('MyCustomFont');
   *
   * // Clear multiple fonts
   * ['Title', 'Heading', 'Body'].forEach(BitmapFont.uninstall);
   * ```
   */ static uninstall(name) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapFontManager$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BitmapFontManager"].uninstall(name);
    }
}
;
 //# sourceMappingURL=BitmapFont.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bitmapFontTextParser",
    ()=>bitmapFontTextParser
]);
"use strict";
const bitmapFontTextParser = {
    test (data) {
        return typeof data === "string" && data.startsWith("info face=");
    },
    parse (txt) {
        const items = txt.match(/^[a-z]+\s+.+$/gm);
        const rawData = {
            info: [],
            common: [],
            page: [],
            char: [],
            chars: [],
            kerning: [],
            kernings: [],
            distanceField: []
        };
        for(const i in items){
            const name = items[i].match(/^[a-z]+/gm)[0];
            const attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
            const itemData = {};
            for(const i2 in attributeList){
                const split = attributeList[i2].split("=");
                const key = split[0];
                const strValue = split[1].replace(/"/gm, "");
                const floatValue = parseFloat(strValue);
                const value = isNaN(floatValue) ? strValue : floatValue;
                itemData[key] = value;
            }
            rawData[name].push(itemData);
        }
        const font = {
            chars: {},
            pages: [],
            lineHeight: 0,
            fontSize: 0,
            fontFamily: "",
            distanceField: null,
            baseLineOffset: 0
        };
        const [info] = rawData.info;
        const [common] = rawData.common;
        const [distanceField] = rawData.distanceField ?? [];
        if (distanceField) {
            font.distanceField = {
                range: parseInt(distanceField.distanceRange, 10),
                type: distanceField.fieldType
            };
        }
        font.fontSize = parseInt(info.size, 10);
        font.fontFamily = info.face;
        font.lineHeight = parseInt(common.lineHeight, 10);
        const page = rawData.page;
        for(let i = 0; i < page.length; i++){
            font.pages.push({
                id: parseInt(page[i].id, 10) || 0,
                file: page[i].file
            });
        }
        const map = {};
        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
        const char = rawData.char;
        for(let i = 0; i < char.length; i++){
            const charNode = char[i];
            const id = parseInt(charNode.id, 10);
            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);
            if (letter === "space") letter = " ";
            map[id] = letter;
            font.chars[letter] = {
                id,
                // texture deets..
                page: parseInt(charNode.page, 10) || 0,
                x: parseInt(charNode.x, 10),
                y: parseInt(charNode.y, 10),
                width: parseInt(charNode.width, 10),
                height: parseInt(charNode.height, 10),
                xOffset: parseInt(charNode.xoffset, 10),
                yOffset: parseInt(charNode.yoffset, 10),
                xAdvance: parseInt(charNode.xadvance, 10),
                kerning: {}
            };
        }
        const kerning = rawData.kerning || [];
        for(let i = 0; i < kerning.length; i++){
            const first = parseInt(kerning[i].first, 10);
            const second = parseInt(kerning[i].second, 10);
            const amount = parseInt(kerning[i].amount, 10);
            font.chars[map[second]].kerning[map[first]] = amount;
        }
        return font;
    }
};
;
 //# sourceMappingURL=bitmapFontTextParser.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bitmapFontXMLParser",
    ()=>bitmapFontXMLParser
]);
"use strict";
const bitmapFontXMLParser = {
    test (data) {
        const xml = data;
        return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
    },
    parse (xml) {
        const data = {
            chars: {},
            pages: [],
            lineHeight: 0,
            fontSize: 0,
            fontFamily: "",
            distanceField: null,
            baseLineOffset: 0
        };
        const info = xml.getElementsByTagName("info")[0];
        const common = xml.getElementsByTagName("common")[0];
        const distanceField = xml.getElementsByTagName("distanceField")[0];
        if (distanceField) {
            data.distanceField = {
                type: distanceField.getAttribute("fieldType"),
                range: parseInt(distanceField.getAttribute("distanceRange"), 10)
            };
        }
        const page = xml.getElementsByTagName("page");
        const char = xml.getElementsByTagName("char");
        const kerning = xml.getElementsByTagName("kerning");
        data.fontSize = parseInt(info.getAttribute("size"), 10);
        data.fontFamily = info.getAttribute("face");
        data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
        for(let i = 0; i < page.length; i++){
            data.pages.push({
                id: parseInt(page[i].getAttribute("id"), 10) || 0,
                file: page[i].getAttribute("file")
            });
        }
        const map = {};
        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
        for(let i = 0; i < char.length; i++){
            const charNode = char[i];
            const id = parseInt(charNode.getAttribute("id"), 10);
            let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id);
            if (letter === "space") letter = " ";
            map[id] = letter;
            data.chars[letter] = {
                id,
                // texture deets..
                page: parseInt(charNode.getAttribute("page"), 10) || 0,
                x: parseInt(charNode.getAttribute("x"), 10),
                y: parseInt(charNode.getAttribute("y"), 10),
                width: parseInt(charNode.getAttribute("width"), 10),
                height: parseInt(charNode.getAttribute("height"), 10),
                // render deets..
                xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
                yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
                // + baseLineOffset,
                xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
                kerning: {}
            };
        }
        for(let i = 0; i < kerning.length; i++){
            const first = parseInt(kerning[i].getAttribute("first"), 10);
            const second = parseInt(kerning[i].getAttribute("second"), 10);
            const amount = parseInt(kerning[i].getAttribute("amount"), 10);
            data.chars[map[second]].kerning[map[first]] = amount;
        }
        return data;
    }
};
;
 //# sourceMappingURL=bitmapFontXMLParser.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bitmapFontXMLStringParser",
    ()=>bitmapFontXMLStringParser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$asset$2f$bitmapFontXMLParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const bitmapFontXMLStringParser = {
    test (data) {
        if (typeof data === "string" && data.match(/<font(\s|>)/)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$asset$2f$bitmapFontXMLParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitmapFontXMLParser"].test(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DOMAdapter"].get().parseXML(data));
        }
        return false;
    },
    parse (data) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$asset$2f$bitmapFontXMLParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitmapFontXMLParser"].parse(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DOMAdapter"].get().parseXML(data));
    }
};
;
 //# sourceMappingURL=bitmapFontXMLStringParser.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bitmapFontCachePlugin",
    ()=>bitmapFontCachePlugin,
    "loadBitmapFont",
    ()=>loadBitmapFont
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$copySearchParams$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/path.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapFont$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$asset$2f$bitmapFontTextParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$asset$2f$bitmapFontXMLStringParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
"use strict";
const validExtensions = [
    ".xml",
    ".fnt"
];
const bitmapFontCachePlugin = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CacheParser,
        name: "cacheBitmapFont"
    },
    test: (asset)=>asset instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapFont$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BitmapFont"],
    getCacheableAssets (keys, asset) {
        const out = {};
        keys.forEach((key)=>{
            out[key] = asset;
            out[`${key}-bitmap`] = asset;
        });
        out[`${asset.fontFamily}-bitmap`] = asset;
        return out;
    }
};
const loadBitmapFont = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].LoadParser,
        priority: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LoaderParserPriority"].Normal
    },
    /** used for deprecation purposes */ name: "loadBitmapFont",
    id: "bitmap-font",
    test (url) {
        return validExtensions.includes(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["path"].extname(url).toLowerCase());
    },
    async testParse (data) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$asset$2f$bitmapFontTextParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitmapFontTextParser"].test(data) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$asset$2f$bitmapFontXMLStringParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitmapFontXMLStringParser"].test(data);
    },
    async parse (asset, data, loader) {
        const bitmapFontData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$asset$2f$bitmapFontTextParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitmapFontTextParser"].test(asset) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$asset$2f$bitmapFontTextParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitmapFontTextParser"].parse(asset) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$asset$2f$bitmapFontXMLStringParser$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitmapFontXMLStringParser"].parse(asset);
        const { src } = data;
        const { pages } = bitmapFontData;
        const textureUrls = [];
        const textureOptions = bitmapFontData.distanceField ? {
            scaleMode: "linear",
            alphaMode: "premultiply-alpha-on-upload",
            autoGenerateMipmaps: false,
            resolution: 1
        } : {};
        for(let i = 0; i < pages.length; ++i){
            const pageFile = pages[i].file;
            let imagePath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["path"].join(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["path"].dirname(src), pageFile);
            imagePath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$copySearchParams$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["copySearchParams"])(imagePath, src);
            textureUrls.push({
                src: imagePath,
                data: textureOptions
            });
        }
        const loadedTextures = await loader.load(textureUrls);
        const textures = textureUrls.map((url)=>loadedTextures[url.src]);
        const bitmapFont = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapFont$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BitmapFont"]({
            data: bitmapFontData,
            textures
        }, src);
        return bitmapFont;
    },
    async load (url, _options) {
        const response = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DOMAdapter"].get().fetch(url);
        return await response.text();
    },
    async unload (bitmapFont, _resolvedAsset, loader) {
        await Promise.all(bitmapFont.pages.map((page)=>loader.unload(page.texture.source._sourceOrigin)));
        bitmapFont.destroy();
    }
};
;
 //# sourceMappingURL=loadBitmapFont.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getGlobalRenderableBounds",
    ()=>getGlobalRenderableBounds
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const tempProjectionMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
function getGlobalRenderableBounds(renderables, bounds) {
    bounds.clear();
    const actualMatrix = bounds.matrix;
    for(let i = 0; i < renderables.length; i++){
        const renderable = renderables[i];
        if (renderable.globalDisplayStatus < 7) {
            continue;
        }
        const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
        if (renderGroup?.isCachedAsTexture) {
            bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform).append(renderable.worldTransform);
        } else if (renderGroup?._parentCacheAsTextureRenderGroup) {
            bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(renderable.groupTransform);
        } else {
            bounds.matrix = renderable.worldTransform;
        }
        bounds.addBounds(renderable.bounds);
    }
    bounds.matrix = actualMatrix;
    return bounds;
}
;
 //# sourceMappingURL=getRenderableBounds.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Graphics",
    ()=>Graphics
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/view/ViewContainer.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
class Graphics extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ViewContainer"] {
    /**
   * Creates a new Graphics object.
   * @param options - Options for the Graphics.
   */ constructor(options){
        if (options instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsContext"]) {
            options = {
                context: options
            };
        }
        const { context, roundPixels, ...rest } = options || {};
        super({
            label: "Graphics",
            ...rest
        });
        /** @internal */ this.renderPipeId = "graphics";
        if (!context) {
            this.context = this._ownedContext = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsContext"]();
            this.context.autoGarbageCollect = this.autoGarbageCollect;
        } else {
            this.context = context;
        }
        this.didViewUpdate = true;
        this.allowChildren = false;
        this.roundPixels = roundPixels ?? false;
    }
    set context(context) {
        if (context === this._context) return;
        if (this._context) {
            this._context.off("update", this.onViewUpdate, this);
            this._context.off("unload", this.unload, this);
        }
        this._context = context;
        this._context.on("update", this.onViewUpdate, this);
        this._context.on("unload", this.unload, this);
        this.onViewUpdate();
    }
    /**
   * The underlying graphics context used for drawing operations.
   * Controls how shapes and paths are rendered.
   * @example
   * ```ts
   * // Create a shared context
   * const sharedContext = new GraphicsContext();
   *
   * // Create graphics objects sharing the same context
   * const graphics1 = new Graphics();
   * const graphics2 = new Graphics();
   *
   * // Assign shared context
   * graphics1.context = sharedContext;
   * graphics2.context = sharedContext;
   *
   * // Both graphics will show the same shapes
   * sharedContext
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   * ```
   * @see {@link GraphicsContext} For drawing operations
   * @see {@link GraphicsOptions} For context configuration
   */ get context() {
        return this._context;
    }
    /**
   * The local bounds of the graphics object.
   * Returns the boundaries after all graphical operations but before any transforms.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw a shape
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   *
   * // Get bounds information
   * const bounds = graphics.bounds;
   * console.log(bounds.width);  // 100
   * console.log(bounds.height); // 100
   * ```
   * @readonly
   * @see {@link Bounds} For bounds operations
   * @see {@link Container#getBounds} For transformed bounds
   */ get bounds() {
        return this._context.bounds;
    }
    /**
   * Graphics objects do not need to update their bounds as the context handles this.
   * @private
   */ updateBounds() {}
    /**
   * Checks if the object contains the given point.
   * Returns true if the point lies within the Graphics object's rendered area.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw a shape
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   *
   * // Check point intersection
   * if (graphics.containsPoint({ x: 50, y: 50 })) {
   *     console.log('Point is inside rectangle!');
   * }
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is inside the Graphics object
   * @see {@link Graphics#bounds} For bounding box checks
   * @see {@link PointData} For point data structure
   */ containsPoint(point) {
        return this._context.containsPoint(point);
    }
    /**
   * Destroys this graphics renderable and optionally its context.
   * @param options - Options parameter. A boolean will act as if all options
   *
   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
   * then the context will still be destroyed.
   *
   * If you want to explicitly not destroy this context that this graphics created,
   * then you should pass destroy({ context: false })
   *
   * If the context was passed in as an argument to the constructor then it will not be destroyed
   * @example
   * ```ts
   * // Destroy the graphics and its context
   * graphics.destroy();
   * graphics.destroy(true);
   * graphics.destroy({ context: true, texture: true, textureSource: true });
   * ```
   */ destroy(options) {
        if (this._ownedContext && !options) {
            this._ownedContext.destroy(options);
        } else if (options === true || options?.context === true) {
            this._context.destroy(options);
        }
        this._ownedContext = null;
        this._context = null;
        super.destroy(options);
    }
    /**
   * @param now - The current time in milliseconds.
   * @internal
   */ _onTouch(now) {
        this._gcLastUsed = now;
        this._context._gcLastUsed = now;
    }
    _callContextMethod(method, args) {
        this.context[method](...args);
        return this;
    }
    // --------------------------------------- GraphicsContext methods ---------------------------------------
    /**
   * Sets the current fill style of the graphics context.
   * The fill style can be a color, gradient, pattern, or a complex style object.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color fill
   * graphics
   *     .setFillStyle({ color: 0xff0000 }) // Red fill
   *     .rect(0, 0, 100, 100)
   *     .fill();
   *
   * // Gradient fill
   * const gradient = new FillGradient({
   *    end: { x: 1, y: 0 },
   *    colorStops: [
   *         { offset: 0, color: 0xff0000 }, // Red at start
   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
   *         { offset: 1, color: 0x0000ff }, // Blue at end
   *    ],
   * });
   *
   * graphics
   *     .setFillStyle(gradient)
   *     .circle(100, 100, 50)
   *     .fill();
   *
   * // Pattern fill
   * const pattern = new FillPattern(texture);
   * graphics
   *     .setFillStyle({
   *         fill: pattern,
   *         alpha: 0.5
   *     })
   *     .rect(0, 0, 200, 200)
   *     .fill();
   * ```
   * @param {FillInput} args - The fill style to apply
   * @returns The Graphics instance for chaining
   * @see {@link FillStyle} For fill style options
   * @see {@link FillGradient} For gradient fills
   * @see {@link FillPattern} For pattern fills
   */ setFillStyle(...args) {
        return this._callContextMethod("setFillStyle", args);
    }
    /**
   * Sets the current stroke style of the graphics context.
   * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color stroke
   * graphics
   *     .setStrokeStyle({
   *         width: 2,
   *         color: 0x000000
   *     })
   *     .rect(0, 0, 100, 100)
   *     .stroke();
   *
   * // Complex stroke style
   * graphics
   *     .setStrokeStyle({
   *         width: 4,
   *         color: 0xff0000,
   *         alpha: 0.5,
   *         join: 'round',
   *         cap: 'round',
   *         alignment: 0.5
   *     })
   *     .circle(100, 100, 50)
   *     .stroke();
   *
   * // Gradient stroke
   * const gradient = new FillGradient({
   *    end: { x: 1, y: 0 },
   *    colorStops: [
   *         { offset: 0, color: 0xff0000 }, // Red at start
   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
   *         { offset: 1, color: 0x0000ff }, // Blue at end
   *    ],
   * });
   *
   * graphics
   *     .setStrokeStyle({
   *         width: 10,
   *         fill: gradient
   *     })
   *     .poly([0,0, 100,50, 0,100])
   *     .stroke();
   * ```
   * @param {StrokeInput} args - The stroke style to apply
   * @returns The Graphics instance for chaining
   * @see {@link StrokeStyle} For stroke style options
   * @see {@link FillGradient} For gradient strokes
   * @see {@link FillPattern} For pattern strokes
   */ setStrokeStyle(...args) {
        return this._callContextMethod("setStrokeStyle", args);
    }
    fill(...args) {
        return this._callContextMethod("fill", args);
    }
    /**
   * Strokes the current path with the current stroke style or specified style.
   * Outlines the shape using the stroke settings.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Stroke with direct color
   * graphics
   *     .circle(50, 50, 25)
   *     .stroke({
   *         width: 2,
   *         color: 0xff0000
   *     }); // 2px red stroke
   *
   * // Fill with texture
   * graphics
   *    .rect(0, 0, 100, 100)
   *    .stroke(myTexture); // Fill with texture
   *
   * // Stroke with gradient
   * const gradient = new FillGradient({
   *     end: { x: 1, y: 0 },
   *     colorStops: [
   *         { offset: 0, color: 0xff0000 },
   *         { offset: 0.5, color: 0x00ff00 },
   *         { offset: 1, color: 0x0000ff },
   *     ],
   * });
   *
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .stroke({
   *         width: 4,
   *         fill: gradient,
   *         alignment: 0.5,
   *         join: 'round'
   *     });
   * ```
   * @param {StrokeStyle} args - Optional stroke style to apply. Can be:
   * - A stroke style object with width, color, etc.
   * - A gradient
   * - A pattern
   * If omitted, uses current stroke style.
   * @returns The Graphics instance for chaining
   * @see {@link StrokeStyle} For stroke style options
   * @see {@link FillGradient} For gradient strokes
   * @see {@link setStrokeStyle} For setting default stroke style
   */ stroke(...args) {
        return this._callContextMethod("stroke", args);
    }
    texture(...args) {
        return this._callContextMethod("texture", args);
    }
    /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @example
   * ```ts
   * const graphics = new Graphics();
   * graphics
   *     .circle(150, 150, 50)
   *     .fill({ color: 0x00ff00 })
   *     .beginPath() // Starts a new path
   *     .circle(250, 150, 50)
   *     .fill({ color: 0x0000ff });
   * ```
   * @returns The Graphics instance for chaining
   * @see {@link Graphics#moveTo} For starting a new subpath
   * @see {@link Graphics#closePath} For closing the current path
   */ beginPath() {
        return this._callContextMethod("beginPath", []);
    }
    /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path.
   *
   * If a hole is not completely in a shape, it will fail to cut correctly.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw outer circle
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 });
   *     .circle(100, 100, 25) // Inner circle
   *     .cut() // Cuts out the inner circle from the outer circle
   * ```
   */ cut() {
        return this._callContextMethod("cut", []);
    }
    arc(...args) {
        return this._callContextMethod("arc", args);
    }
    arcTo(...args) {
        return this._callContextMethod("arcTo", args);
    }
    arcToSvg(...args) {
        return this._callContextMethod("arcToSvg", args);
    }
    bezierCurveTo(...args) {
        return this._callContextMethod("bezierCurveTo", args);
    }
    /**
   * Closes the current path by drawing a straight line back to the start point.
   *
   * This is useful for completing shapes and ensuring they are properly closed for fills.
   * @example
   * ```ts
   * // Create a triangle with closed path
   * const graphics = new Graphics();
   * graphics
   *     .moveTo(50, 50)
   *     .lineTo(100, 100)
   *     .lineTo(0, 100)
   *     .closePath()
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#beginPath} For starting a new path
   * @see {@link Graphics#fill} For filling closed paths
   * @see {@link Graphics#stroke} For stroking paths
   */ closePath() {
        return this._callContextMethod("closePath", []);
    }
    ellipse(...args) {
        return this._callContextMethod("ellipse", args);
    }
    circle(...args) {
        return this._callContextMethod("circle", args);
    }
    path(...args) {
        return this._callContextMethod("path", args);
    }
    lineTo(...args) {
        return this._callContextMethod("lineTo", args);
    }
    moveTo(...args) {
        return this._callContextMethod("moveTo", args);
    }
    quadraticCurveTo(...args) {
        return this._callContextMethod("quadraticCurveTo", args);
    }
    rect(...args) {
        return this._callContextMethod("rect", args);
    }
    roundRect(...args) {
        return this._callContextMethod("roundRect", args);
    }
    poly(...args) {
        return this._callContextMethod("poly", args);
    }
    regularPoly(...args) {
        return this._callContextMethod("regularPoly", args);
    }
    roundPoly(...args) {
        return this._callContextMethod("roundPoly", args);
    }
    roundShape(...args) {
        return this._callContextMethod("roundShape", args);
    }
    filletRect(...args) {
        return this._callContextMethod("filletRect", args);
    }
    chamferRect(...args) {
        return this._callContextMethod("chamferRect", args);
    }
    star(...args) {
        return this._callContextMethod("star", args);
    }
    svg(...args) {
        return this._callContextMethod("svg", args);
    }
    restore(...args) {
        return this._callContextMethod("restore", args);
    }
    /**
   * Saves the current graphics state onto a stack. The state includes:
   * - Current transformation matrix
   * - Current fill style
   * - Current stroke style
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Save state before complex operations
   * graphics.save();
   *
   * // Create transformed and styled shape
   * graphics
   *     .translateTransform(100, 100)
   *     .rotateTransform(Math.PI / 4)
   *     .setFillStyle({
   *         color: 0xff0000,
   *         alpha: 0.5
   *     })
   *     .rect(-25, -25, 50, 50)
   *     .fill();
   *
   * // Restore to original state
   * graphics.restore();
   *
   * // Continue drawing with previous state
   * graphics
   *     .circle(50, 50, 25)
   *     .fill();
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#restore} For restoring the saved state
   * @see {@link Graphics#setTransform} For setting transformations
   */ save() {
        return this._callContextMethod("save", []);
    }
    /**
   * Returns the current transformation matrix of the graphics context.
   * This matrix represents all accumulated transformations including translate, scale, and rotate.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Apply some transformations
   * graphics
   *     .translateTransform(100, 100)
   *     .rotateTransform(Math.PI / 4);
   *
   * // Get the current transform matrix
   * const matrix = graphics.getTransform();
   * console.log(matrix.tx, matrix.ty); // 100, 100
   *
   * // Use the matrix for other operations
   * graphics
   *     .setTransform(matrix)
   *     .circle(0, 0, 50)
   *     .fill({ color: 0xff0000 });
   * ```
   * @returns The current transformation matrix.
   * @see {@link Graphics#setTransform} For setting the transform matrix
   * @see {@link Matrix} For matrix operations
   */ getTransform() {
        return this.context.getTransform();
    }
    /**
   * Resets the current transformation matrix to the identity matrix, effectively removing
   * any transformations (rotation, scaling, translation) previously applied.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Apply transformations
   * graphics
   *     .translateTransform(100, 100)
   *     .scaleTransform(2, 2)
   *     .circle(0, 0, 25)
   *     .fill({ color: 0xff0000 });
   * // Reset transform to default state
   * graphics
   *     .resetTransform()
   *     .circle(50, 50, 25) // Will draw at actual coordinates
   *     .fill({ color: 0x00ff00 });
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#getTransform} For getting the current transform
   * @see {@link Graphics#setTransform} For setting a specific transform
   * @see {@link Graphics#save} For saving the current transform state
   * @see {@link Graphics#restore} For restoring a previous transform state
   */ resetTransform() {
        return this._callContextMethod("resetTransform", []);
    }
    rotateTransform(...args) {
        return this._callContextMethod("rotate", args);
    }
    scaleTransform(...args) {
        return this._callContextMethod("scale", args);
    }
    setTransform(...args) {
        return this._callContextMethod("setTransform", args);
    }
    transform(...args) {
        return this._callContextMethod("transform", args);
    }
    translateTransform(...args) {
        return this._callContextMethod("translate", args);
    }
    /**
   * Clears all drawing commands from the graphics context, effectively resetting it.
   * This includes clearing the current path, fill style, stroke style, and transformations.
   *
   * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.
   * > Instead, they are intended to be used for static or semi-static graphics that
   * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw some shapes
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 })
   *     .rect(200, 100, 100, 50)
   *     .fill({ color: 0x00ff00 });
   *
   * // Clear all graphics
   * graphics.clear();
   *
   * // Start fresh with new shapes
   * graphics
   *     .circle(150, 150, 30)
   *     .fill({ color: 0x0000ff });
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#beginPath} For starting a new path without clearing styles
   * @see {@link Graphics#save} For saving the current state
   * @see {@link Graphics#restore} For restoring a previous state
   */ clear() {
        return this._callContextMethod("clear", []);
    }
    /**
   * Gets or sets the current fill style for the graphics context. The fill style determines
   * how shapes are filled when using the fill() method.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color fill
   * graphics.fillStyle = {
   *     color: 0xff0000,  // Red
   *     alpha: 1
   * };
   *
   * // Using gradients
   * const gradient = new FillGradient({
   *     end: { x: 0, y: 1 }, // Vertical gradient
   *     stops: [
   *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color
   *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color
   *     ]
   * });
   *
   * graphics.fillStyle = {
   *     fill: gradient,
   *     alpha: 0.8
   * };
   *
   * // Using patterns
   * graphics.fillStyle = {
   *     texture: myTexture,
   *     alpha: 1,
   *     matrix: new Matrix()
   *         .scale(0.5, 0.5)
   *         .rotate(Math.PI / 4)
   * };
   * ```
   * @type {ConvertedFillStyle}
   * @see {@link FillStyle} For all available fill style options
   * @see {@link FillGradient} For creating gradient fills
   * @see {@link Graphics#fill} For applying the fill to paths
   */ get fillStyle() {
        return this._context.fillStyle;
    }
    set fillStyle(value) {
        this._context.fillStyle = value;
    }
    /**
   * Gets or sets the current stroke style for the graphics context. The stroke style determines
   * how paths are outlined when using the stroke() method.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic stroke style
   * graphics.strokeStyle = {
   *     width: 2,
   *     color: 0xff0000,
   *     alpha: 1
   * };
   *
   * // Using with gradients
   * const gradient = new FillGradient({
   *   end: { x: 0, y: 1 },
   *   stops: [
   *       { offset: 0, color: 0xff0000, alpha: 1 },
   *       { offset: 1, color: 0x0000ff, alpha: 1 }
   *   ]
   * });
   *
   * graphics.strokeStyle = {
   *     width: 4,
   *     fill: gradient,
   *     alignment: 0.5,
   *     join: 'round',
   *     cap: 'round'
   * };
   *
   * // Complex stroke settings
   * graphics.strokeStyle = {
   *     width: 6,
   *     color: 0x00ff00,
   *     alpha: 0.5,
   *     join: 'miter',
   *     miterLimit: 10,
   * };
   * ```
   * @see {@link StrokeStyle} For all available stroke style options
   * @see {@link Graphics#stroke} For applying the stroke to paths
   */ get strokeStyle() {
        return this._context.strokeStyle;
    }
    set strokeStyle(value) {
        this._context.strokeStyle = value;
    }
    /**
   * Creates a new Graphics object that copies the current graphics content.
   * The clone can either share the same context (shallow clone) or have its own independent
   * context (deep clone).
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Create original graphics content
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 });
   *
   * // Create a shallow clone (shared context)
   * const shallowClone = graphics.clone();
   *
   * // Changes to original affect the clone
   * graphics
   *     .circle(200, 100, 30)
   *     .fill({ color: 0x00ff00 });
   *
   * // Create a deep clone (independent context)
   * const deepClone = graphics.clone(true);
   *
   * // Modify deep clone independently
   * deepClone
   *     .translateTransform(100, 100)
   *     .circle(0, 0, 40)
   *     .fill({ color: 0x0000ff });
   * ```
   * @param deep - Whether to create a deep clone of the graphics object.
   *              If false (default), the context will be shared between objects.
   *              If true, creates an independent copy of the context.
   * @returns A new Graphics instance with either shared or copied context
   * @see {@link Graphics#context} For accessing the underlying graphics context
   * @see {@link GraphicsContext} For understanding the shared context behavior
   */ clone(deep = false) {
        if (deep) {
            return new Graphics(this._context.clone());
        }
        this._ownedContext = null;
        const clone = new Graphics(this._context);
        return clone;
    }
    // -------- v7 deprecations ---------
    /**
   * @param width
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
   */ lineStyle(width, color, alpha) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
        const strokeStyle = {};
        width && (strokeStyle.width = width);
        color && (strokeStyle.color = color);
        alpha && (strokeStyle.alpha = alpha);
        this.context.strokeStyle = strokeStyle;
        return this;
    }
    /**
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */ beginFill(color, alpha) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
        const fillStyle = {};
        if (color !== void 0) fillStyle.color = color;
        if (alpha !== void 0) fillStyle.alpha = alpha;
        this.context.fillStyle = fillStyle;
        return this;
    }
    /**
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */ endFill() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
        this.context.fill();
        const strokeStyle = this.context.strokeStyle;
        if (strokeStyle.width !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsContext"].defaultStrokeStyle.width || strokeStyle.color !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsContext"].defaultStrokeStyle.color || strokeStyle.alpha !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsContext"].defaultStrokeStyle.alpha) {
            this.context.stroke();
        }
        return this;
    }
    /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
   */ drawCircle(...args) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "Graphics#drawCircle has been renamed to Graphics#circle");
        return this._callContextMethod("circle", args);
    }
    /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
   */ drawEllipse(...args) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "Graphics#drawEllipse has been renamed to Graphics#ellipse");
        return this._callContextMethod("ellipse", args);
    }
    /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
   */ drawPolygon(...args) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "Graphics#drawPolygon has been renamed to Graphics#poly");
        return this._callContextMethod("poly", args);
    }
    /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
   */ drawRect(...args) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "Graphics#drawRect has been renamed to Graphics#rect");
        return this._callContextMethod("rect", args);
    }
    /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
   */ drawRoundedRect(...args) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
        return this._callContextMethod("roundRect", args);
    }
    /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#star} instead
   */ drawStar(...args) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "Graphics#drawStar has been renamed to Graphics#star");
        return this._callContextMethod("star", args);
    }
}
;
 //# sourceMappingURL=Graphics.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MeshGeometry",
    ()=>MeshGeometry
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$Buffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$Geometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
const _MeshGeometry = class _MeshGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$Geometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Geometry"] {
    constructor(...args){
        let options = args[0] ?? {};
        if (options instanceof Float32Array) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "use new MeshGeometry({ positions, uvs, indices }) instead");
            options = {
                positions: options,
                uvs: args[1],
                indices: args[2]
            };
        }
        options = {
            ..._MeshGeometry.defaultOptions,
            ...options
        };
        const positions = options.positions || new Float32Array([
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]);
        let uvs = options.uvs;
        if (!uvs) {
            if (options.positions) {
                uvs = new Float32Array(positions.length);
            } else {
                uvs = new Float32Array([
                    0,
                    0,
                    1,
                    0,
                    1,
                    1,
                    0,
                    1
                ]);
            }
        }
        const indices = options.indices || new Uint32Array([
            0,
            1,
            2,
            0,
            2,
            3
        ]);
        const shrinkToFit = options.shrinkBuffersToFit;
        const positionBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$Buffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Buffer"]({
            data: positions,
            label: "attribute-mesh-positions",
            shrinkToFit,
            usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferUsage"].VERTEX | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferUsage"].COPY_DST
        });
        const uvBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$Buffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Buffer"]({
            data: uvs,
            label: "attribute-mesh-uvs",
            shrinkToFit,
            usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferUsage"].VERTEX | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferUsage"].COPY_DST
        });
        const indexBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$Buffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Buffer"]({
            data: indices,
            label: "index-mesh-buffer",
            shrinkToFit,
            usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferUsage"].INDEX | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferUsage"].COPY_DST
        });
        super({
            attributes: {
                aPosition: {
                    buffer: positionBuffer,
                    format: "float32x2",
                    stride: 2 * 4,
                    offset: 0
                },
                aUV: {
                    buffer: uvBuffer,
                    format: "float32x2",
                    stride: 2 * 4,
                    offset: 0
                }
            },
            indexBuffer,
            topology: options.topology
        });
        this.batchMode = "auto";
    }
    /** The positions of the mesh. */ get positions() {
        return this.attributes.aPosition.buffer.data;
    }
    /**
   * Set the positions of the mesh.
   * When setting the positions, its important that the uvs array is at least as long as the positions array.
   * otherwise the geometry will not be valid.
   * @param {Float32Array} value - The positions of the mesh.
   */ set positions(value) {
        this.attributes.aPosition.buffer.data = value;
    }
    /** The UVs of the mesh. */ get uvs() {
        return this.attributes.aUV.buffer.data;
    }
    /**
   * Set the UVs of the mesh.
   * Its important that the uvs array you set is at least as long as the positions array.
   * otherwise the geometry will not be valid.
   * @param {Float32Array} value - The UVs of the mesh.
   */ set uvs(value) {
        this.attributes.aUV.buffer.data = value;
    }
    /** The indices of the mesh. */ get indices() {
        return this.indexBuffer.data;
    }
    set indices(value) {
        this.indexBuffer.data = value;
    }
};
_MeshGeometry.defaultOptions = {
    topology: "triangle-list",
    shrinkBuffersToFit: false
};
let MeshGeometry = _MeshGeometry;
;
 //# sourceMappingURL=MeshGeometry.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Mesh",
    ()=>Mesh
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$pointInTriangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/pointInTriangle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$Geometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$State$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/view/ViewContainer.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
class Mesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ViewContainer"] {
    constructor(...args){
        let options = args[0];
        if (options instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$Geometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Geometry"]) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "Mesh: use new Mesh({ geometry, shader }) instead");
            options = {
                geometry: options,
                shader: args[1]
            };
            if (args[3]) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "Mesh: drawMode argument has been removed, use geometry.topology instead");
                options.geometry.topology = args[3];
            }
        }
        const { geometry, shader, texture, roundPixels, state, ...rest } = options;
        super({
            label: "Mesh",
            ...rest
        });
        /** @internal */ this.renderPipeId = "mesh";
        /** @internal */ this._shader = null;
        this.allowChildren = false;
        this.shader = shader ?? null;
        this.texture = texture ?? shader?.texture ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].WHITE;
        this.state = state ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$State$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["State"].for2d();
        this._geometry = geometry;
        this._geometry.on("update", this.onViewUpdate, this);
        this.roundPixels = roundPixels ?? false;
    }
    /** Alias for {@link Mesh#shader}. */ get material() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "mesh.material property has been removed, use mesh.shader instead");
        return this._shader;
    }
    /**
   * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
   * Can be shared between multiple Mesh objects.
   */ set shader(value) {
        if (this._shader === value) return;
        this._shader = value;
        this.onViewUpdate();
    }
    get shader() {
        return this._shader;
    }
    /**
   * Includes vertex positions, face indices, colors, UVs, and
   * custom attributes within buffers, reducing the cost of passing all
   * this data to the GPU. Can be shared between multiple Mesh objects.
   */ set geometry(value) {
        if (this._geometry === value) return;
        this._geometry?.off("update", this.onViewUpdate, this);
        value.on("update", this.onViewUpdate, this);
        this._geometry = value;
        this.onViewUpdate();
    }
    get geometry() {
        return this._geometry;
    }
    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */ set texture(value) {
        value || (value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY);
        const currentTexture = this._texture;
        if (currentTexture === value) return;
        if (currentTexture && currentTexture.dynamic) currentTexture.off("update", this.onViewUpdate, this);
        if (value.dynamic) value.on("update", this.onViewUpdate, this);
        if (this.shader) {
            this.shader.texture = value;
        }
        this._texture = value;
        this.onViewUpdate();
    }
    get texture() {
        return this._texture;
    }
    get batched() {
        if (this._shader) return false;
        if ((this.state.data & 12) !== 0) return false;
        if (this._geometry instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MeshGeometry"]) {
            if (this._geometry.batchMode === "auto") {
                return this._geometry.positions.length / 2 <= 100;
            }
            return this._geometry.batchMode === "batch";
        }
        return false;
    }
    /**
   * The local bounds of the mesh.
   * @type {Bounds}
   */ get bounds() {
        return this._geometry.bounds;
    }
    /**
   * Update local bounds of the mesh.
   * @private
   */ updateBounds() {
        this._bounds = this._geometry.bounds;
    }
    /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */ containsPoint(point) {
        const { x, y } = point;
        if (!this.bounds.containsPoint(x, y)) return false;
        const vertices = this.geometry.getBuffer("aPosition").data;
        const step = this.geometry.topology === "triangle-strip" ? 3 : 1;
        if (this.geometry.getIndex()) {
            const indices = this.geometry.getIndex().data;
            const len = indices.length;
            for(let i = 0; i + 2 < len; i += step){
                const ind0 = indices[i] * 2;
                const ind1 = indices[i + 1] * 2;
                const ind2 = indices[i + 2] * 2;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$pointInTriangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointInTriangle"])(x, y, vertices[ind0], vertices[ind0 + 1], vertices[ind1], vertices[ind1 + 1], vertices[ind2], vertices[ind2 + 1])) {
                    return true;
                }
            }
        } else {
            const len = vertices.length / 2;
            for(let i = 0; i + 2 < len; i += step){
                const ind0 = i * 2;
                const ind1 = (i + 1) * 2;
                const ind2 = (i + 2) * 2;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$pointInTriangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointInTriangle"])(x, y, vertices[ind0], vertices[ind0 + 1], vertices[ind1], vertices[ind1 + 1], vertices[ind2], vertices[ind2 + 1])) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * mesh.destroy();
   * mesh.destroy(true);
   * mesh.destroy({ texture: true, textureSource: true });
   */ destroy(options) {
        super.destroy(options);
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            this._texture.destroy(destroyTextureSource);
        }
        this._geometry?.off("update", this.onViewUpdate, this);
        this._texture = null;
        this._geometry = null;
        this._shader = null;
    }
}
;
 //# sourceMappingURL=Mesh.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AnimatedSprite",
    ()=>AnimatedSprite
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/ticker/const.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/ticker/Ticker.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$Sprite$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
class AnimatedSprite extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$Sprite$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Sprite"] {
    constructor(...args){
        let options = args[0];
        if (Array.isArray(args[0])) {
            options = {
                textures: args[0],
                autoUpdate: args[1]
            };
        }
        const { animationSpeed = 1, autoPlay = false, autoUpdate = true, loop = true, onComplete = null, onFrameChange = null, onLoop = null, textures, updateAnchor = false, ...rest } = options;
        const [firstFrame] = textures;
        super({
            ...rest,
            texture: firstFrame instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"] ? firstFrame : firstFrame.texture
        });
        this._textures = null;
        this._durations = null;
        this._autoUpdate = autoUpdate;
        this._isConnectedToTicker = false;
        this.animationSpeed = animationSpeed;
        this.loop = loop;
        this.updateAnchor = updateAnchor;
        this.onComplete = onComplete;
        this.onFrameChange = onFrameChange;
        this.onLoop = onLoop;
        this._currentTime = 0;
        this._playing = false;
        this._previousFrame = null;
        this.textures = textures;
        if (autoPlay) {
            this.play();
        }
    }
    /**
   * Stops the animation playback and freezes the current frame.
   * Does not reset the current frame or animation progress.
   * @example
   * ```ts
   * // Create an animated sprite
   * const sprite = new AnimatedSprite({
   *     textures: [
   *         Texture.from('walk1.png'),
   *         Texture.from('walk2.png'),
   *         Texture.from('walk3.png')
   *     ],
   *     autoPlay: true
   * });
   *
   * // Stop at current frame
   * sprite.stop();
   *
   * // Stop at specific frame
   * sprite.gotoAndStop(1); // Stops at second frame
   *
   * // Stop and reset
   * sprite.stop();
   * sprite.currentFrame = 0;
   *
   * // Stop with completion check
   * if (sprite.playing) {
   *     sprite.stop();
   *     sprite.onComplete?.();
   * }
   * ```
   * @see {@link AnimatedSprite#play} For starting playback
   * @see {@link AnimatedSprite#gotoAndStop} For stopping at a specific frame
   * @see {@link AnimatedSprite#playing} For checking play state
   */ stop() {
        if (!this._playing) {
            return;
        }
        this._playing = false;
        if (this._autoUpdate && this._isConnectedToTicker) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ticker"].shared.remove(this.update, this);
            this._isConnectedToTicker = false;
        }
    }
    /**
   * Starts or resumes the animation playback.
   * If the animation was previously stopped, it will continue from where it left off.
   * @example
   * ```ts
   * // Basic playback
   * const sprite = new AnimatedSprite({
   *     textures: [
   *         Texture.from('walk1.png'),
   *         Texture.from('walk2.png'),
   *     ],
   *     autoPlay: false
   * });
   * sprite.play();
   *
   * // Play after stopping
   * sprite.stop();
   * sprite.currentFrame = 0; // Reset to start
   * sprite.play(); // Play from beginning
   *
   * // Play with auto-update disabled
   * sprite.autoUpdate = false;
   * sprite.play();
   * app.ticker.add(() => {
   *     sprite.update(app.ticker); // Manual updates
   * });
   * ```
   * @see {@link AnimatedSprite#stop} For stopping playback
   * @see {@link AnimatedSprite#gotoAndPlay} For playing from a specific frame
   * @see {@link AnimatedSprite#playing} For checking play state
   */ play() {
        if (this._playing) {
            return;
        }
        this._playing = true;
        if (this._autoUpdate && !this._isConnectedToTicker) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ticker"].shared.add(this.update, this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UPDATE_PRIORITY"].HIGH);
            this._isConnectedToTicker = true;
        }
    }
    /**
   * Stops the AnimatedSprite and sets it to a specific frame.
   * @example
   * ```ts
   * // Create an animated sprite
   * const sprite = new AnimatedSprite({
   *     textures: [
   *         Texture.from('walk1.png'),
   *         Texture.from('walk2.png'),
   *         Texture.from('walk3.png'),
   *     ]
   * });
   *
   * // Go to specific frames
   * sprite.gotoAndStop(0);  // First frame
   * sprite.gotoAndStop(2);  // Third frame
   *
   * // Jump to last frame
   * sprite.gotoAndStop(sprite.totalFrames - 1);
   * ```
   * @param frameNumber - Frame index to stop at (0-based)
   * @throws {Error} If frameNumber is out of bounds
   * @see {@link AnimatedSprite#gotoAndPlay} For going to a frame and playing
   * @see {@link AnimatedSprite#currentFrame} For getting/setting current frame
   * @see {@link AnimatedSprite#totalFrames} For total number of frames
   */ gotoAndStop(frameNumber) {
        this.stop();
        this.currentFrame = frameNumber;
    }
    /**
   * Goes to a specific frame and begins playing the AnimatedSprite from that point.
   * Combines frame navigation and playback start in one operation.
   * @example
   * ```ts
   * // Start from specific frame
   * sprite.gotoAndPlay(1); // Starts playing from second frame
   * ```
   * @param frameNumber - Frame index to start playing from (0-based)
   * @throws {Error} If frameNumber is out of bounds
   * @see {@link AnimatedSprite#gotoAndStop} For going to a frame without playing
   * @see {@link AnimatedSprite#play} For playing from current frame
   * @see {@link AnimatedSprite#currentFrame} For getting/setting current frame
   */ gotoAndPlay(frameNumber) {
        this.currentFrame = frameNumber;
        this.play();
    }
    /**
   * Updates the object transform for rendering. This method handles animation timing, frame updates,
   * and manages looping behavior.
   * @example
   * ```ts
   * // Create an animated sprite with manual updates
   * const sprite = new AnimatedSprite({
   *     textures: [
   *         Texture.from('frame1.png'),
   *         Texture.from('frame2.png'),
   *         Texture.from('frame3.png')
   *     ],
   *     autoUpdate: false // Disable automatic updates
   * });
   *
   * // Manual update with app ticker
   * app.ticker.add((ticker) => {
   *     sprite.update(ticker);
   * });
   * ```
   * @param ticker - The ticker to use for updating the animation timing
   * @see {@link AnimatedSprite#autoUpdate} For controlling automatic updates
   * @see {@link AnimatedSprite#animationSpeed} For controlling animation speed
   * @see {@link Ticker} For timing system details
   */ update(ticker) {
        if (!this._playing) {
            return;
        }
        const deltaTime = ticker.deltaTime;
        const elapsed = this.animationSpeed * deltaTime;
        const previousFrame = this.currentFrame;
        if (this._durations !== null) {
            let lag = this._currentTime % 1 * this._durations[this.currentFrame];
            lag += elapsed / 60 * 1e3;
            while(lag < 0){
                this._currentTime--;
                lag += this._durations[this.currentFrame];
            }
            const sign = Math.sign(this.animationSpeed * deltaTime);
            this._currentTime = Math.floor(this._currentTime);
            while(lag >= this._durations[this.currentFrame]){
                lag -= this._durations[this.currentFrame] * sign;
                this._currentTime += sign;
            }
            this._currentTime += lag / this._durations[this.currentFrame];
        } else {
            this._currentTime += elapsed;
        }
        if (this._currentTime < 0 && !this.loop) {
            this.gotoAndStop(0);
            if (this.onComplete) {
                this.onComplete();
            }
        } else if (this._currentTime >= this._textures.length && !this.loop) {
            this.gotoAndStop(this._textures.length - 1);
            if (this.onComplete) {
                this.onComplete();
            }
        } else if (previousFrame !== this.currentFrame) {
            if (this.loop && this.onLoop) {
                if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
                    this.onLoop();
                }
            }
            this._updateTexture();
        }
    }
    /** Updates the displayed texture to match the current frame index. */ _updateTexture() {
        const currentFrame = this.currentFrame;
        if (this._previousFrame === currentFrame) {
            return;
        }
        this._previousFrame = currentFrame;
        this.texture = this._textures[currentFrame];
        if (this.updateAnchor && this.texture.defaultAnchor) {
            this.anchor.copyFrom(this.texture.defaultAnchor);
        }
        if (this.onFrameChange) {
            this.onFrameChange(this.currentFrame);
        }
    }
    /**
   * Stops the AnimatedSprite and destroys it.
   * This method stops the animation playback, removes it from the ticker,
   * and cleans up any resources associated with the sprite.
   * @param options - Options for destroying the sprite, such as whether to remove from parent
   * @example
   * ```ts
   * // Destroy the sprite when done
   * sprite.destroy();
   * // Or with options
   * sprite.destroy({ children: true, texture: true, textureSource: true });
   * ```
   */ destroy(options = false) {
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            this._textures.forEach((texture)=>{
                if (this.texture !== texture) {
                    texture.destroy(destroyTextureSource);
                }
            });
        }
        this._textures = [];
        this._durations = null;
        this.stop();
        super.destroy(options);
        this.onComplete = null;
        this.onFrameChange = null;
        this.onLoop = null;
    }
    /**
   * A short hand way of creating an AnimatedSprite from an array of frame ids.
   * Uses texture frames from the cache to create an animation sequence.
   * @example
   * ```ts
   * // Create from frame IDs
   * const frameIds = [
   *     'walk_001.png',
   *     'walk_002.png',
   *     'walk_003.png'
   * ];
   *
   * const walkingAnimation = AnimatedSprite.fromFrames(frameIds);
   * walkingAnimation.play();
   * ```
   * @param frames - The array of frame ids to use for the animation
   * @returns A new animated sprite using the frames
   * @see {@link Texture.from} For texture creation from frames
   * @see {@link Spritesheet} For loading spritesheets
   */ static fromFrames(frames) {
        const textures = [];
        for(let i = 0; i < frames.length; ++i){
            textures.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].from(frames[i]));
        }
        return new AnimatedSprite(textures);
    }
    /**
   * A short hand way of creating an AnimatedSprite from an array of image urls.
   * Each image will be used as a frame in the animation.
   * @example
   * ```ts
   * // Create from image URLs
   * const images = [
   *     'assets/walk1.png',
   *     'assets/walk2.png',
   *     'assets/walk3.png'
   * ];
   *
   * const walkingSprite = AnimatedSprite.fromImages(images);
   * walkingSprite.play();
   * ```
   * @param images - The array of image urls to use as frames
   * @returns A new animated sprite using the images as frames
   * @see {@link Assets} For asset loading and management
   * @see {@link Texture.from} For texture creation from images
   */ static fromImages(images) {
        const textures = [];
        for(let i = 0; i < images.length; ++i){
            textures.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].from(images[i]));
        }
        return new AnimatedSprite(textures);
    }
    /**
   * The total number of frames in the AnimatedSprite. This is the same as number of textures
   * assigned to the AnimatedSprite.
   * @example
   * ```ts
   * // Create an animated sprite
   * const sprite = new AnimatedSprite({
   *     textures: [
   *         Texture.from('frame1.png'),
   *         Texture.from('frame2.png'),
   *         Texture.from('frame3.png')
   *     ]
   * });
   *
   * // Get total frames
   * console.log(sprite.totalFrames); // Outputs: 3
   *
   * // Use with frame navigation
   * sprite.gotoAndStop(sprite.totalFrames - 1); // Go to last frame
   * ```
   * @readonly
   * @see {@link AnimatedSprite#currentFrame} For the current frame index
   * @see {@link AnimatedSprite#textures} For the array of textures
   * @returns {number} The total number of frames
   */ get totalFrames() {
        return this._textures.length;
    }
    /**
   * The array of textures or frame objects used for the animation sequence.
   * Can be set to either an array of Textures or an array of FrameObjects with custom timing.
   * @example
   * ```ts
   * // Update textures at runtime
   * sprite.textures = [
   *     Texture.from('run1.png'),
   *     Texture.from('run2.png')
   * ];
   *
   * // Use custom frame timing
   * sprite.textures = [
   *     { texture: Texture.from('explosion1.png'), time: 100 },
   *     { texture: Texture.from('explosion2.png'), time: 200 },
   *     { texture: Texture.from('explosion3.png'), time: 300 }
   * ];
   *
   * // Use with spritesheet
   * const sheet = await Assets.load('animations.json');
   * sprite.textures = sheet.animations['walk'];
   * ```
   * @type {AnimatedSpriteFrames}
   * @see {@link FrameObject} For frame timing options
   * @see {@link Spritesheet} For loading from spritesheets
   */ get textures() {
        return this._textures;
    }
    set textures(value) {
        if (value[0] instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]) {
            this._textures = value;
            this._durations = null;
        } else {
            this._textures = [];
            this._durations = [];
            for(let i = 0; i < value.length; i++){
                this._textures.push(value[i].texture);
                this._durations.push(value[i].time);
            }
        }
        this._previousFrame = null;
        this.gotoAndStop(0);
        this._updateTexture();
    }
    /**
   * Gets or sets the current frame index of the animation.
   * When setting, the value will be clamped between 0 and totalFrames - 1.
   * @example
   * ```ts
   * // Create an animated sprite
   * const sprite = new AnimatedSprite({
   *     textures: [
   *         Texture.from('walk1.png'),
   *         Texture.from('walk2.png'),
   *         Texture.from('walk3.png')
   *     ]
   * });
   *
   * // Get current frame
   * console.log(sprite.currentFrame); // 0
   *
   * // Set specific frame
   * sprite.currentFrame = 1; // Show second frame
   *
   * // Use with frame callbacks
   * sprite.onFrameChange = (frame) => {
   *     console.log(`Now showing frame: ${frame}`);
   * };
   * sprite.currentFrame = 2;
   * ```
   * @throws {Error} If attempting to set a frame index out of bounds
   * @see {@link AnimatedSprite#totalFrames} For the total number of frames
   * @see {@link AnimatedSprite#gotoAndPlay} For playing from a specific frame
   * @see {@link AnimatedSprite#gotoAndStop} For stopping at a specific frame
   */ get currentFrame() {
        let currentFrame = Math.floor(this._currentTime) % this._textures.length;
        if (currentFrame < 0) {
            currentFrame += this._textures.length;
        }
        return currentFrame;
    }
    set currentFrame(value) {
        if (value < 0 || value > this.totalFrames - 1) {
            throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
        }
        const previousFrame = this.currentFrame;
        this._currentTime = value;
        if (previousFrame !== this.currentFrame) {
            this._updateTexture();
        }
    }
    /**
   * Indicates if the AnimatedSprite is currently playing.
   * This is a read-only property that reflects the current playback state.
   * @example
   * ```ts
   * // Check if animation is playing
   * console.log('Playing:', sprite.playing); // true
   *
   * // Use with play control
   * if (!sprite.playing) {
   *     sprite.play();
   * }
   * ```
   * @readonly
   * @returns {boolean} True if the animation is currently playing
   * @see {@link AnimatedSprite#play} For starting playback
   * @see {@link AnimatedSprite#stop} For stopping playback
   * @see {@link AnimatedSprite#loop} For controlling looping behavior
   */ get playing() {
        return this._playing;
    }
    /**
   * Controls whether the animation automatically updates using the shared ticker.
   * When enabled, the animation will update on each frame. When disabled, you must
   * manually call update() to advance the animation.
   * @example
   * ```ts
   * // Create sprite with auto-update disabled
   * const sprite = new AnimatedSprite({
   *     textures: [],
   *     autoUpdate: false
   * });
   *
   * // Manual update with app ticker
   * app.ticker.add((ticker) => {
   *     sprite.update(ticker);
   * });
   *
   * // Enable auto-update later
   * sprite.autoUpdate = true;
   * ```
   * @default true
   * @see {@link AnimatedSprite#update} For manual animation updates
   * @see {@link Ticker} For the timing system
   */ get autoUpdate() {
        return this._autoUpdate;
    }
    set autoUpdate(value) {
        if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            if (!this._autoUpdate && this._isConnectedToTicker) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ticker"].shared.remove(this.update, this);
                this._isConnectedToTicker = false;
            } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ticker"].shared.add(this.update, this);
                this._isConnectedToTicker = true;
            }
        }
    }
}
;
 //# sourceMappingURL=AnimatedSprite.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TilingSprite",
    ()=>TilingSprite
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/cache/Cache.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$misc$2f$Transform$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/misc/Transform.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/view/ViewContainer.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
"use strict";
const _TilingSprite = class _TilingSprite extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ViewContainer"] {
    constructor(...args){
        let options = args[0] || {};
        if (options instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]) {
            options = {
                texture: options
            };
        }
        if (args.length > 1) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "use new TilingSprite({ texture, width:100, height:100 }) instead");
            options.width = args[1];
            options.height = args[2];
        }
        options = {
            ..._TilingSprite.defaultOptions,
            ...options
        };
        const { texture, anchor, tilePosition, tileScale, tileRotation, width, height, applyAnchorToTexture, roundPixels, ...rest } = options ?? {};
        super({
            label: "TilingSprite",
            ...rest
        });
        /** @internal */ this.renderPipeId = "tilingSprite";
        /** @advanced */ this.batched = true;
        this.allowChildren = false;
        this._anchor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"]({
            _onUpdate: ()=>{
                this.onViewUpdate();
            }
        });
        this.applyAnchorToTexture = applyAnchorToTexture;
        this.texture = texture;
        this._width = width ?? texture.width;
        this._height = height ?? texture.height;
        this._tileTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$misc$2f$Transform$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Transform"]({
            observer: {
                _onUpdate: ()=>this.onViewUpdate()
            }
        });
        if (anchor) this.anchor = anchor;
        this.tilePosition = tilePosition;
        this.tileScale = tileScale;
        this.tileRotation = tileRotation;
        this.roundPixels = roundPixels ?? false;
    }
    /**
   * Creates a new tiling sprite based on a source texture or image path.
   * This is a convenience method that automatically creates and manages textures.
   * @example
   * ```ts
   * // Create a new tiling sprite from an image path
   * const pattern = TilingSprite.from('pattern.png');
   * pattern.width = 300; // Set the width of the tiling area
   * pattern.height = 200; // Set the height of the tiling area
   *
   * // Create from options
   * const texture = Texture.from('pattern.png');
   * const pattern = TilingSprite.from(texture, {
   *     width: 300,
   *     height: 200,
   *     tileScale: { x: 0.5, y: 0.5 }
   * });
   * ```
   * @param source - The source to create the sprite from. Can be a path to an image or a texture
   * @param options - Additional options for the tiling sprite
   * @returns A new tiling sprite based on the source
   * @see {@link Texture.from} For texture creation details
   * @see {@link Assets} For asset loading and management
   */ static from(source, options = {}) {
        if (typeof source === "string") {
            return new _TilingSprite({
                texture: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Cache"].get(source),
                ...options
            });
        }
        return new _TilingSprite({
            texture: source,
            ...options
        });
    }
    /**
   * @see {@link TilingSpriteOptions.applyAnchorToTexture}
   * @deprecated since 8.0.0
   * @advanced
   */ get uvRespectAnchor() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
        return this.applyAnchorToTexture;
    }
    /** @advanced */ set uvRespectAnchor(value) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
        this.applyAnchorToTexture = value;
    }
    /**
   * Changes frame clamping in corresponding textureMatrix
   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
   * @default 0.5
   * @type {number}
   * @advanced
   */ get clampMargin() {
        return this._texture.textureMatrix.clampMargin;
    }
    /** @advanced */ set clampMargin(value) {
        this._texture.textureMatrix.clampMargin = value;
    }
    /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * - The default is `(0,0)`, this means the sprite's origin is the top left.
   * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * ```ts
   * // Center the anchor point
   * sprite.anchor = 0.5; // Sets both x and y to 0.5
   * sprite.position.set(400, 300); // Sprite will be centered at this position
   *
   * // Set specific x/y anchor points
   * sprite.anchor = {
   *     x: 1, // Right edge
   *     y: 0  // Top edge
   * };
   *
   * // Using individual coordinates
   * sprite.anchor.set(0.5, 1); // Center-bottom
   *
   * // For rotation around center
   * sprite.anchor.set(0.5);
   * sprite.rotation = Math.PI / 4; // 45 degrees around center
   *
   * // For scaling from center
   * sprite.anchor.set(0.5);
   * sprite.scale.set(2); // Scales from center point
   * ```
   */ get anchor() {
        return this._anchor;
    }
    set anchor(value) {
        typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    /**
   * The offset of the tiling texture.
   * Used to scroll or position the repeated pattern.
   * @example
   * ```ts
   * // Offset the tiling pattern by 100 pixels in both x and y directions
   * tilingSprite.tilePosition = { x: 100, y: 100 };
   * ```
   * @default {x: 0, y: 0}
   */ get tilePosition() {
        return this._tileTransform.position;
    }
    set tilePosition(value) {
        this._tileTransform.position.copyFrom(value);
    }
    /**
   * Scale of the tiling texture.
   * Affects the size of each repeated instance of the texture.
   * @example
   * ```ts
   * // Scale the texture by 1.5 in both x and y directions
   * tilingSprite.tileScale = { x: 1.5, y: 1.5 };
   * ```
   * @default {x: 1, y: 1}
   */ get tileScale() {
        return this._tileTransform.scale;
    }
    set tileScale(value) {
        typeof value === "number" ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);
    }
    set tileRotation(value) {
        this._tileTransform.rotation = value;
    }
    /**
   * Rotation of the tiling texture in radians.
   * This controls the rotation applied to the texture before tiling.
   * @example
   * ```ts
   * // Rotate the texture by 45 degrees (in radians)
   * tilingSprite.tileRotation = Math.PI / 4; // 45 degrees
   * ```
   * @default 0
   */ get tileRotation() {
        return this._tileTransform.rotation;
    }
    /**
   * The transform object that controls the tiling texture's position, scale, and rotation.
   * This transform is independent of the sprite's own transform properties.
   * @example
   * ```ts
   * // Access transform properties directly
   * sprite.tileTransform.position.set(100, 50);
   * sprite.tileTransform.scale.set(2);
   * sprite.tileTransform.rotation = Math.PI / 4;
   *
   * // Create smooth scrolling animation
   * app.ticker.add(() => {
   *     sprite.tileTransform.position.x += 1;
   *     sprite.tileTransform.rotation += 0.01;
   * });
   *
   * // Reset transform
   * sprite.tileTransform.position.set(0);
   * sprite.tileTransform.scale.set(1);
   * sprite.tileTransform.rotation = 0;
   * ```
   * @returns {Transform} The transform object for the tiling texture
   * @see {@link Transform} For transform operations
   * @see {@link TilingSprite#tilePosition} For position control
   * @see {@link TilingSprite#tileScale} For scale control
   * @see {@link TilingSprite#tileRotation} For rotation control
   * @advanced
   */ get tileTransform() {
        return this._tileTransform;
    }
    set texture(value) {
        value || (value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY);
        const currentTexture = this._texture;
        if (currentTexture === value) return;
        if (currentTexture && currentTexture.dynamic) currentTexture.off("update", this.onViewUpdate, this);
        if (value.dynamic) value.on("update", this.onViewUpdate, this);
        this._texture = value;
        this.onViewUpdate();
    }
    /**
   * The texture to use for tiling.
   * This is the image that will be repeated across the sprite.
   * @example
   * ```ts
   * // Use a texture from the asset cache
   * tilingSprite.texture = Texture.from('assets/pattern.png');
   * ```
   * @default Texture.WHITE
   */ get texture() {
        return this._texture;
    }
    /**
   * The width of the tiling area. This defines how wide the area is that the texture will be tiled across.
   * @example
   * ```ts
   * // Create a tiling sprite
   * const sprite = new TilingSprite({
   *     texture: Texture.from('pattern.png'),
   *     width: 500,
   *     height: 300
   * });
   *
   * // Adjust width dynamically
   * sprite.width = 800; // Expands tiling area
   *
   * // Update on resize
   * window.addEventListener('resize', () => {
   *     sprite.width = app.screen.width;
   * });
   * ```
   * @see {@link TilingSprite#setSize} For setting both width and height efficiently
   * @see {@link TilingSprite#height} For setting height
   */ set width(value) {
        this._width = value;
        this.onViewUpdate();
    }
    get width() {
        return this._width;
    }
    set height(value) {
        this._height = value;
        this.onViewUpdate();
    }
    /**
   * The height of the tiling area. This defines how tall the area is that the texture will be tiled across.
   * @example
   * ```ts
   * // Create a tiling sprite
   * const sprite = new TilingSprite({
   *     texture: Texture.from('pattern.png'),
   *     width: 500,
   *     height: 300
   * });
   *
   * // Adjust width dynamically
   * sprite.height = 800; // Expands tiling area
   *
   * // Update on resize
   * window.addEventListener('resize', () => {
   *     sprite.height = app.screen.height;
   * });
   * ```
   * @see {@link TilingSprite#setSize} For setting both width and height efficiently
   * @see {@link TilingSprite#width} For setting width
   */ get height() {
        return this._height;
    }
    /**
   * Sets the size of the TilingSprite to the specified width and height.
   * This is faster than setting width and height separately as it only triggers one update.
   * @example
   * ```ts
   * // Set specific dimensions
   * sprite.setSize(300, 200); // Width: 300, Height: 200
   *
   * // Set uniform size (square)
   * sprite.setSize(400); // Width: 400, Height: 400
   *
   * // Set size using object
   * sprite.setSize({
   *     width: 500,
   *     height: 300
   * });
   * ```
   * @param value - This can be either a number for uniform sizing or a Size object with width/height properties
   * @param height - The height to set. Defaults to the value of `width` if not provided
   * @see {@link TilingSprite#width} For setting width only
   * @see {@link TilingSprite#height} For setting height only
   */ setSize(value, height) {
        if (typeof value === "object") {
            height = value.height ?? value.width;
            value = value.width;
        }
        this._width = value;
        this._height = height ?? value;
        this.onViewUpdate();
    }
    /**
   * Retrieves the size of the TilingSprite as a {@link Size} object.
   * This method is more efficient than getting width and height separately as it only allocates one object.
   * @example
   * ```ts
   * // Get basic size
   * const size = sprite.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * sprite.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in, to avoid allocating a new object
   * @returns The size of the TilingSprite
   * @see {@link TilingSprite#width} For getting just the width
   * @see {@link TilingSprite#height} For getting just the height
   * @see {@link TilingSprite#setSize} For setting both width and height efficiently
   */ getSize(out) {
        out || (out = {});
        out.width = this._width;
        out.height = this._height;
        return out;
    }
    /** @private */ updateBounds() {
        const bounds = this._bounds;
        const anchor = this._anchor;
        const width = this._width;
        const height = this._height;
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * height;
        bounds.maxY = bounds.minY + height;
    }
    /**
   * Checks if the object contains the given point in local coordinates.
   * Takes into account the anchor offset when determining boundaries.
   * @example
   * ```ts
   * // Create a tiling sprite
   * const sprite = new TilingSprite({
   *     texture: Texture.from('pattern.png'),
   *     width: 200,
   *     height: 100,
   *     anchor: 0.5 // Center anchor
   * });
   *
   * // Basic point check
   * const contains = sprite.containsPoint({ x: 50, y: 25 });
   * console.log('Point is inside:', contains);
   *
   * // Check with different anchors
   * sprite.anchor.set(0); // Top-left anchor
   * console.log('Contains point:', sprite.containsPoint({ x: 150, y: 75 }));
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is within the sprite's bounds
   * @see {@link TilingSprite#toLocal} For converting global coordinates to local
   * @see {@link TilingSprite#anchor} For understanding boundary calculations
   */ containsPoint(point) {
        const width = this._width;
        const height = this._height;
        const x1 = -width * this._anchor._x;
        let y1 = 0;
        if (point.x >= x1 && point.x <= x1 + width) {
            y1 = -height * this._anchor._y;
            if (point.y >= y1 && point.y <= y1 + height) return true;
        }
        return false;
    }
    /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * tilingSprite.destroy();
   * tilingSprite.destroy(true);
   * tilingSprite.destroy({ texture: true, textureSource: true });
   */ destroy(options = false) {
        super.destroy(options);
        this._anchor = null;
        this._tileTransform = null;
        this._bounds = null;
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
    }
};
/**
 * Default options used when creating a TilingSprite instance.
 * These values are used as fallbacks when specific options are not provided.
 * @example
 * ```ts
 * // Override default options globally
 * TilingSprite.defaultOptions.texture = Texture.from('defaultPattern.png');
 * TilingSprite.defaultOptions.tileScale = { x: 2, y: 2 };
 *
 * // Create sprite using default options
 * const sprite = new TilingSprite();
 * // Will use defaultPattern.png and scale 2x
 * ```
 * @type {TilingSpriteOptions}
 * @see {@link TilingSpriteOptions} For all available options
 * @see {@link TilingSprite.from} For creating sprites with custom options
 * @see {@link Texture.EMPTY} For the default empty texture
 */ _TilingSprite.defaultOptions = {
    /** The texture to use for the sprite. */ texture: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY,
    /** The anchor point of the sprite */ anchor: {
        x: 0,
        y: 0
    },
    /** The offset of the image that is being tiled. */ tilePosition: {
        x: 0,
        y: 0
    },
    /** Scaling of the image that is being tiled. */ tileScale: {
        x: 1,
        y: 1
    },
    /** The rotation of the image that is being tiled. */ tileRotation: 0,
    /**
   * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in
   * local space.
   *
   * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without
   * this, the top-left corner always gets the (0, 0) texture coordinate.
   * @default false
   */ applyAnchorToTexture: false
};
let TilingSprite = _TilingSprite;
;
 //# sourceMappingURL=TilingSprite.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/AbstractText.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbstractText",
    ()=>AbstractText,
    "ensureTextOptions",
    ()=>ensureTextOptions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/view/ViewContainer.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
class AbstractText extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ViewContainer"] {
    constructor(options, styleClass){
        const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;
        super({
            ...rest
        });
        /** @internal */ this.batched = true;
        /** @internal */ this._resolution = null;
        /** @internal */ this._autoResolution = true;
        /** @internal */ this._didTextUpdate = true;
        this._styleClass = styleClass;
        this.text = text ?? "";
        this.style = style;
        this.resolution = resolution ?? null;
        this.allowChildren = false;
        this._anchor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"]({
            _onUpdate: ()=>{
                this.onViewUpdate();
            }
        });
        if (anchor) this.anchor = anchor;
        this.roundPixels = roundPixels ?? false;
        if (width !== void 0) this.width = width;
        if (height !== void 0) this.height = height;
    }
    /**
   * The anchor point of the text that controls the origin point for positioning and rotation.
   * Can be a number (same value for x/y) or a PointData object.
   * - (0,0) is top-left
   * - (0.5,0.5) is center
   * - (1,1) is bottom-right
   * ```ts
   * // Set anchor to center
   * const text = new Text({
   *     text: 'Hello Pixi!',
   *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }
   * });
   * // Set anchor to top-left
   * const text2 = new Text({
   *     text: 'Hello Pixi!',
   *     anchor: { x: 0, y: 0 } // Top-left corner
   * });
   * // Set anchor to bottom-right
   * const text3 = new Text({
   *     text: 'Hello Pixi!',
   *     anchor: { x: 1, y: 1 } // Bottom-right corner
   * });
   * ```
   * @default { x: 0, y: 0 }
   */ get anchor() {
        return this._anchor;
    }
    set anchor(value) {
        typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    /**
   * The text content to display. Use '\n' for line breaks.
   * Accepts strings, numbers, or objects with toString() method.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Hello Pixi!',
   * });
   * const multilineText = new Text({
   *     text: 'Line 1\nLine 2\nLine 3',
   * });
   * const numberText = new Text({
   *     text: 12345, // Will be converted to '12345'
   * });
   * const objectText = new Text({
   *     text: { toString: () => 'Object Text' }, // Custom toString
   * });
   *
   * // Update text dynamically
   * text.text = 'Updated Text'; // Re-renders with new text
   * text.text = 67890; // Updates to '67890'
   * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method
   * // Clear text
   * text.text = ''; // Clears the text
   * ```
   * @default ''
   */ set text(value) {
        value = value.toString();
        if (this._text === value) return;
        this._text = value;
        this.onViewUpdate();
    }
    get text() {
        return this._text;
    }
    /**
   * The resolution/device pixel ratio for rendering.
   * Higher values result in sharper text at the cost of performance.
   * Set to null for auto-resolution based on device.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Hello Pixi!',
   *     resolution: 2 // High DPI for sharper text
   * });
   * const autoResText = new Text({
   *     text: 'Auto Resolution',
   *     resolution: null // Use device's pixel ratio
   * });
   * ```
   * @default null
   */ set resolution(value) {
        this._autoResolution = value === null;
        this._resolution = value;
        this.onViewUpdate();
    }
    get resolution() {
        return this._resolution;
    }
    get style() {
        return this._style;
    }
    /**
   * The style configuration for the text.
   * Can be a TextStyle instance or a configuration object.
   * Supports canvas text styles, HTML text styles, and bitmap text styles.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Styled Text',
   *     style: {
   *         fontSize: 24,
   *         fill: 0xff1010, // Red color
   *         fontFamily: 'Arial',
   *         align: 'center', // Center alignment
   *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke
   *         dropShadow: {
   *             color: '#000000', // Black shadow
   *             blur: 4, // Shadow blur
   *             distance: 6 // Shadow distance
   *         }
   *     }
   * });
   * const htmlText = new HTMLText({
   *     text: 'HTML Styled Text',
   *     style: {
   *         fontSize: '20px',
   *         fill: 'blue',
   *         fontFamily: 'Verdana',
   *     }
   * });
   * const bitmapText = new BitmapText({
   *     text: 'Bitmap Styled Text',
   *     style: {
   *         fontName: 'Arial',
   *         fontSize: 32,
   *     }
   * })
   *
   * // Update style dynamically
   * text.style = {
   *     fontSize: 30, // Change font size
   *     fill: 0x00ff00, // Change color to green
   *     align: 'right', // Change alignment to right
   *     stroke: { color: '#000000', width: 2 }, // Add black stroke
   * }
   */ set style(style) {
        style || (style = {});
        this._style?.off("update", this.onViewUpdate, this);
        if (style instanceof this._styleClass) {
            this._style = style;
        } else {
            this._style = new this._styleClass(style);
        }
        this._style.on("update", this.onViewUpdate, this);
        this.onViewUpdate();
    }
    /**
   * The width of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set width directly
   * texture.width = 200;
   * console.log(texture.scale.x); // Scale adjusted to match width
   *
   * // For better performance when setting both width and height
   * texture.setSize(300, 400); // Avoids recalculating bounds twice
   * ```
   */ get width() {
        return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(value) {
        this._setWidth(value, this.bounds.width);
    }
    /**
   * The height of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set height directly
   * texture.height = 200;
   * console.log(texture.scale.y); // Scale adjusted to match height
   *
   * // For better performance when setting both width and height
   * texture.setSize(300, 400); // Avoids recalculating bounds twice
   * ```
   */ get height() {
        return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(value) {
        this._setHeight(value, this.bounds.height);
    }
    /**
   * Retrieves the size of the Text as a [Size]{@link Size} object based on the texture dimensions and scale.
   * This is faster than getting width and height separately as it only calculates the bounds once.
   * @example
   * ```ts
   * // Basic size retrieval
   * const text = new Text({
   *     text: 'Hello Pixi!',
   *     style: { fontSize: 24 }
   * });
   * const size = text.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * text.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in, to avoid allocating a new object
   * @returns The size of the Sprite
   * @see {@link Text#width} For getting just the width
   * @see {@link Text#height} For getting just the height
   * @see {@link Text#setSize} For setting both width and height
   */ getSize(out) {
        out || (out = {});
        out.width = Math.abs(this.scale.x) * this.bounds.width;
        out.height = Math.abs(this.scale.y) * this.bounds.height;
        return out;
    }
    /**
   * Sets the size of the Text to the specified width and height.
   * This is faster than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * const text = new Text({
   *    text: 'Hello Pixi!',
   *    style: { fontSize: 24 }
   * });
   * text.setSize(100, 200); // Width: 100, Height: 200
   *
   * // Set uniform size
   * text.setSize(100); // Sets both width and height to 100
   *
   * // Set size with object
   * text.setSize({
   *     width: 200,
   *     height: 300
   * });
   * ```
   * @param value - This can be either a number or a {@link Size} object
   * @param height - The height to set. Defaults to the value of `width` if not provided
   * @see {@link Text#width} For setting width only
   * @see {@link Text#height} For setting height only
   */ setSize(value, height) {
        if (typeof value === "object") {
            height = value.height ?? value.width;
            value = value.width;
        } else {
            height ?? (height = value);
        }
        value !== void 0 && this._setWidth(value, this.bounds.width);
        height !== void 0 && this._setHeight(height, this.bounds.height);
    }
    /**
   * Checks if the object contains the given point in local coordinates.
   * Uses the text's bounds for hit testing.
   * @example
   * ```ts
   * // Basic point check
   * const localPoint = { x: 50, y: 25 };
   * const contains = text.containsPoint(localPoint);
   * console.log('Point is inside:', contains);
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is within the text's bounds
   * @see {@link Container#toLocal} For converting global coordinates to local
   */ containsPoint(point) {
        const width = this.bounds.width;
        const height = this.bounds.height;
        const x1 = -width * this.anchor.x;
        let y1 = 0;
        if (point.x >= x1 && point.x <= x1 + width) {
            y1 = -height * this.anchor.y;
            if (point.y >= y1 && point.y <= y1 + height) return true;
        }
        return false;
    }
    /** @internal */ onViewUpdate() {
        if (!this.didViewUpdate) this._didTextUpdate = true;
        super.onViewUpdate();
    }
    /**
   * Destroys this text renderable and optionally its style texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * // Destroys the text and its style
   * text.destroy({ style: true, texture: true, textureSource: true });
   * text.destroy(true);
   * text.destroy() // Destroys the text, but not its style
   */ destroy(options = false) {
        super.destroy(options);
        this.owner = null;
        this._bounds = null;
        this._anchor = null;
        if (typeof options === "boolean" ? options : options?.style) {
            this._style.destroy(options);
        }
        this._style = null;
        this._text = null;
    }
    /**
   * Returns a unique key for this instance.
   * This key is used for caching.
   * @returns {string} Unique key for the instance
   */ get styleKey() {
        return `${this._text}:${this._style.styleKey}:${this._resolution}`;
    }
}
function ensureTextOptions(args, name) {
    let options = args[0] ?? {};
    if (typeof options === "string" || args[1]) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], `use new ${name}({ text: "hi!", style }) instead`);
        options = {
            text: options,
            style: args[1]
        };
    }
    return options;
}
;
 //# sourceMappingURL=AbstractText.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CanvasTextGenerator",
    ()=>CanvasTextGenerator
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$CanvasPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$canvas$2f$getCanvasBoundingBox$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$utils$2f$fontStringFromTextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$utils$2f$getCanvasFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
const tempRect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rectangle"]();
class CanvasTextGeneratorClass {
    /**
   * Creates a canvas with the specified text rendered to it.
   *
   * Generates a canvas of appropriate size, renders the text with the provided style,
   * and returns both the canvas/context and a Rectangle representing the text bounds.
   *
   * When trim is enabled in the style, the frame will represent the bounds of the
   * non-transparent pixels, which can be smaller than the full canvas.
   * @param options - The options for generating the text canvas
   * @param options.text - The text to render
   * @param options.style - The style to apply to the text
   * @param options.resolution - The resolution of the canvas (defaults to 1)
   * @param options.padding
   * @returns An object containing the canvas/context and the frame (bounds) of the text
   */ getCanvasAndContext(options) {
        const { text, style, resolution = 1 } = options;
        const padding = style._getFinalPadding();
        const measured = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].measureText(text || " ", style);
        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + padding * 2) * resolution);
        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + padding * 2) * resolution);
        const canvasAndContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$CanvasPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasPool"].getOptimalCanvasAndContext(width, height);
        this._renderTextToCanvas(text, style, padding, resolution, canvasAndContext);
        const frame = style.trim ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$canvas$2f$getCanvasBoundingBox$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCanvasBoundingBox"])({
            canvas: canvasAndContext.canvas,
            width,
            height,
            resolution: 1,
            output: tempRect
        }) : tempRect.set(0, 0, width, height);
        return {
            canvasAndContext,
            frame
        };
    }
    /**
   * Returns a canvas and context to the pool.
   *
   * This should be called when you're done with the canvas to allow reuse
   * and prevent memory leaks.
   * @param canvasAndContext - The canvas and context to return to the pool
   */ returnCanvasAndContext(canvasAndContext) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$CanvasPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasPool"].returnCanvasAndContext(canvasAndContext);
    }
    /**
   * Renders text to its canvas, and updates its texture.
   * @param text - The text to render
   * @param style - The style of the text
   * @param padding - The padding of the text
   * @param resolution - The resolution of the text
   * @param canvasAndContext - The canvas and context to render the text to
   */ _renderTextToCanvas(text, style, padding, resolution, canvasAndContext) {
        const { canvas, context } = canvasAndContext;
        const font = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$utils$2f$fontStringFromTextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fontStringFromTextStyle"])(style);
        const measured = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].measureText(text || " ", style);
        const lines = measured.lines;
        const lineHeight = measured.lineHeight;
        const lineWidths = measured.lineWidths;
        const maxLineWidth = measured.maxLineWidth;
        const fontProperties = measured.fontProperties;
        const height = canvas.height;
        context.resetTransform();
        context.scale(resolution, resolution);
        context.textBaseline = style.textBaseline;
        if (style._stroke?.width) {
            const strokeStyle = style._stroke;
            context.lineWidth = strokeStyle.width;
            context.miterLimit = strokeStyle.miterLimit;
            context.lineJoin = strokeStyle.join;
            context.lineCap = strokeStyle.cap;
        }
        context.font = font;
        let linePositionX;
        let linePositionY;
        const passesCount = style.dropShadow ? 2 : 1;
        for(let i = 0; i < passesCount; ++i){
            const isShadowPass = style.dropShadow && i === 0;
            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + padding * 2) : 0;
            const dsOffsetShadow = dsOffsetText * resolution;
            if (isShadowPass) {
                context.fillStyle = "black";
                context.strokeStyle = "black";
                const shadowOptions = style.dropShadow;
                const dropShadowColor = shadowOptions.color;
                const dropShadowAlpha = shadowOptions.alpha;
                context.shadowColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
                const dropShadowBlur = shadowOptions.blur * resolution;
                const dropShadowDistance = shadowOptions.distance * resolution;
                context.shadowBlur = dropShadowBlur;
                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
                context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
            } else {
                context.fillStyle = style._fill ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$utils$2f$getCanvasFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCanvasFillStyle"])(style._fill, context, measured, padding * 2) : null;
                if (style._stroke?.width) {
                    const strokePadding = style._stroke.width * 0.5 + padding * 2;
                    context.strokeStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$utils$2f$getCanvasFillStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCanvasFillStyle"])(style._stroke, context, measured, strokePadding);
                }
                context.shadowColor = "black";
            }
            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
            if (lineHeight - fontProperties.fontSize < 0) {
                linePositionYShift = 0;
            }
            const strokeWidth = style._stroke?.width ?? 0;
            for(let i2 = 0; i2 < lines.length; i2++){
                linePositionX = strokeWidth / 2;
                linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;
                if (style.align === "right") {
                    linePositionX += maxLineWidth - lineWidths[i2];
                } else if (style.align === "center") {
                    linePositionX += (maxLineWidth - lineWidths[i2]) / 2;
                }
                if (style._stroke?.width) {
                    this._drawLetterSpacing(lines[i2], style, canvasAndContext, linePositionX + padding, linePositionY + padding - dsOffsetText, true);
                }
                if (style._fill !== void 0) {
                    this._drawLetterSpacing(lines[i2], style, canvasAndContext, linePositionX + padding, linePositionY + padding - dsOffsetText);
                }
            }
        }
    }
    /**
   * Render the text with letter-spacing.
   *
   * This method handles rendering text with the correct letter spacing, using either:
   * 1. Native letter spacing if supported by the browser
   * 2. Manual letter spacing calculation if not natively supported
   *
   * For manual letter spacing, it calculates the position of each character
   * based on its width and the desired spacing.
   * @param text - The text to draw
   * @param style - The text style to apply
   * @param canvasAndContext - The canvas and context to draw to
   * @param x - Horizontal position to draw the text
   * @param y - Vertical position to draw the text
   * @param isStroke - Whether to render the stroke (true) or fill (false)
   * @private
   */ _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {
        const { context } = canvasAndContext;
        const letterSpacing = style.letterSpacing;
        let useExperimentalLetterSpacing = false;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].experimentalLetterSpacingSupported) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].experimentalLetterSpacing) {
                context.letterSpacing = `${letterSpacing}px`;
                context.textLetterSpacing = `${letterSpacing}px`;
                useExperimentalLetterSpacing = true;
            } else {
                context.letterSpacing = "0px";
                context.textLetterSpacing = "0px";
            }
        }
        if (letterSpacing === 0 || useExperimentalLetterSpacing) {
            if (isStroke) {
                context.strokeText(text, x, y);
            } else {
                context.fillText(text, x, y);
            }
            return;
        }
        let currentPosition = x;
        const stringArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].graphemeSegmenter(text);
        let previousWidth = context.measureText(text).width;
        let currentWidth = 0;
        for(let i = 0; i < stringArray.length; ++i){
            const currentChar = stringArray[i];
            if (isStroke) {
                context.strokeText(currentChar, currentPosition, y);
            } else {
                context.fillText(currentChar, currentPosition, y);
            }
            let textStr = "";
            for(let j = i + 1; j < stringArray.length; ++j){
                textStr += stringArray[j];
            }
            currentWidth = context.measureText(textStr).width;
            currentPosition += previousWidth - currentWidth + letterSpacing;
            previousWidth = currentWidth;
        }
    }
}
const CanvasTextGenerator = new CanvasTextGeneratorClass();
;
 //# sourceMappingURL=CanvasTextGenerator.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/Text.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Text",
    ()=>Text
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$AbstractText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/AbstractText.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextGenerator$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/TextStyle.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
"use strict";
class Text extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$AbstractText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AbstractText"] {
    constructor(...args){
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$AbstractText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ensureTextOptions"])(args, "Text");
        super(options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextStyle"]);
        /** @internal */ this.renderPipeId = "text";
        if (options.textureStyle) {
            this.textureStyle = options.textureStyle instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextureStyle"] ? options.textureStyle : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextureStyle"](options.textureStyle);
        }
    }
    /** @private */ updateBounds() {
        const bounds = this._bounds;
        const anchor = this._anchor;
        let width = 0;
        let height = 0;
        if (this._style.trim) {
            const { frame, canvasAndContext } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextGenerator$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextGenerator"].getCanvasAndContext({
                text: this.text,
                style: this._style,
                resolution: 1
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextGenerator$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextGenerator"].returnCanvasAndContext(canvasAndContext);
            width = frame.width;
            height = frame.height;
        } else {
            const canvasMeasurement = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].measureText(this._text, this._style);
            width = canvasMeasurement.width;
            height = canvasMeasurement.height;
        }
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * height;
        bounds.maxY = bounds.minY + height;
    }
}
;
 //# sourceMappingURL=Text.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BitmapText",
    ()=>BitmapText
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$AbstractText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/AbstractText.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/TextStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapFontManager$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
class BitmapText extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$AbstractText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AbstractText"] {
    constructor(...args){
        var _a;
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$AbstractText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ensureTextOptions"])(args, "BitmapText");
        options.style ?? (options.style = options.style || {});
        (_a = options.style).fill ?? (_a.fill = 16777215);
        super(options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextStyle"]);
        /** @internal */ this.renderPipeId = "bitmapText";
    }
    /**
   * @param now - The current time in milliseconds.
   * @internal
   */ _onTouch(now) {
        this._gcLastUsed = now;
        for(const key in this._gpuData){
            this._gpuData[key]?._onTouch(now);
        }
    }
    /** @private */ updateBounds() {
        const bounds = this._bounds;
        const anchor = this._anchor;
        const bitmapMeasurement = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapFontManager$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BitmapFontManager"].measureText(this.text, this._style);
        const scale = bitmapMeasurement.scale;
        const offset = bitmapMeasurement.offsetY * scale;
        let width = bitmapMeasurement.width * scale;
        let height = bitmapMeasurement.height * scale;
        const stroke = this._style._stroke;
        if (stroke) {
            width += stroke.width;
            height += stroke.width;
        }
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * (height + offset);
        bounds.maxY = bounds.minY + height;
    }
    /**
   * The resolution / device pixel ratio for text rendering.
   * Unlike other text types, BitmapText resolution is managed by the BitmapFont.
   * Individual resolution changes are not supported.
   * @example
   * ```ts
   * //  Incorrect: Setting resolution directly (will trigger warning)
   * const text = new BitmapText({
   *     text: 'Hello',
   *     resolution: 2 // This will be ignored
   * });
   *
   * //  Correct: Set resolution when installing the font
   * BitmapFont.install({
   *     name: 'MyFont',
   *     style: {
   *         fontFamily: 'Arial',
   *     },
   *     resolution: 2 // Resolution is set here
   * });
   *
   * const text = new BitmapText({
   *     text: 'Hello',
   *     style: {
   *         fontFamily: 'MyFont' // Uses font's resolution
   *     }
   * });
   * ```
   * @default 1
   * @see {@link BitmapFont.install} For setting font resolution
   * @throws {Warning} When attempting to change resolution directly
   * @readonly
   */ set resolution(value) {
        if (value !== null) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])(// eslint-disable-next-line max-len
            "[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont.");
        }
    }
    get resolution() {
        return this._resolution;
    }
}
;
 //# sourceMappingURL=BitmapText.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "textStyleToCSS",
    ()=>textStyleToCSS
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
;
"use strict";
function textStyleToCSS(style) {
    const stroke = style._stroke;
    const fill = style._fill;
    const cssStyleString = [
        `color: ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(fill.color).toHex()}`,
        `font-size: ${style.fontSize}px`,
        `font-family: ${style.fontFamily}`,
        `font-weight: ${style.fontWeight}`,
        `font-style: ${style.fontStyle}`,
        `font-variant: ${style.fontVariant}`,
        `letter-spacing: ${style.letterSpacing}px`,
        `text-align: ${style.align}`,
        `padding: ${style.padding}px`,
        `white-space: ${style.whiteSpace === "pre" && style.wordWrap ? "pre-wrap" : style.whiteSpace}`,
        ...style.lineHeight ? [
            `line-height: ${style.lineHeight}px`
        ] : [],
        ...style.wordWrap ? [
            `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,
            `max-width: ${style.wordWrapWidth}px`
        ] : [],
        ...stroke ? [
            strokeToCSS(stroke)
        ] : [],
        ...style.dropShadow ? [
            dropShadowToCSS(style.dropShadow)
        ] : [],
        ...style.cssOverrides
    ].join(";");
    const cssStyles = [
        `div { ${cssStyleString} }`
    ];
    tagStyleToCSS(style.tagStyles, cssStyles);
    return cssStyles.join(" ");
}
function dropShadowToCSS(dropShadowStyle) {
    const color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();
    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);
    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);
    const position = `${x}px ${y}px`;
    if (dropShadowStyle.blur > 0) {
        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;
    }
    return `text-shadow: ${position} ${color}`;
}
function strokeToCSS(stroke) {
    return [
        `-webkit-text-stroke-width: ${stroke.width}px`,
        `-webkit-text-stroke-color: ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(stroke.color).toHex()}`,
        `text-stroke-width: ${stroke.width}px`,
        `text-stroke-color: ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(stroke.color).toHex()}`,
        "paint-order: stroke"
    ].join(";");
}
const templates = {
    fontSize: `font-size: {{VALUE}}px`,
    fontFamily: `font-family: {{VALUE}}`,
    fontWeight: `font-weight: {{VALUE}}`,
    fontStyle: `font-style: {{VALUE}}`,
    fontVariant: `font-variant: {{VALUE}}`,
    letterSpacing: `letter-spacing: {{VALUE}}px`,
    align: `text-align: {{VALUE}}`,
    padding: `padding: {{VALUE}}px`,
    whiteSpace: `white-space: {{VALUE}}`,
    lineHeight: `line-height: {{VALUE}}px`,
    wordWrapWidth: `max-width: {{VALUE}}px`
};
const transform = {
    fill: (value)=>`color: ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(value).toHex()}`,
    breakWords: (value)=>`word-wrap: ${value ? "break-all" : "break-word"}`,
    stroke: strokeToCSS,
    dropShadow: dropShadowToCSS
};
function tagStyleToCSS(tagStyles, out) {
    for(const i in tagStyles){
        const tagStyle = tagStyles[i];
        const cssTagStyle = [];
        for(const j in tagStyle){
            if (transform[j]) {
                cssTagStyle.push(transform[j](tagStyle[j]));
            } else if (templates[j]) {
                cssTagStyle.push(templates[j].replace("{{VALUE}}", tagStyle[j]));
            }
        }
        out.push(`${i} { ${cssTagStyle.join(";")} }`);
    }
}
;
 //# sourceMappingURL=textStyleToCSS.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HTMLTextStyle",
    ()=>HTMLTextStyle
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/TextStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$textStyleToCSS$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
class HTMLTextStyle extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextStyle"] {
    constructor(options = {}){
        super(options);
        this._cssOverrides = [];
        this.cssOverrides = options.cssOverrides ?? [];
        this.tagStyles = options.tagStyles ?? {};
    }
    /**
   * List of CSS style overrides to apply to the HTML text.
   * These styles are added after the built-in styles and can override any default styling.
   * @advanced
   */ set cssOverrides(value) {
        this._cssOverrides = value instanceof Array ? value : [
            value
        ];
        this.update();
    }
    /** @advanced */ get cssOverrides() {
        return this._cssOverrides;
    }
    /**
   * Updates the text style and triggers a refresh of the CSS style cache.
   * This method is called automatically when style properties are changed.
   * @example
   * ```ts
   * // Update after multiple changes
   * const text = new HTMLText({
   *     text: 'Hello World',
   *     style
   * });
   *
   * style.fontSize = 32;
   * style.fill = '#00ff00';
   * style.fontFamily = 'Arial';
   * style.update(); // Apply all changes at once
   * ```
   * @advanced
   * @see {@link HTMLTextStyle#cssStyle} For accessing the generated CSS
   * @see {@link HTMLTextStyle#cssOverrides} For managing CSS overrides
   */ update() {
        this._cssStyle = null;
        super.update();
    }
    /**
   * Creates a new HTMLTextStyle object with the same values as this one.
   * This creates a deep copy of all style properties, including dropShadow and tag styles.
   * @example
   * ```ts
   * // Create original style
   * const originalStyle = new HTMLTextStyle({
   *     fontSize: 24,
   *     fill: '#ff0000',
   *     tagStyles: {
   *         header: { fontSize: 32, fill: '#00ff00' }
   *     }
   * });
   *
   * // Clone the style
   * const clonedStyle = originalStyle.clone();
   *
   * // Modify cloned style independently
   * clonedStyle.fontSize = 36;
   * clonedStyle.fill = '#0000ff';
   *
   * // Original style remains unchanged
   * console.log(originalStyle.fontSize); // Still 24
   * console.log(originalStyle.fill); // Still '#ff0000'
   * ```
   *
   * Properties that are cloned:
   * - Basic text properties (fontSize, fontFamily, etc.)
   * - Fill and stroke styles
   * - Drop shadow configuration
   * - CSS overrides
   * - Tag styles (deep copied)
   * - Word wrap settings
   * - Alignment and spacing
   * @returns {HTMLTextStyle} A new HTMLTextStyle instance with the same properties
   * @see {@link HTMLTextStyle} For available style properties
   * @see {@link HTMLTextStyle#cssOverrides} For CSS override handling
   * @see {@link HTMLTextStyle#tagStyles} For tag style configuration
   * @standard
   */ clone() {
        return new HTMLTextStyle({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this.dropShadow ? {
                ...this.dropShadow
            } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            cssOverrides: this.cssOverrides,
            tagStyles: {
                ...this.tagStyles
            }
        });
    }
    /**
   * The CSS style string that will be applied to the HTML text.
   * @advanced
   */ get cssStyle() {
        if (!this._cssStyle) {
            this._cssStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$textStyleToCSS$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["textStyleToCSS"])(this);
        }
        return this._cssStyle;
    }
    /**
   * Add a style override, this can be any CSS property
   * it will override any built-in style. This is the
   * property and the value as a string (e.g., `color: red`).
   * This will override any other internal style.
   * @param {string} value - CSS style(s) to add.
   * @example
   * style.addOverride('background-color: red');
   * @advanced
   */ addOverride(...value) {
        const toAdd = value.filter((v)=>!this.cssOverrides.includes(v));
        if (toAdd.length > 0) {
            this.cssOverrides.push(...toAdd);
            this.update();
        }
    }
    /**
   * Remove any overrides that match the value.
   * @param {string} value - CSS style to remove.
   * @example
   * style.removeOverride('background-color: red');
   * @advanced
   */ removeOverride(...value) {
        const toRemove = value.filter((v)=>this.cssOverrides.includes(v));
        if (toRemove.length > 0) {
            this.cssOverrides = this.cssOverrides.filter((v)=>!toRemove.includes(v));
            this.update();
        }
    }
    /**
   * Sets the fill style for the text. HTML text only supports color fills (string or number values).
   * Texture fills are not supported and will trigger a warning in debug mode.
   * @example
   * ```ts
   * // Using hex colors
   * const text = new HTMLText({
   *     text: 'Colored Text',
   *     style: {
   *         fill: 0xff0000 // Red color
   *     }
   * });
   *
   * // Using CSS color strings
   * text.style.fill = '#00ff00';     // Hex string (Green)
   * text.style.fill = 'blue';        // Named color
   * text.style.fill = 'rgb(255,0,0)' // RGB
   * text.style.fill = '#f0f';        // Short hex
   *
   * // Invalid usage (will trigger warning in debug)
   * text.style.fill = {
   *     type: 'pattern',
   *     texture: Texture.from('pattern.png')
   * }; // Not supported, falls back to default
   * ```
   * @param value - The fill color to use. Must be a string or number.
   * @throws {Warning} In debug mode when attempting to use unsupported fill types
   * @see {@link TextStyle#fill} For full fill options in canvas text
   * @standard
   */ set fill(value) {
        if (typeof value !== "string" && typeof value !== "number") {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("[HTMLTextStyle] only color fill is not supported by HTMLText");
        }
        super.fill = value;
    }
    /**
   * Sets the stroke style for the text. HTML text only supports color strokes (string or number values).
   * Texture strokes are not supported and will trigger a warning in debug mode.
   * @example
   * ```ts
   * // Using hex colors
   * const text = new HTMLText({
   *     text: 'Outlined Text',
   *     style: {
   *         stroke: 0xff0000 // Red outline
   *     }
   * });
   *
   * // Using CSS color strings
   * text.style.stroke = '#00ff00';     // Hex string (Green)
   * text.style.stroke = 'blue';        // Named color
   * text.style.stroke = 'rgb(255,0,0)' // RGB
   * text.style.stroke = '#f0f';        // Short hex
   *
   * // Using stroke width
   * text.style = {
   *     stroke: {
   *         color: '#ff0000',
   *         width: 2
   *     }
   * };
   *
   * // Remove stroke
   * text.style.stroke = null;
   *
   * // Invalid usage (will trigger warning in debug)
   * text.style.stroke = {
   *     type: 'pattern',
   *     texture: Texture.from('pattern.png')
   * }; // Not supported, falls back to default
   * ```
   * @param value - The stroke style to use. Must be a string, number, or stroke configuration object
   * @throws {Warning} In debug mode when attempting to use unsupported stroke types
   * @see {@link TextStyle#stroke} For full stroke options in canvas text
   * @standard
   */ set stroke(value) {
        if (value && typeof value !== "string" && typeof value !== "number") {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("[HTMLTextStyle] only color stroke is not supported by HTMLText");
        }
        super.stroke = value;
    }
}
;
 //# sourceMappingURL=HTMLTextStyle.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HTMLTextRenderData",
    ()=>HTMLTextRenderData
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-ssr] (ecmascript)");
;
"use strict";
const nssvg = "http://www.w3.org/2000/svg";
const nsxhtml = "http://www.w3.org/1999/xhtml";
class HTMLTextRenderData {
    constructor(){
        this.svgRoot = document.createElementNS(nssvg, "svg");
        this.foreignObject = document.createElementNS(nssvg, "foreignObject");
        this.domElement = document.createElementNS(nsxhtml, "div");
        this.styleElement = document.createElementNS(nsxhtml, "style");
        const { foreignObject, svgRoot, styleElement, domElement } = this;
        foreignObject.setAttribute("width", "10000");
        foreignObject.setAttribute("height", "10000");
        foreignObject.style.overflow = "hidden";
        svgRoot.appendChild(foreignObject);
        foreignObject.appendChild(styleElement);
        foreignObject.appendChild(domElement);
        this.image = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DOMAdapter"].get().createImage();
    }
    destroy() {
        this.svgRoot.remove();
        this.foreignObject.remove();
        this.styleElement.remove();
        this.domElement.remove();
        this.image.src = "";
        this.image.remove();
        this.svgRoot = null;
        this.foreignObject = null;
        this.styleElement = null;
        this.domElement = null;
        this.image = null;
        this.canvasAndContext = null;
    }
}
;
 //# sourceMappingURL=HTMLTextRenderData.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "measureHtmlText",
    ()=>measureHtmlText
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$HTMLTextRenderData$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs [app-ssr] (ecmascript)");
;
"use strict";
let tempHTMLTextRenderData;
function measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {
    htmlTextRenderData || (htmlTextRenderData = tempHTMLTextRenderData || (tempHTMLTextRenderData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$HTMLTextRenderData$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HTMLTextRenderData"]()));
    const { domElement, styleElement, svgRoot } = htmlTextRenderData;
    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;
    domElement.setAttribute("style", "transform-origin: top left; display: inline-block");
    if (fontStyleCSS) {
        styleElement.textContent = fontStyleCSS;
    }
    document.body.appendChild(svgRoot);
    const contentBounds = domElement.getBoundingClientRect();
    svgRoot.remove();
    const doublePadding = style.padding * 2;
    return {
        width: contentBounds.width - doublePadding,
        height: contentBounds.height - doublePadding
    };
}
;
 //# sourceMappingURL=measureHtmlText.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/HTMLText.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HTMLText",
    ()=>HTMLText
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$AbstractText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/AbstractText.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$HTMLTextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$measureHtmlText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
class HTMLText extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$AbstractText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AbstractText"] {
    constructor(...args){
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$AbstractText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ensureTextOptions"])(args, "HtmlText");
        super(options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$HTMLTextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HTMLTextStyle"]);
        /** @internal */ this.renderPipeId = "htmlText";
        if (options.textureStyle) {
            this.textureStyle = options.textureStyle instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextureStyle"] ? options.textureStyle : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextureStyle"](options.textureStyle);
        }
    }
    /** @private */ updateBounds() {
        const bounds = this._bounds;
        const anchor = this._anchor;
        const htmlMeasurement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$measureHtmlText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["measureHtmlText"])(this.text, this._style);
        const { width, height } = htmlMeasurement;
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * height;
        bounds.maxY = bounds.minY + height;
    }
    get text() {
        return this._text;
    }
    /**
   * The text content to display. Use '\n' for line breaks.
   * Accepts strings, numbers, or objects with toString() method.
   * @example
   * ```ts
   * const text = new HTMLText({
   *     text: 'Hello Pixi!',
   * });
   * const multilineText = new HTMLText({
   *     text: 'Line 1\nLine 2\nLine 3',
   * });
   * const numberText = new HTMLText({
   *     text: 12345, // Will be converted to '12345'
   * });
   * const objectText = new HTMLText({
   *     text: { toString: () => 'Object Text' }, // Custom toString
   * });
   *
   * // Update text dynamically
   * text.text = 'Updated Text'; // Re-renders with new text
   * text.text = 67890; // Updates to '67890'
   * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method
   * // Clear text
   * text.text = ''; // Clears the text
   * ```
   * @default ''
   */ set text(text) {
        const sanitisedText = this._sanitiseText(text.toString());
        super.text = sanitisedText;
    }
    /**
   * Sanitise text - replace `<br>` with `<br/>`, `&nbsp;` with `&#160;`
   * @param text
   * @see https://www.sitepoint.com/community/t/xhtml-1-0-transitional-xml-parsing-error-entity-nbsp-not-defined/3392/3
   */ _sanitiseText(text) {
        return this._removeInvalidHtmlTags(text.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;"));
    }
    _removeInvalidHtmlTags(input) {
        const brokenTagPattern = /<[^>]*?(?=<|$)/g;
        return input.replace(brokenTagPattern, "");
    }
}
;
 //# sourceMappingURL=HTMLText.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GlGraphicsAdaptor",
    ()=>GlGraphicsAdaptor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$colorBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$generateTextureBatchBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$localUniformBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$gl$2f$shader$2f$getBatchSamplersUniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
"use strict";
class GlGraphicsAdaptor {
    contextChange(renderer) {
        const uniforms = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UniformGroup"]({
            uColor: {
                value: new Float32Array([
                    1,
                    1,
                    1,
                    1
                ]),
                type: "vec4<f32>"
            },
            uTransformMatrix: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"](),
                type: "mat3x3<f32>"
            },
            uRound: {
                value: 0,
                type: "f32"
            }
        });
        const maxTextures = renderer.limits.maxBatchableTextures;
        const glProgram = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compileHighShaderGlProgram"])({
            name: "graphics",
            bits: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$colorBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["colorBitGl"],
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$generateTextureBatchBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generateTextureBatchBitGl"])(maxTextures),
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$localUniformBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["localUniformBitGl"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundPixelsBitGl"]
            ]
        });
        this.shader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Shader"]({
            glProgram,
            resources: {
                localUniforms: uniforms,
                batchSamplers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$gl$2f$shader$2f$getBatchSamplersUniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getBatchSamplersUniformGroup"])(maxTextures)
            }
        });
    }
    execute(graphicsPipe, renderable) {
        const context = renderable.context;
        const shader = context.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        const { batcher, instructions } = contextSystem.getContextRenderData(context);
        shader.groups[0] = renderer.globalUniforms.bindGroup;
        renderer.state.set(graphicsPipe.state);
        renderer.shader.bind(shader);
        renderer.geometry.bind(batcher.geometry, shader.glProgram);
        const batches = instructions.instructions;
        for(let i = 0; i < instructions.instructionSize; i++){
            const batch = batches[i];
            if (batch.size) {
                for(let j = 0; j < batch.textures.count; j++){
                    renderer.texture.bind(batch.textures.textures[j], j);
                }
                renderer.geometry.draw(batch.topology, batch.size, batch.start);
            }
        }
    }
    destroy() {
        this.shader.destroy(true);
        this.shader = null;
    }
}
/** @ignore */ GlGraphicsAdaptor.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipesAdaptor
    ],
    name: "graphics"
};
;
 //# sourceMappingURL=GlGraphicsAdaptor.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GlMeshAdaptor",
    ()=>GlMeshAdaptor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$localUniformBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$textureBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
"use strict";
class GlMeshAdaptor {
    init() {
        const glProgram = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compileHighShaderGlProgram"])({
            name: "mesh",
            bits: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$localUniformBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["localUniformBitGl"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$textureBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["textureBitGl"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundPixelsBitGl"]
            ]
        });
        this._shader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Shader"]({
            glProgram,
            resources: {
                uTexture: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY.source,
                textureUniforms: {
                    uTextureMatrix: {
                        type: "mat3x3<f32>",
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]()
                    }
                }
            }
        });
    }
    execute(meshPipe, mesh) {
        const renderer = meshPipe.renderer;
        let shader = mesh._shader;
        if (!shader) {
            shader = this._shader;
            const texture = mesh.texture;
            const source = texture.source;
            shader.resources.uTexture = source;
            shader.resources.uSampler = source.style;
            shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;
        } else if (!shader.glProgram) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("Mesh shader has no glProgram", mesh.shader);
            return;
        }
        shader.groups[100] = renderer.globalUniforms.bindGroup;
        shader.groups[101] = meshPipe.localUniformsBindGroup;
        renderer.encoder.draw({
            geometry: mesh._geometry,
            shader,
            state: mesh.state
        });
    }
    destroy() {
        this._shader.destroy(true);
        this._shader = null;
    }
}
GlMeshAdaptor.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipesAdaptor
    ],
    name: "mesh"
};
;
 //# sourceMappingURL=GlMeshAdaptor.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CustomRenderPipe",
    ()=>CustomRenderPipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
;
"use strict";
class CustomRenderPipe {
    constructor(renderer){
        this._renderer = renderer;
    }
    updateRenderable() {}
    destroyRenderable() {}
    validateRenderable() {
        return false;
    }
    addRenderable(container, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add(container);
    }
    execute(container) {
        if (!container.isRenderable) return;
        container.render(this._renderer);
    }
    destroy() {
        this._renderer = null;
    }
}
CustomRenderPipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasPipes
    ],
    name: "customRender"
};
;
 //# sourceMappingURL=CustomRenderPipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BatchableSprite",
    ()=>BatchableSprite
]);
"use strict";
class BatchableSprite {
    constructor(){
        this.batcherName = "default";
        this.topology = "triangle-list";
        // batch specific..
        this.attributeSize = 4;
        this.indexSize = 6;
        this.packAsQuad = true;
        this.roundPixels = 0;
        this._attributeStart = 0;
        // location in the buffer
        this._batcher = null;
        this._batch = null;
    }
    get blendMode() {
        return this.renderable.groupBlendMode;
    }
    get color() {
        return this.renderable.groupColorAlpha;
    }
    reset() {
        this.renderable = null;
        this.texture = null;
        this._batcher = null;
        this._batch = null;
        this.bounds = null;
    }
    destroy() {
        this.reset();
    }
}
;
 //# sourceMappingURL=BatchableSprite.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "executeInstructions",
    ()=>executeInstructions
]);
"use strict";
function executeInstructions(renderGroup, renderer) {
    const instructionSet = renderGroup.instructionSet;
    const instructions = instructionSet.instructions;
    for(let i = 0; i < instructionSet.instructionSize; i++){
        const instruction = instructions[i];
        renderer[instruction.renderPipeId].execute(instruction);
    }
}
;
 //# sourceMappingURL=executeInstructions.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RenderGroupPipe",
    ()=>RenderGroupPipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$BatchableSprite$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$executeInstructions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
"use strict";
const tempMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
class RenderGroupPipe {
    constructor(renderer){
        this._renderer = renderer;
    }
    addRenderGroup(renderGroup, instructionSet) {
        if (renderGroup.isCachedAsTexture) {
            this._addRenderableCacheAsTexture(renderGroup, instructionSet);
        } else {
            this._addRenderableDirect(renderGroup, instructionSet);
        }
    }
    execute(renderGroup) {
        if (!renderGroup.isRenderable) return;
        if (renderGroup.isCachedAsTexture) {
            this._executeCacheAsTexture(renderGroup);
        } else {
            this._executeDirect(renderGroup);
        }
    }
    destroy() {
        this._renderer = null;
    }
    _addRenderableDirect(renderGroup, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        if (renderGroup._batchableRenderGroup) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].return(renderGroup._batchableRenderGroup);
            renderGroup._batchableRenderGroup = null;
        }
        instructionSet.add(renderGroup);
    }
    _addRenderableCacheAsTexture(renderGroup, instructionSet) {
        const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$BatchableSprite$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BatchableSprite"]));
        batchableRenderGroup.renderable = renderGroup.root;
        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;
        batchableRenderGroup.texture = renderGroup.texture;
        batchableRenderGroup.bounds = renderGroup._textureBounds;
        instructionSet.add(renderGroup);
        this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);
        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);
        this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);
    }
    _executeCacheAsTexture(renderGroup) {
        if (renderGroup.textureNeedsUpdate) {
            renderGroup.textureNeedsUpdate = false;
            const worldTransformMatrix = tempMatrix.identity().translate(-renderGroup._textureBounds.x, -renderGroup._textureBounds.y);
            this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);
            this._renderer.globalUniforms.push({
                worldTransformMatrix,
                worldColor: 4294967295,
                offset: {
                    x: 0,
                    y: 0
                }
            });
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$executeInstructions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["executeInstructions"])(renderGroup, this._renderer.renderPipes);
            this._renderer.renderTarget.finishRenderPass();
            this._renderer.renderTarget.pop();
            this._renderer.globalUniforms.pop();
        }
        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);
        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();
    }
    _executeDirect(renderGroup) {
        this._renderer.globalUniforms.push({
            worldTransformMatrix: renderGroup.inverseParentTextureTransform,
            worldColor: renderGroup.worldColorAlpha
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$executeInstructions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["executeInstructions"])(renderGroup, this._renderer.renderPipes);
        this._renderer.globalUniforms.pop();
    }
}
RenderGroupPipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasPipes
    ],
    name: "renderGroup"
};
;
 //# sourceMappingURL=RenderGroupPipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/utils/clearList.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clearList",
    ()=>clearList
]);
"use strict";
function clearList(list, index) {
    index || (index = 0);
    for(let j = index; j < list.length; j++){
        if (list[j]) {
            list[j] = null;
        } else {
            break;
        }
    }
}
;
 //# sourceMappingURL=clearList.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "updateRenderGroupTransform",
    ()=>updateRenderGroupTransform,
    "updateRenderGroupTransforms",
    ()=>updateRenderGroupTransforms,
    "updateTransformAndChildren",
    ()=>updateTransformAndChildren
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/Container.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$clearList$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/clearList.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$multiplyColors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
const tempContainer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Container"]();
const UPDATE_BLEND_COLOR_VISIBLE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UPDATE_VISIBLE"] | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UPDATE_COLOR"] | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UPDATE_BLEND"];
function updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {
    updateRenderGroupTransform(renderGroup);
    const childrenToUpdate = renderGroup.childrenToUpdate;
    const updateTick = renderGroup.updateTick++;
    for(const j in childrenToUpdate){
        const renderGroupDepth = Number(j);
        const childrenAtDepth = childrenToUpdate[j];
        const list = childrenAtDepth.list;
        const index = childrenAtDepth.index;
        for(let i = 0; i < index; i++){
            const child = list[i];
            if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {
                updateTransformAndChildren(child, updateTick, 0);
            }
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$clearList$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clearList"])(list, index);
        childrenAtDepth.index = 0;
    }
    if (updateChildRenderGroups) {
        for(let i = 0; i < renderGroup.renderGroupChildren.length; i++){
            updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);
        }
    }
}
function updateRenderGroupTransform(renderGroup) {
    const root = renderGroup.root;
    let worldAlpha;
    if (renderGroup.renderGroupParent) {
        const renderGroupParent = renderGroup.renderGroupParent;
        renderGroup.worldTransform.appendFrom(root.relativeGroupTransform, renderGroupParent.worldTransform);
        renderGroup.worldColor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$multiplyColors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiplyColors"])(root.groupColor, renderGroupParent.worldColor);
        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;
    } else {
        renderGroup.worldTransform.copyFrom(root.localTransform);
        renderGroup.worldColor = root.localColor;
        worldAlpha = root.localAlpha;
    }
    worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
    renderGroup.worldAlpha = worldAlpha;
    renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);
}
function updateTransformAndChildren(container, updateTick, updateFlags) {
    if (updateTick === container.updateTick) return;
    container.updateTick = updateTick;
    container.didChange = false;
    const localTransform = container.localTransform;
    container.updateLocalTransform();
    const parent = container.parent;
    if (parent && !parent.renderGroup) {
        updateFlags |= container._updateFlags;
        container.relativeGroupTransform.appendFrom(localTransform, parent.relativeGroupTransform);
        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
            updateColorBlendVisibility(container, parent, updateFlags);
        }
    } else {
        updateFlags = container._updateFlags;
        container.relativeGroupTransform.copyFrom(localTransform);
        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
            updateColorBlendVisibility(container, tempContainer, updateFlags);
        }
    }
    if (!container.renderGroup) {
        const children = container.children;
        const length = children.length;
        for(let i = 0; i < length; i++){
            updateTransformAndChildren(children[i], updateTick, updateFlags);
        }
        const renderGroup = container.parentRenderGroup;
        const renderable = container;
        if (renderable.renderPipeId && !renderGroup.structureDidChange) {
            renderGroup.updateRenderable(renderable);
        }
    }
}
function updateColorBlendVisibility(container, parent, updateFlags) {
    if (updateFlags & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UPDATE_COLOR"]) {
        container.groupColor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$multiplyColors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiplyColors"])(container.localColor, parent.groupColor);
        let groupAlpha = container.localAlpha * parent.groupAlpha;
        groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;
        container.groupAlpha = groupAlpha;
        container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);
    }
    if (updateFlags & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UPDATE_BLEND"]) {
        container.groupBlendMode = container.localBlendMode === "inherit" ? parent.groupBlendMode : container.localBlendMode;
    }
    if (updateFlags & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UPDATE_VISIBLE"]) {
        container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;
    }
    container._updateFlags = 0;
}
;
 //# sourceMappingURL=updateRenderGroupTransforms.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "validateRenderables",
    ()=>validateRenderables
]);
"use strict";
function validateRenderables(renderGroup, renderPipes) {
    const { list } = renderGroup.childrenRenderablesToUpdate;
    let rebuildRequired = false;
    for(let i = 0; i < renderGroup.childrenRenderablesToUpdate.index; i++){
        const container = list[i];
        const renderable = container;
        const pipe = renderPipes[renderable.renderPipeId];
        rebuildRequired = pipe.validateRenderable(container);
        if (rebuildRequired) {
            break;
        }
    }
    renderGroup.structureDidChange = rebuildRequired;
    return rebuildRequired;
}
;
 //# sourceMappingURL=validateRenderables.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RenderGroupSystem",
    ()=>RenderGroupSystem
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$clearList$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/clearList.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$executeInstructions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$updateRenderGroupTransforms$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$validateRenderables$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
"use strict";
const tempMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
class RenderGroupSystem {
    constructor(renderer){
        this._renderer = renderer;
    }
    render({ container, transform }) {
        const parent = container.parent;
        const renderGroupParent = container.renderGroup.renderGroupParent;
        container.parent = null;
        container.renderGroup.renderGroupParent = null;
        const renderer = this._renderer;
        const originalLocalTransform = tempMatrix;
        if (transform) {
            originalLocalTransform.copyFrom(container.renderGroup.localTransform);
            container.renderGroup.localTransform.copyFrom(transform);
        }
        const renderPipes = renderer.renderPipes;
        this._updateCachedRenderGroups(container.renderGroup, null);
        this._updateRenderGroups(container.renderGroup);
        renderer.globalUniforms.start({
            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,
            worldColor: container.renderGroup.worldColorAlpha
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$executeInstructions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["executeInstructions"])(container.renderGroup, renderPipes);
        if (renderPipes.uniformBatch) {
            renderPipes.uniformBatch.renderEnd();
        }
        if (transform) {
            container.renderGroup.localTransform.copyFrom(originalLocalTransform);
        }
        container.parent = parent;
        container.renderGroup.renderGroupParent = renderGroupParent;
    }
    destroy() {
        this._renderer = null;
    }
    _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {
        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;
        if (renderGroup.isCachedAsTexture) {
            if (!renderGroup.textureNeedsUpdate) return;
            closestCacheAsTexture = renderGroup;
        }
        for(let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--){
            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);
        }
        renderGroup.invalidateMatrices();
        if (renderGroup.isCachedAsTexture) {
            if (renderGroup.textureNeedsUpdate) {
                const bounds = renderGroup.root.getLocalBounds();
                bounds.ceil();
                const lastTexture = renderGroup.texture;
                if (renderGroup.texture) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].returnTexture(renderGroup.texture, true);
                }
                const renderer = this._renderer;
                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;
                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;
                const scaleMode = renderGroup.textureOptions.scaleMode ?? "linear";
                const texture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].getOptimalTexture(bounds.width, bounds.height, resolution, antialias);
                texture._source.style = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextureStyle"]({
                    scaleMode
                });
                renderGroup.texture = texture;
                renderGroup._textureBounds || (renderGroup._textureBounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bounds"]());
                renderGroup._textureBounds.copyFrom(bounds);
                if (lastTexture !== renderGroup.texture) {
                    if (renderGroup.renderGroupParent) {
                        renderGroup.renderGroupParent.structureDidChange = true;
                    }
                }
            }
        } else if (renderGroup.texture) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].returnTexture(renderGroup.texture, true);
            renderGroup.texture = null;
        }
    }
    _updateRenderGroups(renderGroup) {
        const renderer = this._renderer;
        const renderPipes = renderer.renderPipes;
        renderGroup.runOnRender(renderer);
        renderGroup.instructionSet.renderPipes = renderPipes;
        if (!renderGroup.structureDidChange) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$validateRenderables$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateRenderables"])(renderGroup, renderPipes);
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$clearList$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clearList"])(renderGroup.childrenRenderablesToUpdate.list, 0);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$updateRenderGroupTransforms$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["updateRenderGroupTransforms"])(renderGroup);
        if (renderGroup.structureDidChange) {
            renderGroup.structureDidChange = false;
            this._buildInstructions(renderGroup, renderer);
        } else {
            this._updateRenderables(renderGroup);
        }
        renderGroup.childrenRenderablesToUpdate.index = 0;
        renderer.renderPipes.batch.upload(renderGroup.instructionSet);
        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;
        for(let i = 0; i < renderGroup.renderGroupChildren.length; i++){
            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);
        }
    }
    _updateRenderables(renderGroup) {
        const { list, index } = renderGroup.childrenRenderablesToUpdate;
        for(let i = 0; i < index; i++){
            const container = list[i];
            if (container.didViewUpdate) {
                renderGroup.updateRenderable(container);
            }
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$clearList$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clearList"])(list, index);
    }
    _buildInstructions(renderGroup, rendererOrPipes) {
        const root = renderGroup.root;
        const instructionSet = renderGroup.instructionSet;
        instructionSet.reset();
        const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
        const renderPipes = renderer.renderPipes;
        renderPipes.batch.buildStart(instructionSet);
        renderPipes.blendMode.buildStart();
        renderPipes.colorMask.buildStart();
        if (root.sortableChildren) {
            root.sortChildren();
        }
        root.collectRenderablesWithEffects(instructionSet, renderer, null);
        renderPipes.batch.buildEnd(instructionSet);
        renderPipes.blendMode.buildEnd(instructionSet);
    }
}
/** @ignore */ RenderGroupSystem.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasSystem
    ],
    name: "renderGroup"
};
;
 //# sourceMappingURL=RenderGroupSystem.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SpritePipe",
    ()=>SpritePipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$BatchableSprite$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
class SpritePipe {
    constructor(renderer){
        this._renderer = renderer;
    }
    addRenderable(sprite, instructionSet) {
        const gpuSprite = this._getGpuSprite(sprite);
        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);
        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
    }
    updateRenderable(sprite) {
        const gpuSprite = this._getGpuSprite(sprite);
        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);
        gpuSprite._batcher.updateElement(gpuSprite);
    }
    validateRenderable(sprite) {
        const gpuSprite = this._getGpuSprite(sprite);
        return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, sprite._texture);
    }
    _updateBatchableSprite(sprite, batchableSprite) {
        batchableSprite.bounds = sprite.visualBounds;
        batchableSprite.texture = sprite._texture;
    }
    _getGpuSprite(sprite) {
        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);
    }
    _initGPUSprite(sprite) {
        const batchableSprite = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$BatchableSprite$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BatchableSprite"]();
        batchableSprite.renderable = sprite;
        batchableSprite.transform = sprite.groupTransform;
        batchableSprite.texture = sprite._texture;
        batchableSprite.bounds = sprite.visualBounds;
        batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
        sprite._gpuData[this._renderer.uid] = batchableSprite;
        return batchableSprite;
    }
    destroy() {
        this._renderer = null;
    }
}
/** @ignore */ SpritePipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasPipes
    ],
    name: "sprite"
};
;
 //# sourceMappingURL=SpritePipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "color32BitToUniform",
    ()=>color32BitToUniform,
    "colorToUniform",
    ()=>colorToUniform
]);
"use strict";
function colorToUniform(rgb, alpha, out, offset) {
    out[offset++] = (rgb >> 16 & 255) / 255;
    out[offset++] = (rgb >> 8 & 255) / 255;
    out[offset++] = (rgb & 255) / 255;
    out[offset++] = alpha;
}
function color32BitToUniform(abgr, out, offset) {
    const alpha = (abgr >> 24 & 255) / 255;
    out[offset++] = (abgr & 255) / 255 * alpha;
    out[offset++] = (abgr >> 8 & 255) / 255 * alpha;
    out[offset++] = (abgr >> 16 & 255) / 255 * alpha;
    out[offset++] = alpha;
}
;
 //# sourceMappingURL=colorToUniform.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GpuGraphicsAdaptor",
    ()=>GpuGraphicsAdaptor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$batcher$2f$gpu$2f$getTextureBatchBindGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$colorBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$generateTextureBatchBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$localUniformBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
"use strict";
class GpuGraphicsAdaptor {
    constructor(){
        this._maxTextures = 0;
    }
    contextChange(renderer) {
        const localUniforms = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UniformGroup"]({
            uTransformMatrix: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"](),
                type: "mat3x3<f32>"
            },
            uColor: {
                value: new Float32Array([
                    1,
                    1,
                    1,
                    1
                ]),
                type: "vec4<f32>"
            },
            uRound: {
                value: 0,
                type: "f32"
            }
        });
        this._maxTextures = renderer.limits.maxBatchableTextures;
        const gpuProgram = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compileHighShaderGpuProgram"])({
            name: "graphics",
            bits: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$colorBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["colorBit"],
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$generateTextureBatchBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generateTextureBatchBit"])(this._maxTextures),
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$localUniformBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["localUniformBitGroup2"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundPixelsBit"]
            ]
        });
        this.shader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Shader"]({
            gpuProgram,
            resources: {
                // added on the fly!
                localUniforms
            }
        });
    }
    execute(graphicsPipe, renderable) {
        const context = renderable.context;
        const shader = context.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        const { batcher, instructions } = contextSystem.getContextRenderData(context);
        const encoder = renderer.encoder;
        encoder.setGeometry(batcher.geometry, shader.gpuProgram);
        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
        const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
        const batches = instructions.instructions;
        let topology = null;
        for(let i = 0; i < instructions.instructionSize; i++){
            const batch = batches[i];
            if (batch.topology !== topology) {
                topology = batch.topology;
                encoder.setPipelineFromGeometryProgramAndState(batcher.geometry, shader.gpuProgram, graphicsPipe.state, batch.topology);
            }
            shader.groups[1] = batch.bindGroup;
            if (!batch.gpuBindGroup) {
                const textureBatch = batch.textures;
                batch.bindGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$batcher$2f$gpu$2f$getTextureBatchBindGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getTextureBatchBindGroup"])(textureBatch.textures, textureBatch.count, this._maxTextures);
                batch.gpuBindGroup = renderer.bindGroup.getBindGroup(batch.bindGroup, shader.gpuProgram, 1);
            }
            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
        }
    }
    destroy() {
        this.shader.destroy(true);
        this.shader = null;
    }
}
/** @ignore */ GpuGraphicsAdaptor.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipesAdaptor
    ],
    name: "graphics"
};
;
 //# sourceMappingURL=GpuGraphicsAdaptor.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GpuMeshAdapter",
    ()=>GpuMeshAdapter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$localUniformBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$textureBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
"use strict";
class GpuMeshAdapter {
    init() {
        const gpuProgram = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compileHighShaderGpuProgram"])({
            name: "mesh",
            bits: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$localUniformBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["localUniformBit"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$textureBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["textureBit"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundPixelsBit"]
            ]
        });
        this._shader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Shader"]({
            gpuProgram,
            resources: {
                uTexture: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY._source,
                uSampler: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY._source.style,
                textureUniforms: {
                    uTextureMatrix: {
                        type: "mat3x3<f32>",
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]()
                    }
                }
            }
        });
    }
    execute(meshPipe, mesh) {
        const renderer = meshPipe.renderer;
        let shader = mesh._shader;
        if (!shader) {
            shader = this._shader;
            shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);
        } else if (!shader.gpuProgram) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("Mesh shader has no gpuProgram", mesh.shader);
            return;
        }
        const gpuProgram = shader.gpuProgram;
        if (gpuProgram.autoAssignGlobalUniforms) {
            shader.groups[0] = renderer.globalUniforms.bindGroup;
        }
        if (gpuProgram.autoAssignLocalUniforms) {
            const localUniforms = meshPipe.localUniforms;
            shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
        }
        renderer.encoder.draw({
            geometry: mesh._geometry,
            shader,
            state: mesh.state
        });
    }
    destroy() {
        this._shader.destroy(true);
        this._shader = null;
    }
}
/** @ignore */ GpuMeshAdapter.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipesAdaptor
    ],
    name: "mesh"
};
;
 //# sourceMappingURL=GpuMeshAdapter.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>fragment
]);
var fragment = "varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}";
;
 //# sourceMappingURL=particles.frag.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>vertex
]);
var vertex = "attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n";
;
 //# sourceMappingURL=particles.vert.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>wgsl
]);
var wgsl = "\nstruct ParticleUniforms {\n  uTranslationMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uRound:f32,\n  uResolution:vec2<f32>,\n};\n\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n{\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n   if(uniforms.uRound == 1.0) {\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\n   }\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";
;
 //# sourceMappingURL=particles.wgsl.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getFastGlobalBounds",
    ()=>getFastGlobalBounds
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
;
"use strict";
function getFastGlobalBounds(target, bounds) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])("8.7.0", "Use container.getFastGlobalBounds() instead");
    return target.getFastGlobalBounds(true, bounds);
}
;
 //# sourceMappingURL=getFastGlobalBounds.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/RenderContainer.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RenderContainer",
    ()=>RenderContainer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/view/ViewContainer.mjs [app-ssr] (ecmascript)");
;
"use strict";
class RenderContainer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ViewContainer"] {
    /**
   * @param options - The options for the container.
   */ constructor(options){
        if (typeof options === "function") {
            options = {
                render: options
            };
        }
        const { render, ...rest } = options;
        super({
            label: "RenderContainer",
            ...rest
        });
        /** @internal */ this.renderPipeId = "customRender";
        /** @internal */ this.batched = false;
        if (render) this.render = render;
        this.containsPoint = options.containsPoint ?? (()=>false);
        this.addBounds = options.addBounds ?? (()=>false);
    }
    /** @private */ updateBounds() {
        this._bounds.clear();
        this.addBounds(this._bounds);
    }
    /**
   * An overridable function that can be used to render the object using the current renderer.
   * @param _renderer - The current renderer
   */ render(_renderer) {}
}
;
 //# sourceMappingURL=RenderContainer.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/utils/collectAllRenderables.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "collectAllRenderables",
    ()=>collectAllRenderables
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
;
"use strict";
function collectAllRenderables(container, instructionSet, rendererOrPipes) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])("8.7.0", "Please use container.collectRenderables instead.");
    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
    return container.collectRenderables(instructionSet, renderer, null);
}
;
 //# sourceMappingURL=collectAllRenderables.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "updateLocalTransform",
    ()=>updateLocalTransform
]);
"use strict";
function updateLocalTransform(lt, container) {
    const scale = container._scale;
    const pivot = container._pivot;
    const position = container._position;
    const sx = scale._x;
    const sy = scale._y;
    const px = pivot._x;
    const py = pivot._y;
    lt.a = container._cx * sx;
    lt.b = container._sx * sx;
    lt.c = container._cy * sy;
    lt.d = container._sy * sy;
    lt.tx = position._x - (px * lt.a + py * lt.c);
    lt.ty = position._y - (px * lt.b + py * lt.d);
}
;
 //# sourceMappingURL=updateLocalTransform.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "updateWorldTransform",
    ()=>updateWorldTransform
]);
"use strict";
function updateWorldTransform(local, parent, world) {
    const lta = local.a;
    const ltb = local.b;
    const ltc = local.c;
    const ltd = local.d;
    const lttx = local.tx;
    const ltty = local.ty;
    const pta = parent.a;
    const ptb = parent.b;
    const ptc = parent.c;
    const ptd = parent.d;
    world.a = lta * pta + ltb * ptc;
    world.b = lta * ptb + ltb * ptd;
    world.c = ltc * pta + ltd * ptc;
    world.d = ltc * ptb + ltd * ptd;
    world.tx = lttx * pta + ltty * ptc + parent.tx;
    world.ty = lttx * ptb + ltty * ptd + parent.ty;
}
;
 //# sourceMappingURL=updateWorldTransform.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GraphicsGpuData",
    ()=>GraphicsGpuData,
    "GraphicsPipe",
    ()=>GraphicsPipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$State$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/GCManagedHash.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$gpu$2f$colorToUniform$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$BatchableGraphics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
"use strict";
class GraphicsGpuData {
    constructor(){
        this.batches = [];
        this.batched = false;
    }
    destroy() {
        this.batches.forEach((batch)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].return(batch);
        });
        this.batches.length = 0;
    }
}
class GraphicsPipe {
    constructor(renderer, adaptor){
        this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$State$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["State"].for2d();
        this.renderer = renderer;
        this._adaptor = adaptor;
        this.renderer.runners.contextChange.add(this);
        this._managedGraphics = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GCManagedHash"]({
            renderer,
            type: "renderable",
            priority: -1,
            name: "graphics"
        });
    }
    contextChange() {
        this._adaptor.contextChange(this.renderer);
    }
    validateRenderable(graphics) {
        const context = graphics.context;
        const wasBatched = !!graphics._gpuData;
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);
        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
            return true;
        }
        return false;
    }
    addRenderable(graphics, instructionSet) {
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
        if (graphics.didViewUpdate) {
            this._rebuild(graphics);
        }
        if (gpuContext.isBatchable) {
            this._addToBatcher(graphics, instructionSet);
        } else {
            this.renderer.renderPipes.batch.break(instructionSet);
            instructionSet.add(graphics);
        }
    }
    updateRenderable(graphics) {
        const gpuData = this._getGpuDataForRenderable(graphics);
        const batches = gpuData.batches;
        for(let i = 0; i < batches.length; i++){
            const batch = batches[i];
            batch._batcher.updateElement(batch);
        }
    }
    execute(graphics) {
        if (!graphics.isRenderable) return;
        const renderer = this.renderer;
        const context = graphics.context;
        const contextSystem = renderer.graphicsContext;
        if (!contextSystem.getGpuContext(context).batches.length) {
            return;
        }
        const shader = context.customShader || this._adaptor.shader;
        this.state.blendMode = graphics.groupBlendMode;
        const localUniforms = shader.resources.localUniforms.uniforms;
        localUniforms.uTransformMatrix = graphics.groupTransform;
        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$gpu$2f$colorToUniform$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["color32BitToUniform"])(graphics.groupColorAlpha, localUniforms.uColor, 0);
        this._adaptor.execute(this, graphics);
    }
    _rebuild(graphics) {
        const gpuData = this._getGpuDataForRenderable(graphics);
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
        gpuData.destroy();
        if (gpuContext.isBatchable) {
            this._updateBatchesForRenderable(graphics, gpuData);
        }
    }
    _addToBatcher(graphics, instructionSet) {
        const batchPipe = this.renderer.renderPipes.batch;
        const batches = this._getGpuDataForRenderable(graphics).batches;
        for(let i = 0; i < batches.length; i++){
            const batch = batches[i];
            batchPipe.addToBatch(batch, instructionSet);
        }
    }
    _getGpuDataForRenderable(graphics) {
        return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);
    }
    _initGpuDataForRenderable(graphics) {
        const gpuData = new GraphicsGpuData();
        graphics._gpuData[this.renderer.uid] = gpuData;
        this._managedGraphics.add(graphics);
        return gpuData;
    }
    _updateBatchesForRenderable(graphics, gpuData) {
        const context = graphics.context;
        const gpuContext = this.renderer.graphicsContext.getGpuContext(context);
        const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
        gpuData.batches = gpuContext.batches.map((batch)=>{
            const batchClone = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$BatchableGraphics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BatchableGraphics"]);
            batch.copyTo(batchClone);
            batchClone.renderable = graphics;
            batchClone.roundPixels = roundPixels;
            return batchClone;
        });
    }
    destroy() {
        this._managedGraphics.destroy();
        this.renderer = null;
        this._adaptor.destroy();
        this._adaptor = null;
        this.state = null;
    }
}
/** @ignore */ GraphicsPipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasPipes
    ],
    name: "graphics"
};
;
 //# sourceMappingURL=GraphicsPipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildGeometryFromPath.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildGeometryFromPath",
    ()=>buildGeometryFromPath
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$buildUvs$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$transformVertices$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$GraphicsPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$buildContextBatches$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
"use strict";
function buildGeometryFromPath(options) {
    if (options instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$path$2f$GraphicsPath$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GraphicsPath"]) {
        options = {
            path: options,
            textureMatrix: null,
            out: null
        };
    }
    const vertices = [];
    const uvs = [];
    const indices = [];
    const shapePath = options.path.shapePath;
    const textureMatrix = options.textureMatrix;
    shapePath.shapePrimitives.forEach(({ shape, transform: matrix })=>{
        const indexOffset = indices.length;
        const vertOffset = vertices.length / 2;
        const points = [];
        const build = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$utils$2f$buildContextBatches$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shapeBuilders"][shape.type];
        build.build(shape, points);
        if (matrix) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$transformVertices$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformVertices"])(points, matrix);
        }
        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
        const uvsOffset = uvs.length / 2;
        if (textureMatrix) {
            if (matrix) {
                textureMatrix.append(matrix.clone().invert());
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$buildUvs$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildUvs"])(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$buildUvs$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildSimpleUvs"])(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
        }
    });
    const out = options.out;
    if (out) {
        out.positions = new Float32Array(vertices);
        out.uvs = new Float32Array(uvs);
        out.indices = new Uint32Array(indices);
        return out;
    }
    const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MeshGeometry"]({
        positions: new Float32Array(vertices),
        uvs: new Float32Array(uvs),
        indices: new Uint32Array(indices)
    });
    return geometry;
}
;
 //# sourceMappingURL=buildGeometryFromPath.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/layers/RenderLayer.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RenderLayer",
    ()=>RenderLayer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/Container.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const _RenderLayer = class _RenderLayer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Container"] {
    /**
   * Creates a new RenderLayer instance
   * @param options - Configuration options for the RenderLayer
   * @param {boolean} [options.sortableChildren=false] - If true, layer children will be automatically sorted each render
   * @param {Function} [options.sortFunction] - Custom function to sort layer children. Default sorts by zIndex
   */ constructor(options = {}){
        options = {
            ..._RenderLayer.defaultOptions,
            ...options
        };
        super();
        /**
     * The list of objects that this layer is responsible for rendering. Objects in this list maintain
     * their original parent in the scene graph but are rendered as part of this layer.
     * @example
     * ```ts
     * const layer = new RenderLayer();
     * const sprite = new Sprite(texture);
     *
     * // Add sprite to scene graph for transforms
     * container.addChild(sprite);
     *
     * // Add to layer for render order control
     * layer.attach(sprite);
     * console.log(layer.renderLayerChildren.length); // 1
     *
     * // Access objects in the layer
     * layer.renderLayerChildren.forEach(child => {
     *     console.log('Layer child:', child);
     * });
     *
     * // Check if object is in layer
     * const isInLayer = layer.renderLayerChildren.includes(sprite);
     *
     * // Clear all objects from layer
     * layer.detachAll();
     * console.log(layer.renderLayerChildren.length); // 0
     * ```
     * @readonly
     * @see {@link RenderLayer#attach} For adding objects to the layer
     * @see {@link RenderLayer#detach} For removing objects from the layer
     * @see {@link RenderLayer#detachAll} For removing all objects from the layer
     */ this.renderLayerChildren = [];
        this.sortableChildren = options.sortableChildren;
        this.sortFunction = options.sortFunction;
    }
    /**
   * Adds one or more Containers to this render layer. The Containers will be rendered as part of this layer
   * while maintaining their original parent in the scene graph.
   *
   * If the Container already belongs to a layer, it will be removed from the old layer before being added to this one.
   * @example
   * ```ts
   * const layer = new RenderLayer();
   * const container = new Container();
   * const sprite1 = new Sprite(texture1);
   * const sprite2 = new Sprite(texture2);
   *
   * // Add sprites to scene graph for transforms
   * container.addChild(sprite1, sprite2);
   *
   * // Add sprites to layer for render order control
   * layer.attach(sprite1, sprite2);
   *
   * // Add single sprite with type checking
   * const typedSprite = layer.attach<Sprite>(new Sprite(texture3));
   * typedSprite.tint = 'red';
   *
   * // Automatically removes from previous layer if needed
   * const otherLayer = new RenderLayer();
   * otherLayer.attach(sprite1); // Removes from previous layer
   * ```
   * @param children - The Container(s) to add to this layer. Can be any Container or array of Containers.
   * @returns The first child that was added, for method chaining
   * @see {@link RenderLayer#detach} For removing objects from the layer
   * @see {@link RenderLayer#detachAll} For removing all objects from the layer
   * @see {@link Container#addChild} For adding to scene graph hierarchy
   */ attach(...children) {
        for(let i = 0; i < children.length; i++){
            const child = children[i];
            if (child.parentRenderLayer) {
                if (child.parentRenderLayer === this) continue;
                child.parentRenderLayer.detach(child);
            }
            this.renderLayerChildren.push(child);
            child.parentRenderLayer = this;
            const renderGroup = this.renderGroup || this.parentRenderGroup;
            if (renderGroup) {
                renderGroup.structureDidChange = true;
            }
        }
        return children[0];
    }
    /**
   * Removes one or more Containers from this render layer. The Containers will maintain their
   * original parent in the scene graph but will no longer be rendered as part of this layer.
   * @example
   * ```ts
   * const layer = new RenderLayer();
   * const container = new Container();
   * const sprite1 = new Sprite(texture1);
   * const sprite2 = new Sprite(texture2);
   *
   * // Add sprites to scene graph and layer
   * container.addChild(sprite1, sprite2);
   * layer.attach(sprite1, sprite2);
   *
   * // Remove single sprite from layer
   * layer.detach(sprite1);
   * // sprite1 is still child of container but not rendered in layer
   *
   * // Remove multiple sprites at once
   * const otherLayer = new RenderLayer();
   * otherLayer.attach(sprite3, sprite4);
   * otherLayer.detach(sprite3, sprite4);
   *
   * // Type-safe detachment
   * const typedSprite = layer.detach<Sprite>(spriteInLayer);
   * typedSprite.texture = newTexture; // TypeScript knows this is a Sprite
   * ```
   * @param children - The Container(s) to remove from this layer
   * @returns The first child that was removed, for method chaining
   * @see {@link RenderLayer#attach} For adding objects to the layer
   * @see {@link RenderLayer#detachAll} For removing all objects from the layer
   * @see {@link Container#removeChild} For removing from scene graph hierarchy
   */ detach(...children) {
        for(let i = 0; i < children.length; i++){
            const child = children[i];
            const index = this.renderLayerChildren.indexOf(child);
            if (index !== -1) {
                this.renderLayerChildren.splice(index, 1);
            }
            child.parentRenderLayer = null;
            const renderGroup = this.renderGroup || this.parentRenderGroup;
            if (renderGroup) {
                renderGroup.structureDidChange = true;
            }
        }
        return children[0];
    }
    /**
   * Removes all objects from this render layer. Objects will maintain their
   * original parent in the scene graph but will no longer be rendered as part of this layer.
   * @example
   * ```ts
   * const layer = new RenderLayer();
   * const container = new Container();
   *
   * // Add multiple sprites to scene graph and layer
   * const sprites = [
   *     new Sprite(texture1),
   *     new Sprite(texture2),
   *     new Sprite(texture3)
   * ];
   *
   * container.addChild(...sprites);  // Add to scene graph
   * layer.attach(...sprites);       // Add to render layer
   *
   * // Later, remove all sprites from layer at once
   * layer.detachAll();
   * console.log(layer.renderLayerChildren.length); // 0
   * console.log(container.children.length);        // 3 (still in scene graph)
   * ```
   * @returns The RenderLayer instance for method chaining
   * @see {@link RenderLayer#attach} For adding objects to the layer
   * @see {@link RenderLayer#detach} For removing individual objects
   * @see {@link Container#removeChildren} For removing from scene graph
   */ detachAll() {
        const layerChildren = this.renderLayerChildren;
        for(let i = 0; i < layerChildren.length; i++){
            layerChildren[i].parentRenderLayer = null;
        }
        this.renderLayerChildren.length = 0;
    }
    /**
   * Collects renderables for this layer and its children.
   * This method is called by the renderer to gather all objects that should be rendered in this layer.
   * @param instructionSet - The set of instructions to collect renderables into.
   * @param renderer - The renderer that is collecting renderables.
   * @param _currentLayer - The current render layer being processed.
   * @internal
   */ collectRenderables(instructionSet, renderer, _currentLayer) {
        const layerChildren = this.renderLayerChildren;
        const length = layerChildren.length;
        if (this.sortableChildren) {
            this.sortRenderLayerChildren();
        }
        for(let i = 0; i < length; i++){
            if (!layerChildren[i].parent) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("Container must be added to both layer and scene graph. Layers only handle render order - the scene graph is required for transforms (addChild)", layerChildren[i]);
            }
            layerChildren[i].collectRenderables(instructionSet, renderer, this);
        }
    }
    /**
   * Sort the layer's children using the defined sort function. This method allows manual sorting
   * of layer children and is automatically called during rendering if sortableChildren is true.
   * @example
   * ```ts
   * const layer = new RenderLayer();
   *
   * // Add multiple sprites at different depths
   * const sprite1 = new Sprite(texture);
   * const sprite2 = new Sprite(texture);
   * const sprite3 = new Sprite(texture);
   *
   * sprite1.zIndex = 3;
   * sprite2.zIndex = 1;
   * sprite3.zIndex = 2;
   *
   * layer.attach(sprite1, sprite2, sprite3);
   *
   * // Manual sorting with default zIndex sort
   * layer.sortRenderLayerChildren();
   * // Order is now: sprite2 (1), sprite3 (2), sprite1 (3)
   *
   * // Custom sort by y position
   * layer.sortFunction = (a, b) => a.y - b.y;
   * layer.sortRenderLayerChildren();
   *
   * // Automatic sorting
   * layer.sortableChildren = true; // Will sort each render
   * ```
   * @returns The RenderLayer instance for method chaining
   * @see {@link RenderLayer#sortableChildren} For enabling automatic sorting
   * @see {@link RenderLayer#sortFunction} For customizing the sort logic
   */ sortRenderLayerChildren() {
        this.renderLayerChildren.sort(this.sortFunction);
    }
    /**
   * Recursively calculates the global bounds of this RenderLayer and its children.
   * @param factorRenderLayers
   * @param bounds
   * @param _currentLayer
   * @internal
   */ _getGlobalBoundsRecursive(factorRenderLayers, bounds, _currentLayer) {
        if (!factorRenderLayers) return;
        const children = this.renderLayerChildren;
        for(let i = 0; i < children.length; i++){
            children[i]._getGlobalBoundsRecursive(true, bounds, this);
        }
    }
    /**
   * @inheritdoc
   * @internal
   */ getFastGlobalBounds(factorRenderLayers, bounds) {
        return super.getFastGlobalBounds(factorRenderLayers, bounds);
    }
    /**
   * This method is not available in RenderLayer.
   *
   * Calling this method will throw an error. Please use `RenderLayer.attach()` instead.
   * @param {...any} _children
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ addChild(..._children) {
        throw new Error("RenderLayer.addChild() is not available. Please use RenderLayer.attach()");
    }
    /**
   * This method is not available in RenderLayer.
   * Calling this method will throw an error. Please use `RenderLayer.detach()` instead.
   * @param {...any} _children
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ removeChild(..._children) {
        throw new Error("RenderLayer.removeChild() is not available. Please use RenderLayer.detach()");
    }
    /**
   * This method is not available in RenderLayer.
   *
   * Calling this method will throw an error. Please use `RenderLayer.detach()` instead.
   * @param {number} [_beginIndex]
   * @param {number} [_endIndex]
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ removeChildren(_beginIndex, _endIndex) {
        throw new Error("RenderLayer.removeChildren() is not available. Please use RenderLayer.detach()");
    }
    /**
   * This method is not available in RenderLayer.
   *
   * Calling this method will throw an error.
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ removeChildAt(_index) {
        throw new Error("RenderLayer.removeChildAt() is not available");
    }
    /**
   * This method is not available in RenderLayer.
   *
   * Calling this method will throw an error.
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ getChildAt(_index) {
        throw new Error("RenderLayer.getChildAt() is not available");
    }
    /**
   * This method is not available in RenderLayer.
   *
   * Calling this method will throw an error.
   * @param {Container} _child
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ setChildIndex(_child, _index) {
        throw new Error("RenderLayer.setChildIndex() is not available");
    }
    /**
   * This method is not available in RenderLayer.
   *
   * Calling this method will throw an error.
   * @param {Container} _child
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ getChildIndex(_child) {
        throw new Error("RenderLayer.getChildIndex() is not available");
    }
    /**
   * This method is not available in RenderLayer.
   *
   * Calling this method will throw an error.
   * @param {Container} _child
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ addChildAt(_child, _index) {
        throw new Error("RenderLayer.addChildAt() is not available");
    }
    /**
   * This method is not available in RenderLayer.
   *
   * Calling this method will throw an error.
   * @param {Container} _child
   * @param {Container} _child2
   * @ignore
   */ swapChildren(_child, _child2) {
        throw new Error("RenderLayer.swapChildren() is not available");
    }
    /**
   * This method is not available in RenderLayer.
   *
   * Calling this method will throw an error.
   * @param _child - The child to reparent
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ reparentChild(..._child) {
        throw new Error("RenderLayer.reparentChild() is not available with the render layer");
    }
    /**
   * This method is not available in RenderLayer.
   *
   * Calling this method will throw an error.
   * @param _child - The child to reparent
   * @param _index - The index to reparent the child to
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ reparentChildAt(_child, _index) {
        throw new Error("RenderLayer.reparentChildAt() is not available with the render layer");
    }
};
/**
 * Default options for RenderLayer instances. These options control the sorting behavior
 * of objects within the render layer.
 * @example
 * ```ts
 * // Create a custom render layer with modified default options
 * RenderLayer.defaultOptions = {
 *     sortableChildren: true,
 *     sortFunction: (a, b) => a.y - b.y // Sort by vertical position
 * };
 *
 * // All new render layers will use these defaults
 * const layer1 = new RenderLayer();
 * // layer1 will have sortableChildren = true
 * ```
 * @property {boolean} sortableChildren -
 * @property {Function} sortFunction -
 * @see {@link RenderLayer} For the main render layer class
 * @see {@link Container#zIndex} For the default sort property
 * @see {@link RenderLayer#sortRenderLayerChildren} For manual sorting
 */ _RenderLayer.defaultOptions = {
    /** If true, layer children will be automatically sorted each render. Default is false. */ sortableChildren: false,
    /**
   * Function used to sort layer children.
   * Default sorts by zIndex. Accepts two Container objects and returns
   * a number indicating their relative order.
   * @param a - First container to compare
   * @param b - Second container to compare
   * @returns Negative if a should render before b, positive if b should render before a
   */ sortFunction: (a, b)=>a.zIndex - b.zIndex
};
let RenderLayer = _RenderLayer;
;
 //# sourceMappingURL=RenderLayer.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PlaneGeometry",
    ()=>PlaneGeometry
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const _PlaneGeometry = class _PlaneGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MeshGeometry"] {
    constructor(...args){
        super({});
        let options = args[0] ?? {};
        if (typeof options === "number") {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
            options = {
                width: options,
                height: args[1],
                verticesX: args[2],
                verticesY: args[3]
            };
        }
        this.build(options);
    }
    /**
   * Refreshes plane coordinates
   * @param options - Options to be applied to plane geometry
   */ build(options) {
        options = {
            ..._PlaneGeometry.defaultOptions,
            ...options
        };
        this.verticesX = this.verticesX ?? options.verticesX;
        this.verticesY = this.verticesY ?? options.verticesY;
        this.width = this.width ?? options.width;
        this.height = this.height ?? options.height;
        const total = this.verticesX * this.verticesY;
        const verts = [];
        const uvs = [];
        const indices = [];
        const verticesX = this.verticesX - 1;
        const verticesY = this.verticesY - 1;
        const sizeX = this.width / verticesX;
        const sizeY = this.height / verticesY;
        for(let i = 0; i < total; i++){
            const x = i % this.verticesX;
            const y = i / this.verticesX | 0;
            verts.push(x * sizeX, y * sizeY);
            uvs.push(x / verticesX, y / verticesY);
        }
        const totalSub = verticesX * verticesY;
        for(let i = 0; i < totalSub; i++){
            const xpos = i % verticesX;
            const ypos = i / verticesX | 0;
            const value = ypos * this.verticesX + xpos;
            const value2 = ypos * this.verticesX + xpos + 1;
            const value3 = (ypos + 1) * this.verticesX + xpos;
            const value4 = (ypos + 1) * this.verticesX + xpos + 1;
            indices.push(value, value2, value3, value2, value4, value3);
        }
        this.buffers[0].data = new Float32Array(verts);
        this.buffers[1].data = new Float32Array(uvs);
        this.indexBuffer.data = new Uint32Array(indices);
        this.buffers[0].update();
        this.buffers[1].update();
        this.indexBuffer.update();
    }
};
_PlaneGeometry.defaultOptions = {
    width: 100,
    height: 100,
    verticesX: 10,
    verticesY: 10
};
let PlaneGeometry = _PlaneGeometry;
;
 //# sourceMappingURL=PlaneGeometry.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "applyProjectiveTransformationToPlane",
    ()=>applyProjectiveTransformationToPlane
]);
"use strict";
function applyProjectiveTransformationToPlane(width, height, geometry, transformationMatrix) {
    const buffer = geometry.buffers[0];
    const vertices = buffer.data;
    const { verticesX, verticesY } = geometry;
    const sizeX = width / (verticesX - 1);
    const sizeY = height / (verticesY - 1);
    let index = 0;
    const a00 = transformationMatrix[0];
    const a01 = transformationMatrix[1];
    const a02 = transformationMatrix[2];
    const a10 = transformationMatrix[3];
    const a11 = transformationMatrix[4];
    const a12 = transformationMatrix[5];
    const a20 = transformationMatrix[6];
    const a21 = transformationMatrix[7];
    const a22 = transformationMatrix[8];
    for(let i = 0; i < vertices.length; i += 2){
        const x = index % verticesX * sizeX;
        const y = (index / verticesX | 0) * sizeY;
        const newX = a00 * x + a01 * y + a02;
        const newY = a10 * x + a11 * y + a12;
        const w = a20 * x + a21 * y + a22;
        vertices[i] = newX / w;
        vertices[i + 1] = newY / w;
        index++;
    }
    buffer.update();
}
;
 //# sourceMappingURL=applyProjectiveTransformationToPlane.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "compute2DProjection",
    ()=>compute2DProjection
]);
"use strict";
function computeAdjugate(out, matrix) {
    const a00 = matrix[0];
    const a01 = matrix[1];
    const a02 = matrix[2];
    const a10 = matrix[3];
    const a11 = matrix[4];
    const a12 = matrix[5];
    const a20 = matrix[6];
    const a21 = matrix[7];
    const a22 = matrix[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
}
function multiplyMatrix3x3(out, a, b) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a10 = a[3];
    const a11 = a[4];
    const a12 = a[5];
    const a20 = a[6];
    const a21 = a[7];
    const a22 = a[8];
    const b00 = b[0];
    const b01 = b[1];
    const b02 = b[2];
    const b10 = b[3];
    const b11 = b[4];
    const b12 = b[5];
    const b20 = b[6];
    const b21 = b[7];
    const b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
}
function multiplyMatrixAndVector(out, m, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    out[0] = m[0] * x + m[1] * y + m[2] * z;
    out[1] = m[3] * x + m[4] * y + m[5] * z;
    out[2] = m[6] * x + m[7] * y + m[8] * z;
    return out;
}
const tempMatrix = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
const tempVec = [
    0,
    0,
    0
];
const tempVec2 = [
    0,
    0,
    0
];
function generateBasisToPointsMatrix(out, x1, y1, x2, y2, x3, y3, x4, y4) {
    const m = tempMatrix;
    m[0] = x1;
    m[1] = x2;
    m[2] = x3;
    m[3] = y1;
    m[4] = y2;
    m[5] = y3;
    m[6] = 1;
    m[7] = 1;
    m[8] = 1;
    const adjugateM = computeAdjugate(out, // reusing out as adjugateM is only used once
    m);
    tempVec2[0] = x4;
    tempVec2[1] = y4;
    tempVec2[2] = 1;
    const v = multiplyMatrixAndVector(tempVec, adjugateM, tempVec2);
    const diagonalMatrix = out;
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = v[2];
    return multiplyMatrix3x3(out, diagonalMatrix, m);
}
const tempSourceMatrix = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
const tempDestinationMatrix = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
function compute2DProjection(out, x1s, y1s, x1d, y1d, x2s, y2s, x2d, y2d, x3s, y3s, x3d, y3d, x4s, y4s, x4d, y4d) {
    const sourceMatrix = generateBasisToPointsMatrix(tempSourceMatrix, x1s, y1s, x2s, y2s, x3s, y3s, x4s, y4s);
    const destinationMatrix = generateBasisToPointsMatrix(tempDestinationMatrix, x1d, y1d, x2d, y2d, x3d, y3d, x4d, y4d);
    return multiplyMatrix3x3(out, computeAdjugate(sourceMatrix, sourceMatrix), destinationMatrix);
}
;
 //# sourceMappingURL=compute2DProjections.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PerspectivePlaneGeometry",
    ()=>PerspectivePlaneGeometry
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$plane$2f$PlaneGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$perspective$2f$utils$2f$applyProjectiveTransformationToPlane$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$perspective$2f$utils$2f$compute2DProjections$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
class PerspectivePlaneGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$plane$2f$PlaneGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PlaneGeometry"] {
    /**
   * @param options - Options to be applied to MeshPlane
   * @param options.width - The width of the plane
   * @param options.height - The height of the plane
   * @param options.verticesX - The amount of vertices on the x axis
   * @param options.verticesY - The amount of vertices on the y axis
   */ constructor(options){
        super(options);
        this._projectionMatrix = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ];
        const { width, height } = options;
        this.corners = [
            0,
            0,
            width,
            0,
            width,
            height,
            0,
            height
        ];
    }
    /**
   * Will set the corners of the quad to the given coordinates
   * Calculating the perspective so it looks correct!
   * @param x0 - x coordinate of the first corner
   * @param y0 - y coordinate of the first corner
   * @param x1 - x coordinate of the second corner
   * @param y1 - y coordinate of the second corner
   * @param x2 - x coordinate of the third corner
   * @param y2 - y coordinate of the third corner
   * @param x3 - x coordinate of the fourth corner
   * @param y3 - y coordinate of the fourth corner
   */ setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {
        const corners = this.corners;
        corners[0] = x0;
        corners[1] = y0;
        corners[2] = x1;
        corners[3] = y1;
        corners[4] = x2;
        corners[5] = y2;
        corners[6] = x3;
        corners[7] = y3;
        this.updateProjection();
    }
    /** Update the projection matrix based on the corners */ updateProjection() {
        const { width, height } = this;
        const corners = this.corners;
        const projectionMatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$perspective$2f$utils$2f$compute2DProjections$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compute2DProjection"])(this._projectionMatrix, 0, 0, // top-left source
        corners[0], corners[1], // top-left dest
        width, 0, // top-right source
        corners[2], corners[3], // top-right dest
        width, height, // bottom-right source
        corners[4], corners[5], // bottom-right dest
        0, height, // bottom-left source
        corners[6], corners[7]);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$perspective$2f$utils$2f$applyProjectiveTransformationToPlane$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["applyProjectiveTransformationToPlane"])(width, height, this, projectionMatrix);
    }
}
;
 //# sourceMappingURL=PerspectivePlaneGeometry.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PerspectiveMesh",
    ()=>PerspectiveMesh
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$Mesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$perspective$2f$PerspectivePlaneGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
const _PerspectiveMesh = class _PerspectiveMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$Mesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"] {
    /**
   * @param options - Options to be applied to PerspectiveMesh
   */ constructor(options){
        options = {
            ..._PerspectiveMesh.defaultOptions,
            ...options
        };
        const { texture, verticesX, verticesY, ...rest } = options;
        const planeGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$perspective$2f$PerspectivePlaneGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PerspectivePlaneGeometry"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["definedProps"])({
            width: texture.width,
            height: texture.height,
            verticesX,
            verticesY
        }));
        super((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["definedProps"])({
            ...rest,
            geometry: planeGeometry
        }));
        this._texture = texture;
        this.geometry.setCorners(options.x0, options.y0, options.x1, options.y1, options.x2, options.y2, options.x3, options.y3);
    }
    /** Update the geometry when the texture is updated */ textureUpdated() {
        const geometry = this.geometry;
        if (!geometry) return;
        const { width, height } = this.texture;
        if (geometry.width !== width || geometry.height !== height) {
            geometry.width = width;
            geometry.height = height;
            geometry.updateProjection();
        }
    }
    set texture(value) {
        if (this._texture === value) return;
        super.texture = value;
        this.textureUpdated();
    }
    /**
   * The texture that the mesh uses for rendering. When changed, automatically updates
   * the geometry to match the new texture dimensions.
   * @example
   * ```ts
   * const mesh = new PerspectiveMesh({
   *     texture: Texture.from('initial.png'),
   * });
   *
   * // Update texture and maintain perspective
   * mesh.texture = Texture.from('newImage.png');
   * ```
   * @see {@link Texture} For texture creation and management
   * @see {@link PerspectiveMesh#setCorners} For adjusting the mesh perspective
   */ get texture() {
        return this._texture;
    }
    /**
   * Sets the corners of the mesh to create a perspective transformation. The corners should be
   * specified in clockwise order starting from the top-left.
   *
   * The mesh automatically recalculates the UV coordinates to create the perspective effect.
   * @example
   * ```ts
   * const mesh = new PerspectiveMesh({
   *     texture: Texture.from('myImage.png'),
   * });
   *
   * // Create a basic perspective tilt
   * mesh.setCorners(
   *     0, 0,      // Top-left
   *     100, 20,   // Top-right (raised)
   *     100, 100,  // Bottom-right
   *     0, 80      // Bottom-left
   * );
   *
   * // Create a skewed billboard effect
   * mesh.setCorners(
   *     0, 30,     // Top-left (shifted down)
   *     128, 0,    // Top-right (raised)
   *     128, 128,  // Bottom-right
   *     0, 98      // Bottom-left (shifted up)
   * );
   *
   * // Animate perspective
   * app.ticker.add((delta) => {
   *     const time = performance.now() / 1000;
   *     const wave = Math.sin(time) * 20;
   *
   *     mesh.setCorners(
   *         0, wave,      // Top-left
   *         100, -wave,   // Top-right
   *         100, 100,     // Bottom-right
   *         0, 100        // Bottom-left
   *     );
   * });
   * ```
   * @param x0 - x-coordinate of the top-left corner
   * @param y0 - y-coordinate of the top-left corner
   * @param x1 - x-coordinate of the top-right corner
   * @param y1 - y-coordinate of the top-right corner
   * @param x2 - x-coordinate of the bottom-right corner
   * @param y2 - y-coordinate of the bottom-right corner
   * @param x3 - x-coordinate of the bottom-left corner
   * @param y3 - y-coordinate of the bottom-left corner
   * @returns The PerspectiveMesh instance for method chaining
   * @see {@link PerspectivePlaneGeometry} For the underlying geometry calculations
   */ setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {
        this.geometry.setCorners(x0, y0, x1, y1, x2, y2, x3, y3);
    }
};
/**
 * Default options for creating a PerspectiveMesh instance.
 *
 * Creates a 100x100 pixel square mesh
 * with a white texture and 10x10 vertex grid for the perspective calculations.
 * @example
 * ```ts
 * // Change defaults globally
 * PerspectiveMesh.defaultOptions = {
 *     ...PerspectiveMesh.defaultOptions,
 *     verticesX: 15,
 *     verticesY: 15,
 *     // Move top edge up for default skew
 *     y0: -20,
 *     y1: -20
 * };
 * ```
 * @see {@link PerspectivePlaneOptions} For all available options
 * @see {@link PerspectivePlaneGeometry} For how vertices affect perspective quality
 */ _PerspectiveMesh.defaultOptions = {
    texture: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].WHITE,
    verticesX: 10,
    verticesY: 10,
    x0: 0,
    y0: 0,
    x1: 100,
    y1: 0,
    x2: 100,
    y2: 100,
    x3: 0,
    y3: 100
};
let PerspectiveMesh = _PerspectiveMesh;
;
 //# sourceMappingURL=PerspectiveMesh.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MeshPlane",
    ()=>MeshPlane
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$Mesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$plane$2f$PlaneGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
class MeshPlane extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$Mesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"] {
    /**
   * @param options - Options to be applied to MeshPlane
   */ constructor(options){
        const { texture, verticesX, verticesY, ...rest } = options;
        const planeGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$plane$2f$PlaneGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PlaneGeometry"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["definedProps"])({
            width: texture.width,
            height: texture.height,
            verticesX,
            verticesY
        }));
        super((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["definedProps"])({
            ...rest,
            geometry: planeGeometry,
            texture
        }));
        this.texture = texture;
        this.autoResize = true;
    }
    /**
   * Method used for overrides, to do something in case texture frame was changed.
   * Meshes based on plane can override it and change more details based on texture.
   * @internal
   */ textureUpdated() {
        const geometry = this.geometry;
        const { width, height } = this.texture;
        if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
            geometry.width = width;
            geometry.height = height;
            geometry.build({});
        }
    }
    set texture(value) {
        this._texture?.off("update", this.textureUpdated, this);
        super.texture = value;
        value.on("update", this.textureUpdated, this);
        this.textureUpdated();
    }
    /**
   * The texture that the mesh plane uses for rendering. When changed, automatically updates
   * geometry dimensions if autoResize is true and manages texture update event listeners.
   * @example
   * ```ts
   * const plane = new MeshPlane({
   *     texture: Assets.get('initial.png'),
   *     verticesX: 10,
   *     verticesY: 10
   * });
   *
   * // Update texture and auto-resize geometry
   * plane.texture = Assets.get('larger.png');
   * ```
   * @see {@link MeshPlane#autoResize} For controlling automatic geometry updates
   * @see {@link PlaneGeometry} For manual geometry updates
   * @see {@link Texture} For texture creation and management
   */ get texture() {
        return this._texture;
    }
    /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * meshPlane.destroy();
   * meshPlane.destroy(true);
   * meshPlane.destroy({ texture: true, textureSource: true });
   */ destroy(options) {
        this.texture.off("update", this.textureUpdated, this);
        super.destroy(options);
    }
}
;
 //# sourceMappingURL=MeshPlane.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RopeGeometry",
    ()=>RopeGeometry
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs [app-ssr] (ecmascript)");
;
"use strict";
const _RopeGeometry = class _RopeGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MeshGeometry"] {
    /**
   * @param options - Options to be applied to rope geometry
   */ constructor(options){
        const { width, points, textureScale } = {
            ..._RopeGeometry.defaultOptions,
            ...options
        };
        super({
            positions: new Float32Array(points.length * 4),
            uvs: new Float32Array(points.length * 4),
            indices: new Uint32Array((points.length - 1) * 6)
        });
        this.points = points;
        this._width = width;
        this.textureScale = textureScale;
        this._build();
    }
    /**
   * The width (i.e., thickness) of the rope.
   * @readonly
   */ get width() {
        return this._width;
    }
    /** Refreshes Rope indices and uvs */ _build() {
        const points = this.points;
        if (!points) return;
        const vertexBuffer = this.getBuffer("aPosition");
        const uvBuffer = this.getBuffer("aUV");
        const indexBuffer = this.getIndex();
        if (points.length < 1) {
            return;
        }
        if (vertexBuffer.data.length / 4 !== points.length) {
            vertexBuffer.data = new Float32Array(points.length * 4);
            uvBuffer.data = new Float32Array(points.length * 4);
            indexBuffer.data = new Uint16Array((points.length - 1) * 6);
        }
        const uvs = uvBuffer.data;
        const indices = indexBuffer.data;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        let amount = 0;
        let prev = points[0];
        const textureWidth = this._width * this.textureScale;
        const total = points.length;
        for(let i = 0; i < total; i++){
            const index = i * 4;
            if (this.textureScale > 0) {
                const dx = prev.x - points[i].x;
                const dy = prev.y - points[i].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                prev = points[i];
                amount += distance / textureWidth;
            } else {
                amount = i / (total - 1);
            }
            uvs[index] = amount;
            uvs[index + 1] = 0;
            uvs[index + 2] = amount;
            uvs[index + 3] = 1;
        }
        let indexCount = 0;
        for(let i = 0; i < total - 1; i++){
            const index = i * 2;
            indices[indexCount++] = index;
            indices[indexCount++] = index + 1;
            indices[indexCount++] = index + 2;
            indices[indexCount++] = index + 2;
            indices[indexCount++] = index + 1;
            indices[indexCount++] = index + 3;
        }
        uvBuffer.update();
        indexBuffer.update();
        this.updateVertices();
    }
    /** refreshes vertices of Rope mesh */ updateVertices() {
        const points = this.points;
        if (points.length < 1) {
            return;
        }
        let lastPoint = points[0];
        let nextPoint;
        let perpX = 0;
        let perpY = 0;
        const vertices = this.buffers[0].data;
        const total = points.length;
        const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
        for(let i = 0; i < total; i++){
            const point = points[i];
            const index = i * 4;
            if (i < points.length - 1) {
                nextPoint = points[i + 1];
            } else {
                nextPoint = point;
            }
            perpY = -(nextPoint.x - lastPoint.x);
            perpX = nextPoint.y - lastPoint.y;
            let ratio = (1 - i / (total - 1)) * 10;
            if (ratio > 1) {
                ratio = 1;
            }
            const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
            if (perpLength < 1e-6) {
                perpX = 0;
                perpY = 0;
            } else {
                perpX /= perpLength;
                perpY /= perpLength;
                perpX *= halfWidth;
                perpY *= halfWidth;
            }
            vertices[index] = point.x + perpX;
            vertices[index + 1] = point.y + perpY;
            vertices[index + 2] = point.x - perpX;
            vertices[index + 3] = point.y - perpY;
            lastPoint = point;
        }
        this.buffers[0].update();
    }
    /** Refreshes Rope indices and uvs */ update() {
        if (this.textureScale > 0) {
            this._build();
        } else {
            this.updateVertices();
        }
    }
};
/** Default options for RopeGeometry constructor. */ _RopeGeometry.defaultOptions = {
    /** The width (i.e., thickness) of the rope. */ width: 200,
    /** An array of points that determine the rope. */ points: [],
    /** Rope texture scale, if zero then the rope texture is stretched. */ textureScale: 0
};
let RopeGeometry = _RopeGeometry;
;
 //# sourceMappingURL=RopeGeometry.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MeshRope",
    ()=>MeshRope
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$Mesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$simple$2f$RopeGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
const _MeshRope = class _MeshRope extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$Mesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"] {
    /**
   * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.
   * @param options
   * @param options.texture - The texture to use on the rope.
   * @param options.points - An array of {@link math.Point} objects to construct this rope.
   * @param {number} options.textureScale - Optional. Positive values scale rope texture
   * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture
   * and downsampling here. If set to zero, texture will be stretched instead.
   */ constructor(options){
        const { texture, points, textureScale, ...rest } = {
            ..._MeshRope.defaultOptions,
            ...options
        };
        const ropeGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$simple$2f$RopeGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RopeGeometry"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["definedProps"])({
            width: texture.height,
            points,
            textureScale
        }));
        if (textureScale > 0) {
            texture.source.style.addressMode = "repeat";
        }
        super((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["definedProps"])({
            ...rest,
            texture,
            geometry: ropeGeometry
        }));
        this.autoUpdate = true;
        this.onRender = this._render;
    }
    _render() {
        const geometry = this.geometry;
        if (this.autoUpdate || geometry._width !== this.texture.height) {
            geometry._width = this.texture.height;
            geometry.update();
        }
    }
};
/**
 * Default options for creating a MeshRope instance. These values are used when specific
 * options aren't provided in the constructor.
 * @example
 * ```ts
 * // Use default options globally
 * MeshRope.defaultOptions = {
 *     textureScale: 0.5  // Set higher quality texture scaling
 * };
 *
 * // Create rope with modified defaults
 * const rope = new MeshRope({
 *     texture: Texture.from('rope.png'),
 *     points: [
 *         new Point(0, 0),
 *         new Point(100, 0)
 *     ]
 * }); // Will use textureScale: 0.5
 * ```
 * @property {number} textureScale - Controls texture scaling along the rope (0 = stretch)
 * @see {@link MeshRopeOptions} For all available options
 */ _MeshRope.defaultOptions = {
    textureScale: 0
};
let MeshRope = _MeshRope;
;
 //# sourceMappingURL=MeshRope.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MeshSimple",
    ()=>MeshSimple
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$Mesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
class MeshSimple extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$Mesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"] {
    /**
   * @param options - Options to be used for construction
   */ constructor(options){
        const { texture, vertices, uvs, indices, topology, ...rest } = options;
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MeshGeometry"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["definedProps"])({
            positions: vertices,
            uvs,
            indices,
            topology
        }));
        super((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$definedProps$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["definedProps"])({
            ...rest,
            texture,
            geometry
        }));
        this.autoUpdate = true;
        this.onRender = this._render;
    }
    /**
   * The vertex positions of the mesh as a TypedArray. Each vertex is represented by two
   * consecutive values (x, y) in the array. Changes to these values will update the mesh's shape.
   * @example
   * ```ts
   * // Read vertex positions
   * const vertices = mesh.vertices;
   * console.log('First vertex:', vertices[0], vertices[1]);
   *
   * // Modify vertices directly
   * vertices[0] += 10;  // Move first vertex right
   * vertices[1] -= 20;  // Move first vertex up
   *
   * // Animate vertices
   * app.ticker.add(() => {
   *     const time = performance.now() / 1000;
   *     const vertices = mesh.vertices;
   *
   *     // Wave motion
   *     for (let i = 0; i < vertices.length; i += 2) {
   *         vertices[i + 1] = Math.sin(time + i * 0.5) * 20;
   *     }
   * });
   * ```
   * @see {@link MeshSimple#autoUpdate} For controlling vertex buffer updates
   * @see {@link MeshGeometry#getBuffer} For direct buffer access
   */ get vertices() {
        return this.geometry.getBuffer("aPosition").data;
    }
    set vertices(value) {
        this.geometry.getBuffer("aPosition").data = value;
    }
    _render() {
        if (this.autoUpdate) {
            this.geometry.getBuffer("aPosition").update();
        }
    }
}
;
 //# sourceMappingURL=MeshSimple.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BatchableMesh",
    ()=>BatchableMesh
]);
"use strict";
class BatchableMesh {
    constructor(){
        this.batcherName = "default";
        this.packAsQuad = false;
        this.indexOffset = 0;
        this.attributeOffset = 0;
        this.roundPixels = 0;
        this._batcher = null;
        this._batch = null;
        this._textureMatrixUpdateId = -1;
        this._uvUpdateId = -1;
    }
    get blendMode() {
        return this.renderable.groupBlendMode;
    }
    get topology() {
        return this._topology || this.geometry.topology;
    }
    set topology(value) {
        this._topology = value;
    }
    reset() {
        this.renderable = null;
        this.texture = null;
        this._batcher = null;
        this._batch = null;
        this.geometry = null;
        this._uvUpdateId = -1;
        this._textureMatrixUpdateId = -1;
    }
    /**
   * Sets the texture for the batchable mesh.
   * As it does so, it resets the texture matrix update ID.
   * this is to ensure that the texture matrix is recalculated when the uvs are referenced
   * @param value - The texture to set.
   */ setTexture(value) {
        if (this.texture === value) return;
        this.texture = value;
        this._textureMatrixUpdateId = -1;
    }
    get uvs() {
        const geometry = this.geometry;
        const uvBuffer = geometry.getBuffer("aUV");
        const uvs = uvBuffer.data;
        let transformedUvs = uvs;
        const textureMatrix = this.texture.textureMatrix;
        if (!textureMatrix.isSimple) {
            transformedUvs = this._transformedUvs;
            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
                if (!transformedUvs || transformedUvs.length < uvs.length) {
                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
                }
                this._textureMatrixUpdateId = textureMatrix._updateID;
                this._uvUpdateId = uvBuffer._updateID;
                textureMatrix.multiplyUvs(uvs, transformedUvs);
            }
        }
        return transformedUvs;
    }
    get positions() {
        return this.geometry.positions;
    }
    get indices() {
        return this.geometry.indices;
    }
    get color() {
        return this.renderable.groupColorAlpha;
    }
    get groupTransform() {
        return this.renderable.groupTransform;
    }
    get attributeSize() {
        return this.geometry.positions.length / 2;
    }
    get indexSize() {
        return this.geometry.indices.length;
    }
}
;
 //# sourceMappingURL=BatchableMesh.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getTextureDefaultMatrix",
    ()=>getTextureDefaultMatrix
]);
"use strict";
function getTextureDefaultMatrix(texture, out) {
    const { width, height } = texture.frame;
    out.scale(1 / width, 1 / height);
    return out;
}
;
 //# sourceMappingURL=getTextureDefaultMatrix.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MeshGpuData",
    ()=>MeshGpuData,
    "MeshPipe",
    ()=>MeshPipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$gpu$2f$shader$2f$BindGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$getAdjustedBlendModeBlend$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$gpu$2f$colorToUniform$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$BatchableMesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
class MeshGpuData {
    destroy() {}
}
class MeshPipe {
    constructor(renderer, adaptor){
        this.localUniforms = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UniformGroup"]({
            uTransformMatrix: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"](),
                type: "mat3x3<f32>"
            },
            uColor: {
                value: new Float32Array([
                    1,
                    1,
                    1,
                    1
                ]),
                type: "vec4<f32>"
            },
            uRound: {
                value: 0,
                type: "f32"
            }
        });
        this.localUniformsBindGroup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$gpu$2f$shader$2f$BindGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BindGroup"]({
            0: this.localUniforms
        });
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init();
    }
    validateRenderable(mesh) {
        const meshData = this._getMeshData(mesh);
        const wasBatched = meshData.batched;
        const isBatched = mesh.batched;
        meshData.batched = isBatched;
        if (wasBatched !== isBatched) {
            return true;
        } else if (isBatched) {
            const geometry = mesh._geometry;
            if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
                meshData.indexSize = geometry.indices.length;
                meshData.vertexSize = geometry.positions.length;
                return true;
            }
            const batchableMesh = this._getBatchableMesh(mesh);
            if (batchableMesh.texture.uid !== mesh._texture.uid) {
                batchableMesh._textureMatrixUpdateId = -1;
            }
            return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, mesh._texture);
        }
        return false;
    }
    addRenderable(mesh, instructionSet) {
        const batcher = this.renderer.renderPipes.batch;
        const meshData = this._getMeshData(mesh);
        if (mesh.didViewUpdate) {
            meshData.indexSize = mesh._geometry.indices?.length;
            meshData.vertexSize = mesh._geometry.positions?.length;
        }
        if (meshData.batched) {
            const gpuBatchableMesh = this._getBatchableMesh(mesh);
            gpuBatchableMesh.setTexture(mesh._texture);
            gpuBatchableMesh.geometry = mesh._geometry;
            batcher.addToBatch(gpuBatchableMesh, instructionSet);
        } else {
            batcher.break(instructionSet);
            instructionSet.add(mesh);
        }
    }
    updateRenderable(mesh) {
        if (mesh.batched) {
            const gpuBatchableMesh = this._getBatchableMesh(mesh);
            gpuBatchableMesh.setTexture(mesh._texture);
            gpuBatchableMesh.geometry = mesh._geometry;
            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);
        }
    }
    execute(mesh) {
        if (!mesh.isRenderable) return;
        mesh.state.blendMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$getAdjustedBlendModeBlend$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAdjustedBlendModeBlend"])(mesh.groupBlendMode, mesh.texture._source);
        const localUniforms = this.localUniforms;
        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
        localUniforms.update();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$gpu$2f$colorToUniform$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["color32BitToUniform"])(mesh.groupColorAlpha, localUniforms.uniforms.uColor, 0);
        this._adaptor.execute(this, mesh);
    }
    _getMeshData(mesh) {
        var _a, _b;
        (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());
        return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);
    }
    _initMeshData(mesh) {
        mesh._gpuData[this.renderer.uid].meshData = {
            batched: mesh.batched,
            indexSize: 0,
            vertexSize: 0
        };
        return mesh._gpuData[this.renderer.uid].meshData;
    }
    _getBatchableMesh(mesh) {
        var _a, _b;
        (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());
        return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);
    }
    _initBatchableMesh(mesh) {
        const gpuMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$BatchableMesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BatchableMesh"]();
        gpuMesh.renderable = mesh;
        gpuMesh.setTexture(mesh._texture);
        gpuMesh.transform = mesh.groupTransform;
        gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
        mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;
        return gpuMesh;
    }
    destroy() {
        this.localUniforms = null;
        this.localUniformsBindGroup = null;
        this._adaptor.destroy();
        this._adaptor = null;
        this.renderer = null;
    }
}
/** @ignore */ MeshPipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasPipes
    ],
    name: "mesh"
};
;
 //# sourceMappingURL=MeshPipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GlParticleContainerAdaptor",
    ()=>GlParticleContainerAdaptor
]);
"use strict";
class GlParticleContainerAdaptor {
    execute(particleContainerPipe, container) {
        const state = particleContainerPipe.state;
        const renderer = particleContainerPipe.renderer;
        const shader = container.shader || particleContainerPipe.defaultShader;
        shader.resources.uTexture = container.texture._source;
        shader.resources.uniforms = particleContainerPipe.localUniforms;
        const gl = renderer.gl;
        const buffer = particleContainerPipe.getBuffers(container);
        renderer.shader.bind(shader);
        renderer.state.set(state);
        renderer.geometry.bind(buffer.geometry, shader.glProgram);
        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;
        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);
    }
}
;
 //# sourceMappingURL=GlParticleContainerAdaptor.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GpuParticleContainerAdaptor",
    ()=>GpuParticleContainerAdaptor
]);
"use strict";
class GpuParticleContainerAdaptor {
    execute(particleContainerPipe, container) {
        const renderer = particleContainerPipe.renderer;
        const shader = container.shader || particleContainerPipe.defaultShader;
        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);
        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);
        const state = particleContainerPipe.state;
        const buffer = particleContainerPipe.getBuffers(container);
        renderer.encoder.draw({
            geometry: buffer.geometry,
            shader: container.shader || particleContainerPipe.defaultShader,
            state,
            size: container.particleChildren.length * 6
        });
    }
}
;
 //# sourceMappingURL=GpuParticleContainerAdaptor.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createIndicesForQuads",
    ()=>createIndicesForQuads
]);
"use strict";
function createIndicesForQuads(size, outBuffer = null) {
    const totalIndices = size * 6;
    if (totalIndices > 65535) {
        outBuffer || (outBuffer = new Uint32Array(totalIndices));
    } else {
        outBuffer || (outBuffer = new Uint16Array(totalIndices));
    }
    if (outBuffer.length !== totalIndices) {
        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
    }
    for(let i = 0, j = 0; i < totalIndices; i += 6, j += 4){
        outBuffer[i + 0] = j + 0;
        outBuffer[i + 1] = j + 1;
        outBuffer[i + 2] = j + 2;
        outBuffer[i + 3] = j + 0;
        outBuffer[i + 4] = j + 2;
        outBuffer[i + 5] = j + 3;
    }
    return outBuffer;
}
;
 //# sourceMappingURL=createIndicesForQuads.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generateParticleUpdateFunction",
    ()=>generateParticleUpdateFunction
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$getAttributeInfoFromFormat$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs [app-ssr] (ecmascript)");
;
"use strict";
function generateParticleUpdateFunction(properties) {
    return {
        dynamicUpdate: generateUpdateFunction(properties, true),
        staticUpdate: generateUpdateFunction(properties, false)
    };
}
function generateUpdateFunction(properties, dynamic) {
    const funcFragments = [];
    funcFragments.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
    let offset = 0;
    for(const i in properties){
        const property = properties[i];
        if (dynamic !== property.dynamic) continue;
        funcFragments.push(`offset = index + ${offset}`);
        funcFragments.push(property.code);
        const attributeInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$getAttributeInfoFromFormat$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAttributeInfoFromFormat"])(property.format);
        offset += attributeInfo.stride / 4;
    }
    funcFragments.push(`
            index += stride * 4;
        }
    `);
    funcFragments.unshift(`
        var stride = ${offset};
    `);
    const functionSource = funcFragments.join("\n");
    return new Function("ps", "f32v", "u32v", functionSource);
}
;
 //# sourceMappingURL=generateParticleUpdateFunction.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ParticleBuffer",
    ()=>ParticleBuffer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$Buffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$Geometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$getAttributeInfoFromFormat$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$ViewableBuffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$utils$2f$createIndicesForQuads$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$utils$2f$generateParticleUpdateFunction$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
class ParticleBuffer {
    constructor(options){
        this._size = 0;
        this._generateParticleUpdateCache = {};
        const size = this._size = options.size ?? 1e3;
        const properties = options.properties;
        let staticVertexSize = 0;
        let dynamicVertexSize = 0;
        for(const i in properties){
            const property = properties[i];
            const attributeInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$getAttributeInfoFromFormat$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAttributeInfoFromFormat"])(property.format);
            if (property.dynamic) {
                dynamicVertexSize += attributeInfo.stride;
            } else {
                staticVertexSize += attributeInfo.stride;
            }
        }
        this._dynamicStride = dynamicVertexSize / 4;
        this._staticStride = staticVertexSize / 4;
        this.staticAttributeBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$ViewableBuffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ViewableBuffer"](size * 4 * staticVertexSize);
        this.dynamicAttributeBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$ViewableBuffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ViewableBuffer"](size * 4 * dynamicVertexSize);
        this.indexBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$utils$2f$createIndicesForQuads$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createIndicesForQuads"])(size);
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$Geometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Geometry"]();
        let dynamicOffset = 0;
        let staticOffset = 0;
        this._staticBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$Buffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Buffer"]({
            data: new Float32Array(1),
            label: "static-particle-buffer",
            shrinkToFit: false,
            usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferUsage"].VERTEX | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferUsage"].COPY_DST
        });
        this._dynamicBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$Buffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Buffer"]({
            data: new Float32Array(1),
            label: "dynamic-particle-buffer",
            shrinkToFit: false,
            usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferUsage"].VERTEX | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$buffer$2f$const$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferUsage"].COPY_DST
        });
        for(const i in properties){
            const property = properties[i];
            const attributeInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$geometry$2f$utils$2f$getAttributeInfoFromFormat$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAttributeInfoFromFormat"])(property.format);
            if (property.dynamic) {
                geometry.addAttribute(property.attributeName, {
                    buffer: this._dynamicBuffer,
                    stride: this._dynamicStride * 4,
                    offset: dynamicOffset * 4,
                    format: property.format
                });
                dynamicOffset += attributeInfo.size;
            } else {
                geometry.addAttribute(property.attributeName, {
                    buffer: this._staticBuffer,
                    stride: this._staticStride * 4,
                    offset: staticOffset * 4,
                    format: property.format
                });
                staticOffset += attributeInfo.size;
            }
        }
        geometry.addIndex(this.indexBuffer);
        const uploadFunction = this.getParticleUpdate(properties);
        this._dynamicUpload = uploadFunction.dynamicUpdate;
        this._staticUpload = uploadFunction.staticUpdate;
        this.geometry = geometry;
    }
    getParticleUpdate(properties) {
        const key = getParticleSyncKey(properties);
        if (this._generateParticleUpdateCache[key]) {
            return this._generateParticleUpdateCache[key];
        }
        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);
        return this._generateParticleUpdateCache[key];
    }
    generateParticleUpdate(properties) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$utils$2f$generateParticleUpdateFunction$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generateParticleUpdateFunction"])(properties);
    }
    update(particles, uploadStatic) {
        if (particles.length > this._size) {
            uploadStatic = true;
            this._size = Math.max(particles.length, this._size * 1.5 | 0);
            this.staticAttributeBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$ViewableBuffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ViewableBuffer"](this._size * this._staticStride * 4 * 4);
            this.dynamicAttributeBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$ViewableBuffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ViewableBuffer"](this._size * this._dynamicStride * 4 * 4);
            this.indexBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$utils$2f$createIndicesForQuads$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createIndicesForQuads"])(this._size);
            this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, true);
        }
        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;
        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);
        this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);
        if (uploadStatic) {
            const staticAttributeBuffer = this.staticAttributeBuffer;
            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);
            this._staticBuffer.setDataWithSize(staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);
        }
    }
    destroy() {
        this._staticBuffer.destroy();
        this._dynamicBuffer.destroy();
        this.geometry.destroy();
    }
}
function getParticleSyncKey(properties) {
    const keyGen = [];
    for(const key in properties){
        const property = properties[key];
        keyGen.push(key, property.code, property.dynamic ? "d" : "s");
    }
    return keyGen.join("_");
}
;
 //# sourceMappingURL=ParticleBuffer.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ParticleShader",
    ()=>ParticleShader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$gl$2f$shader$2f$GlProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$gpu$2f$shader$2f$GpuProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$shader$2f$particles$2e$frag$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$shader$2f$particles$2e$vert$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$shader$2f$particles$2e$wgsl$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
"use strict";
class ParticleShader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Shader"] {
    constructor(){
        const glProgram = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$gl$2f$shader$2f$GlProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GlProgram"].from({
            vertex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$shader$2f$particles$2e$vert$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
            fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$shader$2f$particles$2e$frag$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
        });
        const gpuProgram = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$gpu$2f$shader$2f$GpuProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GpuProgram"].from({
            fragment: {
                source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$shader$2f$particles$2e$wgsl$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
                entryPoint: "mainFragment"
            },
            vertex: {
                source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$shader$2f$particles$2e$wgsl$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
                entryPoint: "mainVertex"
            }
        });
        super({
            glProgram,
            gpuProgram,
            resources: {
                // this will be replaced with the texture from the particle container
                uTexture: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].WHITE.source,
                // this will be replaced with the texture style from the particle container
                uSampler: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextureStyle"]({}),
                // this will be replaced with the local uniforms from the particle container
                uniforms: {
                    uTranslationMatrix: {
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"](),
                        type: "mat3x3<f32>"
                    },
                    uColor: {
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"](16777215),
                        type: "vec4<f32>"
                    },
                    uRound: {
                        value: 1,
                        type: "f32"
                    },
                    uResolution: {
                        value: [
                            0,
                            0
                        ],
                        type: "vec2<f32>"
                    }
                }
            }
        });
    }
}
;
 //# sourceMappingURL=ParticleShader.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ParticleContainerPipe",
    ()=>ParticleContainerPipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$getAdjustedBlendModeBlend$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$State$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/GCManagedHash.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$gpu$2f$colorToUniform$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$ParticleBuffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$shader$2f$ParticleShader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
"use strict";
class ParticleContainerPipe {
    /**
   * @param renderer - The renderer this sprite batch works for.
   * @param adaptor
   */ constructor(renderer, adaptor){
        /** @internal */ this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$State$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["State"].for2d();
        /** Local uniforms that are used for rendering particles. */ this.localUniforms = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UniformGroup"]({
            uTranslationMatrix: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"](),
                type: "mat3x3<f32>"
            },
            uColor: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uRound: {
                value: 1,
                type: "f32"
            },
            uResolution: {
                value: [
                    0,
                    0
                ],
                type: "vec2<f32>"
            }
        });
        this.renderer = renderer;
        this.adaptor = adaptor;
        this.defaultShader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$shader$2f$ParticleShader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ParticleShader"]();
        this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$State$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["State"].for2d();
        this._managedContainers = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GCManagedHash"]({
            renderer,
            type: "renderable",
            name: "particleContainer"
        });
    }
    validateRenderable(_renderable) {
        return false;
    }
    addRenderable(renderable, instructionSet) {
        this.renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add(renderable);
    }
    getBuffers(renderable) {
        return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);
    }
    _initBuffer(renderable) {
        renderable._gpuData[this.renderer.uid] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$ParticleBuffer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ParticleBuffer"]({
            size: renderable.particleChildren.length,
            properties: renderable._properties
        });
        this._managedContainers.add(renderable);
        return renderable._gpuData[this.renderer.uid];
    }
    updateRenderable(_renderable) {}
    execute(container) {
        const children = container.particleChildren;
        if (children.length === 0) {
            return;
        }
        const renderer = this.renderer;
        const buffer = this.getBuffers(container);
        container.texture || (container.texture = children[0].texture);
        const state = this.state;
        buffer.update(children, container._childrenDirty);
        container._childrenDirty = false;
        state.blendMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$getAdjustedBlendModeBlend$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAdjustedBlendModeBlend"])(container.blendMode, container.texture._source);
        const uniforms = this.localUniforms.uniforms;
        const transformationMatrix = uniforms.uTranslationMatrix;
        container.worldTransform.copyTo(transformationMatrix);
        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);
        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;
        uniforms.uRound = renderer._roundPixels | container._roundPixels;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$gpu$2f$colorToUniform$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["color32BitToUniform"])(container.groupColorAlpha, uniforms.uColor, 0);
        this.adaptor.execute(this, container);
    }
    /** Destroys the ParticleRenderer. */ destroy() {
        this._managedContainers.destroy();
        this.renderer = null;
        if (this.defaultShader) {
            this.defaultShader.destroy();
            this.defaultShader = null;
        }
    }
}
;
 //# sourceMappingURL=ParticleContainerPipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GlParticleContainerPipe",
    ()=>GlParticleContainerPipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$gl$2f$GlParticleContainerAdaptor$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$ParticleContainerPipe$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
class GlParticleContainerPipe extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$ParticleContainerPipe$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ParticleContainerPipe"] {
    constructor(renderer){
        super(renderer, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$gl$2f$GlParticleContainerAdaptor$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GlParticleContainerAdaptor"]());
    }
}
/** @ignore */ GlParticleContainerPipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipes
    ],
    name: "particle"
};
;
 //# sourceMappingURL=GlParticleContainerPipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GpuParticleContainerPipe",
    ()=>GpuParticleContainerPipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$gpu$2f$GpuParticleContainerAdaptor$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$ParticleContainerPipe$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
class GpuParticleContainerPipe extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$ParticleContainerPipe$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ParticleContainerPipe"] {
    constructor(renderer){
        super(renderer, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$gpu$2f$GpuParticleContainerAdaptor$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GpuParticleContainerAdaptor"]());
    }
}
/** @ignore */ GpuParticleContainerPipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipes
    ],
    name: "particle"
};
;
 //# sourceMappingURL=GpuParticleContainerPipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/shared/Particle.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Particle",
    ()=>Particle
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$getGlobalMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$assignWithIgnore$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
const _Particle = class _Particle {
    constructor(options){
        if (options instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]) {
            this.texture = options;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$assignWithIgnore$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assignWithIgnore"])(this, _Particle.defaultOptions, {});
        } else {
            const combined = {
                ..._Particle.defaultOptions,
                ...options
            };
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$utils$2f$assignWithIgnore$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assignWithIgnore"])(this, combined, {});
        }
    }
    /**
   * The transparency of the particle. Values range from 0 (fully transparent)
   * to 1 (fully opaque). Values outside this range are clamped.
   * @example
   * ```ts
   * // Create a semi-transparent particle
   * const particle = new Particle({
   *     texture: Texture.from('particle.png'),
   *     alpha: 0.5
   * });
   *
   * // Fade out
   * particle.alpha *= 0.9;
   *
   * // Fade in
   * particle.alpha = Math.min(particle.alpha + 0.1, 1);
   *
   * // Values are clamped to valid range
   * particle.alpha = 1.5; // Becomes 1.0
   * particle.alpha = -0.5; // Becomes 0.0
   *
   * // Animate transparency
   * app.ticker.add((delta) => {
   *     const time = performance.now() / 1000;
   *     particle.alpha = 0.5 + Math.sin(time) * 0.5; // Pulse between 0-1
   * });
   * ```
   * @default 1
   * @see {@link Particle#tint} For controlling particle color
   * @see {@link Particle#color} For the combined color and alpha value
   */ get alpha() {
        return this._alpha;
    }
    set alpha(value) {
        this._alpha = Math.min(Math.max(value, 0), 1);
        this._updateColor();
    }
    /**
   * The tint color of the particle. Can be set using hex numbers or CSS color strings.
   * The tint is multiplied with the texture color to create the final particle color.
   * @example
   * ```ts
   * // Create a red particle
   * const particle = new Particle({
   *     texture: Texture.from('particle.png'),
   *     tint: 0xff0000
   * });
   *
   * // Use CSS color strings
   * particle.tint = '#00ff00';  // Green
   * particle.tint = 'blue';     // Blue
   *
   * // Animate tint color
   * app.ticker.add(() => {
   *     const time = performance.now() / 1000;
   *
   *     // Cycle through hues
   *     const hue = (time * 50) % 360;
   *     particle.tint = `hsl(${hue}, 100%, 50%)`;
   * });
   *
   * // Reset to white (no tint)
   * particle.tint = 0xffffff;
   * ```
   * @type {ColorSource} Hex number or CSS color string
   * @default 0xffffff
   * @see {@link Particle#alpha} For controlling transparency
   * @see {@link Particle#color} For the combined color and alpha value
   * @see {@link Color} For supported color formats
   */ get tint() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$container$2d$mixins$2f$getGlobalMixin$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bgr2rgb"])(this._tint);
    }
    set tint(value) {
        this._tint = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(value ?? 16777215).toBgrNumber();
        this._updateColor();
    }
    _updateColor() {
        this.color = this._tint + ((this._alpha * 255 | 0) << 24);
    }
};
/**
 * Default options used when creating new particles. These values are applied when specific
 * options aren't provided in the constructor.
 * @example
 * ```ts
 * // Override defaults globally
 * Particle.defaultOptions = {
 *     ...Particle.defaultOptions,
 *     anchorX: 0.5,
 *     anchorY: 0.5,
 *     alpha: 0.8
 * };
 *
 * // New particles use modified defaults
 * const centeredParticle = new Particle(texture);
 * console.log(centeredParticle.anchorX); // 0.5
 * console.log(centeredParticle.alpha); // 0.8
 * ```
 * @see {@link ParticleOptions} For all available options
 * @see {@link Particle} For the particle implementation
 */ _Particle.defaultOptions = {
    anchorX: 0,
    anchorY: 0,
    x: 0,
    y: 0,
    scaleX: 1,
    scaleY: 1,
    rotation: 0,
    tint: 16777215,
    alpha: 1
};
let Particle = _Particle;
;
 //# sourceMappingURL=Particle.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/shared/particleData.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "particleData",
    ()=>particleData
]);
"use strict";
const particleData = {
    vertex: {
        attributeName: "aVertex",
        format: "float32x2",
        code: `
            const texture = p.texture;
            const sx = p.scaleX;
            const sy = p.scaleY;
            const ax = p.anchorX;
            const ay = p.anchorY;
            const trim = texture.trim;
            const orig = texture.orig;

            if (trim)
            {
                w1 = trim.x - (ax * orig.width);
                w0 = w1 + trim.width;

                h1 = trim.y - (ay * orig.height);
                h0 = h1 + trim.height;
            }
            else
            {
                w1 = -ax * (orig.width);
                w0 = w1 + orig.width;

                h1 = -ay * (orig.height);
                h0 = h1 + orig.height;
            }

            f32v[offset] = w1 * sx;
            f32v[offset + 1] = h1 * sy;

            f32v[offset + stride] = w0 * sx;
            f32v[offset + stride + 1] = h1 * sy;

            f32v[offset + (stride * 2)] = w0 * sx;
            f32v[offset + (stride * 2) + 1] = h0 * sy;

            f32v[offset + (stride * 3)] = w1 * sx;
            f32v[offset + (stride * 3) + 1] = h0 * sy;
        `,
        dynamic: false
    },
    // positionData
    position: {
        attributeName: "aPosition",
        format: "float32x2",
        code: `
            var x = p.x;
            var y = p.y;

            f32v[offset] = x;
            f32v[offset + 1] = y;

            f32v[offset + stride] = x;
            f32v[offset + stride + 1] = y;

            f32v[offset + (stride * 2)] = x;
            f32v[offset + (stride * 2) + 1] = y;

            f32v[offset + (stride * 3)] = x;
            f32v[offset + (stride * 3) + 1] = y;
        `,
        dynamic: true
    },
    // rotationData
    rotation: {
        attributeName: "aRotation",
        format: "float32",
        code: `
            var rotation = p.rotation;

            f32v[offset] = rotation;
            f32v[offset + stride] = rotation;
            f32v[offset + (stride * 2)] = rotation;
            f32v[offset + (stride * 3)] = rotation;
        `,
        dynamic: false
    },
    // uvsData
    uvs: {
        attributeName: "aUV",
        format: "float32x2",
        code: `
            var uvs = p.texture.uvs;

            f32v[offset] = uvs.x0;
            f32v[offset + 1] = uvs.y0;

            f32v[offset + stride] = uvs.x1;
            f32v[offset + stride + 1] = uvs.y1;

            f32v[offset + (stride * 2)] = uvs.x2;
            f32v[offset + (stride * 2) + 1] = uvs.y2;

            f32v[offset + (stride * 3)] = uvs.x3;
            f32v[offset + (stride * 3) + 1] = uvs.y3;
        `,
        dynamic: false
    },
    // tintData
    color: {
        attributeName: "aColor",
        format: "unorm8x4",
        code: `
            const c = p.color;

            u32v[offset] = c;
            u32v[offset + stride] = c;
            u32v[offset + (stride * 2)] = c;
            u32v[offset + (stride * 3)] = c;
        `,
        dynamic: false
    }
};
;
 //# sourceMappingURL=particleData.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ParticleContainer",
    ()=>ParticleContainer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/view/ViewContainer.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$particleData$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/particle-container/shared/particleData.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
const emptyBounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bounds"](0, 0, 0, 0);
const _ParticleContainer = class _ParticleContainer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ViewContainer"] {
    /**
   * @param options - The options for creating the sprite.
   */ constructor(options = {}){
        options = {
            ..._ParticleContainer.defaultOptions,
            ...options,
            dynamicProperties: {
                ..._ParticleContainer.defaultOptions.dynamicProperties,
                ...options?.dynamicProperties
            }
        };
        const { dynamicProperties, shader, roundPixels, texture, particles, ...rest } = options;
        super({
            label: "ParticleContainer",
            ...rest
        });
        /**
     * The unique identifier for the render pipe of this ParticleContainer.
     * @internal
     */ this.renderPipeId = "particle";
        /** @internal */ this.batched = false;
        /**
     * Indicates if the children of this ParticleContainer have changed and need to be updated.
     * @internal
     */ this._childrenDirty = false;
        this.texture = texture || null;
        this.shader = shader;
        this._properties = {};
        for(const key in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$particleData$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["particleData"]){
            const property = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$particle$2d$container$2f$shared$2f$particleData$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["particleData"][key];
            const dynamic = dynamicProperties[key];
            this._properties[key] = {
                ...property,
                dynamic
            };
        }
        this.allowChildren = true;
        this.roundPixels = roundPixels ?? false;
        this.particleChildren = particles ?? [];
    }
    /**
   * Adds one or more particles to the container. The particles will be rendered using the container's shared texture
   * and properties. When adding multiple particles, they must all share the same base texture.
   * @example
   * ```ts
   * const container = new ParticleContainer();
   *
   * // Add a single particle
   * const particle = new Particle(Assets.get('particleTexture'));
   * container.addParticle(particle);
   *
   * // Add multiple particles at once
   * const particles = [
   *     new Particle(Assets.get('particleTexture')),
   *     new Particle(Assets.get('particleTexture')),
   *     new Particle(Assets.get('particleTexture'))
   * ];
   *
   * container.addParticle(...particles);
   * ```
   * @param children - The Particle(s) to add to the container
   * @returns The first particle that was added, for method chaining
   * @see {@link ParticleContainer#texture} For setting the shared texture
   * @see {@link ParticleContainer#update} For updating after modifications
   */ addParticle(...children) {
        for(let i = 0; i < children.length; i++){
            this.particleChildren.push(children[i]);
        }
        this.onViewUpdate();
        return children[0];
    }
    /**
   * Removes one or more particles from the container. The particles must already be children
   * of this container to be removed.
   * @example
   * ```ts
   * // Remove a single particle
   * container.removeParticle(particle1);
   *
   * // Remove multiple particles at once
   * container.removeParticle(particle2, particle3);
   * ```
   * @param children - The Particle(s) to remove from the container
   * @returns The first particle that was removed, for method chaining
   * @see {@link ParticleContainer#particleChildren} For accessing all particles
   * @see {@link ParticleContainer#removeParticles} For removing particles by index
   * @see {@link ParticleContainer#removeParticleAt} For removing a particle at a specific index
   */ removeParticle(...children) {
        let didRemove = false;
        for(let i = 0; i < children.length; i++){
            const index = this.particleChildren.indexOf(children[i]);
            if (index > -1) {
                this.particleChildren.splice(index, 1);
                didRemove = true;
            }
        }
        if (didRemove) this.onViewUpdate();
        return children[0];
    }
    /**
   * Updates the particle container's internal state. Call this method after manually modifying
   * the particleChildren array or when changing static properties of particles.
   * @example
   * ```ts
   * // Batch modify particles
   * container.particleChildren.push(...particles);
   * container.update(); // Required after direct array modification
   *
   * // Update static properties
   * container.particleChildren.forEach(particle => {
   *     particle.position.set(
   *         Math.random() * 800,
   *         Math.random() * 600
   *     );
   * });
   * container.update(); // Required after changing static positions
   * ```
   * @see {@link ParticleProperties} For configuring dynamic vs static properties
   * @see {@link ParticleContainer#particleChildren} For direct array access
   */ update() {
        this._childrenDirty = true;
    }
    onViewUpdate() {
        this._childrenDirty = true;
        super.onViewUpdate();
    }
    /**
   * Returns a static empty bounds object since ParticleContainer does not calculate bounds automatically
   * for performance reasons. Use the `boundsArea` property to manually set container bounds.
   * @example
   * ```ts
   * const container = new ParticleContainer({
   *     texture: Texture.from('particle.png')
   * });
   *
   * // Default bounds are empty
   * console.log(container.bounds); // Bounds(0, 0, 0, 0)
   *
   * // Set manual bounds for the particle area
   * container.boundsArea = {
   *     minX: 0,
   *     minY: 0,
   *     maxX: 800,
   *     maxY: 600
   * };
   * ```
   * @readonly
   * @returns {Bounds} An empty bounds object (0,0,0,0)
   * @see {@link Container#boundsArea} For manually setting container bounds
   * @see {@link Bounds} For bounds object structure
   */ get bounds() {
        return emptyBounds;
    }
    /** @private */ updateBounds() {}
    /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * particleContainer.destroy();
   * particleContainer.destroy(true);
   * particleContainer.destroy({ texture: true, textureSource: true, children: true });
   */ destroy(options = false) {
        super.destroy(options);
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            const texture = this.texture ?? this.particleChildren[0]?.texture;
            if (texture) {
                texture.destroy(destroyTextureSource);
            }
        }
        this.texture = null;
        this.shader?.destroy();
    }
    /**
   * Removes all particles from this container that are within the begin and end indexes.
   * @param beginIndex - The beginning position.
   * @param endIndex - The ending position. Default value is size of the container.
   * @returns - List of removed particles
   */ removeParticles(beginIndex, endIndex) {
        beginIndex ?? (beginIndex = 0);
        endIndex ?? (endIndex = this.particleChildren.length);
        const children = this.particleChildren.splice(beginIndex, endIndex - beginIndex);
        this.onViewUpdate();
        return children;
    }
    /**
   * Removes a particle from the specified index position.
   * @param index - The index to get the particle from
   * @returns The particle that was removed.
   */ removeParticleAt(index) {
        const child = this.particleChildren.splice(index, 1);
        this.onViewUpdate();
        return child[0];
    }
    /**
   * Adds a particle to the container at a specified index. If the index is out of bounds an error will be thrown.
   * If the particle is already in this container, it will be moved to the specified index.
   * @param {Container} child - The particle to add.
   * @param {number} index - The absolute index where the particle will be positioned at the end of the operation.
   * @returns {Container} The particle that was added.
   */ addParticleAt(child, index) {
        this.particleChildren.splice(index, 0, child);
        this.onViewUpdate();
        return child;
    }
    /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.addParticle()` instead.
   * @param {...any} _children
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ addChild(..._children) {
        throw new Error("ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()");
    }
    /**
   * This method is not available in ParticleContainer.
   * Calling this method will throw an error. Please use `ParticleContainer.removeParticle()` instead.
   * @param {...any} _children
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ removeChild(..._children) {
        throw new Error("ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()");
    }
    /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.removeParticles()` instead.
   * @param {number} [_beginIndex]
   * @param {number} [_endIndex]
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ removeChildren(_beginIndex, _endIndex) {
        throw new Error("ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()");
    }
    /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.removeParticleAt()` instead.
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ removeChildAt(_index) {
        throw new Error("ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()");
    }
    /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.getParticleAt()` instead.
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ getChildAt(_index) {
        throw new Error("ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()");
    }
    /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.setParticleIndex()` instead.
   * @param {ContainerChild} _child
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ setChildIndex(_child, _index) {
        throw new Error("ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()");
    }
    /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.getParticleIndex()` instead.
   * @param {ContainerChild} _child
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ getChildIndex(_child) {
        throw new Error("ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()");
    }
    /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.addParticleAt()` instead.
   * @param {ContainerChild} _child
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ addChildAt(_child, _index) {
        throw new Error("ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()");
    }
    /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.swapParticles()` instead.
   * @param {ContainerChild} _child
   * @param {ContainerChild} _child2
   * @ignore
   */ swapChildren(_child, _child2) {
        throw new Error("ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()");
    }
    /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error.
   * @param _child - The child to reparent
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ reparentChild(..._child) {
        throw new Error("ParticleContainer.reparentChild() is not available with the particle container");
    }
    /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error.
   * @param _child - The child to reparent
   * @param _index - The index to reparent the child to
   * @throws {Error} Always throws an error as this method is not available.
   * @ignore
   */ reparentChildAt(_child, _index) {
        throw new Error("ParticleContainer.reparentChildAt() is not available with the particle container");
    }
};
/**
 * Defines the default options for creating a ParticleContainer.
 * @example
 * ```ts
 * // Change defaults globally
 * ParticleContainer.defaultOptions = {
 *     dynamicProperties: {
 *         position: true,  // Update positions each frame
 *         rotation: true,  // Update rotations each frame
 *         vertex: false,   // Static vertices
 *         uvs: false,      // Static texture coordinates
 *         color: false     // Static colors
 *     },
 *     roundPixels: true // Enable pixel rounding for crisp rendering
 * };
 * ```
 * @property {Record<string, boolean>} dynamicProperties - Specifies which properties are dynamic.
 * @property {boolean} roundPixels - Indicates if pixels should be rounded.
 */ _ParticleContainer.defaultOptions = {
    /** Specifies which properties are dynamic. */ dynamicProperties: {
        /** Indicates if vertex positions are dynamic. */ vertex: false,
        /** Indicates if particle positions are dynamic. */ position: true,
        /** Indicates if particle rotations are dynamic. */ rotation: false,
        /** Indicates if UV coordinates are dynamic. */ uvs: false,
        /** Indicates if particle colors are dynamic. */ color: false
    },
    /** Indicates if pixels should be rounded for rendering. */ roundPixels: false
};
let ParticleContainer = _ParticleContainer;
;
 //# sourceMappingURL=ParticleContainer.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NineSliceGeometry",
    ()=>NineSliceGeometry
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$plane$2f$PlaneGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs [app-ssr] (ecmascript)");
;
"use strict";
const _NineSliceGeometry = class _NineSliceGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2d$plane$2f$PlaneGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PlaneGeometry"] {
    constructor(options = {}){
        options = {
            ..._NineSliceGeometry.defaultOptions,
            ...options
        };
        super({
            width: options.width,
            height: options.height,
            verticesX: 4,
            verticesY: 4
        });
        this.update(options);
    }
    /**
   * Updates the NineSliceGeometry with the options.
   * @param options - The options of the NineSliceGeometry.
   */ update(options) {
        this.width = options.width ?? this.width;
        this.height = options.height ?? this.height;
        this._originalWidth = options.originalWidth ?? this._originalWidth;
        this._originalHeight = options.originalHeight ?? this._originalHeight;
        this._leftWidth = options.leftWidth ?? this._leftWidth;
        this._rightWidth = options.rightWidth ?? this._rightWidth;
        this._topHeight = options.topHeight ?? this._topHeight;
        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
        this._anchorX = options.anchor?.x;
        this._anchorY = options.anchor?.y;
        this.updateUvs();
        this.updatePositions();
    }
    /** Updates the positions of the vertices. */ updatePositions() {
        const p = this.positions;
        const { width, height, _leftWidth, _rightWidth, _topHeight, _bottomHeight, _anchorX, _anchorY } = this;
        const w = _leftWidth + _rightWidth;
        const scaleW = width > w ? 1 : width / w;
        const h = _topHeight + _bottomHeight;
        const scaleH = height > h ? 1 : height / h;
        const scale = Math.min(scaleW, scaleH);
        const anchorOffsetX = _anchorX * width;
        const anchorOffsetY = _anchorY * height;
        p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;
        p[2] = p[10] = p[18] = p[26] = _leftWidth * scale - anchorOffsetX;
        p[4] = p[12] = p[20] = p[28] = width - _rightWidth * scale - anchorOffsetX;
        p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;
        p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;
        p[9] = p[11] = p[13] = p[15] = _topHeight * scale - anchorOffsetY;
        p[17] = p[19] = p[21] = p[23] = height - _bottomHeight * scale - anchorOffsetY;
        p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;
        this.getBuffer("aPosition").update();
    }
    /** Updates the UVs of the vertices. */ updateUvs() {
        const uvs = this.uvs;
        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
        const _uvw = 1 / this._originalWidth;
        const _uvh = 1 / this._originalHeight;
        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
        this.getBuffer("aUV").update();
    }
};
/** The default options for the NineSliceGeometry. */ _NineSliceGeometry.defaultOptions = {
    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */ width: 100,
    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */ height: 100,
    /** The width of the left column. */ leftWidth: 10,
    /** The height of the top row. */ topHeight: 10,
    /** The width of the right column. */ rightWidth: 10,
    /** The height of the bottom row. */ bottomHeight: 10,
    /** The original width of the texture */ originalWidth: 100,
    /** The original height of the texture */ originalHeight: 100
};
let NineSliceGeometry = _NineSliceGeometry;
;
 //# sourceMappingURL=NineSliceGeometry.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NineSlicePlane",
    ()=>NineSlicePlane,
    "NineSliceSprite",
    ()=>NineSliceSprite
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/view/ViewContainer.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$nine$2d$slice$2f$NineSliceGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
"use strict";
const _NineSliceSprite = class _NineSliceSprite extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ViewContainer"] {
    constructor(options){
        if (options instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]) {
            options = {
                texture: options
            };
        }
        const { width, height, anchor, leftWidth, rightWidth, topHeight, bottomHeight, texture, roundPixels, ...rest } = options;
        super({
            label: "NineSliceSprite",
            ...rest
        });
        /** @internal */ this.renderPipeId = "nineSliceSprite";
        /** @internal */ this.batched = true;
        this._leftWidth = leftWidth ?? texture?.defaultBorders?.left ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$nine$2d$slice$2f$NineSliceGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NineSliceGeometry"].defaultOptions.leftWidth;
        this._topHeight = topHeight ?? texture?.defaultBorders?.top ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$nine$2d$slice$2f$NineSliceGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NineSliceGeometry"].defaultOptions.topHeight;
        this._rightWidth = rightWidth ?? texture?.defaultBorders?.right ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$nine$2d$slice$2f$NineSliceGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NineSliceGeometry"].defaultOptions.rightWidth;
        this._bottomHeight = bottomHeight ?? texture?.defaultBorders?.bottom ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$nine$2d$slice$2f$NineSliceGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NineSliceGeometry"].defaultOptions.bottomHeight;
        this._width = width ?? texture.width ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$nine$2d$slice$2f$NineSliceGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NineSliceGeometry"].defaultOptions.width;
        this._height = height ?? texture.height ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$nine$2d$slice$2f$NineSliceGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NineSliceGeometry"].defaultOptions.height;
        this.allowChildren = false;
        this.texture = texture ?? _NineSliceSprite.defaultOptions.texture;
        this.roundPixels = roundPixels ?? false;
        this._anchor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservablePoint"]({
            _onUpdate: ()=>{
                this.onViewUpdate();
            }
        });
        if (anchor) {
            this.anchor = anchor;
        } else if (this.texture.defaultAnchor) {
            this.anchor = this.texture.defaultAnchor;
        }
    }
    /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * - The default is `(0,0)`, this means the sprite's origin is the top left.
   * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * ```ts
   * // Center the anchor point
   * sprite.anchor = 0.5; // Sets both x and y to 0.5
   * sprite.position.set(400, 300); // Sprite will be centered at this position
   *
   * // Set specific x/y anchor points
   * sprite.anchor = {
   *     x: 1, // Right edge
   *     y: 0  // Top edge
   * };
   *
   * // Using individual coordinates
   * sprite.anchor.set(0.5, 1); // Center-bottom
   *
   * // For rotation around center
   * sprite.anchor.set(0.5);
   * sprite.rotation = Math.PI / 4; // 45 degrees around center
   *
   * // For scaling from center
   * sprite.anchor.set(0.5);
   * sprite.scale.set(2); // Scales from center point
   * ```
   */ get anchor() {
        return this._anchor;
    }
    set anchor(value) {
        typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    /**
   * The width of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane.
   * The width affects how the middle sections are scaled.
   * @example
   * ```ts
   * // Create a nine-slice sprite with fixed width
   * const panel = new NineSliceSprite({
   *     texture: Texture.from('panel.png'),
   *     width: 200  // Sets initial width
   * });
   *
   * // Adjust width dynamically
   * panel.width = 300;  // Stretches middle sections
   * ```
   * @see {@link NineSliceSprite#setSize} For setting both width and height efficiently
   * @see {@link NineSliceSprite#height} For setting height
   */ get width() {
        return this._width;
    }
    set width(value) {
        this._width = value;
        this.onViewUpdate();
    }
    /**
   * The height of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane.
   * The height affects how the middle sections are scaled.
   * @example
   * ```ts
   * // Create a nine-slice sprite with fixed height
   * const panel = new NineSliceSprite({
   *     texture: Texture.from('panel.png'),
   *     height: 150  // Sets initial height
   * });
   *
   * // Adjust height dynamically
   * panel.height = 200;  // Stretches middle sections
   *
   * // Create responsive UI element
   * const dialog = new NineSliceSprite({
   *     texture: Texture.from('dialog.png'),
   *     topHeight: 30,
   *     bottomHeight: 30,
   *     height: parent.height * 0.5  // 50% of parent height
   * });
   * ```
   * @see {@link NineSliceSprite#setSize} For setting both width and height efficiently
   * @see {@link NineSliceSprite#width} For setting width
   */ get height() {
        return this._height;
    }
    set height(value) {
        this._height = value;
        this.onViewUpdate();
    }
    /**
   * Sets the size of the NineSliceSprite to the specified width and height.
   * This method directly modifies the vertices and UV coordinates of the sprite.
   *
   * Using this is more efficient than setting width and height separately as it only triggers one update.
   * @example
   * ```ts
   * // Set to specific dimensions
   * panel.setSize(300, 200); // Width: 300, Height: 200
   *
   * // Set uniform size
   * panel.setSize(200); // Makes a square 200x200
   *
   * // Set size using object
   * panel.setSize({
   *     width: 400,
   *     height: 300
   * });
   * ```
   * @param value - This can be either a number or a Size object with width/height properties
   * @param height - The height to set. Defaults to the value of `width` if not provided
   * @see {@link NineSliceSprite#width} For setting width only
   * @see {@link NineSliceSprite#height} For setting height only
   */ setSize(value, height) {
        if (typeof value === "object") {
            height = value.height ?? value.width;
            value = value.width;
        }
        this._width = value;
        this._height = height ?? value;
        this.onViewUpdate();
    }
    /**
   * Retrieves the size of the NineSliceSprite as a [Size]{@link Size} object.
   * This method is more efficient than getting width and height separately.
   * @example
   * ```ts
   * // Get basic size
   * const size = panel.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * panel.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in, to avoid allocating a new object
   * @returns The size of the NineSliceSprite
   * @see {@link NineSliceSprite#width} For getting just the width
   * @see {@link NineSliceSprite#height} For getting just the height
   * @see {@link NineSliceSprite#setSize} For setting both width and height efficiently
   */ getSize(out) {
        out || (out = {});
        out.width = this._width;
        out.height = this._height;
        return out;
    }
    /**
   * Width of the left vertical bar (A).
   * Controls the size of the left edge that remains unscaled
   * @example
   * ```ts
   * const sprite = new NineSliceSprite({ ..., leftWidth: 20 });
   * sprite.leftWidth = 20; // Set left border width
   * ```
   * @default 10
   */ get leftWidth() {
        return this._leftWidth;
    }
    set leftWidth(value) {
        this._leftWidth = value;
        this.onViewUpdate();
    }
    /**
   * Height of the top horizontal bar (C).
   * Controls the size of the top edge that remains unscaled
   * @example
   * ```ts
   * const sprite = new NineSliceSprite({ ..., topHeight: 20 });
   * sprite.topHeight = 20; // Set top border height
   * ```
   * @default 10
   */ get topHeight() {
        return this._topHeight;
    }
    set topHeight(value) {
        this._topHeight = value;
        this.onViewUpdate();
    }
    /**
   * Width of the right vertical bar (B).
   * Controls the size of the right edge that remains unscaled
   * @example
   * ```ts
   * const sprite = new NineSliceSprite({ ..., rightWidth: 20 });
   * sprite.rightWidth = 20; // Set right border width
   * ```
   * @default 10
   */ get rightWidth() {
        return this._rightWidth;
    }
    set rightWidth(value) {
        this._rightWidth = value;
        this.onViewUpdate();
    }
    /**
   * Height of the bottom horizontal bar (D).
   * Controls the size of the bottom edge that remains unscaled
   * @example
   * ```ts
   * const sprite = new NineSliceSprite({ ..., bottomHeight: 20 });
   * sprite.bottomHeight = 20; // Set bottom border height
   * ```
   * @default 10
   */ get bottomHeight() {
        return this._bottomHeight;
    }
    set bottomHeight(value) {
        this._bottomHeight = value;
        this.onViewUpdate();
    }
    /**
   * The texture to use on the NineSliceSprite.
   * ```ts
   * // Create a sprite with a texture
   * const sprite = new NineSliceSprite({
   *     texture: Texture.from('path/to/image.png')
   * });
   * // Update the texture later
   * sprite.texture = Texture.from('path/to/another-image.png');
   * ```
   * @default Texture.EMPTY
   */ get texture() {
        return this._texture;
    }
    set texture(value) {
        value || (value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY);
        const currentTexture = this._texture;
        if (currentTexture === value) return;
        if (currentTexture && currentTexture.dynamic) currentTexture.off("update", this.onViewUpdate, this);
        if (value.dynamic) value.on("update", this.onViewUpdate, this);
        this._texture = value;
        this.onViewUpdate();
    }
    /**
   * The original width of the texture before any nine-slice scaling.
   * This is the width of the source texture used to create the nine-slice sprite.
   * @example
   * ```ts
   * // Get original dimensions
   * console.log(`Original size: ${sprite.originalWidth}x${sprite.originalHeight}`);
   *
   * // Use for relative scaling
   * sprite.width = sprite.originalWidth * 2; // Double the original width
   *
   * // Reset to original size
   * sprite.setSize(sprite.originalWidth, sprite.originalHeight);
   * ```
   * @readonly
   * @see {@link NineSliceSprite#width} For the current displayed width
   * @see {@link Texture#width} For direct texture width access
   * @returns The original width of the texture
   */ get originalWidth() {
        return this._texture.width;
    }
    /**
   * The original height of the texture before any nine-slice scaling.
   * This is the height of the source texture used to create the nine-slice sprite.
   * @example
   * ```ts
   * // Get original dimensions
   * console.log(`Original size: ${sprite.originalWidth}x${sprite.originalHeight}`);
   *
   * // Use for relative scaling
   * sprite.height = sprite.originalHeight * 2; // Double the original height
   *
   * // Reset to original size
   * sprite.setSize(sprite.originalWidth, sprite.originalHeight);
   * ```
   * @readonly
   * @see {@link NineSliceSprite#height} For the current displayed height
   * @see {@link Texture#height} For direct texture height access
   * @returns The original height of the texture
   */ get originalHeight() {
        return this._texture.height;
    }
    /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * nineSliceSprite.destroy();
   * nineSliceSprite.destroy(true);
   * nineSliceSprite.destroy({ texture: true, textureSource: true });
   */ destroy(options) {
        super.destroy(options);
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
    }
    /** @private */ updateBounds() {
        const bounds = this._bounds;
        const anchor = this._anchor;
        const width = this._width;
        const height = this._height;
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * height;
        bounds.maxY = bounds.minY + height;
    }
};
/**
 * The default options used to override initial values of any options passed in the constructor.
 * These values are used as fallbacks when specific options are not provided.
 * @example
 * ```ts
 * // Override default options globally
 * NineSliceSprite.defaultOptions.texture = Texture.from('defaultButton.png');
 * // Create sprite with default texture
 * const sprite = new NineSliceSprite({...});
 * // sprite will use 'defaultButton.png' as its texture
 *
 * // Reset to empty texture
 * NineSliceSprite.defaultOptions.texture = Texture.EMPTY;
 * ```
 * @type {NineSliceSpriteOptions}
 * @see {@link NineSliceSpriteOptions} For all available options
 * @see {@link Texture#defaultBorders} For texture-level border settings
 */ _NineSliceSprite.defaultOptions = {
    /** @default Texture.EMPTY */ texture: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY
};
let NineSliceSprite = _NineSliceSprite;
class NineSlicePlane extends NineSliceSprite {
    constructor(...args){
        let options = args[0];
        if (options instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"]) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}");
            options = {
                texture: options,
                leftWidth: args[1],
                topHeight: args[2],
                rightWidth: args[3],
                bottomHeight: args[4]
            };
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v8_0_0"], "NineSlicePlane is deprecated. Use NineSliceSprite instead.");
        super(options);
    }
}
;
 //# sourceMappingURL=NineSliceSprite.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NineSliceSpriteGpuData",
    ()=>NineSliceSpriteGpuData,
    "NineSliceSpritePipe",
    ()=>NineSliceSpritePipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/GCManagedHash.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$BatchableMesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$nine$2d$slice$2f$NineSliceGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
class NineSliceSpriteGpuData extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$BatchableMesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BatchableMesh"] {
    constructor(){
        super();
        this.geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$nine$2d$slice$2f$NineSliceGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NineSliceGeometry"]();
    }
    destroy() {
        this.geometry.destroy();
    }
}
class NineSliceSpritePipe {
    constructor(renderer){
        this._renderer = renderer;
        this._managedSprites = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GCManagedHash"]({
            renderer,
            type: "renderable",
            name: "nineSliceSprite"
        });
    }
    addRenderable(sprite, instructionSet) {
        const gpuSprite = this._getGpuSprite(sprite);
        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);
        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
    }
    updateRenderable(sprite) {
        const gpuSprite = this._getGpuSprite(sprite);
        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);
        gpuSprite._batcher.updateElement(gpuSprite);
    }
    validateRenderable(sprite) {
        const gpuSprite = this._getGpuSprite(sprite);
        return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, sprite._texture);
    }
    _updateBatchableSprite(sprite, batchableSprite) {
        batchableSprite.geometry.update(sprite);
        batchableSprite.setTexture(sprite._texture);
    }
    _getGpuSprite(sprite) {
        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);
    }
    _initGPUSprite(sprite) {
        const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();
        const batchableMesh = gpuData;
        batchableMesh.renderable = sprite;
        batchableMesh.transform = sprite.groupTransform;
        batchableMesh.texture = sprite._texture;
        batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
        this._managedSprites.add(sprite);
        if (!sprite.didViewUpdate) {
            this._updateBatchableSprite(sprite, batchableMesh);
        }
        return gpuData;
    }
    destroy() {
        this._managedSprites.destroy();
        this._renderer = null;
    }
}
/** @ignore */ NineSliceSpritePipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasPipes
    ],
    name: "nineSliceSprite"
};
;
 //# sourceMappingURL=NineSliceSpritePipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "tilingBit",
    ()=>tilingBit,
    "tilingBitGl",
    ()=>tilingBitGl
]);
"use strict";
const tilingBit = {
    name: "tiling-bit",
    vertex: {
        header: /* wgsl */ `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
        main: /* wgsl */ `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
    },
    fragment: {
        header: /* wgsl */ `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
        main: /* wgsl */ `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
    }
};
const tilingBitGl = {
    name: "tiling-bit",
    vertex: {
        header: /* glsl */ `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `,
        main: /* glsl */ `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
    },
    fragment: {
        header: /* glsl */ `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
        main: /* glsl */ `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `
    }
};
;
 //# sourceMappingURL=tilingBit.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TilingSpriteShader",
    ()=>TilingSpriteShader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$localUniformBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$shader$2f$tilingBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
"use strict";
let gpuProgram;
let glProgram;
class TilingSpriteShader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Shader"] {
    constructor(){
        gpuProgram ?? (gpuProgram = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compileHighShaderGpuProgram"])({
            name: "tiling-sprite-shader",
            bits: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$localUniformBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["localUniformBit"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$shader$2f$tilingBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tilingBit"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundPixelsBit"]
            ]
        }));
        glProgram ?? (glProgram = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compileHighShaderGlProgram"])({
            name: "tiling-sprite-shader",
            bits: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$localUniformBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["localUniformBitGl"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$shader$2f$tilingBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tilingBitGl"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundPixelsBitGl"]
            ]
        }));
        const tilingUniforms = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UniformGroup"]({
            uMapCoord: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"](),
                type: "mat3x3<f32>"
            },
            uClampFrame: {
                value: new Float32Array([
                    0,
                    0,
                    1,
                    1
                ]),
                type: "vec4<f32>"
            },
            uClampOffset: {
                value: new Float32Array([
                    0,
                    0
                ]),
                type: "vec2<f32>"
            },
            uTextureTransform: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"](),
                type: "mat3x3<f32>"
            },
            uSizeAnchor: {
                value: new Float32Array([
                    100,
                    100,
                    0.5,
                    0.5
                ]),
                type: "vec4<f32>"
            }
        });
        super({
            glProgram,
            gpuProgram,
            resources: {
                localUniforms: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UniformGroup"]({
                    uTransformMatrix: {
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"](),
                        type: "mat3x3<f32>"
                    },
                    uColor: {
                        value: new Float32Array([
                            1,
                            1,
                            1,
                            1
                        ]),
                        type: "vec4<f32>"
                    },
                    uRound: {
                        value: 0,
                        type: "f32"
                    }
                }),
                tilingUniforms,
                uTexture: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY.source,
                uSampler: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY.source.style
            }
        });
    }
    updateUniforms(width, height, matrix, anchorX, anchorY, texture) {
        const tilingUniforms = this.resources.tilingUniforms;
        const textureWidth = texture.width;
        const textureHeight = texture.height;
        const textureMatrix = texture.textureMatrix;
        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
        uTextureTransform.set(matrix.a * textureWidth / width, matrix.b * textureWidth / height, matrix.c * textureHeight / width, matrix.d * textureHeight / height, matrix.tx / width, matrix.ty / height);
        uTextureTransform.invert();
        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
        tilingUniforms.uniforms.uSizeAnchor[0] = width;
        tilingUniforms.uniforms.uSizeAnchor[1] = height;
        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;
        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;
        if (texture) {
            this.resources.uTexture = texture.source;
            this.resources.uSampler = texture.source.style;
        }
    }
}
;
 //# sourceMappingURL=TilingSpriteShader.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "QuadGeometry",
    ()=>QuadGeometry
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs [app-ssr] (ecmascript)");
;
"use strict";
class QuadGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MeshGeometry"] {
    constructor(){
        super({
            positions: new Float32Array([
                0,
                0,
                1,
                0,
                1,
                1,
                0,
                1
            ]),
            uvs: new Float32Array([
                0,
                0,
                1,
                0,
                1,
                1,
                0,
                1
            ]),
            indices: new Uint32Array([
                0,
                1,
                2,
                0,
                2,
                3
            ])
        });
    }
}
;
 //# sourceMappingURL=QuadGeometry.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "setPositions",
    ()=>setPositions
]);
"use strict";
function setPositions(tilingSprite, positions) {
    const anchorX = tilingSprite.anchor.x;
    const anchorY = tilingSprite.anchor.y;
    positions[0] = -anchorX * tilingSprite.width;
    positions[1] = -anchorY * tilingSprite.height;
    positions[2] = (1 - anchorX) * tilingSprite.width;
    positions[3] = -anchorY * tilingSprite.height;
    positions[4] = (1 - anchorX) * tilingSprite.width;
    positions[5] = (1 - anchorY) * tilingSprite.height;
    positions[6] = -anchorX * tilingSprite.width;
    positions[7] = (1 - anchorY) * tilingSprite.height;
}
;
 //# sourceMappingURL=setPositions.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "applyMatrix",
    ()=>applyMatrix
]);
"use strict";
function applyMatrix(array, stride, offset, matrix) {
    let index = 0;
    const size = array.length / (stride || 2);
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    offset *= stride;
    while(index < size){
        const x = array[offset];
        const y = array[offset + 1];
        array[offset] = a * x + c * y + tx;
        array[offset + 1] = b * x + d * y + ty;
        offset += stride;
        index++;
    }
}
;
 //# sourceMappingURL=applyMatrix.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "setUvs",
    ()=>setUvs
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$utils$2f$applyMatrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
function setUvs(tilingSprite, uvs) {
    const texture = tilingSprite.texture;
    const width = texture.frame.width;
    const height = texture.frame.height;
    let anchorX = 0;
    let anchorY = 0;
    if (tilingSprite.applyAnchorToTexture) {
        anchorX = tilingSprite.anchor.x;
        anchorY = tilingSprite.anchor.y;
    }
    uvs[0] = uvs[6] = -anchorX;
    uvs[2] = uvs[4] = 1 - anchorX;
    uvs[1] = uvs[3] = -anchorY;
    uvs[5] = uvs[7] = 1 - anchorY;
    const textureMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"].shared;
    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);
    textureMatrix.tx /= tilingSprite.width;
    textureMatrix.ty /= tilingSprite.height;
    textureMatrix.invert();
    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$utils$2f$applyMatrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["applyMatrix"])(uvs, 2, 0, textureMatrix);
}
;
 //# sourceMappingURL=setUvs.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TilingSpriteGpuData",
    ()=>TilingSpriteGpuData,
    "TilingSpritePipe",
    ()=>TilingSpritePipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$getAdjustedBlendModeBlend$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$State$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/types.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/GCManagedHash.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$gpu$2f$colorToUniform$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$BatchableMesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$shader$2f$TilingSpriteShader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$utils$2f$QuadGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$utils$2f$setPositions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$utils$2f$setUvs$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
"use strict";
const sharedQuad = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$utils$2f$QuadGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["QuadGeometry"]();
class TilingSpriteGpuData {
    constructor(){
        this.canBatch = true;
        this.geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$MeshGeometry$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MeshGeometry"]({
            indices: sharedQuad.indices.slice(),
            positions: sharedQuad.positions.slice(),
            uvs: sharedQuad.uvs.slice()
        });
    }
    destroy() {
        this.geometry.destroy();
        this.shader?.destroy();
    }
}
class TilingSpritePipe {
    constructor(renderer){
        this._state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$State$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["State"].default2d;
        this._renderer = renderer;
        this._managedTilingSprites = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GCManagedHash"]({
            renderer,
            type: "renderable",
            name: "tilingSprite"
        });
    }
    validateRenderable(renderable) {
        const tilingSpriteData = this._getTilingSpriteData(renderable);
        const couldBatch = tilingSpriteData.canBatch;
        this._updateCanBatch(renderable);
        const canBatch = tilingSpriteData.canBatch;
        if (canBatch && canBatch === couldBatch) {
            const { batchableMesh } = tilingSpriteData;
            return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);
        }
        return couldBatch !== canBatch;
    }
    addRenderable(tilingSprite, instructionSet) {
        const batcher = this._renderer.renderPipes.batch;
        this._updateCanBatch(tilingSprite);
        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
        const { geometry, canBatch } = tilingSpriteData;
        if (canBatch) {
            tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$BatchableMesh$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BatchableMesh"]());
            const batchableMesh = tilingSpriteData.batchableMesh;
            if (tilingSprite.didViewUpdate) {
                this._updateBatchableMesh(tilingSprite);
                batchableMesh.geometry = geometry;
                batchableMesh.renderable = tilingSprite;
                batchableMesh.transform = tilingSprite.groupTransform;
                batchableMesh.setTexture(tilingSprite._texture);
            }
            batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;
            batcher.addToBatch(batchableMesh, instructionSet);
        } else {
            batcher.break(instructionSet);
            tilingSpriteData.shader || (tilingSpriteData.shader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$shader$2f$TilingSpriteShader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TilingSpriteShader"]());
            this.updateRenderable(tilingSprite);
            instructionSet.add(tilingSprite);
        }
    }
    execute(tilingSprite) {
        const { shader } = this._getTilingSpriteData(tilingSprite);
        shader.groups[0] = this._renderer.globalUniforms.bindGroup;
        const localUniforms = shader.resources.localUniforms.uniforms;
        localUniforms.uTransformMatrix = tilingSprite.groupTransform;
        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$gpu$2f$colorToUniform$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["color32BitToUniform"])(tilingSprite.groupColorAlpha, localUniforms.uColor, 0);
        this._state.blendMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$state$2f$getAdjustedBlendModeBlend$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAdjustedBlendModeBlend"])(tilingSprite.groupBlendMode, tilingSprite.texture._source);
        this._renderer.encoder.draw({
            geometry: sharedQuad,
            shader,
            state: this._state
        });
    }
    updateRenderable(tilingSprite) {
        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
        const { canBatch } = tilingSpriteData;
        if (canBatch) {
            const { batchableMesh } = tilingSpriteData;
            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);
            batchableMesh._batcher.updateElement(batchableMesh);
        } else if (tilingSprite.didViewUpdate) {
            const { shader } = tilingSpriteData;
            shader.updateUniforms(tilingSprite.width, tilingSprite.height, tilingSprite._tileTransform.matrix, tilingSprite.anchor.x, tilingSprite.anchor.y, tilingSprite.texture);
        }
    }
    _getTilingSpriteData(renderable) {
        return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);
    }
    _initTilingSpriteData(tilingSprite) {
        const gpuData = new TilingSpriteGpuData();
        gpuData.renderable = tilingSprite;
        tilingSprite._gpuData[this._renderer.uid] = gpuData;
        this._managedTilingSprites.add(tilingSprite);
        return gpuData;
    }
    _updateBatchableMesh(tilingSprite) {
        const renderableData = this._getTilingSpriteData(tilingSprite);
        const { geometry } = renderableData;
        const style = tilingSprite.texture.source.style;
        if (style.addressMode !== "repeat") {
            style.addressMode = "repeat";
            style.update();
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$utils$2f$setUvs$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setUvs"])(tilingSprite, geometry.uvs);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$utils$2f$setPositions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setPositions"])(tilingSprite, geometry.positions);
    }
    destroy() {
        this._managedTilingSprites.destroy();
        this._renderer = null;
    }
    _updateCanBatch(tilingSprite) {
        const renderableData = this._getTilingSpriteData(tilingSprite);
        const texture = tilingSprite.texture;
        let _nonPowOf2wrapping = true;
        if (this._renderer.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RendererType"].WEBGL) {
            _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;
        }
        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);
        return renderableData.canBatch;
    }
}
/** @ignore */ TilingSpritePipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasPipes
    ],
    name: "tilingSprite"
};
;
 //# sourceMappingURL=TilingSpritePipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "localUniformMSDFBit",
    ()=>localUniformMSDFBit,
    "localUniformMSDFBitGl",
    ()=>localUniformMSDFBitGl
]);
"use strict";
const localUniformMSDFBit = {
    name: "local-uniform-msdf-bit",
    vertex: {
        header: /* wgsl */ `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
        main: /* wgsl */ `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
        end: /* wgsl */ `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    },
    fragment: {
        header: /* wgsl */ `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
        main: /* wgsl */ `
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
    }
};
const localUniformMSDFBitGl = {
    name: "local-uniform-msdf-bit",
    vertex: {
        header: /* glsl */ `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
        main: /* glsl */ `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
        end: /* glsl */ `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    },
    fragment: {
        header: /* glsl */ `
            uniform float uDistance;
         `,
        main: /* glsl */ `
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
    }
};
;
 //# sourceMappingURL=localUniformMSDFBit.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "mSDFBit",
    ()=>mSDFBit,
    "mSDFBitGl",
    ()=>mSDFBitGl
]);
"use strict";
const mSDFBit = {
    name: "msdf-bit",
    fragment: {
        header: /* wgsl */ `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `
    }
};
const mSDFBitGl = {
    name: "msdf-bit",
    fragment: {
        header: /* glsl */ `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `
    }
};
;
 //# sourceMappingURL=mSDFBit.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SdfShader",
    ()=>SdfShader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$colorBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$generateTextureBatchBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$gl$2f$shader$2f$getBatchSamplersUniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$sdfShader$2f$shader$2d$bits$2f$localUniformMSDFBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$sdfShader$2f$shader$2d$bits$2f$mSDFBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
"use strict";
let gpuProgram;
let glProgram;
class SdfShader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$Shader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Shader"] {
    constructor(maxTextures){
        const uniforms = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$shader$2f$UniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UniformGroup"]({
            uColor: {
                value: new Float32Array([
                    1,
                    1,
                    1,
                    1
                ]),
                type: "vec4<f32>"
            },
            uTransformMatrix: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"](),
                type: "mat3x3<f32>"
            },
            uDistance: {
                value: 4,
                type: "f32"
            },
            uRound: {
                value: 0,
                type: "f32"
            }
        });
        gpuProgram ?? (gpuProgram = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compileHighShaderGpuProgram"])({
            name: "sdf-shader",
            bits: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$colorBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["colorBit"],
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$generateTextureBatchBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generateTextureBatchBit"])(maxTextures),
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$sdfShader$2f$shader$2d$bits$2f$localUniformMSDFBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["localUniformMSDFBit"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$sdfShader$2f$shader$2d$bits$2f$mSDFBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mSDFBit"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundPixelsBit"]
            ]
        }));
        glProgram ?? (glProgram = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$compileHighShaderToProgram$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compileHighShaderGlProgram"])({
            name: "sdf-shader",
            bits: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$colorBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["colorBitGl"],
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$generateTextureBatchBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generateTextureBatchBitGl"])(maxTextures),
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$sdfShader$2f$shader$2d$bits$2f$localUniformMSDFBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["localUniformMSDFBitGl"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$sdfShader$2f$shader$2d$bits$2f$mSDFBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mSDFBitGl"],
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$high$2d$shader$2f$shader$2d$bits$2f$roundPixelsBit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["roundPixelsBitGl"]
            ]
        }));
        super({
            glProgram,
            gpuProgram,
            resources: {
                localUniforms: uniforms,
                batchSamplers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$gl$2f$shader$2f$getBatchSamplersUniformGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getBatchSamplersUniformGroup"])(maxTextures)
            }
        });
    }
}
;
 //# sourceMappingURL=SdfShader.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BitmapTextGraphics",
    ()=>BitmapTextGraphics,
    "BitmapTextPipe",
    ()=>BitmapTextPipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/cache/Cache.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/GCManagedHash.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$Graphics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$sdfShader$2f$SdfShader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapFontManager$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$utils$2f$getBitmapTextLayout$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
"use strict";
class BitmapTextGraphics extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$Graphics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Graphics"] {
    destroy() {
        if (this.context.customShader) {
            this.context.customShader.destroy();
        }
        super.destroy();
    }
}
class BitmapTextPipe {
    constructor(renderer){
        this._renderer = renderer;
        this._managedBitmapTexts = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GCManagedHash"]({
            renderer,
            type: "renderable",
            priority: -2,
            name: "bitmapText"
        });
    }
    validateRenderable(bitmapText) {
        const graphicsRenderable = this._getGpuBitmapText(bitmapText);
        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
    }
    addRenderable(bitmapText, instructionSet) {
        const graphicsRenderable = this._getGpuBitmapText(bitmapText);
        syncWithProxy(bitmapText, graphicsRenderable);
        if (bitmapText._didTextUpdate) {
            bitmapText._didTextUpdate = false;
            this._updateContext(bitmapText, graphicsRenderable);
        }
        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
        if (graphicsRenderable.context.customShader) {
            this._updateDistanceField(bitmapText);
        }
    }
    updateRenderable(bitmapText) {
        const graphicsRenderable = this._getGpuBitmapText(bitmapText);
        syncWithProxy(bitmapText, graphicsRenderable);
        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
        if (graphicsRenderable.context.customShader) {
            this._updateDistanceField(bitmapText);
        }
    }
    _updateContext(bitmapText, proxyGraphics) {
        const { context } = proxyGraphics;
        const bitmapFont = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapFontManager$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BitmapFontManager"].getFont(bitmapText.text, bitmapText._style);
        context.clear();
        if (bitmapFont.distanceField.type !== "none") {
            if (!context.customShader) {
                context.customShader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$sdfShader$2f$SdfShader$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SdfShader"](this._renderer.limits.maxBatchableTextures);
            }
        }
        const chars = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].graphemeSegmenter(bitmapText.text);
        const style = bitmapText._style;
        let currentY = bitmapFont.baseLineOffset;
        const bitmapTextLayout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$utils$2f$getBitmapTextLayout$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getBitmapTextLayout"])(chars, style, bitmapFont, true);
        const padding = style.padding;
        const scale = bitmapTextLayout.scale;
        let tx = bitmapTextLayout.width;
        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;
        if (style._stroke) {
            tx += style._stroke.width / scale;
            ty += style._stroke.width / scale;
        }
        context.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);
        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;
        let fontSize = bitmapFont.fontMetrics.fontSize;
        let lineHeight = bitmapFont.lineHeight;
        if (style.lineHeight) {
            fontSize = style.fontSize / scale;
            lineHeight = style.lineHeight / scale;
        }
        let linePositionYShift = (lineHeight - fontSize) / 2;
        if (linePositionYShift - bitmapFont.baseLineOffset < 0) {
            linePositionYShift = 0;
        }
        for(let i = 0; i < bitmapTextLayout.lines.length; i++){
            const line = bitmapTextLayout.lines[i];
            for(let j = 0; j < line.charPositions.length; j++){
                const char = line.chars[j];
                const charData = bitmapFont.chars[char];
                if (charData?.texture) {
                    const texture = charData.texture;
                    context.texture(texture, tint ? tint : "black", Math.round(line.charPositions[j] + charData.xOffset), Math.round(currentY + charData.yOffset + linePositionYShift), texture.orig.width, texture.orig.height);
                }
            }
            currentY += lineHeight;
        }
    }
    _getGpuBitmapText(bitmapText) {
        return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);
    }
    initGpuText(bitmapText) {
        const proxyRenderable = new BitmapTextGraphics();
        bitmapText._gpuData[this._renderer.uid] = proxyRenderable;
        this._updateContext(bitmapText, proxyRenderable);
        this._managedBitmapTexts.add(bitmapText);
        return proxyRenderable;
    }
    _updateDistanceField(bitmapText) {
        const context = this._getGpuBitmapText(bitmapText).context;
        const fontFamily = bitmapText._style.fontFamily;
        const dynamicFont = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Cache"].get(`${fontFamily}-bitmap`);
        const { a, b, c, d } = bitmapText.groupTransform;
        const dx = Math.sqrt(a * a + b * b);
        const dy = Math.sqrt(c * c + d * d);
        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;
        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);
        context.customShader.resources.localUniforms.uniforms.uDistance = distance;
    }
    destroy() {
        this._managedBitmapTexts.destroy();
        this._renderer = null;
        this._managedBitmapTexts = null;
    }
}
/** @ignore */ BitmapTextPipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasPipes
    ],
    name: "bitmapText"
};
function syncWithProxy(container, proxy) {
    proxy.groupTransform = container.groupTransform;
    proxy.groupColorAlpha = container.groupColorAlpha;
    proxy.groupColor = container.groupColor;
    proxy.groupBlendMode = container.groupBlendMode;
    proxy.globalDisplayStatus = container.globalDisplayStatus;
    proxy.groupTransform = container.groupTransform;
    proxy.localDisplayStatus = container.localDisplayStatus;
    proxy.groupAlpha = container.groupAlpha;
    proxy._roundPixels = container._roundPixels;
}
;
 //# sourceMappingURL=BitmapTextPipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-bitmap/utils/bitmapTextSplit.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bitmapTextSplit",
    ()=>bitmapTextSplit
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/Container.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapFontManager$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$utils$2f$getBitmapTextLayout$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
"use strict";
function bitmapTextSplit(options) {
    const { text, style, chars: existingChars } = options;
    const textStyle = style;
    const font = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapFontManager$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BitmapFontManager"].getFont(text, textStyle);
    const segments = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].graphemeSegmenter(text);
    const layout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$utils$2f$getBitmapTextLayout$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getBitmapTextLayout"])(segments, textStyle, font, true);
    const scale = layout.scale;
    const chars = [];
    const words = [];
    const lines = [];
    const lineHeight = style.lineHeight ? style.lineHeight : font.lineHeight * scale;
    let yOffset = 0;
    for (const line of layout.lines){
        if (line.chars.length === 0) continue;
        const lineContainer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Container"]({
            label: "line"
        });
        lineContainer.y = yOffset;
        lines.push(lineContainer);
        let currentWordContainer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Container"]({
            label: "word"
        });
        let currentWordStartIndex = 0;
        for(let i = 0; i < line.chars.length; i++){
            const char = line.chars[i];
            if (!char) continue;
            const charData = font.chars[char];
            if (!charData) continue;
            const isSpace = char === " ";
            const isLastChar = i === line.chars.length - 1;
            let charInstance;
            if (existingChars.length > 0) {
                charInstance = existingChars.shift();
                charInstance.text = char;
                charInstance.style = textStyle;
                charInstance.label = `char-${char}`;
                charInstance.x = line.charPositions[i] * scale - line.charPositions[currentWordStartIndex] * scale;
            } else {
                charInstance = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BitmapText"]({
                    text: char,
                    style: textStyle,
                    label: `char-${char}`,
                    x: line.charPositions[i] * scale - line.charPositions[currentWordStartIndex] * scale
                });
            }
            if (!isSpace) {
                chars.push(charInstance);
                currentWordContainer.addChild(charInstance);
            }
            if (isSpace || isLastChar) {
                if (currentWordContainer.children.length > 0) {
                    currentWordContainer.x = line.charPositions[currentWordStartIndex] * scale;
                    words.push(currentWordContainer);
                    lineContainer.addChild(currentWordContainer);
                    currentWordContainer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Container"]({
                        label: "word"
                    });
                    currentWordStartIndex = i + 1;
                }
            }
        }
        yOffset += lineHeight;
    }
    return {
        chars,
        lines,
        words
    };
}
;
 //# sourceMappingURL=bitmapTextSplit.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BatchableHTMLText",
    ()=>BatchableHTMLText
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$BatchableSprite$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs [app-ssr] (ecmascript)");
;
"use strict";
class BatchableHTMLText extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$BatchableSprite$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BatchableSprite"] {
    constructor(){
        super(...arguments);
        this.generatingTexture = false;
        this.currentKey = "--";
    }
    /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */ destroy() {
        this.texturePromise = null;
        this.generatingTexture = false;
        this.currentKey = "--";
        super.destroy();
    }
}
;
 //# sourceMappingURL=BatchableHTMLText.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "updateTextBounds",
    ()=>updateTextBounds
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$updateQuadBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs [app-ssr] (ecmascript)");
;
"use strict";
function updateTextBounds(batchableSprite, text) {
    const { texture, bounds } = batchableSprite;
    const padding = text._style._getFinalPadding();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$updateQuadBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["updateQuadBounds"])(bounds, text._anchor, texture);
    const paddingOffset = text._anchor._x * padding * 2;
    const paddingOffsetY = text._anchor._y * padding * 2;
    bounds.minX -= padding - paddingOffset;
    bounds.minY -= padding - paddingOffsetY;
    bounds.maxX -= padding - paddingOffset;
    bounds.maxY -= padding - paddingOffsetY;
}
;
 //# sourceMappingURL=updateTextBounds.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HTMLTextPipe",
    ()=>HTMLTextPipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/GCManagedHash.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$utils$2f$updateTextBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$BatchableHTMLText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
"use strict";
class HTMLTextPipe {
    constructor(renderer){
        this._renderer = renderer;
        renderer.runners.resolutionChange.add(this);
        this._managedTexts = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GCManagedHash"]({
            renderer,
            type: "renderable",
            onUnload: this.onTextUnload.bind(this),
            name: "htmlText"
        });
    }
    resolutionChange() {
        for(const key in this._managedTexts.items){
            const text = this._managedTexts.items[key];
            if (text?._autoResolution) {
                text.onViewUpdate();
            }
        }
    }
    validateRenderable(htmlText) {
        const gpuText = this._getGpuText(htmlText);
        const newKey = htmlText.styleKey;
        if (gpuText.currentKey !== newKey) {
            return true;
        }
        return false;
    }
    addRenderable(htmlText, instructionSet) {
        const batchableHTMLText = this._getGpuText(htmlText);
        if (htmlText._didTextUpdate) {
            const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
            if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution) {
                this._updateGpuText(htmlText).catch((e)=>{
                    console.error(e);
                });
            }
            htmlText._didTextUpdate = false;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$utils$2f$updateTextBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["updateTextBounds"])(batchableHTMLText, htmlText);
        }
        this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);
    }
    updateRenderable(htmlText) {
        const batchableHTMLText = this._getGpuText(htmlText);
        batchableHTMLText._batcher.updateElement(batchableHTMLText);
    }
    async _updateGpuText(htmlText) {
        htmlText._didTextUpdate = false;
        const batchableHTMLText = this._getGpuText(htmlText);
        if (batchableHTMLText.generatingTexture) return;
        const oldTexturePromise = batchableHTMLText.texturePromise;
        batchableHTMLText.texturePromise = null;
        batchableHTMLText.generatingTexture = true;
        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
        let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);
        if (oldTexturePromise) {
            texturePromise = texturePromise.finally(()=>{
                this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);
                this._renderer.htmlText.returnTexturePromise(oldTexturePromise);
            });
        }
        batchableHTMLText.texturePromise = texturePromise;
        batchableHTMLText.currentKey = htmlText.styleKey;
        batchableHTMLText.texture = await texturePromise;
        const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;
        if (renderGroup) {
            renderGroup.structureDidChange = true;
        }
        batchableHTMLText.generatingTexture = false;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$utils$2f$updateTextBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["updateTextBounds"])(batchableHTMLText, htmlText);
    }
    _getGpuText(htmlText) {
        return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);
    }
    initGpuText(htmlText) {
        const batchableHTMLText = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$BatchableHTMLText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BatchableHTMLText"]();
        batchableHTMLText.renderable = htmlText;
        batchableHTMLText.transform = htmlText.groupTransform;
        batchableHTMLText.texture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].EMPTY;
        batchableHTMLText.bounds = {
            minX: 0,
            maxX: 1,
            minY: 0,
            maxY: 0
        };
        batchableHTMLText.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;
        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
        htmlText._gpuData[this._renderer.uid] = batchableHTMLText;
        this._managedTexts.add(htmlText);
        return batchableHTMLText;
    }
    onTextUnload(text) {
        const gpuData = text._gpuData[this._renderer.uid];
        if (!gpuData) return;
        const { htmlText } = this._renderer;
        htmlText.getReferenceCount(gpuData.currentKey) === null ? htmlText.returnTexturePromise(gpuData.texturePromise) : htmlText.decreaseReferenceCount(gpuData.currentKey);
    }
    destroy() {
        this._managedTexts.destroy();
        this._renderer = null;
    }
}
/** @ignore */ HTMLTextPipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasPipes
    ],
    name: "htmlText"
};
;
 //# sourceMappingURL=HTMLTextPipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getPo2TextureFromSource",
    ()=>getPo2TextureFromSource
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const tempBounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Bounds"]();
function getPo2TextureFromSource(image, width, height, resolution) {
    const bounds = tempBounds;
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = image.width / resolution | 0;
    bounds.maxY = image.height / resolution | 0;
    const texture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].getOptimalTexture(bounds.width, bounds.height, resolution, false);
    texture.source.uploadMethodId = "image";
    texture.source.resource = image;
    texture.source.alphaMode = "premultiply-alpha-on-upload";
    texture.frame.width = width / resolution;
    texture.frame.height = height / resolution;
    texture.source.emit("update", texture.source);
    texture.updateUvs();
    return texture;
}
;
 //# sourceMappingURL=getPo2TextureFromSource.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "extractFontFamilies",
    ()=>extractFontFamilies
]);
"use strict";
function extractFontFamilies(text, style) {
    const fontFamily = style.fontFamily;
    const fontFamilies = [];
    const dedupe = {};
    const regex = /font-family:([^;"\s]+)/g;
    const matches = text.match(regex);
    function addFontFamily(fontFamily2) {
        if (!dedupe[fontFamily2]) {
            fontFamilies.push(fontFamily2);
            dedupe[fontFamily2] = true;
        }
    }
    if (Array.isArray(fontFamily)) {
        for(let i = 0; i < fontFamily.length; i++){
            addFontFamily(fontFamily[i]);
        }
    } else {
        addFontFamily(fontFamily);
    }
    if (matches) {
        matches.forEach((match)=>{
            const fontFamily2 = match.split(":")[1].trim();
            addFontFamily(fontFamily2);
        });
    }
    for(const i in style.tagStyles){
        const fontFamily2 = style.tagStyles[i].fontFamily;
        addFontFamily(fontFamily2);
    }
    return fontFamilies;
}
;
 //# sourceMappingURL=extractFontFamilies.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadFontAsBase64",
    ()=>loadFontAsBase64
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-ssr] (ecmascript)");
;
"use strict";
async function loadFontAsBase64(url) {
    const response = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DOMAdapter"].get().fetch(url);
    const blob = await response.blob();
    const reader = new FileReader();
    const dataSrc = await new Promise((resolve, reject)=>{
        reader.onloadend = ()=>resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
    return dataSrc;
}
;
 //# sourceMappingURL=loadFontAsBase64.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadFontCSS",
    ()=>loadFontCSS
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$loadFontAsBase64$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs [app-ssr] (ecmascript)");
;
"use strict";
async function loadFontCSS(style, url) {
    const dataSrc = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$loadFontAsBase64$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["loadFontAsBase64"])(url);
    return `@font-face {
        font-family: "${style.fontFamily}";
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
        src: url('${dataSrc}');
    }`;
}
;
 //# sourceMappingURL=loadFontCSS.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FontStylePromiseCache",
    ()=>FontStylePromiseCache,
    "getFontCss",
    ()=>getFontCss
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/cache/Cache.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$loadFontCSS$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
const FontStylePromiseCache = /* @__PURE__ */ new Map();
async function getFontCss(fontFamilies) {
    const fontPromises = fontFamilies.filter((fontFamily)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Cache"].has(`${fontFamily}-and-url`)).map((fontFamily)=>{
        if (!FontStylePromiseCache.has(fontFamily)) {
            const { entries } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$cache$2f$Cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Cache"].get(`${fontFamily}-and-url`);
            const promises = [];
            entries.forEach((entry)=>{
                const url = entry.url;
                const faces = entry.faces;
                const out = faces.map((face)=>({
                        weight: face.weight,
                        style: face.style
                    }));
                promises.push(...out.map((style)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$loadFontCSS$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["loadFontCSS"])({
                        fontWeight: style.weight,
                        fontStyle: style.style,
                        fontFamily
                    }, url)));
            });
            FontStylePromiseCache.set(fontFamily, Promise.all(promises).then((css)=>css.join("\n")));
        }
        return FontStylePromiseCache.get(fontFamily);
    });
    return (await Promise.all(fontPromises)).join("\n");
}
;
 //# sourceMappingURL=getFontCss.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getSVGUrl",
    ()=>getSVGUrl
]);
"use strict";
function getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {
    const { domElement, styleElement, svgRoot } = htmlTextData;
    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;
    domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);
    styleElement.textContent = fontCSS;
    const { width, height } = htmlTextData.image;
    svgRoot.setAttribute("width", width.toString());
    svgRoot.setAttribute("height", height.toString());
    return new XMLSerializer().serializeToString(svgRoot);
}
;
 //# sourceMappingURL=getSVGUrl.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getTemporaryCanvasFromImage",
    ()=>getTemporaryCanvasFromImage
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$CanvasPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs [app-ssr] (ecmascript)");
;
"use strict";
function getTemporaryCanvasFromImage(image, resolution) {
    const canvasAndContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$CanvasPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasPool"].getOptimalCanvasAndContext(image.width, image.height, resolution);
    const { context } = canvasAndContext;
    context.clearRect(0, 0, image.width, image.height);
    context.drawImage(image, 0, 0);
    return canvasAndContext;
}
;
 //# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadSVGImage",
    ()=>loadSVGImage
]);
"use strict";
function loadSVGImage(image, url, delay) {
    return new Promise(async (resolve)=>{
        if (delay) {
            await new Promise((resolve2)=>setTimeout(resolve2, 100));
        }
        image.onload = ()=>{
            resolve();
        };
        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;
        image.crossOrigin = "anonymous";
    });
}
;
 //# sourceMappingURL=loadSVGImage.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HTMLTextSystem",
    ()=>HTMLTextSystem
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$CanvasPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/types.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isSafari$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/browser/isSafari.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$utils$2f$getPo2TextureFromSource$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$HTMLTextRenderData$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$extractFontFamilies$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$getFontCss$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$getSVGUrl$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$getTemporaryCanvasFromImage$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$loadSVGImage$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$measureHtmlText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
"use strict";
class HTMLTextSystem {
    constructor(renderer){
        this._activeTextures = {};
        this._renderer = renderer;
        this._createCanvas = renderer.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RendererType"].WEBGPU;
    }
    /**
   * @param options
   * @deprecated Use getTexturePromise instead
   */ getTexture(options) {
        return this.getTexturePromise(options);
    }
    /**
   * Increases the reference count for a texture.
   * @param text - The HTMLText instance associated with the texture.
   */ getManagedTexture(text) {
        const textKey = text.styleKey;
        if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].promise;
        }
        const promise = this._buildTexturePromise(text).then((texture)=>{
            this._activeTextures[textKey].texture = texture;
            return texture;
        });
        this._activeTextures[textKey] = {
            texture: null,
            promise,
            usageCount: 1
        };
        return promise;
    }
    /**
   * Gets the current reference count for a texture associated with a text key.
   * @param textKey - The unique key identifying the text style configuration
   * @returns The number of Text instances currently using this texture
   */ getReferenceCount(textKey) {
        return this._activeTextures[textKey]?.usageCount ?? null;
    }
    _increaseReferenceCount(textKey) {
        this._activeTextures[textKey].usageCount++;
    }
    /**
   * Decreases the reference count for a texture.
   * If the count reaches zero, the texture is cleaned up.
   * @param textKey - The key associated with the HTMLText instance.
   */ decreaseReferenceCount(textKey) {
        const activeTexture = this._activeTextures[textKey];
        if (!activeTexture) return;
        activeTexture.usageCount--;
        if (activeTexture.usageCount === 0) {
            if (activeTexture.texture) {
                this._cleanUp(activeTexture.texture);
            } else {
                activeTexture.promise.then((texture)=>{
                    activeTexture.texture = texture;
                    this._cleanUp(activeTexture.texture);
                }).catch(()=>{
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("HTMLTextSystem: Failed to clean texture");
                });
            }
            this._activeTextures[textKey] = null;
        }
    }
    /**
   * Returns a promise that resolves to a texture for the given HTMLText options.
   * @param options - The options for the HTMLText.
   * @returns A promise that resolves to a Texture.
   */ getTexturePromise(options) {
        return this._buildTexturePromise(options);
    }
    async _buildTexturePromise(options) {
        const { text, style, resolution, textureStyle } = options;
        const htmlTextData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$HTMLTextRenderData$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HTMLTextRenderData"]);
        const fontFamilies = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$extractFontFamilies$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractFontFamilies"])(text, style);
        const fontCSS = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$getFontCss$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFontCss"])(fontFamilies);
        const measured = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$measureHtmlText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["measureHtmlText"])(text, style, fontCSS, htmlTextData);
        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        const image = htmlTextData.image;
        const uvSafeOffset = 2;
        image.width = (width | 0) + uvSafeOffset;
        image.height = (height | 0) + uvSafeOffset;
        const svgURL = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$getSVGUrl$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSVGUrl"])(text, style, resolution, fontCSS, htmlTextData);
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$loadSVGImage$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["loadSVGImage"])(image, svgURL, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isSafari$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSafari"])() && fontFamilies.length > 0);
        const resource = image;
        let canvasAndContext;
        if (this._createCanvas) {
            canvasAndContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$utils$2f$getTemporaryCanvasFromImage$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getTemporaryCanvasFromImage"])(image, resolution);
        }
        const texture = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$utils$2f$getPo2TextureFromSource$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPo2TextureFromSource"])(canvasAndContext ? canvasAndContext.canvas : resource, image.width - uvSafeOffset, image.height - uvSafeOffset, resolution);
        if (textureStyle) texture.source.style = textureStyle;
        if (this._createCanvas) {
            this._renderer.texture.initSource(texture.source);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$CanvasPool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasPool"].returnCanvasAndContext(canvasAndContext);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$PoolGroup$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigPool"].return(htmlTextData);
        return texture;
    }
    returnTexturePromise(texturePromise) {
        texturePromise.then((texture)=>{
            this._cleanUp(texture);
        }).catch(()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["warn"])("HTMLTextSystem: Failed to clean texture");
        });
    }
    _cleanUp(texture) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].returnTexture(texture, true);
        texture.source.resource = null;
        texture.source.uploadMethodId = "unknown";
    }
    destroy() {
        this._renderer = null;
        for(const key in this._activeTextures){
            if (this._activeTextures[key]) this.returnTexturePromise(this._activeTextures[key].promise);
        }
        this._activeTextures = null;
    }
}
/** @ignore */ HTMLTextSystem.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasSystem
    ],
    name: "htmlText"
};
;
 //# sourceMappingURL=HTMLTextSystem.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-split/AbstractSplitText.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbstractSplitText",
    ()=>AbstractSplitText
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/Container.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/TextStyle.mjs [app-ssr] (ecmascript)");
;
;
"use strict";
class AbstractSplitText extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Container"] {
    constructor(config){
        const { text, style, autoSplit, lineAnchor, wordAnchor, charAnchor, ...options } = config;
        super(options);
        this._dirty = false;
        this._canReuseChars = false;
        this.chars = [];
        this.words = [];
        this.lines = [];
        this._originalText = text;
        this._autoSplit = autoSplit;
        this._lineAnchor = lineAnchor;
        this._wordAnchor = wordAnchor;
        this._charAnchor = charAnchor;
        this.style = style;
    }
    /**
   * Splits the text into lines, words, and characters.
   * Call this manually when autoSplit is false.
   * @example Manual Splitting
   * ```ts
   * const text = new SplitText({
   *   text: 'Manual Update',
   *   autoSplit: false
   * });
   *
   * text.text = 'New Content';
   * text.style = { fontSize: 32 };
   * text.split(); // Apply changes
   * ```
   */ split() {
        const res = this.splitFn();
        this.chars = res.chars;
        this.words = res.words;
        this.lines = res.lines;
        this.addChild(...this.lines);
        this.charAnchor = this._charAnchor;
        this.wordAnchor = this._wordAnchor;
        this.lineAnchor = this._lineAnchor;
        this._dirty = false;
        this._canReuseChars = true;
    }
    get text() {
        return this._originalText;
    }
    /**
   * Gets or sets the text content.
   * Setting new text triggers splitting if autoSplit is true.
   * > [!NOTE] Setting this frequently can have a performance impact, especially with large texts and canvas text.
   * @example Dynamic Text Updates
   * ```ts
   * const text = new SplitText({
   *   text: 'Original',
   *   autoSplit: true
   * });
   *
   * // Auto-splits on change
   * text.text = 'Updated Content';
   *
   * // Manual update
   * text.autoSplit = false;
   * text.text = 'Manual Update';
   * text.split();
   * ```
   */ set text(value) {
        this._originalText = value;
        this.lines.forEach((line)=>line.destroy({
                children: true
            }));
        this.lines.length = 0;
        this.words.length = 0;
        this.chars.length = 0;
        this._canReuseChars = false;
        this.onTextUpdate();
    }
    _setOrigin(value, elements, property) {
        let originPoint;
        if (typeof value === "number") {
            originPoint = {
                x: value,
                y: value
            };
        } else {
            originPoint = {
                x: value.x,
                y: value.y
            };
        }
        elements.forEach((element)=>{
            const localBounds = element.getLocalBounds();
            const originX = localBounds.minX + localBounds.width * originPoint.x;
            const originY = localBounds.minY + localBounds.height * originPoint.y;
            element.origin.set(originX, originY);
        });
        this[property] = value;
    }
    /**
   * Gets or sets the transform anchor for line segments.
   * The anchor point determines the center of rotation and scaling for each line.
   * @example Setting Line Anchors
   * ```ts
   * // Center rotation/scaling
   * text.lineAnchor = 0.5;
   *
   * // Rotate/scale from top-right corner
   * text.lineAnchor = { x: 1, y: 0 };
   *
   * // Custom anchor point
   * text.lineAnchor = {
   *   x: 0.2, // 20% from left
   *   y: 0.8  // 80% from top
   * };
   * ```
   */ get lineAnchor() {
        return this._lineAnchor;
    }
    set lineAnchor(value) {
        this._setOrigin(value, this.lines, "_lineAnchor");
    }
    /**
   * Gets or sets the transform anchor for word segments.
   * The anchor point determines the center of rotation and scaling for each word.
   * @example
   * ```ts
   * // Center each word
   * text.wordAnchor = 0.5;
   *
   * // Scale from bottom-left
   * text.wordAnchor = { x: 0, y: 1 };
   *
   * // Rotate around custom point
   * text.wordAnchor = {
   *   x: 0.75,  // 75% from left
   *   y: 0.5    // Middle vertically
   * };
   * ```
   */ get wordAnchor() {
        return this._wordAnchor;
    }
    set wordAnchor(value) {
        this._setOrigin(value, this.words, "_wordAnchor");
    }
    /**
   * Gets or sets the transform anchor for character segments.
   * The anchor point determines the center of rotation and scaling for each character.
   * @example Setting Character Anchors
   * ```ts
   * // Center each character
   * text.charAnchor = 0.5;
   *
   * // Rotate from top-center
   * text.charAnchor = { x: 0.5, y: 0 };
   *
   * // Scale from bottom-right
   * text.charAnchor = { x: 1, y: 1 };
   * ```
   * @example Animation with Anchors
   * ```ts
   * // Rotate characters around their centers
   * text.charAnchor = 0.5;
   * text.chars.forEach((char, i) => {
   *   gsap.to(char, {
   *     rotation: Math.PI * 2,
   *     duration: 1,
   *     delay: i * 0.1,
   *     repeat: -1
   *   });
   * });
   * ```
   */ get charAnchor() {
        return this._charAnchor;
    }
    set charAnchor(value) {
        this._setOrigin(value, this.chars, "_charAnchor");
    }
    get style() {
        return this._style;
    }
    /**
   * The style configuration for the text.
   * Can be a TextStyle instance or a configuration object.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Styled Text',
   *     style: {
   *         fontSize: 24,
   *         fill: 0xff1010, // Red color
   *         fontFamily: 'Arial',
   *         align: 'center', // Center alignment
   *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke
   *         dropShadow: {
   *             color: '#000000', // Black shadow
   *             blur: 4, // Shadow blur
   *             distance: 6 // Shadow distance
   *         }
   *     }
   * });
   * // Update style dynamically
   * text.style = {
   *     fontSize: 30, // Change font size
   *     fill: 0x00ff00, // Change color to green
   *     align: 'right', // Change alignment to right
   *     stroke: { color: '#000000', width: 2 }, // Add black stroke
   * }
   */ set style(style) {
        style || (style = {});
        this._style = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextStyle"](style);
        this.words.forEach((word)=>word.destroy());
        this.words.length = 0;
        this.lines.forEach((line)=>line.destroy());
        this.lines.length = 0;
        this._canReuseChars = true;
        this.onTextUpdate();
    }
    onTextUpdate() {
        this._dirty = true;
        if (this._autoSplit) {
            this.split();
        }
    }
    /**
   * Destroys the SplitText instance and all its resources.
   * Cleans up all segment arrays, event listeners, and optionally the text style.
   * @param options - Destroy configuration options
   * @example
   * ```ts
   * // Clean up everything
   * text.destroy({ children: true, texture: true, style: true });
   *
   * // Remove from parent but keep style
   * text.destroy({ children: true, style: false });
   * ```
   */ destroy(options) {
        super.destroy(options);
        this.chars = [];
        this.words = [];
        this.lines = [];
        if (typeof options === "boolean" ? options : options?.style) {
            this._style.destroy(options);
        }
        this._style = null;
        this._originalText = "";
    }
}
;
 //# sourceMappingURL=AbstractSplitText.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-split/SplitBitmapText.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SplitBitmapText",
    ()=>SplitBitmapText
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/TextStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$utils$2f$bitmapTextSplit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/utils/bitmapTextSplit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$split$2f$AbstractSplitText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-split/AbstractSplitText.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
const _SplitBitmapText = class _SplitBitmapText extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$split$2f$AbstractSplitText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AbstractSplitText"] {
    constructor(config){
        const completeOptions = {
            ..._SplitBitmapText.defaultOptions,
            ...config
        };
        super(completeOptions);
    }
    /**
   * Creates a SplitBitmapText instance from an existing text object.
   * Useful for converting standard Text or BitmapText objects into segmented versions.
   * @param text - The source text object to convert
   * @param options - Additional splitting options
   * @returns A new SplitBitmapText instance
   * @example
   * ```ts
   * const bitmapText = new BitmapText({
   *   text: 'Bitmap Text',
   *   style: { fontFamily: 'Arial' }
   * });
   *
   * const segmented = SplitBitmapText.from(bitmapText);
   *
   * // with additional options
   * const segmentedWithOptions = SplitBitmapText.from(bitmapText, {
   *   autoSplit: false,
   *   lineAnchor: 0.5,
   *   wordAnchor: { x: 0, y: 0.5 },
   * })
   * ```
   */ static from(text, options) {
        const completeOptions = {
            ..._SplitBitmapText.defaultOptions,
            ...options,
            text: text.text,
            style: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextStyle"](text.style)
        };
        return new _SplitBitmapText({
            ...completeOptions
        });
    }
    splitFn() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$utils$2f$bitmapTextSplit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bitmapTextSplit"])({
            text: this._originalText,
            style: this._style,
            chars: this._canReuseChars ? this.chars : []
        });
    }
};
/**
 * Default configuration options for SplitBitmapText instances.
 * @example
 * ```ts
 * // Override defaults globally
 * SplitBitmapText.defaultOptions = {
 *   autoSplit: false,
 *   lineAnchor: 0.5,  // Center alignment
 *   wordAnchor: { x: 0, y: 0.5 },  // Left-center
 *   charAnchor: { x: 0.5, y: 1 }   // Bottom-center
 * };
 * ```
 */ _SplitBitmapText.defaultOptions = {
    autoSplit: true,
    // Auto-update on text/style changes
    lineAnchor: 0,
    // Top-left alignment
    wordAnchor: 0,
    // Top-left alignment
    charAnchor: 0
};
let SplitBitmapText = _SplitBitmapText;
;
 //# sourceMappingURL=SplitBitmapText.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/utils/canvasTextSplit.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "canvasTextSplit",
    ()=>canvasTextSplit
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/Container.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$Text$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/Text.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
function getAlignmentOffset(alignment, lineWidth, largestLine) {
    switch(alignment){
        case "center":
            return (largestLine - lineWidth) / 2;
        case "right":
            return largestLine - lineWidth;
        case "left":
        default:
            return 0;
    }
}
function isNewlineCharacter(char) {
    return char === "\r" || char === "\n" || char === "\r\n";
}
function groupTextSegments(segments, measuredText, textStyle) {
    const groupedSegments = [];
    let currentLine = measuredText.lines[0];
    let matchedLine = "";
    let chars = [];
    let lineCount = 0;
    textStyle.wordWrap = false;
    segments.forEach((segment)=>{
        const isWhitespace = /^\s*$/.test(segment);
        const isNewline = isNewlineCharacter(segment);
        const isSpaceAtStart = matchedLine.length === 0 && isWhitespace;
        if (isWhitespace && !isNewline && isSpaceAtStart) {
            return;
        }
        if (!isNewline) matchedLine += segment;
        const metric = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].measureText(segment, textStyle);
        chars.push({
            char: segment,
            metric
        });
        if (matchedLine.length >= currentLine.length) {
            groupedSegments.push({
                line: matchedLine,
                chars,
                width: chars.reduce((acc, seg)=>acc + seg.metric.width, 0)
            });
            chars = [];
            matchedLine = "";
            lineCount++;
            currentLine = measuredText.lines[lineCount];
        }
    });
    return groupedSegments;
}
function canvasTextSplit(options) {
    const { text, style, chars: existingChars } = options;
    const textStyle = style;
    const measuredText = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].measureText(text, textStyle);
    const segments = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextMetrics$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextMetrics"].graphemeSegmenter(text);
    const groupedSegments = groupTextSegments(segments, measuredText, textStyle.clone());
    const alignment = textStyle.align;
    const largestLine = measuredText.lineWidths.reduce((max, line)=>Math.max(max, line), 0);
    const chars = [];
    const lineContainers = [];
    const wordContainers = [];
    let yOffset = 0;
    const strokeWidth = textStyle.stroke?.width || 0;
    const dropShadowDistance = textStyle.dropShadow?.distance || 0;
    groupedSegments.forEach((group, i)=>{
        const lineContainer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Container"]({
            label: `line-${i}`
        });
        lineContainer.y = yOffset;
        lineContainers.push(lineContainer);
        const lineWidth = measuredText.lineWidths[i];
        let xOffset = getAlignmentOffset(alignment, lineWidth, largestLine);
        let currentWordContainer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Container"]({
            label: "word"
        });
        currentWordContainer.x = xOffset;
        group.chars.forEach((segment, i2)=>{
            if (segment.metric.width === 0) {
                return;
            }
            if (isNewlineCharacter(segment.char)) {
                xOffset += segment.metric.width - strokeWidth;
                return;
            }
            if (segment.char === " ") {
                if (currentWordContainer.children.length > 0) {
                    wordContainers.push(currentWordContainer);
                    lineContainer.addChild(currentWordContainer);
                }
                xOffset += segment.metric.width + textStyle.letterSpacing - strokeWidth;
                currentWordContainer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Container"]({
                    label: "word"
                });
                currentWordContainer.x = xOffset;
            } else {
                let char;
                if (existingChars.length > 0) {
                    char = existingChars.shift();
                    char.text = segment.char;
                    char.style = textStyle;
                    char.setFromMatrix(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"].IDENTITY);
                    char.x = xOffset - currentWordContainer.x - dropShadowDistance * i2;
                } else {
                    char = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$Text$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Text"]({
                        text: segment.char,
                        style: textStyle,
                        x: xOffset - currentWordContainer.x - dropShadowDistance * i2
                    });
                }
                chars.push(char);
                currentWordContainer.addChild(char);
                xOffset += segment.metric.width + textStyle.letterSpacing - strokeWidth;
            }
        });
        if (currentWordContainer.children.length > 0) {
            wordContainers.push(currentWordContainer);
            lineContainer.addChild(currentWordContainer);
        }
        yOffset += measuredText.lineHeight;
    });
    return {
        chars,
        lines: lineContainers,
        words: wordContainers
    };
}
;
 //# sourceMappingURL=canvasTextSplit.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text-split/SplitText.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SplitText",
    ()=>SplitText
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/TextStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$utils$2f$canvasTextSplit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/utils/canvasTextSplit.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$split$2f$AbstractSplitText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-split/AbstractSplitText.mjs [app-ssr] (ecmascript)");
;
;
;
"use strict";
const _SplitText = class _SplitText extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$split$2f$AbstractSplitText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AbstractSplitText"] {
    constructor(config){
        const completeOptions = {
            ..._SplitText.defaultOptions,
            ...config
        };
        super(completeOptions);
    }
    /**
   * Creates a SplitText instance from an existing text object.
   * Useful for converting standard Text or Text objects into segmented versions.
   * @param text - The source text object to convert
   * @param options - Additional splitting options
   * @returns A new SplitText instance
   * @example
   * ```ts
   * const text = new Text({
   *   text: 'Bitmap Text',
   *   style: { fontFamily: 'Arial' }
   * });
   *
   * const segmented = SplitText.from(text);
   *
   * // with additional options
   * const segmentedWithOptions = SplitText.from(text, {
   *   autoSplit: false,
   *   lineAnchor: 0.5,
   *   wordAnchor: { x: 0, y: 0.5 },
   * })
   * ```
   */ static from(text, options) {
        const completeOptions = {
            ..._SplitText.defaultOptions,
            ...options,
            text: text.text,
            style: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextStyle"](text.style)
        };
        return new _SplitText({
            ...completeOptions
        });
    }
    splitFn() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$utils$2f$canvasTextSplit$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["canvasTextSplit"])({
            text: this._originalText,
            style: this._style,
            chars: this._canReuseChars ? this.chars : []
        });
    }
};
/**
 * Default configuration options for SplitText instances.
 * @example
 * ```ts
 * // Override defaults globally
 * SplitText.defaultOptions = {
 *   autoSplit: false,
 *   lineAnchor: 0.5,  // Center alignment
 *   wordAnchor: { x: 0, y: 0.5 },  // Left-center
 *   charAnchor: { x: 0.5, y: 1 }   // Bottom-center
 * };
 * ```
 */ _SplitText.defaultOptions = {
    autoSplit: true,
    // Auto-update on text/style changes
    lineAnchor: 0,
    // Top-left alignment
    wordAnchor: 0,
    // Top-left alignment
    charAnchor: 0
};
let SplitText = _SplitText;
;
 //# sourceMappingURL=SplitText.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BatchableText",
    ()=>BatchableText
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$BatchableSprite$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs [app-ssr] (ecmascript)");
;
"use strict";
class BatchableText extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$BatchableSprite$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BatchableSprite"] {
}
;
 //# sourceMappingURL=BatchableText.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CanvasTextPipe",
    ()=>CanvasTextPipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/GCManagedHash.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$utils$2f$updateTextBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$BatchableText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs [app-ssr] (ecmascript)");
;
;
;
;
"use strict";
class CanvasTextPipe {
    constructor(renderer){
        this._renderer = renderer;
        renderer.runners.resolutionChange.add(this);
        this._managedTexts = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$GCManagedHash$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GCManagedHash"]({
            renderer,
            type: "renderable",
            onUnload: this.onTextUnload.bind(this),
            name: "canvasText"
        });
    }
    resolutionChange() {
        for(const key in this._managedTexts.items){
            const text = this._managedTexts.items[key];
            if (text?._autoResolution) text.onViewUpdate();
        }
    }
    validateRenderable(text) {
        const gpuText = this._getGpuText(text);
        const newKey = text.styleKey;
        if (gpuText.currentKey !== newKey) return true;
        return text._didTextUpdate;
    }
    addRenderable(text, instructionSet) {
        const batchableText = this._getGpuText(text);
        if (text._didTextUpdate) {
            const resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
            if (batchableText.currentKey !== text.styleKey || text.resolution !== resolution) {
                this._updateGpuText(text);
            }
            text._didTextUpdate = false;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$utils$2f$updateTextBounds$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["updateTextBounds"])(batchableText, text);
        }
        this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);
    }
    updateRenderable(text) {
        const batchableText = this._getGpuText(text);
        batchableText._batcher.updateElement(batchableText);
    }
    _updateGpuText(text) {
        const batchableText = this._getGpuText(text);
        if (batchableText.texture) {
            this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey);
        }
        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
        batchableText.texture = this._renderer.canvasText.getManagedTexture(text);
        batchableText.currentKey = text.styleKey;
    }
    _getGpuText(text) {
        return text._gpuData[this._renderer.uid] || this.initGpuText(text);
    }
    initGpuText(text) {
        const batchableText = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$BatchableText$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BatchableText"]();
        batchableText.currentKey = "--";
        batchableText.renderable = text;
        batchableText.transform = text.groupTransform;
        batchableText.bounds = {
            minX: 0,
            maxX: 1,
            minY: 0,
            maxY: 0
        };
        batchableText.roundPixels = this._renderer._roundPixels | text._roundPixels;
        text._gpuData[this._renderer.uid] = batchableText;
        this._managedTexts.add(text);
        return batchableText;
    }
    onTextUnload(text) {
        const gpuData = text._gpuData[this._renderer.uid];
        if (!gpuData) return;
        const { canvasText } = this._renderer;
        const refCount = canvasText.getReferenceCount(gpuData.currentKey);
        if (refCount > 0) {
            canvasText.decreaseReferenceCount(gpuData.currentKey);
        } else if (gpuData.texture) {
            canvasText.returnTexture(gpuData.texture);
        }
    }
    destroy() {
        this._managedTexts.destroy();
        this._renderer = null;
    }
}
/** @ignore */ CanvasTextPipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasPipes
    ],
    name: "text"
};
;
 //# sourceMappingURL=CanvasTextPipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CanvasTextSystem",
    ()=>CanvasTextSystem
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/TextStyle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$utils$2f$getPo2TextureFromSource$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextGenerator$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
class CanvasTextSystem {
    constructor(_renderer){
        this._activeTextures = {};
        this._renderer = _renderer;
    }
    getTexture(options, _resolution, _style, _textKey) {
        if (typeof options === "string") {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");
            options = {
                text: options,
                style: _style,
                resolution: _resolution
            };
        }
        if (!(options.style instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextStyle"])) {
            options.style = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$TextStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextStyle"](options.style);
        }
        if (!(options.textureStyle instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextureStyle"])) {
            options.textureStyle = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TextureStyle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextureStyle"](options.textureStyle);
        }
        if (typeof options.text !== "string") {
            options.text = options.text.toString();
        }
        const { text, style, textureStyle } = options;
        const resolution = options.resolution ?? this._renderer.resolution;
        const { frame, canvasAndContext } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextGenerator$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextGenerator"].getCanvasAndContext({
            text,
            style,
            resolution
        });
        const texture = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$utils$2f$getPo2TextureFromSource$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPo2TextureFromSource"])(canvasAndContext.canvas, frame.width, frame.height, resolution);
        if (textureStyle) texture.source.style = textureStyle;
        if (style.trim) {
            frame.pad(style.padding);
            texture.frame.copyFrom(frame);
            texture.frame.scale(1 / resolution);
            texture.updateUvs();
        }
        if (style.filters) {
            const filteredTexture = this._applyFilters(texture, style.filters);
            this.returnTexture(texture);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextGenerator$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextGenerator"].returnCanvasAndContext(canvasAndContext);
            return filteredTexture;
        }
        this._renderer.texture.initSource(texture._source);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$canvas$2f$CanvasTextGenerator$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CanvasTextGenerator"].returnCanvasAndContext(canvasAndContext);
        return texture;
    }
    /**
   * Returns a texture that was created wit the above `getTexture` function.
   * Handy if you are done with a texture and want to return it to the pool.
   * @param texture - The texture to be returned.
   */ returnTexture(texture) {
        const source = texture.source;
        source.resource = null;
        source.uploadMethodId = "unknown";
        source.alphaMode = "no-premultiply-alpha";
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$TexturePool$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TexturePool"].returnTexture(texture, true);
    }
    /**
   * Renders text to its canvas, and updates its texture.
   * @deprecated since 8.10.0
   */ renderTextToCanvas() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deprecation"])("8.10.0", "CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead");
    }
    /**
   * Gets or creates a managed texture for a Text object. This method handles texture reuse and reference counting.
   * @param text - The Text object that needs a texture
   * @returns A Texture instance that represents the rendered text
   * @remarks
   * This method performs the following:
   * 1. Sets the appropriate resolution based on auto-resolution settings
   * 2. Checks if a texture already exists for the text's style
   * 3. Creates a new texture if needed or returns an existing one
   * 4. Manages reference counting for texture reuse
   */ getManagedTexture(text) {
        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
        const textKey = text.styleKey;
        if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].texture;
        }
        const texture = this.getTexture({
            text: text.text,
            style: text.style,
            resolution: text._resolution,
            textureStyle: text.textureStyle
        });
        this._activeTextures[textKey] = {
            texture,
            usageCount: 1
        };
        return texture;
    }
    /**
   * Decreases the reference count for a texture associated with a text key.
   * When the reference count reaches zero, the texture is returned to the pool.
   * @param textKey - The unique key identifying the text style configuration
   * @remarks
   * This method is crucial for memory management, ensuring textures are properly
   * cleaned up when they are no longer needed by any Text instances.
   */ decreaseReferenceCount(textKey) {
        const activeTexture = this._activeTextures[textKey];
        activeTexture.usageCount--;
        if (activeTexture.usageCount === 0) {
            this.returnTexture(activeTexture.texture);
            this._activeTextures[textKey] = null;
        }
    }
    /**
   * Gets the current reference count for a texture associated with a text key.
   * @param textKey - The unique key identifying the text style configuration
   * @returns The number of Text instances currently using this texture
   */ getReferenceCount(textKey) {
        return this._activeTextures[textKey]?.usageCount ?? 0;
    }
    _increaseReferenceCount(textKey) {
        this._activeTextures[textKey].usageCount++;
    }
    /**
   * Applies the specified filters to the given texture.
   *
   * This method takes a texture and a list of filters, applies the filters to the texture,
   * and returns the resulting texture. It also ensures that the alpha mode of the resulting
   * texture is set to 'premultiplied-alpha'.
   * @param {Texture} texture - The texture to which the filters will be applied.
   * @param {Filter[]} filters - The filters to apply to the texture.
   * @returns {Texture} The resulting texture after all filters have been applied.
   */ _applyFilters(texture, filters) {
        const currentRenderTarget = this._renderer.renderTarget.renderTarget;
        const resultTexture = this._renderer.filter.generateFilteredTexture({
            texture,
            filters
        });
        this._renderer.renderTarget.bind(currentRenderTarget, false);
        return resultTexture;
    }
    destroy() {
        this._renderer = null;
        for(const key in this._activeTextures){
            if (this._activeTextures[key]) this.returnTexture(this._activeTextures[key].texture);
        }
        this._activeTextures = null;
    }
}
/** @ignore */ CanvasTextSystem.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasSystem
    ],
    name: "canvasText"
};
;
 //# sourceMappingURL=CanvasTextSystem.mjs.map
}),
"[project]/node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generateTextStyleKey",
    ()=>generateTextStyleKey
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/color/Color.mjs [app-ssr] (ecmascript)");
;
"use strict";
const valuesToIterateForKeys = [
    "align",
    "breakWords",
    "cssOverrides",
    "fontVariant",
    "fontWeight",
    "leading",
    "letterSpacing",
    "lineHeight",
    "padding",
    "textBaseline",
    "trim",
    "whiteSpace",
    "wordWrap",
    "wordWrapWidth",
    "fontFamily",
    "fontStyle",
    "fontSize"
];
function generateTextStyleKey(style) {
    const key = [];
    let index = 0;
    for(let i = 0; i < valuesToIterateForKeys.length; i++){
        const prop = `_${valuesToIterateForKeys[i]}`;
        key[index++] = style[prop];
    }
    index = addFillStyleKey(style._fill, key, index);
    index = addStokeStyleKey(style._stroke, key, index);
    index = addDropShadowKey(style.dropShadow, key, index);
    index = addFiltersKey(style.filters, key, index);
    return key.join("-");
}
function addFiltersKey(filters, key, index) {
    if (!filters) return index;
    for (const filter of filters){
        key[index++] = filter.uid;
    }
    return index;
}
function addFillStyleKey(fillStyle, key, index) {
    if (!fillStyle) return index;
    key[index++] = fillStyle.color;
    key[index++] = fillStyle.alpha;
    key[index++] = fillStyle.fill?.styleKey;
    return index;
}
function addStokeStyleKey(strokeStyle, key, index) {
    if (!strokeStyle) return index;
    index = addFillStyleKey(strokeStyle, key, index);
    key[index++] = strokeStyle.width;
    key[index++] = strokeStyle.alignment;
    key[index++] = strokeStyle.cap;
    key[index++] = strokeStyle.join;
    key[index++] = strokeStyle.miterLimit;
    return index;
}
function addDropShadowKey(dropShadow, key, index) {
    if (!dropShadow) return index;
    key[index++] = dropShadow.alpha;
    key[index++] = dropShadow.angle;
    key[index++] = dropShadow.blur;
    key[index++] = dropShadow.distance;
    key[index++] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$color$2f$Color$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"].shared.setValue(dropShadow.color).toNumber();
    return index;
}
;
 //# sourceMappingURL=generateTextStyleKey.mjs.map
}),
];

//# sourceMappingURL=node_modules_pixi_js_lib_scene_b7b12c19._.js.map