(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ExtensionType",
    ()=>ExtensionType,
    "extensions",
    ()=>extensions,
    "normalizeExtensionPriority",
    ()=>normalizeExtensionPriority
]);
"use strict";
var ExtensionType = /* @__PURE__ */ ((ExtensionType2)=>{
    ExtensionType2["Application"] = "application";
    ExtensionType2["WebGLPipes"] = "webgl-pipes";
    ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
    ExtensionType2["WebGLSystem"] = "webgl-system";
    ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
    ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
    ExtensionType2["WebGPUSystem"] = "webgpu-system";
    ExtensionType2["CanvasSystem"] = "canvas-system";
    ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
    ExtensionType2["CanvasPipes"] = "canvas-pipes";
    ExtensionType2["Asset"] = "asset";
    ExtensionType2["LoadParser"] = "load-parser";
    ExtensionType2["ResolveParser"] = "resolve-parser";
    ExtensionType2["CacheParser"] = "cache-parser";
    ExtensionType2["DetectionParser"] = "detection-parser";
    ExtensionType2["MaskEffect"] = "mask-effect";
    ExtensionType2["BlendMode"] = "blend-mode";
    ExtensionType2["TextureSource"] = "texture-source";
    ExtensionType2["Environment"] = "environment";
    ExtensionType2["ShapeBuilder"] = "shape-builder";
    ExtensionType2["Batcher"] = "batcher";
    return ExtensionType2;
})(ExtensionType || {});
const normalizeExtension = (ext)=>{
    if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
        if (!ext.extension) {
            throw new Error("Extension class must have an extension object");
        }
        const metadata = typeof ext.extension !== "object" ? {
            type: ext.extension
        } : ext.extension;
        ext = {
            ...metadata,
            ref: ext
        };
    }
    if (typeof ext === "object") {
        ext = {
            ...ext
        };
    } else {
        throw new Error("Invalid extension type");
    }
    if (typeof ext.type === "string") {
        ext.type = [
            ext.type
        ];
    }
    return ext;
};
const normalizeExtensionPriority = (ext, defaultPriority)=>normalizeExtension(ext).priority ?? defaultPriority;
const extensions = {
    /** @ignore */ _addHandlers: {},
    /** @ignore */ _removeHandlers: {},
    /** @ignore */ _queue: {},
    /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed. Can be:
   * - Extension class with static `extension` property
   * - Extension format object with `type` and `ref`
   * - Multiple extensions as separate arguments
   * @returns {extensions} this for chaining
   * @example
   * ```ts
   * // Remove a single extension
   * extensions.remove(MyRendererPlugin);
   *
   * // Remove multiple extensions
   * extensions.remove(
   *     MyRendererPlugin,
   *     MySystemPlugin
   * );
   * ```
   * @see {@link ExtensionType} For available extension types
   * @see {@link ExtensionFormat} For extension format details
   */ remove (...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext)=>{
            ext.type.forEach((type)=>this._removeHandlers[type]?.(ext));
        });
        return this;
    },
    /**
   * Register new extensions with PixiJS. Extensions can be registered in multiple formats:
   * - As a class with a static `extension` property
   * - As an extension format object
   * - As multiple extensions passed as separate arguments
   * @param extensions - Extensions to add to PixiJS. Each can be:
   * - A class with static `extension` property
   * - An extension format object with `type` and `ref`
   * - Multiple extensions as separate arguments
   * @returns This extensions instance for chaining
   * @example
   * ```ts
   * // Register a simple extension
   * extensions.add(MyRendererPlugin);
   *
   * // Register multiple extensions
   * extensions.add(
   *     MyRendererPlugin,
   *     MySystemPlugin,
   * });
   * ```
   * @see {@link ExtensionType} For available extension types
   * @see {@link ExtensionFormat} For extension format details
   * @see {@link extensions.remove} For removing registered extensions
   */ add (...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext)=>{
            ext.type.forEach((type)=>{
                const handlers = this._addHandlers;
                const queue = this._queue;
                if (!handlers[type]) {
                    queue[type] = queue[type] || [];
                    queue[type]?.push(ext);
                } else {
                    handlers[type]?.(ext);
                }
            });
        });
        return this;
    },
    /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
   * @returns this for chaining.
   * @internal
   * @ignore
   */ handle (type, onAdd, onRemove) {
        const addHandlers = this._addHandlers;
        const removeHandlers = this._removeHandlers;
        if (addHandlers[type] || removeHandlers[type]) {
            throw new Error(`Extension type ${type} already has a handler`);
        }
        addHandlers[type] = onAdd;
        removeHandlers[type] = onRemove;
        const queue = this._queue;
        if (queue[type]) {
            queue[type]?.forEach((ext)=>onAdd(ext));
            delete queue[type];
        }
        return this;
    },
    /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns this for chaining.
   * @ignore
   */ handleByMap (type, map) {
        return this.handle(type, (extension)=>{
            if (extension.name) {
                map[extension.name] = extension.ref;
            }
        }, (extension)=>{
            if (extension.name) {
                delete map[extension.name];
            }
        });
    },
    /**
   * Handle a type, but using a list of extensions with a `name` property.
   * @param type - Type of extension to handle.
   * @param map - The array of named extensions.
   * @param defaultPriority - Fallback priority if none is defined.
   * @returns this for chaining.
   * @ignore
   */ handleByNamedList (type, map, defaultPriority = -1) {
        return this.handle(type, (extension)=>{
            const index = map.findIndex((item)=>item.name === extension.name);
            if (index >= 0) return;
            map.push({
                name: extension.name,
                value: extension.ref
            });
            map.sort((a, b)=>normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));
        }, (extension)=>{
            const index = map.findIndex((item)=>item.name === extension.name);
            if (index !== -1) {
                map.splice(index, 1);
            }
        });
    },
    /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @param defaultPriority - The default priority to use if none is specified.
   * @returns this for chaining.
   * @ignore
   */ handleByList (type, list, defaultPriority = -1) {
        return this.handle(type, (extension)=>{
            if (list.includes(extension.ref)) {
                return;
            }
            list.push(extension.ref);
            list.sort((a, b)=>normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));
        }, (extension)=>{
            const index = list.indexOf(extension.ref);
            if (index !== -1) {
                list.splice(index, 1);
            }
        });
    },
    /**
   * Mixin the source object(s) properties into the target class's prototype.
   * Copies all property descriptors from source objects to the target's prototype.
   * @param Target - The target class to mix properties into
   * @param sources - One or more source objects containing properties to mix in
   * @example
   * ```ts
   * // Create a mixin with shared properties
   * const moveable = {
   *     x: 0,
   *     y: 0,
   *     move(x: number, y: number) {
   *         this.x += x;
   *         this.y += y;
   *     }
   * };
   *
   * // Create a mixin with computed properties
   * const scalable = {
   *     scale: 1,
   *     get scaled() {
   *         return this.scale > 1;
   *     }
   * };
   *
   * // Apply mixins to a class
   * extensions.mixin(Sprite, moveable, scalable);
   *
   * // Use mixed-in properties
   * const sprite = new Sprite();
   * sprite.move(10, 20);
   * console.log(sprite.x, sprite.y); // 10, 20
   * ```
   * @remarks
   * - Copies all properties including getters/setters
   * - Does not modify source objects
   * - Preserves property descriptors
   * @see {@link Object.defineProperties} For details on property descriptors
   * @see {@link Object.getOwnPropertyDescriptors} For details on property copying
   */ mixin (Target, ...sources) {
        for (const source of sources){
            Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source));
        }
    }
};
;
 //# sourceMappingURL=Extensions.mjs.map
}),
"[project]/node_modules/pixi.js/lib/environment-browser/browserExt.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "browserExt",
    ()=>browserExt
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
;
"use strict";
const browserExt = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].Environment,
        name: "browser",
        priority: -1
    },
    test: ()=>true,
    load: async ()=>{
        await __turbopack_context__.A("[project]/node_modules/pixi.js/lib/environment-browser/browserAll.mjs [app-client] (ecmascript, async loader)");
    }
};
;
 //# sourceMappingURL=browserExt.mjs.map
}),
"[project]/node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BrowserAdapter",
    ()=>BrowserAdapter
]);
"use strict";
const BrowserAdapter = {
    createCanvas: (width, height)=>{
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        return canvas;
    },
    createImage: ()=>new Image(),
    getCanvasRenderingContext2D: ()=>CanvasRenderingContext2D,
    getWebGLRenderingContext: ()=>WebGLRenderingContext,
    getNavigator: ()=>navigator,
    getBaseUrl: ()=>document.baseURI ?? window.location.href,
    getFontFaceSet: ()=>document.fonts,
    fetch: (url, options)=>fetch(url, options),
    parseXML: (xml)=>{
        const parser = new DOMParser();
        return parser.parseFromString(xml, "text/xml");
    }
};
;
 //# sourceMappingURL=BrowserAdapter.mjs.map
}),
"[project]/node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "webworkerExt",
    ()=>webworkerExt
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
;
"use strict";
const webworkerExt = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].Environment,
        name: "webworker",
        priority: 0
    },
    test: ()=>typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,
    load: async ()=>{
        await __turbopack_context__.A("[project]/node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs [app-client] (ecmascript, async loader)");
    }
};
;
 //# sourceMappingURL=webworkerExt.mjs.map
}),
"[project]/node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebWorkerAdapter",
    ()=>WebWorkerAdapter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$xmldom$2f$xmldom$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@xmldom/xmldom/lib/index.js [app-client] (ecmascript)");
;
"use strict";
const WebWorkerAdapter = {
    createCanvas: (width, height)=>new OffscreenCanvas(width ?? 0, height ?? 0),
    createImage: ()=>new Image(),
    getCanvasRenderingContext2D: ()=>OffscreenCanvasRenderingContext2D,
    getWebGLRenderingContext: ()=>WebGLRenderingContext,
    getNavigator: ()=>navigator,
    getBaseUrl: ()=>globalThis.location.href,
    getFontFaceSet: ()=>globalThis.fonts,
    fetch: (url, options)=>fetch(url, options),
    parseXML: (xml)=>{
        const parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$xmldom$2f$xmldom$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMParser"]();
        return parser.parseFromString(xml, "text/xml");
    }
};
;
 //# sourceMappingURL=WebWorkerAdapter.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/data/uid.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "resetUids",
    ()=>resetUids,
    "uid",
    ()=>uid
]);
"use strict";
const uidCache = {
    default: -1
};
function uid(name = "default") {
    if (uidCache[name] === void 0) {
        uidCache[name] = -1;
    }
    return ++uidCache[name];
}
function resetUids() {
    for(const key in uidCache){
        delete uidCache[key];
    }
}
;
 //# sourceMappingURL=uid.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "deprecation",
    ()=>deprecation,
    "v8_0_0",
    ()=>v8_0_0,
    "v8_3_4",
    ()=>v8_3_4
]);
"use strict";
const warnings = /* @__PURE__ */ new Set();
const v8_0_0 = "8.0.0";
const v8_3_4 = "8.3.4";
const deprecationState = {
    quiet: false,
    noColor: false
};
const deprecation = (version, message, ignoreDepth = 3)=>{
    if (deprecationState.quiet || warnings.has(message)) return;
    let stack = new Error().stack;
    const deprecationMessage = `${message}
Deprecated since v${version}`;
    const useGroup = typeof console.groupCollapsed === "function" && !deprecationState.noColor;
    if (typeof stack === "undefined") {
        console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
    } else {
        stack = stack.split("\n").splice(ignoreDepth).join("\n");
        if (useGroup) {
            console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", deprecationMessage);
            console.warn(stack);
            console.groupEnd();
        } else {
            console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
            console.warn(stack);
        }
    }
    warnings.add(message);
};
Object.defineProperties(deprecation, {
    quiet: {
        get: ()=>deprecationState.quiet,
        set: (value)=>{
            deprecationState.quiet = value;
        },
        enumerable: true,
        configurable: false
    },
    noColor: {
        get: ()=>deprecationState.noColor,
        set: (value)=>{
            deprecationState.noColor = value;
        },
        enumerable: true,
        configurable: false
    }
});
;
 //# sourceMappingURL=deprecation.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/misc/NOOP.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NOOP",
    ()=>NOOP
]);
"use strict";
const NOOP = ()=>{};
;
 //# sourceMappingURL=NOOP.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "updateQuadBounds",
    ()=>updateQuadBounds
]);
"use strict";
function updateQuadBounds(bounds, anchor, texture) {
    const { width, height } = texture.orig;
    const trim = texture.trim;
    if (trim) {
        const sourceWidth = trim.width;
        const sourceHeight = trim.height;
        bounds.minX = trim.x - anchor._x * width;
        bounds.maxX = bounds.minX + sourceWidth;
        bounds.minY = trim.y - anchor._y * height;
        bounds.maxY = bounds.minY + sourceHeight;
    } else {
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * height;
        bounds.maxY = bounds.minY + height;
    }
}
;
 //# sourceMappingURL=updateQuadBounds.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "warn",
    ()=>warn
]);
"use strict";
let warnCount = 0;
const maxWarnings = 500;
function warn(...args) {
    if (warnCount === maxWarnings) return;
    warnCount++;
    if (warnCount === maxWarnings) {
        console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
    } else {
        console.warn("PixiJS Warning: ", ...args);
    }
}
;
 //# sourceMappingURL=warn.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/pool/GlobalResourceRegistry.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GlobalResourceRegistry",
    ()=>GlobalResourceRegistry
]);
"use strict";
const GlobalResourceRegistry = {
    /**
   * Set of registered pools and cleanable objects.
   * @private
   */ _registeredResources: /* @__PURE__ */ new Set(),
    /**
   * Registers a pool or cleanable object for cleanup.
   * @param {Cleanable} pool - The pool or object to register.
   */ register (pool) {
        this._registeredResources.add(pool);
    },
    /**
   * Unregisters a pool or cleanable object from cleanup.
   * @param {Cleanable} pool - The pool or object to unregister.
   */ unregister (pool) {
        this._registeredResources.delete(pool);
    },
    /** Clears all registered pools and cleanable objects. This will call clear() on each registered item. */ release () {
        this._registeredResources.forEach((pool)=>pool.clear());
    },
    /**
   * Gets the number of registered pools and cleanable objects.
   * @returns {number} The count of registered items.
   */ get registeredCount () {
        return this._registeredResources.size;
    },
    /**
   * Checks if a specific pool or cleanable object is registered.
   * @param {Cleanable} pool - The pool or object to check.
   * @returns {boolean} True if the item is registered, false otherwise.
   */ isRegistered (pool) {
        return this._registeredResources.has(pool);
    },
    /**
   * Removes all registrations without clearing the pools.
   * Useful if you want to reset the collector without affecting the pools.
   */ reset () {
        this._registeredResources.clear();
    }
};
;
 //# sourceMappingURL=GlobalResourceRegistry.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/pool/Pool.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Pool",
    ()=>Pool
]);
"use strict";
class Pool {
    /**
   * Constructs a new Pool.
   * @param ClassType - The constructor of the items in the pool.
   * @param {number} [initialSize] - The initial size of the pool.
   */ constructor(ClassType, initialSize){
        this._pool = [];
        this._count = 0;
        this._index = 0;
        this._classType = ClassType;
        if (initialSize) {
            this.prepopulate(initialSize);
        }
    }
    /**
   * Prepopulates the pool with a given number of items.
   * @param total - The number of items to add to the pool.
   */ prepopulate(total) {
        for(let i = 0; i < total; i++){
            this._pool[this._index++] = new this._classType();
        }
        this._count += total;
    }
    /**
   * Gets an item from the pool. Calls the item's `init` method if it exists.
   * If there are no items left in the pool, a new one will be created.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */ get(data) {
        let item;
        if (this._index > 0) {
            item = this._pool[--this._index];
        } else {
            item = new this._classType();
            this._count++;
        }
        item.init?.(data);
        return item;
    }
    /**
   * Returns an item to the pool. Calls the item's `reset` method if it exists.
   * @param {T} item - The item to return to the pool.
   */ return(item) {
        item.reset?.();
        this._pool[this._index++] = item;
    }
    /**
   * Gets the number of items in the pool.
   * @readonly
   */ get totalSize() {
        return this._count;
    }
    /**
   * Gets the number of items in the pool that are free to use without needing to create more.
   * @readonly
   */ get totalFree() {
        return this._index;
    }
    /**
   * Gets the number of items in the pool that are currently in use.
   * @readonly
   */ get totalUsed() {
        return this._count - this._index;
    }
    /** clears the pool */ clear() {
        if (this._pool.length > 0 && this._pool[0].destroy) {
            for(let i = 0; i < this._index; i++){
                this._pool[i].destroy();
            }
        }
        this._pool.length = 0;
        this._count = 0;
        this._index = 0;
    }
}
;
 //# sourceMappingURL=Pool.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BigPool",
    ()=>BigPool,
    "PoolGroupClass",
    ()=>PoolGroupClass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$GlobalResourceRegistry$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/pool/GlobalResourceRegistry.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$Pool$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/pool/Pool.mjs [app-client] (ecmascript)");
;
;
"use strict";
class PoolGroupClass {
    constructor(){
        /**
     * A map to store the pools by their class type.
     * @private
     */ this._poolsByClass = /* @__PURE__ */ new Map();
    }
    /**
   * Prepopulates a specific pool with a given number of items.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {number} total - The number of items to add to the pool.
   */ prepopulate(Class, total) {
        const classPool = this.getPool(Class);
        classPool.prepopulate(total);
    }
    /**
   * Gets an item from a specific pool.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */ get(Class, data) {
        const pool = this.getPool(Class);
        return pool.get(data);
    }
    /**
   * Returns an item to its respective pool.
   * @param {PoolItem} item - The item to return to the pool.
   */ return(item) {
        const pool = this.getPool(item.constructor);
        pool.return(item);
    }
    /**
   * Gets a specific pool based on the class type.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
   * @returns {Pool<T>} The pool of the given class type.
   */ getPool(ClassType) {
        if (!this._poolsByClass.has(ClassType)) {
            this._poolsByClass.set(ClassType, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$Pool$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Pool"](ClassType));
        }
        return this._poolsByClass.get(ClassType);
    }
    /** gets the usage stats of each pool in the system */ stats() {
        const stats = {};
        this._poolsByClass.forEach((pool)=>{
            const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
            stats[name] = {
                free: pool.totalFree,
                used: pool.totalUsed,
                size: pool.totalSize
            };
        });
        return stats;
    }
    /** Clears all pools in the group. This will reset all pools and free their resources. */ clear() {
        this._poolsByClass.forEach((pool)=>pool.clear());
        this._poolsByClass.clear();
    }
}
const BigPool = new PoolGroupClass();
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$pool$2f$GlobalResourceRegistry$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GlobalResourceRegistry"].register(BigPool);
;
 //# sourceMappingURL=PoolGroup.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/data/removeItems.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "removeItems",
    ()=>removeItems
]);
"use strict";
function removeItems(arr, startIdx, removeCount) {
    const length = arr.length;
    let i;
    if (startIdx >= length || removeCount === 0) {
        return;
    }
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    const len = length - removeCount;
    for(i = startIdx; i < len; ++i){
        arr[i] = arr[i + removeCount];
    }
    arr.length = len;
}
;
 //# sourceMappingURL=removeItems.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "detectVideoAlphaMode",
    ()=>detectVideoAlphaMode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-client] (ecmascript)");
;
"use strict";
let promise;
async function detectVideoAlphaMode() {
    promise ?? (promise = (async ()=>{
        const canvas = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMAdapter"].get().createCanvas(1, 1);
        const gl = canvas.getContext("webgl");
        if (!gl) {
            return "premultiply-alpha-on-upload";
        }
        const video = await new Promise((resolve)=>{
            const video2 = document.createElement("video");
            video2.onloadeddata = ()=>resolve(video2);
            video2.onerror = ()=>resolve(null);
            video2.autoplay = false;
            video2.crossOrigin = "anonymous";
            video2.preload = "auto";
            video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
            video2.load();
        });
        if (!video) {
            return "premultiply-alpha-on-upload";
        }
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
        const pixel = new Uint8Array(4);
        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
        gl.deleteFramebuffer(framebuffer);
        gl.deleteTexture(texture);
        gl.getExtension("WEBGL_lose_context")?.loseContext();
        return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })());
    return promise;
}
;
 //# sourceMappingURL=detectVideoAlphaMode.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/path.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "path",
    ()=>path
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-client] (ecmascript)");
;
"use strict";
function assertPath(path2) {
    if (typeof path2 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
}
function removeUrlParams(url) {
    const re = url.split("?")[0];
    return re.split("#")[0];
}
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
    return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = -1;
    for(let i = 0; i <= path2.length; ++i){
        if (i < path2.length) {
            code = path2.charCodeAt(i);
        } else if (code === 47) {
            break;
        } else {
            code = 47;
        }
        if (code === 47) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf("/");
                        if (lastSlashIndex !== res.length - 1) {
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            } else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) {
                        res += "/..";
                    } else {
                        res = "..";
                    }
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) {
                    res += `/${path2.slice(lastSlash + 1, i)}`;
                } else {
                    res = path2.slice(lastSlash + 1, i);
                }
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
const path = {
    /**
   * Converts a path to posix format.
   * @param path - The path to convert to posix
   * @example
   * ```ts
   * // Convert a Windows path to POSIX format
   * path.toPosix('C:\\Users\\User\\Documents\\file.txt');
   * // -> 'C:/Users/User/Documents/file.txt'
   * ```
   */ toPosix (path2) {
        return replaceAll(path2, "\\", "/");
    },
    /**
   * Checks if the path is a URL e.g. http://, https://
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a URL
   * path.isUrl('http://www.example.com');
   * // -> true
   * path.isUrl('C:/Users/User/Documents/file.txt');
   * // -> false
   * ```
   */ isUrl (path2) {
        return /^https?:/.test(this.toPosix(path2));
    },
    /**
   * Checks if the path is a data URL
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a data URL
   * path.isDataUrl('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');
   * // -> true
   * ```
   */ isDataUrl (path2) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
    },
    /**
   * Checks if the path is a blob URL
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a blob URL
   * path.isBlobUrl('blob:http://www.example.com/12345678-1234-1234-1234-123456789012');
   * // -> true
   * ```
   */ isBlobUrl (path2) {
        return path2.startsWith("blob:");
    },
    /**
   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
   * This will return true for windows file paths
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path has a protocol
   * path.hasProtocol('http://www.example.com');
   * // -> true
   * path.hasProtocol('C:/Users/User/Documents/file.txt');
   * // -> true
   * ```
   */ hasProtocol (path2) {
        return /^[^/:]+:/.test(this.toPosix(path2));
    },
    /**
   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
   * @param path - The path to get the protocol from
   * @example
   * ```ts
   * // Get the protocol from a URL
   * path.getProtocol('http://www.example.com/path/to/resource');
   * // -> 'http://'
   * // Get the protocol from a file path
   * path.getProtocol('C:/Users/User/Documents/file.txt');
   * // -> 'C:/'
   * ```
   */ getProtocol (path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        const matchFile = /^file:\/\/\//.exec(path2);
        if (matchFile) {
            return matchFile[0];
        }
        const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
        if (matchProtocol) {
            return matchProtocol[0];
        }
        return "";
    },
    /**
   * Converts URL to an absolute path.
   * When loading from a Web Worker, we must use absolute paths.
   * If the URL is already absolute we return it as is
   * If it's not, we convert it
   * @param url - The URL to test
   * @param customBaseUrl - The base URL to use
   * @param customRootUrl - The root URL to use
   * @example
   * ```ts
   * // Convert a relative URL to an absolute path
   * path.toAbsolute('images/texture.png', 'http://example.com/assets/');
   * // -> 'http://example.com/assets/images/texture.png'
   * ```
   */ toAbsolute (url, customBaseUrl, customRootUrl) {
        assertPath(url);
        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;
        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMAdapter"].get().getBaseUrl()));
        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
        url = this.toPosix(url);
        if (url.startsWith("/")) {
            return path.join(rootUrl, url.slice(1));
        }
        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
        return absolutePath;
    },
    /**
   * Normalizes the given path, resolving '..' and '.' segments
   * @param path - The path to normalize
   * @example
   * ```ts
   * // Normalize a path with relative segments
   * path.normalize('http://www.example.com/foo/bar/../baz');
   * // -> 'http://www.example.com/foo/baz'
   * // Normalize a file path with relative segments
   * path.normalize('C:\\Users\\User\\Documents\\..\\file.txt');
   * // -> 'C:/Users/User/file.txt'
   * ```
   */ normalize (path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        if (this.isDataUrl(path2) || this.isBlobUrl(path2)) return path2;
        path2 = this.toPosix(path2);
        let protocol = "";
        const isAbsolute = path2.startsWith("/");
        if (this.hasProtocol(path2)) {
            protocol = this.rootname(path2);
            path2 = path2.slice(protocol.length);
        }
        const trailingSeparator = path2.endsWith("/");
        path2 = normalizeStringPosix(path2, false);
        if (path2.length > 0 && trailingSeparator) path2 += "/";
        if (isAbsolute) return `/${path2}`;
        return protocol + path2;
    },
    /**
   * Determines if path is an absolute path.
   * Absolute paths can be urls, data urls, or paths on disk
   * @param path - The path to test
   * @example
   * ```ts
   * // Check if a path is absolute
   * path.isAbsolute('http://www.example.com/foo/bar');
   * // -> true
   * path.isAbsolute('C:/Users/User/Documents/file.txt');
   * // -> true
   * ```
   */ isAbsolute (path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        if (this.hasProtocol(path2)) return true;
        return path2.startsWith("/");
    },
    /**
   * Joins all given path segments together using the platform-specific separator as a delimiter,
   * then normalizes the resulting path
   * @param segments - The segments of the path to join
   * @example
   * ```ts
   * // Join multiple path segments
   * path.join('assets', 'images', 'sprite.png');
   * // -> 'assets/images/sprite.png'
   * // Join with relative segments
   * path.join('assets', 'images', '../textures', 'sprite.png');
   * // -> 'assets/textures/sprite.png'
   * ```
   */ join (...segments) {
        if (segments.length === 0) {
            return ".";
        }
        let joined;
        for(let i = 0; i < segments.length; ++i){
            const arg = segments[i];
            assertPath(arg);
            if (arg.length > 0) {
                if (joined === void 0) joined = arg;
                else {
                    const prevArg = segments[i - 1] ?? "";
                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
                        joined += `/../${arg}`;
                    } else {
                        joined += `/${arg}`;
                    }
                }
            }
        }
        if (joined === void 0) {
            return ".";
        }
        return this.normalize(joined);
    },
    /**
   * Returns the directory name of a path
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the directory name of a path
   * path.dirname('http://www.example.com/foo/bar/baz.png');
   * // -> 'http://www.example.com/foo/bar'
   * // Get the directory name of a file path
   * path.dirname('C:/Users/User/Documents/file.txt');
   * // -> 'C:/Users/User/Documents'
   * ```
   */ dirname (path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        path2 = this.toPosix(path2);
        let code = path2.charCodeAt(0);
        const hasRoot = code === 47;
        let end = -1;
        let matchedSlash = true;
        const proto = this.getProtocol(path2);
        const origpath = path2;
        path2 = path2.slice(proto.length);
        for(let i = path2.length - 1; i >= 1; --i){
            code = path2.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            } else {
                matchedSlash = false;
            }
        }
        if (end === -1) return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
        if (hasRoot && end === 1) return "//";
        return proto + path2.slice(0, end);
    },
    /**
   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the root of a URL
   * path.rootname('http://www.example.com/foo/bar/baz.png');
   * // -> 'http://www.example.com/'
   * // Get the root of a file path
   * path.rootname('C:/Users/User/Documents/file.txt');
   * // -> 'C:/'
   * ```
   */ rootname (path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        let root = "";
        if (path2.startsWith("/")) root = "/";
        else {
            root = this.getProtocol(path2);
        }
        if (this.isUrl(path2)) {
            const index = path2.indexOf("/", root.length);
            if (index !== -1) {
                root = path2.slice(0, index);
            } else root = path2;
            if (!root.endsWith("/")) root += "/";
        }
        return root;
    },
    /**
   * Returns the last portion of a path
   * @param path - The path to test
   * @param ext - Optional extension to remove
   * @example
   * ```ts
   * // Get the basename of a URL
   * path.basename('http://www.example.com/foo/bar/baz.png');
   * // -> 'baz.png'
   * // Get the basename of a file path
   * path.basename('C:/Users/User/Documents/file.txt');
   * // -> 'file.txt'
   * ```
   */ basename (path2, ext) {
        assertPath(path2);
        if (ext) assertPath(ext);
        path2 = removeUrlParams(this.toPosix(path2));
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
            if (ext.length === path2.length && ext === path2) return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for(i = path2.length - 1; i >= 0; --i){
                const code = path2.charCodeAt(i);
                if (code === 47) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else {
                    if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                end = i;
                            }
                        } else {
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) end = firstNonSlashEnd;
            else if (end === -1) end = path2.length;
            return path2.slice(start, end);
        }
        for(i = path2.length - 1; i >= 0; --i){
            if (path2.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path2.slice(start, end);
    },
    /**
   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
   * the first character of the basename of path, an empty string is returned.
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the extension of a URL
   * path.extname('http://www.example.com/foo/bar/baz.png');
   * // -> '.png'
   * // Get the extension of a file path
   * path.extname('C:/Users/User/Documents/file.txt');
   * // -> '.txt'
   * ```
   */ extname (path2) {
        assertPath(path2);
        path2 = removeUrlParams(this.toPosix(path2));
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for(let i = path2.length - 1; i >= 0; --i){
            const code = path2.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46) {
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
        }
        return path2.slice(startDot, end);
    },
    /**
   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
   * @param path - The path to parse
   * @example
   * ```ts
   * // Parse a URL
   * const parsed = path.parse('http://www.example.com/foo/bar/baz.png');
   * // -> {
   * //   root: 'http://www.example.com/',
   * //   dir: 'http://www.example.com/foo/bar',
   * //   base: 'baz.png',
   * //   ext: '.png',
   * //   name: 'baz'
   * // }
   * // Parse a file path
   * const parsedFile = path.parse('C:/Users/User/Documents/file.txt');
   * // -> {
   * //   root: 'C:/',
   * //   dir: 'C:/Users/User/Documents',
   * //   base: 'file.txt',
   * //   ext: '.txt',
   * //   name: 'file'
   * // }
   * ```
   */ parse (path2) {
        assertPath(path2);
        const ret = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (path2.length === 0) return ret;
        path2 = removeUrlParams(this.toPosix(path2));
        let code = path2.charCodeAt(0);
        const isAbsolute = this.isAbsolute(path2);
        let start;
        const protocol = "";
        ret.root = this.rootname(path2);
        if (isAbsolute || this.hasProtocol(path2)) {
            start = 1;
        } else {
            start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path2.length - 1;
        let preDotState = 0;
        for(; i >= start; --i){
            code = path2.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46) {
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) ret.base = ret.name = path2.slice(1, end);
                else ret.base = ret.name = path2.slice(startPart, end);
            }
        } else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path2.slice(1, startDot);
                ret.base = path2.slice(1, end);
            } else {
                ret.name = path2.slice(startPart, startDot);
                ret.base = path2.slice(startPart, end);
            }
            ret.ext = path2.slice(startDot, end);
        }
        ret.dir = this.dirname(path2);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return ret;
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [
        ".html"
    ]
};
;
 //# sourceMappingURL=path.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/browser/isMobile.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isMobile",
    ()=>isMobile
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ismobilejs$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/ismobilejs/esm/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ismobilejs$2f$esm$2f$isMobile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ismobilejs/esm/isMobile.js [app-client] (ecmascript)");
;
"use strict";
const isMobileCall = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ismobilejs$2f$esm$2f$isMobile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].default ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ismobilejs$2f$esm$2f$isMobile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
const isMobile = isMobileCall(globalThis.navigator);
;
 //# sourceMappingURL=isMobile.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "unsafeEvalSupported",
    ()=>unsafeEvalSupported
]);
"use strict";
let unsafeEval;
function unsafeEvalSupported() {
    if (typeof unsafeEval === "boolean") {
        return unsafeEval;
    }
    try {
        const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
        unsafeEval = func({
            a: "b"
        }, "a", "b") === true;
    } catch (_e) {
        unsafeEval = false;
    }
    return unsafeEval;
}
;
 //# sourceMappingURL=unsafeEvalSupported.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isWebGLSupported",
    ()=>isWebGLSupported
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$system$2f$AbstractRenderer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs [app-client] (ecmascript)");
;
;
"use strict";
let _isWebGLSupported;
function isWebGLSupported(failIfMajorPerformanceCaveat) {
    if (_isWebGLSupported !== void 0) return _isWebGLSupported;
    _isWebGLSupported = (()=>{
        const contextOptions = {
            stencil: true,
            failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$system$2f$AbstractRenderer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AbstractRenderer"].defaultOptions.failIfMajorPerformanceCaveat
        };
        try {
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMAdapter"].get().getWebGLRenderingContext()) {
                return false;
            }
            const canvas = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMAdapter"].get().createCanvas();
            let gl = canvas.getContext("webgl", contextOptions);
            const success = !!gl?.getContextAttributes()?.stencil;
            if (gl) {
                const loseContext = gl.getExtension("WEBGL_lose_context");
                if (loseContext) {
                    loseContext.loseContext();
                }
            }
            gl = null;
            return success;
        } catch (_e) {
            return false;
        }
    })();
    return _isWebGLSupported;
}
;
 //# sourceMappingURL=isWebGLSupported.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isWebGPUSupported",
    ()=>isWebGPUSupported
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-client] (ecmascript)");
;
"use strict";
let _isWebGPUSupported;
async function isWebGPUSupported(options = {}) {
    if (_isWebGPUSupported !== void 0) return _isWebGPUSupported;
    _isWebGPUSupported = await (async ()=>{
        const gpu = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMAdapter"].get().getNavigator().gpu;
        if (!gpu) {
            return false;
        }
        try {
            const adapter = await gpu.requestAdapter(options);
            await adapter.requestDevice();
            return true;
        } catch (_e) {
            return false;
        }
    })();
    return _isWebGPUSupported;
}
;
 //# sourceMappingURL=isWebGPUSupported.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/const.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DATA_URI",
    ()=>DATA_URI,
    "VERSION",
    ()=>VERSION
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-client] (ecmascript) <locals>");
;
"use strict";
const DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
const VERSION = "8.15.0";
;
 //# sourceMappingURL=const.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/global/globalHooks.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApplicationInitHook",
    ()=>ApplicationInitHook,
    "RendererInitHook",
    ()=>RendererInitHook
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/const.mjs [app-client] (ecmascript) <locals>");
;
;
"use strict";
class ApplicationInitHook {
    static init() {
        globalThis.__PIXI_APP_INIT__?.(this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["VERSION"]);
    }
    static destroy() {}
}
/** @ignore */ ApplicationInitHook.extension = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].Application;
class RendererInitHook {
    constructor(renderer){
        this._renderer = renderer;
    }
    init() {
        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["VERSION"]);
    }
    destroy() {
        this._renderer = null;
    }
}
/** @ignore */ RendererInitHook.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUSystem
    ],
    name: "initHook",
    priority: -10
};
;
 //# sourceMappingURL=globalHooks.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ViewableBuffer",
    ()=>ViewableBuffer
]);
"use strict";
class ViewableBuffer {
    constructor(sizeOrBuffer){
        if (typeof sizeOrBuffer === "number") {
            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
        } else if (sizeOrBuffer instanceof Uint8Array) {
            this.rawBinaryData = sizeOrBuffer.buffer;
        } else {
            this.rawBinaryData = sizeOrBuffer;
        }
        this.uint32View = new Uint32Array(this.rawBinaryData);
        this.float32View = new Float32Array(this.rawBinaryData);
        this.size = this.rawBinaryData.byteLength;
    }
    /** View on the raw binary data as a `Int8Array`. */ get int8View() {
        if (!this._int8View) {
            this._int8View = new Int8Array(this.rawBinaryData);
        }
        return this._int8View;
    }
    /** View on the raw binary data as a `Uint8Array`. */ get uint8View() {
        if (!this._uint8View) {
            this._uint8View = new Uint8Array(this.rawBinaryData);
        }
        return this._uint8View;
    }
    /**  View on the raw binary data as a `Int16Array`. */ get int16View() {
        if (!this._int16View) {
            this._int16View = new Int16Array(this.rawBinaryData);
        }
        return this._int16View;
    }
    /** View on the raw binary data as a `Int32Array`. */ get int32View() {
        if (!this._int32View) {
            this._int32View = new Int32Array(this.rawBinaryData);
        }
        return this._int32View;
    }
    /** View on the raw binary data as a `Float64Array`. */ get float64View() {
        if (!this._float64Array) {
            this._float64Array = new Float64Array(this.rawBinaryData);
        }
        return this._float64Array;
    }
    /** View on the raw binary data as a `BigUint64Array`. */ get bigUint64View() {
        if (!this._bigUint64Array) {
            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
        }
        return this._bigUint64Array;
    }
    /**
   * Returns the view of the given type.
   * @param type - One of `int8`, `uint8`, `int16`,
   *    `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - typed array of given type
   */ view(type) {
        return this[`${type}View`];
    }
    /** Destroys all buffer references. Do not use after calling this. */ destroy() {
        this.rawBinaryData = null;
        this.uint32View = null;
        this.float32View = null;
        this.uint16View = null;
        this._int8View = null;
        this._uint8View = null;
        this._int16View = null;
        this._int32View = null;
        this._float64Array = null;
        this._bigUint64Array = null;
    }
    /**
   * Returns the size of the given type in bytes.
   * @param type - One of `int8`, `uint8`, `int16`,
   *   `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - size of the type in bytes
   */ static sizeOf(type) {
        switch(type){
            case "int8":
            case "uint8":
                return 1;
            case "int16":
            case "uint16":
                return 2;
            case "int32":
            case "uint32":
            case "float32":
                return 4;
            default:
                throw new Error(`${type} isn't a valid view type`);
        }
    }
}
;
 //# sourceMappingURL=ViewableBuffer.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/data/GCManagedHash.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GCManagedHash",
    ()=>GCManagedHash
]);
"use strict";
class GCManagedHash {
    constructor(options){
        // Exposed directly for GC system access
        this.items = /* @__PURE__ */ Object.create(null);
        const { renderer, type, onUnload, priority, name } = options;
        this._renderer = renderer;
        renderer.gc.addResourceHash(this, "items", type, priority ?? 0);
        this._onUnload = onUnload;
        this.name = name;
    }
    /**
   * Add an item to the hash. No-op if already added.
   * @param item
   * @returns true if the item was added, false if it was already in the hash
   */ add(item) {
        if (this.items[item.uid]) return false;
        this.items[item.uid] = item;
        item.once("unload", this.remove, this);
        item._gcLastUsed = this._renderer.gc.now;
        return true;
    }
    remove(item, ...args) {
        if (!this.items[item.uid]) return;
        const gpuData = item._gpuData[this._renderer.uid];
        if (!gpuData) return;
        this._onUnload?.(item, ...args);
        gpuData.destroy();
        item._gpuData[this._renderer.uid] = null;
        this.items[item.uid] = null;
    }
    removeAll(...args) {
        Object.values(this.items).forEach((item)=>item && this.remove(item, ...args));
    }
    destroy(...args) {
        this.removeAll(...args);
        this.items = /* @__PURE__ */ Object.create(null);
        this._renderer = null;
        this._onUnload = null;
    }
}
;
 //# sourceMappingURL=GCManagedHash.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/utils.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "earcut",
    ()=>earcut
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$earcut$2f$src$2f$earcut$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/earcut/src/earcut.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-client] (ecmascript) <locals>");
;
;
"use strict";
const earcut = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$earcut$2f$src$2f$earcut$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].default || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$earcut$2f$src$2f$earcut$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
 //# sourceMappingURL=utils.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getResolutionOfUrl",
    ()=>getResolutionOfUrl
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$resolver$2f$Resolver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs [app-client] (ecmascript)");
;
"use strict";
function getResolutionOfUrl(url, defaultValue = 1) {
    const resolution = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$resolver$2f$Resolver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resolver"].RETINA_PREFIX?.exec(url);
    if (resolution) {
        return parseFloat(resolution[1]);
    }
    return defaultValue;
}
;
 //# sourceMappingURL=getResolutionOfUrl.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/misc/Transform.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Transform",
    ()=>Transform
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs [app-client] (ecmascript)");
;
;
"use strict";
class Transform {
    /**
   * @param options - Options for the transform.
   * @param options.matrix - The matrix to use.
   * @param options.observer - The observer to use.
   */ constructor({ matrix, observer } = {}){
        this.dirty = true;
        this._matrix = matrix ?? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$matrix$2f$Matrix$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"]();
        this.observer = observer;
        this.position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObservablePoint"](this, 0, 0);
        this.scale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObservablePoint"](this, 1, 1);
        this.pivot = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObservablePoint"](this, 0, 0);
        this.skew = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$ObservablePoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObservablePoint"](this, 0, 0);
        this._rotation = 0;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
    }
    /**
   * The transformation matrix computed from the transform's properties.
   * Combines position, scale, rotation, skew, and pivot into a single matrix.
   * @example
   * ```ts
   * // Get current matrix
   * const matrix = transform.matrix;
   * console.log(matrix.toString());
   * ```
   * @readonly
   * @see {@link Matrix} For matrix operations
   * @see {@link Transform.setFromMatrix} For setting transform from matrix
   */ get matrix() {
        const lt = this._matrix;
        if (!this.dirty) return lt;
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this.dirty = false;
        return lt;
    }
    /**
   * Called when a value changes.
   * @param point
   * @internal
   */ _onUpdate(point) {
        this.dirty = true;
        if (point === this.skew) {
            this.updateSkew();
        }
        this.observer?._onUpdate(this);
    }
    /** Called when the skew or the rotation changes. */ updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew.y);
        this._sx = Math.sin(this._rotation + this.skew.y);
        this._cy = -Math.sin(this._rotation - this.skew.x);
        this._sy = Math.cos(this._rotation - this.skew.x);
        this.dirty = true;
    }
    toString() {
        return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
    }
    /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @example
   * ```ts
   * // Basic matrix decomposition
   * const transform = new Transform();
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4)
   *     .scale(2, 2);
   *
   * transform.setFromMatrix(matrix);
   * console.log(transform.position.x); // 100
   * console.log(transform.rotation); // ~0.785 (/4)
   * ```
   * @param matrix - The matrix to decompose
   * @see {@link Matrix#decompose} For the decomposition logic
   * @see {@link Transform#matrix} For getting the current matrix
   */ setFromMatrix(matrix) {
        matrix.decompose(this);
        this.dirty = true;
    }
    /**
   * The rotation of the object in radians.
   * @example
   * ```ts
   * // Basic rotation
   * transform.rotation = Math.PI / 4; // 45 degrees
   *
   * // Rotate around pivot point
   * transform.pivot.set(50, 50);
   * transform.rotation = Math.PI; // 180 degrees around pivot
   *
   * // Animate rotation
   * app.ticker.add(() => {
   *     transform.rotation += 0.1;
   * });
   * ```
   * @see {@link Transform#pivot} For rotation point
   * @see {@link Transform#skew} For skew effects
   */ get rotation() {
        return this._rotation;
    }
    set rotation(value) {
        if (this._rotation !== value) {
            this._rotation = value;
            this._onUpdate(this.skew);
        }
    }
}
;
 //# sourceMappingURL=Transform.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getCanvasBoundingBox",
    ()=>getCanvasBoundingBox
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$misc$2f$pow2$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/misc/pow2.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-client] (ecmascript)");
;
;
;
"use strict";
let _internalCanvas = null;
let _internalContext = null;
function ensureInternalCanvas(width, height) {
    if (!_internalCanvas) {
        _internalCanvas = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMAdapter"].get().createCanvas(256, 128);
        _internalContext = _internalCanvas.getContext("2d", {
            willReadFrequently: true
        });
        _internalContext.globalCompositeOperation = "copy";
        _internalContext.globalAlpha = 1;
    }
    if (_internalCanvas.width < width || _internalCanvas.height < height) {
        _internalCanvas.width = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$misc$2f$pow2$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nextPow2"])(width);
        _internalCanvas.height = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$misc$2f$pow2$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nextPow2"])(height);
    }
}
function checkRow(data, width, y) {
    for(let x = 0, index = 4 * y * width; x < width; ++x, index += 4){
        if (data[index + 3] !== 0) return false;
    }
    return true;
}
function checkColumn(data, width, x, top, bottom) {
    const stride = 4 * width;
    for(let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride){
        if (data[index + 3] !== 0) return false;
    }
    return true;
}
function getCanvasBoundingBox(...args) {
    let options = args[0];
    if (!options.canvas) {
        options = {
            canvas: args[0],
            resolution: args[1]
        };
    }
    const { canvas } = options;
    const resolution = Math.min(options.resolution ?? 1, 1);
    const width = options.width ?? canvas.width;
    const height = options.height ?? canvas.height;
    let output = options.output;
    ensureInternalCanvas(width, height);
    if (!_internalContext) {
        throw new TypeError("Failed to get canvas 2D context");
    }
    _internalContext.drawImage(canvas, 0, 0, width, height, 0, 0, width * resolution, height * resolution);
    const imageData = _internalContext.getImageData(0, 0, width, height);
    const data = imageData.data;
    let left = 0;
    let top = 0;
    let right = width - 1;
    let bottom = height - 1;
    while(top < height && checkRow(data, width, top))++top;
    if (top === height) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rectangle"].EMPTY;
    while(checkRow(data, width, bottom))--bottom;
    while(checkColumn(data, width, left, top, bottom))++left;
    while(checkColumn(data, width, right, top, bottom))--right;
    ++right;
    ++bottom;
    _internalContext.globalCompositeOperation = "source-over";
    _internalContext.strokeRect(left, top, right - left, bottom - top);
    _internalContext.globalCompositeOperation = "copy";
    output ?? (output = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rectangle"]());
    output.set(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);
    return output;
}
;
 //# sourceMappingURL=getCanvasBoundingBox.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/sayHello.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sayHello",
    ()=>sayHello
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/const.mjs [app-client] (ecmascript) <locals>");
;
;
"use strict";
let saidHello = false;
function sayHello(type) {
    if (saidHello) {
        return;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMAdapter"].get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
        const args = [
            `%c  %c  %c  %c  %c PixiJS %c v${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["VERSION"]} (${type}) http://www.pixijs.com/

`,
            "background: #E72264; padding:5px 0;",
            "background: #6CA2EA; padding:5px 0;",
            "background: #B5D33D; padding:5px 0;",
            "background: #FED23F; padding:5px 0;",
            "color: #FFFFFF; background: #E72264; padding:5px 0;",
            "color: #E72264; background: #FFFFFF; padding:5px 0;"
        ];
        globalThis.console.log(...args);
    } else if (globalThis.console) {
        globalThis.console.log(`PixiJS ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["VERSION"]} - ${type} - http://www.pixijs.com/`);
    }
    saidHello = true;
}
;
 //# sourceMappingURL=sayHello.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/data/clean.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cleanArray",
    ()=>cleanArray,
    "cleanHash",
    ()=>cleanHash
]);
"use strict";
function cleanHash(hash) {
    let clean = false;
    for(const i in hash){
        if (hash[i] == void 0) {
            clean = true;
            break;
        }
    }
    if (!clean) return hash;
    const cleanHash2 = /* @__PURE__ */ Object.create(null);
    for(const i in hash){
        const value = hash[i];
        if (value) {
            cleanHash2[i] = value;
        }
    }
    return cleanHash2;
}
function cleanArray(arr) {
    let offset = 0;
    for(let i = 0; i < arr.length; i++){
        if (arr[i] == void 0) {
            offset++;
        } else {
            arr[i - offset] = arr[i];
        }
    }
    arr.length -= offset;
    return arr;
}
;
 //# sourceMappingURL=clean.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/browser/isSafari.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isSafari",
    ()=>isSafari
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-client] (ecmascript)");
;
"use strict";
function isSafari() {
    const { userAgent } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2f$adapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMAdapter"].get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
}
;
 //# sourceMappingURL=isSafari.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/logging/logDebugTexture.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "logDebugTexture",
    ()=>logDebugTexture
]);
"use strict";
async function logDebugTexture(texture, renderer, size = 200) {
    const base64 = await renderer.extract.base64(texture);
    await renderer.encoder.commandFinished;
    const width = size;
    console.log(`logging texture ${texture.source.width}px ${texture.source.height}px`);
    const style = [
        "font-size: 1px;",
        `padding: ${width}px ${300}px;`,
        `background: url(${base64}) no-repeat;`,
        "background-size: contain;"
    ].join(" ");
    console.log("%c ", style);
}
;
 //# sourceMappingURL=logDebugTexture.mjs.map
}),
"[project]/node_modules/pixi.js/lib/utils/logging/logScene.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "logRenderGroupScene",
    ()=>logRenderGroupScene,
    "logScene",
    ()=>logScene
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$Sprite$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs [app-client] (ecmascript)");
;
"use strict";
const colors = [
    "#000080",
    // Navy Blue
    "#228B22",
    // Forest Green
    "#8B0000",
    // Dark Red
    "#4169E1",
    // Royal Blue
    "#008080",
    // Teal
    "#800000",
    // Maroon
    "#9400D3",
    // Dark Violet
    "#FF8C00",
    // Dark Orange
    "#556B2F",
    // Olive Green
    "#8B008B"
];
let colorTick = 0;
function logScene(container, depth = 0, data = {
    color: "#000000"
}) {
    if (container.renderGroup) {
        data.color = colors[colorTick++];
    }
    let spaces = "";
    for(let i = 0; i < depth; i++){
        spaces += "    ";
    }
    let label = container.label;
    if (!label && container instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$Sprite$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sprite"]) {
        label = `sprite:${container.texture.label}`;
    }
    let output = `%c ${spaces}|- ${label} (worldX:${container.worldTransform.tx}, relativeRenderX:${container.relativeGroupTransform.tx}, renderX:${container.groupTransform.tx}, localX:${container.x})`;
    if (container.renderGroup) {
        output += " (RenderGroup)";
    }
    if (container.filters) {
        output += "(*filters)";
    }
    console.log(output, `color:${data.color}; font-weight:bold;`);
    depth++;
    for(let i = 0; i < container.children.length; i++){
        const child = container.children[i];
        logScene(child, depth, {
            ...data
        });
    }
}
function logRenderGroupScene(renderGroup, depth = 0, data = {
    index: 0,
    color: "#000000"
}) {
    let spaces = "";
    for(let i = 0; i < depth; i++){
        spaces += "    ";
    }
    const output = `%c ${spaces}- ${data.index}: ${renderGroup.root.label} worldX:${renderGroup.worldTransform.tx}`;
    console.log(output, `color:${data.color}; font-weight:bold;`);
    depth++;
    for(let i = 0; i < renderGroup.renderGroupChildren.length; i++){
        const child = renderGroup.renderGroupChildren[i];
        logRenderGroupScene(child, depth, {
            ...data,
            index: i
        });
    }
}
;
 //# sourceMappingURL=logScene.mjs.map
}),
"[project]/node_modules/pixi.js/lib/color/Color.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Color",
    ()=>Color
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$pixi$2f$colord$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@pixi/colord/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$pixi$2f$colord$2f$plugins$2f$names$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@pixi/colord/plugins/names.mjs [app-client] (ecmascript)");
;
;
"use strict";
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$pixi$2f$colord$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extend"])([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$pixi$2f$colord$2f$plugins$2f$names$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
const _Color = class _Color {
    /**
   * @param {ColorSource} value - Optional value to use, if not provided, white is used.
   */ constructor(value = 16777215){
        this._value = null;
        this._components = new Float32Array(4);
        this._components.fill(1);
        this._int = 16777215;
        this.value = value;
    }
    /**
   * Get the red component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('red');
   * console.log(color.red); // 1
   *
   * const green = new Color('#00ff00');
   * console.log(green.red); // 0
   * ```
   */ get red() {
        return this._components[0];
    }
    /**
   * Get the green component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('lime');
   * console.log(color.green); // 1
   *
   * const red = new Color('#ff0000');
   * console.log(red.green); // 0
   * ```
   */ get green() {
        return this._components[1];
    }
    /**
   * Get the blue component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('blue');
   * console.log(color.blue); // 1
   *
   * const yellow = new Color('#ffff00');
   * console.log(yellow.blue); // 0
   * ```
   */ get blue() {
        return this._components[2];
    }
    /**
   * Get the alpha component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('red');
   * console.log(color.alpha); // 1 (fully opaque)
   *
   * const transparent = new Color('rgba(255, 0, 0, 0.5)');
   * console.log(transparent.alpha); // 0.5 (semi-transparent)
   * ```
   */ get alpha() {
        return this._components[3];
    }
    /**
   * Sets the color value and returns the instance for chaining.
   *
   * This is a chainable version of setting the `value` property.
   * @param value - The color to set. Accepts various formats:
   * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
   * - RGB/RGBA values (arrays, objects)
   * - CSS color names
   * - HSL/HSLA values
   * - HSV/HSVA values
   * @returns The Color instance for chaining
   * @example
   * ```ts
   * // Basic usage
   * const color = new Color();
   * color.setValue('#ff0000')
   *     .setAlpha(0.5)
   *     .premultiply(0.8);
   *
   * // Different formats
   * color.setValue(0xff0000);          // Hex number
   * color.setValue('#ff0000');         // Hex string
   * color.setValue([1, 0, 0]);         // RGB array
   * color.setValue([1, 0, 0, 0.5]);    // RGBA array
   * color.setValue({ r: 1, g: 0, b: 0 }); // RGB object
   *
   * // Copy from another color
   * const red = new Color('red');
   * color.setValue(red);
   * ```
   * @throws {Error} If the color value is invalid or null
   * @see {@link Color.value} For the underlying value property
   */ setValue(value) {
        this.value = value;
        return this;
    }
    /**
   * The current color source. This property allows getting and setting the color value
   * while preserving the original format where possible.
   * @remarks
   * When setting:
   * - Setting to a `Color` instance copies its source and components
   * - Setting to other valid sources normalizes and stores the value
   * - Setting to `null` throws an Error
   * - The color remains unchanged if normalization fails
   *
   * When getting:
   * - Returns `null` if color was modified by {@link Color.multiply} or {@link Color.premultiply}
   * - Otherwise returns the original color source
   * @example
   * ```ts
   * // Setting different color formats
   * const color = new Color();
   *
   * color.value = 0xff0000;         // Hex number
   * color.value = '#ff0000';        // Hex string
   * color.value = [1, 0, 0];        // RGB array
   * color.value = [1, 0, 0, 0.5];   // RGBA array
   * color.value = { r: 1, g: 0, b: 0 }; // RGB object
   *
   * // Copying from another color
   * const red = new Color('red');
   * color.value = red;  // Copies red's components
   *
   * // Getting the value
   * console.log(color.value);  // Returns original format
   *
   * // After modifications
   * color.multiply([0.5, 0.5, 0.5]);
   * console.log(color.value);  // Returns null
   * ```
   * @throws {Error} When attempting to set `null`
   */ set value(value) {
        if (value instanceof _Color) {
            this._value = this._cloneSource(value._value);
            this._int = value._int;
            this._components.set(value._components);
        } else if (value === null) {
            throw new Error("Cannot set Color#value to null");
        } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
            this._value = this._cloneSource(value);
            this._normalize(this._value);
        }
    }
    get value() {
        return this._value;
    }
    /**
   * Copy a color source internally.
   * @param value - Color source
   */ _cloneSource(value) {
        if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
            return value;
        } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
            return value.slice(0);
        } else if (typeof value === "object" && value !== null) {
            return {
                ...value
            };
        }
        return value;
    }
    /**
   * Equality check for color sources.
   * @param value1 - First color source
   * @param value2 - Second color source
   * @returns `true` if the color sources are equal, `false` otherwise.
   */ _isSourceEqual(value1, value2) {
        const type1 = typeof value1;
        const type2 = typeof value2;
        if (type1 !== type2) {
            return false;
        } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
            return value1 === value2;
        } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
            if (value1.length !== value2.length) {
                return false;
            }
            return value1.every((v, i)=>v === value2[i]);
        } else if (value1 !== null && value2 !== null) {
            const keys1 = Object.keys(value1);
            const keys2 = Object.keys(value2);
            if (keys1.length !== keys2.length) {
                return false;
            }
            return keys1.every((key)=>value1[key] === value2[key]);
        }
        return value1 === value2;
    }
    /**
   * Convert to a RGBA color object with normalized components (0-1).
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGBA objects
   * new Color('white').toRgba();     // returns { r: 1, g: 1, b: 1, a: 1 }
   * new Color('#ff0000').toRgba();   // returns { r: 1, g: 0, b: 0, a: 1 }
   *
   * // With transparency
   * new Color('rgba(255,0,0,0.5)').toRgba(); // returns { r: 1, g: 0, b: 0, a: 0.5 }
   * ```
   * @returns An RGBA object with normalized components
   */ toRgba() {
        const [r, g, b, a] = this._components;
        return {
            r,
            g,
            b,
            a
        };
    }
    /**
   * Convert to a RGB color object with normalized components (0-1).
   *
   * Alpha component is omitted in the output.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGB objects
   * new Color('white').toRgb();     // returns { r: 1, g: 1, b: 1 }
   * new Color('#ff0000').toRgb();   // returns { r: 1, g: 0, b: 0 }
   *
   * // Alpha is ignored
   * new Color('rgba(255,0,0,0.5)').toRgb(); // returns { r: 1, g: 0, b: 0 }
   * ```
   * @returns An RGB object with normalized components
   */ toRgb() {
        const [r, g, b] = this._components;
        return {
            r,
            g,
            b
        };
    }
    /**
   * Convert to a CSS-style rgba string representation.
   *
   * RGB components are scaled to 0-255 range, alpha remains 0-1.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGBA strings
   * new Color('white').toRgbaString();     // returns "rgba(255,255,255,1)"
   * new Color('#ff0000').toRgbaString();   // returns "rgba(255,0,0,1)"
   *
   * // With transparency
   * new Color([1, 0, 0, 0.5]).toRgbaString(); // returns "rgba(255,0,0,0.5)"
   * ```
   * @returns A CSS-compatible rgba string
   */ toRgbaString() {
        const [r, g, b] = this.toUint8RgbArray();
        return `rgba(${r},${g},${b},${this.alpha})`;
    }
    /**
   * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).
   * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGB components as integers between 0-255
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]
   * new Color('#ff0000').toUint8RgbArray(); // returns [255, 0, 0]
   *
   * // Using custom output array
   * const rgb = new Uint8Array(3);
   * new Color('blue').toUint8RgbArray(rgb); // rgb is now [0, 0, 255]
   *
   * // Using different array types
   * new Color('red').toUint8RgbArray(new Uint8ClampedArray(3)); // [255, 0, 0]
   * new Color('red').toUint8RgbArray([]); // [255, 0, 0]
   * ```
   * @remarks
   * - Output values are always clamped between 0-255
   * - Alpha component is not included in output
   * - Reuses internal cache array if no output array provided
   */ toUint8RgbArray(out) {
        const [r, g, b] = this._components;
        if (!this._arrayRgb) {
            this._arrayRgb = [];
        }
        out || (out = this._arrayRgb);
        out[0] = Math.round(r * 255);
        out[1] = Math.round(g * 255);
        out[2] = Math.round(b * 255);
        return out;
    }
    /**
   * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).
   * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGBA components as floats between 0-1
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toArray();  // returns [1, 1, 1, 1]
   * new Color('red').toArray();    // returns [1, 0, 0, 1]
   *
   * // With alpha
   * new Color('rgba(255,0,0,0.5)').toArray(); // returns [1, 0, 0, 0.5]
   *
   * // Using custom output array
   * const rgba = new Float32Array(4);
   * new Color('blue').toArray(rgba); // rgba is now [0, 0, 1, 1]
   * ```
   * @remarks
   * - Output values are normalized between 0-1
   * - Includes alpha component as the fourth value
   * - Reuses internal cache array if no output array provided
   */ toArray(out) {
        if (!this._arrayRgba) {
            this._arrayRgba = [];
        }
        out || (out = this._arrayRgba);
        const [r, g, b, a] = this._components;
        out[0] = r;
        out[1] = g;
        out[2] = b;
        out[3] = a;
        return out;
    }
    /**
   * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).
   * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGB components as floats between 0-1
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toRgbArray(); // returns [1, 1, 1]
   * new Color('red').toRgbArray();   // returns [1, 0, 0]
   *
   * // Using custom output array
   * const rgb = new Float32Array(3);
   * new Color('blue').toRgbArray(rgb); // rgb is now [0, 0, 1]
   * ```
   * @remarks
   * - Output values are normalized between 0-1
   * - Alpha component is omitted from output
   * - Reuses internal cache array if no output array provided
   */ toRgbArray(out) {
        if (!this._arrayRgb) {
            this._arrayRgb = [];
        }
        out || (out = this._arrayRgb);
        const [r, g, b] = this._components;
        out[0] = r;
        out[1] = g;
        out[2] = b;
        return out;
    }
    /**
   * Convert to a hexadecimal number.
   * @returns The color as a 24-bit RGB integer
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toNumber(); // returns 0xffffff
   * new Color('red').toNumber();   // returns 0xff0000
   *
   * // Store as hex
   * const color = new Color('blue');
   * const hex = color.toNumber(); // 0x0000ff
   * ```
   */ toNumber() {
        return this._int;
    }
    /**
   * Convert to a BGR number.
   *
   * Useful for platforms that expect colors in BGR format.
   * @returns The color as a 24-bit BGR integer
   * @example
   * ```ts
   * // Convert RGB to BGR
   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
   *
   * // Common use case: platform-specific color format
   * const color = new Color('orange');
   * const bgrColor = color.toBgrNumber(); // Color with swapped R/B channels
   * ```
   * @remarks
   * This swaps the red and blue channels compared to the normal RGB format:
   * - RGB 0xRRGGBB becomes BGR 0xBBGGRR
   */ toBgrNumber() {
        const [r, g, b] = this.toUint8RgbArray();
        return (b << 16) + (g << 8) + r;
    }
    /**
   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
   *
   * Useful for platforms that expect colors in little endian byte order.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert RGB color to little endian format
   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
   *
   * // Common use cases:
   * const color = new Color('orange');
   * const leColor = color.toLittleEndianNumber(); // Swaps byte order for LE systems
   *
   * // Multiple conversions
   * const colors = {
   *     normal: 0xffcc99,
   *     littleEndian: new Color(0xffcc99).toLittleEndianNumber(), // 0x99ccff
   *     backToNormal: new Color(0x99ccff).toLittleEndianNumber()  // 0xffcc99
   * };
   * ```
   * @remarks
   * - Swaps R and B channels in the color value
   * - RGB 0xRRGGBB becomes 0xBBGGRR
   * - Useful for systems that use little endian byte order
   * - Can be used to convert back and forth between formats
   * @returns The color as a number in little endian format (BBGGRR)
   * @see {@link Color.toBgrNumber} For BGR format without byte swapping
   */ toLittleEndianNumber() {
        const value = this._int;
        return (value >> 16) + (value & 65280) + ((value & 255) << 16);
    }
    /**
   * Multiply with another color.
   *
   * This action is destructive and modifies the original color.
   * @param {ColorSource} value - The color to multiply by. Accepts any valid color format:
   * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
   * - RGB/RGBA arrays ([1, 0, 0], [1, 0, 0, 1])
   * - Color objects ({ r: 1, g: 0, b: 0 })
   * - CSS color names ('red', 'blue')
   * @returns this - The Color instance for chaining
   * @example
   * ```ts
   * // Basic multiplication
   * const color = new Color('#ff0000');
   * color.multiply(0x808080); // 50% darker red
   *
   * // With transparency
   * color.multiply([1, 1, 1, 0.5]); // 50% transparent
   *
   * // Chain operations
   * color
   *     .multiply('#808080')
   *     .multiply({ r: 1, g: 1, b: 1, a: 0.5 });
   * ```
   * @remarks
   * - Multiplies each RGB component and alpha separately
   * - Values are clamped between 0-1
   * - Original color format is lost (value becomes null)
   * - Operation cannot be undone
   */ multiply(value) {
        const [r, g, b, a] = _Color._temp.setValue(value)._components;
        this._components[0] *= r;
        this._components[1] *= g;
        this._components[2] *= b;
        this._components[3] *= a;
        this._refreshInt();
        this._value = null;
        return this;
    }
    /**
   * Converts color to a premultiplied alpha format.
   *
   * This action is destructive and modifies the original color.
   * @param alpha - The alpha value to multiply by (0-1)
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
   * @returns {Color} The Color instance for chaining
   * @example
   * ```ts
   * // Basic premultiplication
   * const color = new Color('red');
   * color.premultiply(0.5); // 50% transparent red with premultiplied RGB
   *
   * // Alpha only (RGB unchanged)
   * color.premultiply(0.5, false); // 50% transparent, original RGB
   *
   * // Chain with other operations
   * color
   *     .multiply(0x808080)
   *     .premultiply(0.5)
   *     .toNumber();
   * ```
   * @remarks
   * - RGB channels are multiplied by alpha when applyToRGB is true
   * - Alpha is always set to the provided value
   * - Values are clamped between 0-1
   * - Original color format is lost (value becomes null)
   * - Operation cannot be undone
   */ premultiply(alpha, applyToRGB = true) {
        if (applyToRGB) {
            this._components[0] *= alpha;
            this._components[1] *= alpha;
            this._components[2] *= alpha;
        }
        this._components[3] = alpha;
        this._refreshInt();
        this._value = null;
        return this;
    }
    /**
   * Returns the color as a 32-bit premultiplied alpha integer.
   *
   * Format: 0xAARRGGBB
   * @param {number} alpha - The alpha value to multiply by (0-1)
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
   * @returns {number} The premultiplied color as a 32-bit integer
   * @example
   * ```ts
   * // Convert to premultiplied format
   * const color = new Color('red');
   *
   * // Full opacity (0xFFRRGGBB)
   * color.toPremultiplied(1.0); // 0xFFFF0000
   *
   * // 50% transparency with premultiplied RGB
   * color.toPremultiplied(0.5); // 0x7F7F0000
   *
   * // 50% transparency without RGB premultiplication
   * color.toPremultiplied(0.5, false); // 0x7FFF0000
   * ```
   * @remarks
   * - Returns full opacity (0xFF000000) when alpha is 1.0
   * - Returns 0 when alpha is 0.0 and applyToRGB is true
   * - RGB values are rounded during premultiplication
   */ toPremultiplied(alpha, applyToRGB = true) {
        if (alpha === 1) {
            return (255 << 24) + this._int;
        }
        if (alpha === 0) {
            return applyToRGB ? 0 : this._int;
        }
        let r = this._int >> 16 & 255;
        let g = this._int >> 8 & 255;
        let b = this._int & 255;
        if (applyToRGB) {
            r = r * alpha + 0.5 | 0;
            g = g * alpha + 0.5 | 0;
            b = b * alpha + 0.5 | 0;
        }
        return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;
    }
    /**
   * Convert to a hexadecimal string (6 characters).
   * @returns A CSS-compatible hex color string (e.g., "#ff0000")
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Basic colors
   * new Color('red').toHex();    // returns "#ff0000"
   * new Color('white').toHex();  // returns "#ffffff"
   * new Color('black').toHex();  // returns "#000000"
   *
   * // From different formats
   * new Color(0xff0000).toHex(); // returns "#ff0000"
   * new Color([1, 0, 0]).toHex(); // returns "#ff0000"
   * new Color({ r: 1, g: 0, b: 0 }).toHex(); // returns "#ff0000"
   * ```
   * @remarks
   * - Always returns a 6-character hex string
   * - Includes leading "#" character
   * - Alpha channel is ignored
   * - Values are rounded to nearest hex value
   */ toHex() {
        const hexString = this._int.toString(16);
        return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
    }
    /**
   * Convert to a hexadecimal string with alpha (8 characters).
   * @returns A CSS-compatible hex color string with alpha (e.g., "#ff0000ff")
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Fully opaque colors
   * new Color('red').toHexa();   // returns "#ff0000ff"
   * new Color('white').toHexa(); // returns "#ffffffff"
   *
   * // With transparency
   * new Color('rgba(255, 0, 0, 0.5)').toHexa(); // returns "#ff00007f"
   * new Color([1, 0, 0, 0]).toHexa(); // returns "#ff000000"
   * ```
   * @remarks
   * - Returns an 8-character hex string
   * - Includes leading "#" character
   * - Alpha is encoded in last two characters
   * - Values are rounded to nearest hex value
   */ toHexa() {
        const alphaValue = Math.round(this._components[3] * 255);
        const alphaString = alphaValue.toString(16);
        return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
    }
    /**
   * Set alpha (transparency) value while preserving color components.
   *
   * Provides a chainable interface for setting alpha.
   * @param alpha - Alpha value between 0 (fully transparent) and 1 (fully opaque)
   * @returns The Color instance for chaining
   * @example
   * ```ts
   * // Basic alpha setting
   * const color = new Color('red');
   * color.setAlpha(0.5);  // 50% transparent red
   *
   * // Chain with other operations
   * color
   *     .setValue('#ff0000')
   *     .setAlpha(0.8)    // 80% opaque
   *     .premultiply(0.5); // Further modify alpha
   *
   * // Reset to fully opaque
   * color.setAlpha(1);
   * ```
   * @remarks
   * - Alpha value is clamped between 0-1
   * - Can be chained with other color operations
   */ setAlpha(alpha) {
        this._components[3] = this._clamp(alpha);
        return this;
    }
    /**
   * Normalize the input value into rgba
   * @param value - Input value
   */ _normalize(value) {
        let r;
        let g;
        let b;
        let a;
        if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
            const int = value;
            r = (int >> 16 & 255) / 255;
            g = (int >> 8 & 255) / 255;
            b = (int & 255) / 255;
            a = 1;
        } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value);
            [r, g, b, a = 1] = value;
        } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value, 0, 255);
            [r, g, b, a = 255] = value;
            r /= 255;
            g /= 255;
            b /= 255;
            a /= 255;
        } else if (typeof value === "string" || typeof value === "object") {
            if (typeof value === "string") {
                const match = _Color.HEX_PATTERN.exec(value);
                if (match) {
                    value = `#${match[2]}`;
                }
            }
            const color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$pixi$2f$colord$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colord"])(value);
            if (color.isValid()) {
                ({ r, g, b, a } = color.rgba);
                r /= 255;
                g /= 255;
                b /= 255;
            }
        }
        if (r !== void 0) {
            this._components[0] = r;
            this._components[1] = g;
            this._components[2] = b;
            this._components[3] = a;
            this._refreshInt();
        } else {
            throw new Error(`Unable to convert color ${value}`);
        }
    }
    /** Refresh the internal color rgb number */ _refreshInt() {
        this._clamp(this._components);
        const [r, g, b] = this._components;
        this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);
    }
    /**
   * Clamps values to a range. Will override original values
   * @param value - Value(s) to clamp
   * @param min - Minimum value
   * @param max - Maximum value
   */ _clamp(value, min = 0, max = 1) {
        if (typeof value === "number") {
            return Math.min(Math.max(value, min), max);
        }
        value.forEach((v, i)=>{
            value[i] = Math.min(Math.max(v, min), max);
        });
        return value;
    }
    /**
   * Check if a value can be interpreted as a valid color format.
   * Supports all color formats that can be used with the Color class.
   * @param value - Value to check
   * @returns True if the value can be used as a color
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // CSS colors and hex values
   * Color.isColorLike('red');          // true
   * Color.isColorLike('#ff0000');      // true
   * Color.isColorLike(0xff0000);       // true
   *
   * // Arrays (RGB/RGBA)
   * Color.isColorLike([1, 0, 0]);      // true
   * Color.isColorLike([1, 0, 0, 0.5]); // true
   *
   * // TypedArrays
   * Color.isColorLike(new Float32Array([1, 0, 0]));          // true
   * Color.isColorLike(new Uint8Array([255, 0, 0]));          // true
   * Color.isColorLike(new Uint8ClampedArray([255, 0, 0]));   // true
   *
   * // Object formats
   * Color.isColorLike({ r: 1, g: 0, b: 0 });            // true (RGB)
   * Color.isColorLike({ r: 1, g: 0, b: 0, a: 0.5 });    // true (RGBA)
   * Color.isColorLike({ h: 0, s: 100, l: 50 });         // true (HSL)
   * Color.isColorLike({ h: 0, s: 100, l: 50, a: 0.5 }); // true (HSLA)
   * Color.isColorLike({ h: 0, s: 100, v: 100 });        // true (HSV)
   * Color.isColorLike({ h: 0, s: 100, v: 100, a: 0.5 });// true (HSVA)
   *
   * // Color instances
   * Color.isColorLike(new Color('red')); // true
   *
   * // Invalid values
   * Color.isColorLike(null);           // false
   * Color.isColorLike(undefined);      // false
   * Color.isColorLike({});             // false
   * Color.isColorLike([]);             // false
   * Color.isColorLike('not-a-color');  // false
   * ```
   * @remarks
   * Checks for the following formats:
   * - Numbers (0x000000 to 0xffffff)
   * - CSS color strings
   * - RGB/RGBA arrays and objects
   * - HSL/HSLA objects
   * - HSV/HSVA objects
   * - TypedArrays (Float32Array, Uint8Array, Uint8ClampedArray)
   * - Color instances
   * @see {@link ColorSource} For supported color format types
   * @see {@link Color.setValue} For setting color values
   * @category utility
   */ static isColorLike(value) {
        return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
    }
};
/**
 * Static shared Color instance used for utility operations. This is a singleton color object
 * that can be reused to avoid creating unnecessary Color instances.
 * > [!IMPORTANT] You should be careful when using this shared instance, as it is mutable and can be
 * > changed by any code that uses it.
 * >
 * > It is best used for one-off color operations or temporary transformations.
 * > For persistent colors, create your own Color instance instead.
 * @example
 * ```ts
 * import { Color } from 'pixi.js';
 *
 * // Use shared instance for one-off color operations
 * Color.shared.setValue(0xff0000);
 * const redHex = Color.shared.toHex();     // "#ff0000"
 * const redRgb = Color.shared.toRgbArray(); // [1, 0, 0]
 *
 * // Temporary color transformations
 * const colorNumber = Color.shared
 *     .setValue('#ff0000')     // Set to red
 *     .setAlpha(0.5)          // Make semi-transparent
 *     .premultiply(0.8)       // Apply premultiplication
 *     .toNumber();            // Convert to number
 *
 * // Chain multiple operations
 * const result = Color.shared
 *     .setValue(someColor)
 *     .multiply(tintColor)
 *     .toPremultiplied(alpha);
 * ```
 * @remarks
 * - This is a shared instance - be careful about multiple code paths using it simultaneously
 * - Use for temporary color operations to avoid allocating new Color instances
 * - The value is preserved between operations, so reset if needed
 * - For persistent colors, create your own Color instance instead
 */ _Color.shared = new _Color();
/**
 * Temporary Color object for static uses internally.
 * As to not conflict with Color.shared.
 * @ignore
 */ _Color._temp = new _Color();
/** Pattern for hex strings */ // eslint-disable-next-line @typescript-eslint/naming-convention
_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let Color = _Color;
;
 //# sourceMappingURL=Color.mjs.map
}),
"[project]/node_modules/pixi.js/lib/culling/cullingMixin.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cullingMixin",
    ()=>cullingMixin
]);
"use strict";
const cullingMixin = {
    cullArea: null,
    cullable: false,
    cullableChildren: true
};
;
 //# sourceMappingURL=cullingMixin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/culling/Culler.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Culler",
    ()=>Culler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$getGlobalBounds$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs [app-client] (ecmascript)");
;
;
"use strict";
const tempBounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$Bounds$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Bounds"]();
const _Culler = class _Culler {
    /**
   * Culls the children of a specific container based on the given view rectangle.
   * This determines which objects should be rendered and which can be skipped.
   * @param container - The container to cull. Must be a Container instance.
   * @param view - The view rectangle that defines the visible area
   * @param skipUpdateTransform - Whether to skip updating transforms for better performance
   * @example
   * ```ts
   * // Basic culling with view bounds
   * const culler = new Culler();
   * culler.cull(stage, {
   *     x: 0,
   *     y: 0,
   *     width: 800,
   *     height: 600
   * });
   *
   * // Culling to renderer screen
   * culler.cull(stage, renderer.screen, false);
   * ```
   * @remarks
   * - Recursively processes all cullable children
   * - Uses cullArea if defined, otherwise calculates bounds
   * - Performance depends on scene complexity
   * @see {@link CullingMixinConstructor.cullable} For enabling culling on objects
   * @see {@link CullingMixinConstructor.cullArea} For custom culling boundaries
   */ cull(container, view, skipUpdateTransform = true) {
        this._cullRecursive(container, view, skipUpdateTransform);
    }
    _cullRecursive(container, view, skipUpdateTransform = true) {
        if (container.cullable && container.measurable && container.includeInBuild) {
            const bounds = container.cullArea ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$bounds$2f$getGlobalBounds$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGlobalBounds"])(container, skipUpdateTransform, tempBounds);
            container.culled = bounds.x >= view.x + view.width || bounds.y >= view.y + view.height || bounds.x + bounds.width <= view.x || bounds.y + bounds.height <= view.y;
        } else {
            container.culled = false;
        }
        if (!container.cullableChildren || container.culled || !container.renderable || !container.measurable || !container.includeInBuild) return;
        for(let i = 0; i < container.children.length; i++){
            this._cullRecursive(container.children[i], view, skipUpdateTransform);
        }
    }
};
/**
 * A shared instance of the Culler class. Provides a global culler instance for convenience.
 * @example
 * ```ts
 * // Use the shared instance instead of creating a new one
 * Culler.shared.cull(stage, {
 *     x: 0,
 *     y: 0,
 *     width: 800,
 *     height: 600
 * });
 * ```
 * @see {@link CullerPlugin} For automatic culling using this instance
 */ _Culler.shared = new _Culler();
let Culler = _Culler;
;
 //# sourceMappingURL=Culler.mjs.map
}),
"[project]/node_modules/pixi.js/lib/culling/CullerPlugin.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CullerPlugin",
    ()=>CullerPlugin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$culling$2f$Culler$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/culling/Culler.mjs [app-client] (ecmascript)");
;
;
"use strict";
class CullerPlugin {
    /**
   * Initialize the plugin with scope of application instance
   * @private
   * @param {object} [options] - See application options
   */ static init(options) {
        this._renderRef = this.render.bind(this);
        this.render = ()=>{
            const updateTransform = options?.culler?.updateTransform !== true;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$culling$2f$Culler$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Culler"].shared.cull(this.stage, this.renderer.screen, updateTransform);
            this.renderer.render({
                container: this.stage
            });
        };
    }
    /** @internal */ static destroy() {
        this.render = this._renderRef;
    }
}
/** @ignore */ CullerPlugin.extension = {
    priority: 10,
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].Application,
    name: "culler"
};
;
 //# sourceMappingURL=CullerPlugin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/environment/adapter.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DOMAdapter",
    ()=>DOMAdapter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2d$browser$2f$BrowserAdapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs [app-client] (ecmascript)");
;
"use strict";
let currentAdapter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2d$browser$2f$BrowserAdapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BrowserAdapter"];
const DOMAdapter = {
    /**
   * Returns the current adapter.
   * @returns {environment.Adapter} The current adapter.
   */ get () {
        return currentAdapter;
    },
    /**
   * Sets the current adapter.
   * @param adapter - The new adapter.
   */ set (adapter) {
        currentAdapter = adapter;
    }
};
;
 //# sourceMappingURL=adapter.mjs.map
}),
"[project]/node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "autoDetectEnvironment",
    ()=>autoDetectEnvironment,
    "loadEnvironmentExtensions",
    ()=>loadEnvironmentExtensions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
;
"use strict";
const environments = [];
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extensions"].handleByNamedList(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].Environment, environments);
async function loadEnvironmentExtensions(skip) {
    if (skip) return;
    for(let i = 0; i < environments.length; i++){
        const env = environments[i];
        if (env.value.test()) {
            await env.value.load();
            return;
        }
    }
}
async function autoDetectEnvironment(add) {
    return loadEnvironmentExtensions(!add);
}
;
 //# sourceMappingURL=autoDetectEnvironment.mjs.map
}),
"[project]/node_modules/pixi.js/lib/ticker/const.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "UPDATE_PRIORITY",
    ()=>UPDATE_PRIORITY
]);
"use strict";
var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2)=>{
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
    return UPDATE_PRIORITY2;
})(UPDATE_PRIORITY || {});
;
 //# sourceMappingURL=const.mjs.map
}),
"[project]/node_modules/pixi.js/lib/ticker/TickerListener.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TickerListener",
    ()=>TickerListener
]);
"use strict";
class TickerListener {
    /**
   * Constructor
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting
   * @param once - If the handler should fire once
   */ constructor(fn, context = null, priority = 0, once = false){
        /** The next item in chain. */ this.next = null;
        /** The previous item in chain. */ this.previous = null;
        /** `true` if this listener has been destroyed already. */ this._destroyed = false;
        this._fn = fn;
        this._context = context;
        this.priority = priority;
        this._once = once;
    }
    /**
   * Simple compare function to figure out if a function and context match.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @returns `true` if the listener match the arguments
   */ match(fn, context = null) {
        return this._fn === fn && this._context === context;
    }
    /**
   * Emit by calling the current function.
   * @param ticker - The ticker emitting.
   * @returns Next ticker
   */ emit(ticker) {
        if (this._fn) {
            if (this._context) {
                this._fn.call(this._context, ticker);
            } else {
                this._fn(ticker);
            }
        }
        const redirect = this.next;
        if (this._once) {
            this.destroy(true);
        }
        if (this._destroyed) {
            this.next = null;
        }
        return redirect;
    }
    /**
   * Connect to the list.
   * @param previous - Input node, previous listener
   */ connect(previous) {
        this.previous = previous;
        if (previous.next) {
            previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
    }
    /**
   * Destroy and don't use after this.
   * @param hard - `true` to remove the `next` reference, this
   *        is considered a hard destroy. Soft destroy maintains the next reference.
   * @returns The listener to redirect while emitting or removing.
   */ destroy(hard = false) {
        this._destroyed = true;
        this._fn = null;
        this._context = null;
        if (this.previous) {
            this.previous.next = this.next;
        }
        if (this.next) {
            this.next.previous = this.previous;
        }
        const redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
    }
}
;
 //# sourceMappingURL=TickerListener.mjs.map
}),
"[project]/node_modules/pixi.js/lib/ticker/Ticker.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Ticker",
    ()=>Ticker
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/ticker/const.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$TickerListener$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/ticker/TickerListener.mjs [app-client] (ecmascript)");
;
;
"use strict";
const _Ticker = class _Ticker {
    constructor(){
        /**
     * Whether or not this ticker should invoke the method {@link Ticker#start|start}
     * automatically when a listener is added.
     * @example
     * ```ts
     * // Default behavior (manual start)
     * const ticker = new Ticker();
     * ticker.autoStart = false;
     * ticker.add(() => {
     *     // Won't run until ticker.start() is called
     * });
     *
     * // Auto-start behavior
     * const autoTicker = new Ticker();
     * autoTicker.autoStart = true;
     * autoTicker.add(() => {
     *     // Runs immediately when added
     * });
     * ```
     * @default false
     * @see {@link Ticker#start} For manually starting the ticker
     * @see {@link Ticker#stop} For manually stopping the ticker
     */ this.autoStart = false;
        /**
     * Scalar representing the delta time factor.
     * This is a dimensionless value representing the fraction of a frame at the target framerate.
     * At 60 FPS, this value is typically around 1.0.
     *
     * This is NOT in milliseconds - it's a scalar multiplier for frame-independent animations.
     * For actual milliseconds, use {@link Ticker#deltaMS}.
     * @example
     * ```ts
     * // Frame-independent animation using deltaTime scalar
     * ticker.add((ticker) => {
     *     // Rotate sprite by 0.1 radians per frame, scaled by deltaTime
     *     sprite.rotation += 0.1 * ticker.deltaTime;
     * });
     * ```
     */ this.deltaTime = 1;
        /**
     * The last time update was invoked, in milliseconds since epoch.
     * Similar to performance.now() timestamp format.
     *
     * Used internally for calculating time deltas between frames.
     * @example
     * ```ts
     * ticker.add((ticker) => {
     *     const currentTime = performance.now();
     *     const timeSinceLastFrame = currentTime - ticker.lastTime;
     *     console.log(`Time since last frame: ${timeSinceLastFrame}ms`);
     * });
     * ```
     */ this.lastTime = -1;
        /**
     * Factor of current {@link Ticker#deltaTime|deltaTime}.
     * Used to scale time for slow motion or fast-forward effects.
     * @example
     * ```ts
     * // Basic speed adjustment
     * ticker.speed = 0.5; // Half speed (slow motion)
     * ticker.speed = 2.0; // Double speed (fast forward)
     *
     * // Temporary speed changes
     * function slowMotion() {
     *     const normalSpeed = ticker.speed;
     *     ticker.speed = 0.2;
     *     setTimeout(() => {
     *         ticker.speed = normalSpeed;
     *     }, 1000);
     * }
     * ```
     */ this.speed = 1;
        /**
     * Whether or not this ticker has been started.
     *
     * `true` if {@link Ticker#start|start} has been called.
     * `false` if {@link Ticker#stop|Stop} has been called.
     *
     * While `false`, this value may change to `true` in the
     * event of {@link Ticker#autoStart|autoStart} being `true`
     * and a listener is added.
     * @example
     * ```ts
     * // Check ticker state
     * const ticker = new Ticker();
     * console.log(ticker.started); // false
     *
     * // Start and verify
     * ticker.start();
     * console.log(ticker.started); // true
     * ```
     */ this.started = false;
        /** Internal current frame request ID */ this._requestId = null;
        /**
     * Internal value managed by minFPS property setter and getter.
     * This is the maximum allowed milliseconds between updates.
     */ this._maxElapsedMS = 100;
        /**
     * Internal value managed by minFPS property setter and getter.
     * This is the minimum allowed milliseconds between updates.
     */ this._minElapsedMS = 0;
        /** If enabled, deleting is disabled.*/ this._protected = false;
        /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */ this._lastFrame = -1;
        this._head = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$TickerListener$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TickerListener"](null, null, Infinity);
        this.deltaMS = 1 / _Ticker.targetFPMS;
        this.elapsedMS = 1 / _Ticker.targetFPMS;
        this._tick = (time)=>{
            this._requestId = null;
            if (this.started) {
                this.update(time);
                if (this.started && this._requestId === null && this._head.next) {
                    this._requestId = requestAnimationFrame(this._tick);
                }
            }
        };
    }
    /**
   * Conditionally requests a new animation frame.
   * If a frame has not already been requested, and if the internal
   * emitter has listeners, a new frame is requested.
   */ _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
            this.lastTime = performance.now();
            this._lastFrame = this.lastTime;
            this._requestId = requestAnimationFrame(this._tick);
        }
    }
    /** Conditionally cancels a pending animation frame. */ _cancelIfNeeded() {
        if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
        }
    }
    /**
   * Conditionally requests a new animation frame.
   * If the ticker has been started it checks if a frame has not already
   * been requested, and if the internal emitter has listeners. If these
   * conditions are met, a new frame is requested. If the ticker has not
   * been started, but autoStart is `true`, then the ticker starts now,
   * and continues with the previous conditions to request a new frame.
   */ _startIfPossible() {
        if (this.started) {
            this._requestIfNeeded();
        } else if (this.autoStart) {
            this.start();
        }
    }
    /**
   * Register a handler for tick events.
   * @param fn - The listener function to add. Receives the Ticker instance as parameter
   * @param context - The context for the listener
   * @param priority - The priority of the listener
   * @example
   * ```ts
   * // Access time properties through the ticker parameter
   * ticker.add((ticker) => {
   *     // Use deltaTime (dimensionless scalar) for frame-independent animations
   *     sprite.rotation += 0.1 * ticker.deltaTime;
   *
   *     // Use deltaMS (milliseconds) for time-based calculations
   *     const progress = ticker.deltaMS / animationDuration;
   *
   *     // Use elapsedMS for raw timing measurements
   *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);
   * });
   * ```
   */ add(fn, context, priority = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UPDATE_PRIORITY"].NORMAL) {
        return this._addListener(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$TickerListener$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TickerListener"](fn, context, priority));
    }
    /**
   * Add a handler for the tick event which is only executed once on the next frame.
   * @example
   * ```ts
   * // Basic one-time update
   * ticker.addOnce(() => {
   *     console.log('Runs next frame only');
   * });
   *
   * // With specific context
   * const game = {
   *     init(ticker) {
   *         this.loadResources();
   *         console.log('Game initialized');
   *     }
   * };
   * ticker.addOnce(game.init, game);
   *
   * // With priority
   * ticker.addOnce(
   *     () => {
   *         // High priority one-time setup
   *         physics.init();
   *     },
   *     undefined,
   *     UPDATE_PRIORITY.HIGH
   * );
   * ```
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)
   * @returns This instance of a ticker
   * @see {@link Ticker#add} For continuous updates
   * @see {@link Ticker#remove} For removing handlers
   */ addOnce(fn, context, priority = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UPDATE_PRIORITY"].NORMAL) {
        return this._addListener(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$TickerListener$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TickerListener"](fn, context, priority, true));
    }
    /**
   * Internally adds the event handler so that it can be sorted by priority.
   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
   * before the rendering.
   * @private
   * @param listener - Current listener being added.
   * @returns This instance of a ticker
   */ _addListener(listener) {
        let current = this._head.next;
        let previous = this._head;
        if (!current) {
            listener.connect(previous);
        } else {
            while(current){
                if (listener.priority > current.priority) {
                    listener.connect(previous);
                    break;
                }
                previous = current;
                current = current.next;
            }
            if (!listener.previous) {
                listener.connect(previous);
            }
        }
        this._startIfPossible();
        return this;
    }
    /**
   * Removes any handlers matching the function and context parameters.
   * If no handlers are left after removing, then it cancels the animation frame.
   * @example
   * ```ts
   * // Basic removal
   * const onTick = () => {
   *     sprite.rotation += 0.1;
   * };
   * ticker.add(onTick);
   * ticker.remove(onTick);
   *
   * // Remove with context
   * const game = {
   *     update(ticker) {
   *         this.physics.update(ticker.deltaTime);
   *     }
   * };
   * ticker.add(game.update, game);
   * ticker.remove(game.update, game);
   *
   * // Remove all matching handlers
   * // (if same function was added multiple times)
   * ticker.add(onTick);
   * ticker.add(onTick);
   * ticker.remove(onTick); // Removes all instances
   * ```
   * @param fn - The listener function to be removed
   * @param context - The listener context to be removed
   * @returns This instance of a ticker
   * @see {@link Ticker#add} For adding handlers
   * @see {@link Ticker#addOnce} For one-time handlers
   */ remove(fn, context) {
        let listener = this._head.next;
        while(listener){
            if (listener.match(fn, context)) {
                listener = listener.destroy();
            } else {
                listener = listener.next;
            }
        }
        if (!this._head.next) {
            this._cancelIfNeeded();
        }
        return this;
    }
    /**
   * The number of listeners on this ticker, calculated by walking through linked list.
   * @example
   * ```ts
   * // Check number of active listeners
   * const ticker = new Ticker();
   * console.log(ticker.count); // 0
   *
   * // Add some listeners
   * ticker.add(() => {});
   * ticker.add(() => {});
   * console.log(ticker.count); // 2
   *
   * // Check after cleanup
   * ticker.destroy();
   * console.log(ticker.count); // 0
   * ```
   * @readonly
   * @see {@link Ticker#add} For adding listeners
   * @see {@link Ticker#remove} For removing listeners
   */ get count() {
        if (!this._head) {
            return 0;
        }
        let count = 0;
        let current = this._head;
        while(current = current.next){
            count++;
        }
        return count;
    }
    /**
   * Starts the ticker. If the ticker has listeners a new animation frame is requested at this point.
   * @example
   * ```ts
   * // Basic manual start
   * const ticker = new Ticker();
   * ticker.add(() => {
   *     // Animation code here
   * });
   * ticker.start();
   * ```
   * @see {@link Ticker#stop} For stopping the ticker
   * @see {@link Ticker#autoStart} For automatic starting
   * @see {@link Ticker#started} For checking ticker state
   */ start() {
        if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
        }
    }
    /**
   * Stops the ticker. If the ticker has requested an animation frame it is canceled at this point.
   * @example
   * ```ts
   * // Basic stop
   * const ticker = new Ticker();
   * ticker.stop();
   * ```
   * @see {@link Ticker#start} For starting the ticker
   * @see {@link Ticker#started} For checking ticker state
   * @see {@link Ticker#destroy} For cleaning up the ticker
   */ stop() {
        if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
        }
    }
    /**
   * Destroy the ticker and don't use after this. Calling this method removes all references to internal events.
   * @example
   * ```ts
   * // Clean up with active listeners
   * const ticker = new Ticker();
   * ticker.add(() => {});
   * ticker.destroy(); // Removes all listeners
   * ```
   * @see {@link Ticker#stop} For stopping without destroying
   * @see {@link Ticker#remove} For removing specific listeners
   */ destroy() {
        if (!this._protected) {
            this.stop();
            let listener = this._head.next;
            while(listener){
                listener = listener.destroy(true);
            }
            this._head.destroy();
            this._head = null;
        }
    }
    /**
   * Triggers an update.
   *
   * An update entails setting the
   * current {@link Ticker#elapsedMS|elapsedMS},
   * the current {@link Ticker#deltaTime|deltaTime},
   * invoking all listeners with current deltaTime,
   * and then finally setting {@link Ticker#lastTime|lastTime}
   * with the value of currentTime that was provided.
   *
   * This method will be called automatically by animation
   * frame callbacks if the ticker instance has been started
   * and listeners are added.
   * @example
   * ```ts
   * // Basic manual update
   * const ticker = new Ticker();
   * ticker.update(performance.now());
   * ```
   * @param currentTime - The current time of execution (defaults to performance.now())
   * @see {@link Ticker#deltaTime} For frame delta value
   * @see {@link Ticker#elapsedMS} For raw elapsed time
   */ update(currentTime = performance.now()) {
        let elapsedMS;
        if (currentTime > this.lastTime) {
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;
            if (elapsedMS > this._maxElapsedMS) {
                elapsedMS = this._maxElapsedMS;
            }
            elapsedMS *= this.speed;
            if (this._minElapsedMS) {
                const delta = currentTime - this._lastFrame | 0;
                if (delta < this._minElapsedMS) {
                    return;
                }
                this._lastFrame = currentTime - delta % this._minElapsedMS;
            }
            this.deltaMS = elapsedMS;
            this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
            const head = this._head;
            let listener = head.next;
            while(listener){
                listener = listener.emit(this);
            }
            if (!head.next) {
                this._cancelIfNeeded();
            }
        } else {
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
    }
    /**
   * The frames per second at which this ticker is running.
   * The default is approximately 60 in most modern browsers.
   * > [!NOTE] This does not factor in the value of
   * > {@link Ticker#speed|speed}, which is specific
   * > to scaling {@link Ticker#deltaTime|deltaTime}.
   * @example
   * ```ts
   * // Basic FPS monitoring
   * ticker.add(() => {
   *     console.log(`Current FPS: ${Math.round(ticker.FPS)}`);
   * });
   * ```
   * @readonly
   */ get FPS() {
        return 1e3 / this.elapsedMS;
    }
    /**
   * Manages the maximum amount of milliseconds allowed to
   * elapse between invoking {@link Ticker#update|update}.
   *
   * This value is used to cap {@link Ticker#deltaTime|deltaTime},
   * but does not effect the measured value of {@link Ticker#FPS|FPS}.
   *
   * When setting this property it is clamped to a value between
   * `0` and `Ticker.targetFPMS * 1000`.
   * @example
   * ```ts
   * // Set minimum acceptable frame rate
   * const ticker = new Ticker();
   * ticker.minFPS = 30; // Never go below 30 FPS
   *
   * // Use with maxFPS for frame rate clamping
   * ticker.minFPS = 30;
   * ticker.maxFPS = 60;
   *
   * // Monitor delta capping
   * ticker.add(() => {
   *     // Delta time will be capped based on minFPS
   *     console.log(`Delta time: ${ticker.deltaTime}`);
   * });
   * ```
   * @default 10
   */ get minFPS() {
        return 1e3 / this._maxElapsedMS;
    }
    set minFPS(fps) {
        const minFPS = Math.min(this.maxFPS, fps);
        const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
        this._maxElapsedMS = 1 / minFPMS;
    }
    /**
   * Manages the minimum amount of milliseconds required to
   * elapse between invoking {@link Ticker#update|update}.
   *
   * This will effect the measured value of {@link Ticker#FPS|FPS}.
   *
   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
   * Otherwise it will be at least `minFPS`
   * @example
   * ```ts
   * // Set minimum acceptable frame rate
   * const ticker = new Ticker();
   * ticker.maxFPS = 60; // Never go above 60 FPS
   *
   * // Use with maxFPS for frame rate clamping
   * ticker.minFPS = 30;
   * ticker.maxFPS = 60;
   *
   * // Monitor delta capping
   * ticker.add(() => {
   *     // Delta time will be capped based on maxFPS
   *     console.log(`Delta time: ${ticker.deltaTime}`);
   * });
   * ```
   * @default 0
   */ get maxFPS() {
        if (this._minElapsedMS) {
            return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
    }
    set maxFPS(fps) {
        if (fps === 0) {
            this._minElapsedMS = 0;
        } else {
            const maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
    }
    /**
   * The shared ticker instance used by {@link AnimatedSprite} and by
   * {@link VideoSource} to update animation frames / video textures.
   *
   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
   *
   * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
   * @example
   * import { Ticker } from 'pixi.js';
   *
   * const ticker = Ticker.shared;
   * // Set this to prevent starting this ticker when listeners are added.
   * // By default this is true only for the Ticker.shared instance.
   * ticker.autoStart = false;
   *
   * // FYI, call this to ensure the ticker is stopped. It should be stopped
   * // if you have not attempted to render anything yet.
   * ticker.stop();
   *
   * // Call this when you are ready for a running shared ticker.
   * ticker.start();
   * @example
   * import { autoDetectRenderer, Container } from 'pixi.js';
   *
   * // You may use the shared ticker to render...
   * const renderer = autoDetectRenderer();
   * const stage = new Container();
   * document.body.appendChild(renderer.view);
   * ticker.add((time) => renderer.render(stage));
   *
   * // Or you can just update it manually.
   * ticker.autoStart = false;
   * ticker.stop();
   * const animate = (time) => {
   *     ticker.update(time);
   *     renderer.render(stage);
   *     requestAnimationFrame(animate);
   * };
   * animate(performance.now());
   * @type {Ticker}
   * @readonly
   */ static get shared() {
        if (!_Ticker._shared) {
            const shared = _Ticker._shared = new _Ticker();
            shared.autoStart = true;
            shared._protected = true;
        }
        return _Ticker._shared;
    }
    /**
   * The system ticker instance used by {@link PrepareBase} for core timing
   * functionality that shouldn't usually need to be paused, unlike the `shared`
   * ticker which drives visual animations and rendering which may want to be paused.
   *
   * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
   * @type {Ticker}
   * @readonly
   * @advanced
   */ static get system() {
        if (!_Ticker._system) {
            const system = _Ticker._system = new _Ticker();
            system.autoStart = true;
            system._protected = true;
        }
        return _Ticker._system;
    }
};
/**
 * Target frame rate in frames per millisecond.
 * Used for converting deltaTime to a scalar time delta.
 * @example
 * ```ts
 * // Default is 0.06 (60 FPS)
 * console.log(Ticker.targetFPMS); // 0.06
 *
 * // Calculate target frame duration
 * const frameDuration = 1 / Ticker.targetFPMS; //  16.67ms
 *
 * // Use in custom timing calculations
 * const deltaTime = elapsedMS * Ticker.targetFPMS;
 * ```
 * @remarks
 * - Default is 0.06 (equivalent to 60 FPS)
 * - Used in deltaTime calculations
 * - Affects all ticker instances
 * @default 0.06
 * @see {@link Ticker#deltaTime} For time scaling
 * @see {@link Ticker#FPS} For actual frame rate
 */ _Ticker.targetFPMS = 0.06;
let Ticker = _Ticker;
;
 //# sourceMappingURL=Ticker.mjs.map
}),
"[project]/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Spritesheet",
    ()=>Spritesheet
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$TextureSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-client] (ecmascript)");
;
;
;
"use strict";
const _Spritesheet = class _Spritesheet {
    constructor(optionsOrTexture, arg1){
        /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */ this.linkedSheets = [];
        let options = optionsOrTexture;
        if (optionsOrTexture?.source instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$TextureSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureSource"]) {
            options = {
                texture: optionsOrTexture,
                data: arg1
            };
        }
        const { texture, data, cachePrefix = "" } = options;
        this.cachePrefix = cachePrefix;
        this._texture = texture instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"] ? texture : null;
        this.textureSource = texture.source;
        this.textures = {};
        this.animations = {};
        this.data = data;
        const metaResolution = parseFloat(data.meta.scale);
        if (metaResolution) {
            this.resolution = metaResolution;
            texture.source.resolution = this.resolution;
        } else {
            this.resolution = texture.source._resolution;
        }
        this._frames = this.data.frames;
        this._frameKeys = Object.keys(this._frames);
        this._batchIndex = 0;
        this._callback = null;
    }
    /**
   * Parser spritesheet from loaded data. This is done asynchronously
   * to prevent creating too many Texture within a single process.
   */ parse() {
        return new Promise((resolve)=>{
            this._callback = resolve;
            this._batchIndex = 0;
            if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
                this._processFrames(0);
                this._processAnimations();
                this._parseComplete();
            } else {
                this._nextBatch();
            }
        });
    }
    /**
   * Process a batch of frames
   * @param initialFrameIndex - The index of frame to start.
   */ _processFrames(initialFrameIndex) {
        let frameIndex = initialFrameIndex;
        const maxFrames = _Spritesheet.BATCH_SIZE;
        while(frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length){
            const i = this._frameKeys[frameIndex];
            const data = this._frames[i];
            const rect = data.frame;
            if (rect) {
                let frame = null;
                let trim = null;
                const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
                const orig = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rectangle"](0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
                if (data.rotated) {
                    frame = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rectangle"](Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
                } else {
                    frame = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rectangle"](Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
                }
                if (data.trimmed !== false && data.spriteSourceSize) {
                    trim = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$shapes$2f$Rectangle$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rectangle"](Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
                }
                this.textures[i] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]({
                    source: this.textureSource,
                    frame,
                    orig,
                    trim,
                    rotate: data.rotated ? 2 : 0,
                    defaultAnchor: data.anchor,
                    defaultBorders: data.borders,
                    label: i.toString()
                });
            }
            frameIndex++;
        }
    }
    /** Parse animations config. */ _processAnimations() {
        const animations = this.data.animations || {};
        for(const animName in animations){
            this.animations[animName] = [];
            for(let i = 0; i < animations[animName].length; i++){
                const frameName = animations[animName][i];
                this.animations[animName].push(this.textures[frameName]);
            }
        }
    }
    /** The parse has completed. */ _parseComplete() {
        const callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
    }
    /** Begin the next batch of textures. */ _nextBatch() {
        this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(()=>{
            if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
                this._nextBatch();
            } else {
                this._processAnimations();
                this._parseComplete();
            }
        }, 0);
    }
    /**
   * Destroy Spritesheet and don't use after this.
   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
   */ destroy(destroyBase = false) {
        for(const i in this.textures){
            this.textures[i].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
            this._texture?.destroy();
            this.textureSource.destroy();
        }
        this._texture = null;
        this.textureSource = null;
        this.linkedSheets = [];
    }
};
/**
 * The maximum number of Textures to build per process.
 * @advanced
 */ _Spritesheet.BATCH_SIZE = 1e3;
let Spritesheet = _Spritesheet;
;
 //# sourceMappingURL=Spritesheet.mjs.map
}),
"[project]/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "spritesheetAsset",
    ()=>spritesheetAsset
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$resolver$2f$Resolver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$copySearchParams$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/path.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$spritesheet$2f$Spritesheet$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
const validImages = [
    "jpg",
    "png",
    "jpeg",
    "avif",
    "webp",
    "basis",
    "etc2",
    "bc7",
    "bc6h",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac",
    "astc"
];
function getCacheableAssets(keys, asset, ignoreMultiPack) {
    const out = {};
    keys.forEach((key)=>{
        out[key] = asset;
    });
    Object.keys(asset.textures).forEach((key)=>{
        out[`${asset.cachePrefix}${key}`] = asset.textures[key];
    });
    if (!ignoreMultiPack) {
        const basePath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["path"].dirname(keys[0]);
        asset.linkedSheets.forEach((item, i)=>{
            const out2 = getCacheableAssets([
                `${basePath}/${asset.data.meta.related_multi_packs[i]}`
            ], item, true);
            Object.assign(out, out2);
        });
    }
    return out;
}
const spritesheetAsset = {
    extension: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].Asset,
    /** Handle the caching of the related Spritesheet Textures */ cache: {
        test: (asset)=>asset instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$spritesheet$2f$Spritesheet$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Spritesheet"],
        getCacheableAssets: (keys, asset)=>getCacheableAssets(keys, asset, false)
    },
    /** Resolve the resolution of the asset. */ resolver: {
        extension: {
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].ResolveParser,
            name: "resolveSpritesheet"
        },
        test: (value)=>{
            const tempURL = value.split("?")[0];
            const split = tempURL.split(".");
            const extension = split.pop();
            const format = split.pop();
            return extension === "json" && validImages.includes(format);
        },
        parse: (value)=>{
            const split = value.split(".");
            return {
                resolution: parseFloat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$resolver$2f$Resolver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resolver"].RETINA_PREFIX.exec(value)?.[1] ?? "1"),
                format: split[split.length - 2],
                src: value
            };
        }
    },
    /**
   * Loader plugin that parses sprite sheets!
   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
   * If it is, we load the spritesheets image and parse the data into Spritesheet
   * All textures in the sprite sheet are then added to the cache
   */ loader: {
        /** used for deprecation purposes */ name: "spritesheetLoader",
        id: "spritesheet",
        extension: {
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].LoadParser,
            priority: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderParserPriority"].Normal,
            name: "spritesheetLoader"
        },
        async testParse (asset, options) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["path"].extname(options.src).toLowerCase() === ".json" && !!asset.frames;
        },
        async parse (asset, options, loader) {
            const { texture: imageTexture, // if user need to use preloaded texture
            imageFilename, // if user need to use custom filename (not from jsonFile.meta.image)
            textureOptions, // if user need to set texture options on texture
            cachePrefix } = options?.data ?? {};
            let basePath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$path$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["path"].dirname(options.src);
            if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
                basePath += "/";
            }
            let texture;
            if (imageTexture instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]) {
                texture = imageTexture;
            } else {
                const imagePath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$copySearchParams$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copySearchParams"])(basePath + (imageFilename ?? asset.meta.image), options.src);
                const assets = await loader.load([
                    {
                        src: imagePath,
                        data: textureOptions
                    }
                ]);
                texture = assets[imagePath];
            }
            const spritesheet = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$spritesheet$2f$Spritesheet$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Spritesheet"]({
                texture: texture.source,
                data: asset,
                cachePrefix
            });
            await spritesheet.parse();
            const multiPacks = asset?.meta?.related_multi_packs;
            if (Array.isArray(multiPacks)) {
                const promises = [];
                for (const item of multiPacks){
                    if (typeof item !== "string") {
                        continue;
                    }
                    let itemUrl = basePath + item;
                    if (options.data?.ignoreMultiPack) {
                        continue;
                    }
                    itemUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$copySearchParams$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copySearchParams"])(itemUrl, options.src);
                    promises.push(loader.load({
                        src: itemUrl,
                        data: {
                            textureOptions,
                            ignoreMultiPack: true
                        }
                    }));
                }
                const res = await Promise.all(promises);
                spritesheet.linkedSheets = res;
                res.forEach((item)=>{
                    item.linkedSheets = [
                        spritesheet
                    ].concat(spritesheet.linkedSheets.filter((sp)=>sp !== item));
                });
            }
            return spritesheet;
        },
        async unload (spritesheet, _resolvedAsset, loader) {
            await loader.unload(spritesheet.textureSource._sourceOrigin);
            spritesheet.destroy(false);
        }
    }
};
;
 //# sourceMappingURL=spritesheetAsset.mjs.map
}),
"[project]/node_modules/pixi.js/lib/spritesheet/init.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$spritesheet$2f$spritesheetAsset$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs [app-client] (ecmascript)");
;
;
"use strict";
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extensions"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$spritesheet$2f$spritesheetAsset$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["spritesheetAsset"]); //# sourceMappingURL=init.mjs.map
}),
"[project]/node_modules/pixi.js/lib/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2d$browser$2f$browserExt$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment-browser/browserExt.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2d$webworker$2f$webworkerExt$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$init$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/init.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$spritesheet$2f$init$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/spritesheet/init.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$utils$2f$textureFrom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-client] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
"use strict";
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extensions"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2d$browser$2f$browserExt$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["browserExt"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$environment$2d$webworker$2f$webworkerExt$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["webworkerExt"]);
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/pixi.js/lib/dom/CanvasObserver.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CanvasObserver",
    ()=>CanvasObserver
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/ticker/const.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/ticker/Ticker.mjs [app-client] (ecmascript)");
;
;
"use strict";
class CanvasObserver {
    constructor(options){
        /** A cached value of the last transform applied to the DOM element. */ this._lastTransform = "";
        /** A ResizeObserver instance to observe changes in the canvas size. */ this._observer = null;
        /** A flag to indicate whether the observer is attached to the Ticker for continuous updates. */ this._tickerAttached = false;
        /**
     * Updates the transform of the DOM element based on the canvas size and position.
     * This method calculates the scale and translation needed to keep the DOM element in sync with the canvas.
     */ this.updateTranslation = ()=>{
            if (!this._canvas) return;
            const rect = this._canvas.getBoundingClientRect();
            const contentWidth = this._canvas.width;
            const contentHeight = this._canvas.height;
            const sx = rect.width / contentWidth * this._renderer.resolution;
            const sy = rect.height / contentHeight * this._renderer.resolution;
            const tx = rect.left;
            const ty = rect.top;
            const newTransform = `translate(${tx}px, ${ty}px) scale(${sx}, ${sy})`;
            if (newTransform !== this._lastTransform) {
                this._domElement.style.transform = newTransform;
                this._lastTransform = newTransform;
            }
        };
        this._domElement = options.domElement;
        this._renderer = options.renderer;
        if (globalThis.OffscreenCanvas && this._renderer.canvas instanceof OffscreenCanvas) return;
        this._canvas = this._renderer.canvas;
        this._attachObserver();
    }
    /** The canvas element that this CanvasObserver is associated with. */ get canvas() {
        return this._canvas;
    }
    /** Attaches the DOM element to the canvas parent if it is not already attached. */ ensureAttached() {
        if (!this._domElement.parentNode && this._canvas.parentNode) {
            this._canvas.parentNode.appendChild(this._domElement);
            this.updateTranslation();
        }
    }
    /** Sets up a ResizeObserver if available. This ensures that the DOM element is kept in sync with the canvas size . */ _attachObserver() {
        if ("ResizeObserver" in globalThis) {
            if (this._observer) {
                this._observer.disconnect();
                this._observer = null;
            }
            this._observer = new ResizeObserver((entries)=>{
                for (const entry of entries){
                    if (entry.target !== this._canvas) {
                        continue;
                    }
                    const contentWidth = this.canvas.width;
                    const contentHeight = this.canvas.height;
                    const sx = entry.contentRect.width / contentWidth * this._renderer.resolution;
                    const sy = entry.contentRect.height / contentHeight * this._renderer.resolution;
                    const needsUpdate = this._lastScaleX !== sx || this._lastScaleY !== sy;
                    if (needsUpdate) {
                        this.updateTranslation();
                        this._lastScaleX = sx;
                        this._lastScaleY = sy;
                    }
                }
            });
            this._observer.observe(this._canvas);
        } else if (!this._tickerAttached) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ticker"].shared.add(this.updateTranslation, this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UPDATE_PRIORITY"].HIGH);
        }
    }
    /** Destroys the CanvasObserver instance, cleaning up observers and Ticker. */ destroy() {
        if (this._observer) {
            this._observer.disconnect();
            this._observer = null;
        } else if (this._tickerAttached) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ticker"].shared.remove(this.updateTranslation);
        }
        this._domElement = null;
        this._renderer = null;
        this._canvas = null;
        this._tickerAttached = false;
        this._lastTransform = "";
        this._lastScaleX = null;
        this._lastScaleY = null;
    }
}
;
 //# sourceMappingURL=CanvasObserver.mjs.map
}),
"[project]/node_modules/pixi.js/lib/dom/DOMContainer.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DOMContainer",
    ()=>DOMContainer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/view/ViewContainer.mjs [app-client] (ecmascript)");
;
;
"use strict";
class DOMContainer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$view$2f$ViewContainer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewContainer"] {
    /**
   * @param options - The options for creating the DOM container.
   */ constructor(options = {}){
        const { element, anchor, ...rest } = options;
        super({
            label: "DOMContainer",
            ...rest
        });
        /** @internal */ this.renderPipeId = "dom";
        /** @internal */ this.batched = false;
        this._anchor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](0, 0);
        if (anchor) {
            this.anchor = anchor;
        }
        this.element = options.element || document.createElement("div");
    }
    /**
   * The anchor sets the origin point of the container.
   * Controls the relative positioning of the DOM element.
   *
   * The default is `(0,0)`, this means the container's origin is the top left.
   * Setting the anchor to `(0.5,0.5)` means the container's origin is centered.
   * Setting the anchor to `(1,1)` would mean the container's origin point will be the bottom right corner.
   * @example
   * ```ts
   * const container = new DOMContainer();
   *
   * // Set anchor to center (shorthand)
   * container.anchor = 0.5;
   *
   * // Set anchor to bottom-right
   * container.anchor = { x: 1, y: 1 };
   *
   * // Set anchor to custom position
   * container.anchor = new Point(0.3, 0.7);
   * ```
   */ get anchor() {
        return this._anchor;
    }
    /**
   * Sets the anchor point of the container.
   * @param value - New anchor value:
   * - number: Sets both x and y to same value
   * - PointData: Sets x and y separately
   */ set anchor(value) {
        typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    /**
   * Sets the DOM element for this container.
   * This will replace the current element and update the view.
   * @param value - The new DOM element to use
   * @example
   * ```ts
   * const domContainer = new DOMContainer();
   * domContainer.element = document.createElement('input');
   * ```
   */ set element(value) {
        if (this._element === value) return;
        this._element = value;
        this.onViewUpdate();
    }
    /**
   * The DOM element associated with this container.
   * @example
   * ```ts
   * const domContainer = new DOMContainer();
   * domContainer.element.innerHTML = 'Hello World!';
   * document.body.appendChild(domContainer.element);
   * ```
   */ get element() {
        return this._element;
    }
    /** @private */ updateBounds() {
        const bounds = this._bounds;
        const element = this._element;
        if (!element) {
            bounds.minX = 0;
            bounds.minY = 0;
            bounds.maxX = 0;
            bounds.maxY = 0;
            return;
        }
        const { offsetWidth, offsetHeight } = element;
        bounds.minX = 0;
        bounds.maxX = offsetWidth;
        bounds.minY = 0;
        bounds.maxY = offsetHeight;
    }
    /**
   * Destroys this DOM container.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that
   * @example
   * domContainer.destroy();
   * domContainer.destroy(true);
   */ destroy(options = false) {
        super.destroy(options);
        this._element?.parentNode?.removeChild(this._element);
        this._element = null;
        this._anchor = null;
    }
}
;
 //# sourceMappingURL=DOMContainer.mjs.map
}),
"[project]/node_modules/pixi.js/lib/dom/DOMPipe.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DOMPipe",
    ()=>DOMPipe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$dom$2f$CanvasObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/dom/CanvasObserver.mjs [app-client] (ecmascript)");
;
;
"use strict";
class DOMPipe {
    /**
   * Constructor for the DOMPipe class.
   * @param renderer - The renderer instance that this DOMPipe will be associated with.
   */ constructor(renderer){
        /** Array to keep track of attached DOM elements */ this._attachedDomElements = [];
        this._renderer = renderer;
        this._renderer.runners.postrender.add(this);
        this._renderer.runners.init.add(this);
        this._domElement = document.createElement("div");
        this._domElement.style.position = "absolute";
        this._domElement.style.top = "0";
        this._domElement.style.left = "0";
        this._domElement.style.pointerEvents = "none";
        this._domElement.style.zIndex = "1000";
    }
    /** Initializes the DOMPipe, setting up the main DOM element and adding it to the document body. */ init() {
        this._canvasObserver = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$dom$2f$CanvasObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CanvasObserver"]({
            domElement: this._domElement,
            renderer: this._renderer
        });
    }
    /**
   * Adds a renderable DOM container to the list of attached elements.
   * @param domContainer - The DOM container to be added.
   * @param _instructionSet - The instruction set (unused).
   */ addRenderable(domContainer, _instructionSet) {
        if (!this._attachedDomElements.includes(domContainer)) {
            this._attachedDomElements.push(domContainer);
        }
    }
    /**
   * Updates a renderable DOM container.
   * @param _domContainer - The DOM container to be updated (unused).
   */ updateRenderable(_domContainer) {}
    /**
   * Validates a renderable DOM container.
   * @param _domContainer - The DOM container to be validated (unused).
   * @returns Always returns true as validation is not required.
   */ validateRenderable(_domContainer) {
        return true;
    }
    /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */ postrender() {
        const attachedDomElements = this._attachedDomElements;
        if (attachedDomElements.length === 0) {
            this._domElement.remove();
            return;
        }
        this._canvasObserver.ensureAttached();
        for(let i = 0; i < attachedDomElements.length; i++){
            const domContainer = attachedDomElements[i];
            const element = domContainer.element;
            if (!domContainer.parent || domContainer.globalDisplayStatus < 7) {
                element?.remove();
                attachedDomElements.splice(i, 1);
                i--;
            } else {
                if (!this._domElement.contains(element)) {
                    element.style.position = "absolute";
                    element.style.pointerEvents = "auto";
                    this._domElement.appendChild(element);
                }
                const wt = domContainer.worldTransform;
                const anchor = domContainer._anchor;
                const ax = domContainer.width * anchor.x;
                const ay = domContainer.height * anchor.y;
                element.style.transformOrigin = `${ax}px ${ay}px`;
                element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;
                element.style.opacity = domContainer.groupAlpha.toString();
            }
        }
    }
    /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */ destroy() {
        this._renderer.runners.postrender.remove(this);
        for(let i = 0; i < this._attachedDomElements.length; i++){
            const domContainer = this._attachedDomElements[i];
            domContainer.element?.remove();
        }
        this._attachedDomElements.length = 0;
        this._domElement.remove();
        this._canvasObserver.destroy();
        this._renderer = null;
    }
}
/**
 * Static property defining the extension type and name for the DOMPipe.
 * This is used to register the DOMPipe with different rendering pipelines.
 */ DOMPipe.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUPipes,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasPipes
    ],
    name: "dom"
};
;
 //# sourceMappingURL=DOMPipe.mjs.map
}),
"[project]/node_modules/pixi.js/lib/events/FederatedEvent.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FederatedEvent",
    ()=>FederatedEvent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-client] (ecmascript)");
;
"use strict";
class FederatedEvent {
    /**
   * @param manager - The event boundary which manages this event. Propagation can only occur
   *  within the boundary's jurisdiction.
   */ constructor(manager){
        /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */ this.bubbles = true;
        /** @deprecated since 7.0.0 */ this.cancelBubble = true;
        /**
     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always
     * false (for now).
     */ this.cancelable = false;
        /**
     * Flag added for compatibility with DOM `Event`. It is not used in the Federated Events
     * API.
     * @see https://dom.spec.whatwg.org/#dom-event-composed
     * @ignore
     */ this.composed = false;
        /** Flags whether the default response of the user agent was prevent through this event. */ this.defaultPrevented = false;
        /**
     * The propagation phase.
     * @default {@link FederatedEvent.NONE}
     */ this.eventPhase = FederatedEvent.prototype.NONE;
        /** Flags whether propagation was stopped. */ this.propagationStopped = false;
        /** Flags whether propagation was immediately stopped. */ this.propagationImmediatelyStopped = false;
        /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */ this.layer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
        /** The coordinates of the event relative to the DOM document. This is a non-standard property. */ this.page = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
        /**
     * The event propagation phase NONE that indicates that the event is not in any phase.
     * @default 0
     * @advanced
     */ this.NONE = 0;
        /**
     * The event propagation phase CAPTURING_PHASE that indicates that the event is in the capturing phase.
     * @default 1
     * @advanced
     */ this.CAPTURING_PHASE = 1;
        /**
     * The event propagation phase AT_TARGET that indicates that the event is at the target.
     * @default 2
     * @advanced
     */ this.AT_TARGET = 2;
        /**
     * The event propagation phase BUBBLING_PHASE that indicates that the event is in the bubbling phase.
     * @default 3
     * @advanced
     */ this.BUBBLING_PHASE = 3;
        this.manager = manager;
    }
    /** @readonly */ get layerX() {
        return this.layer.x;
    }
    /** @readonly */ get layerY() {
        return this.layer.y;
    }
    /** @readonly */ get pageX() {
        return this.page.x;
    }
    /** @readonly */ get pageY() {
        return this.page.y;
    }
    /**
   * Fallback for the deprecated `InteractionEvent.data`.
   * @deprecated since 7.0.0
   */ get data() {
        return this;
    }
    /**
   * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.
   * @advanced
   */ composedPath() {
        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
            this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
    }
    /**
   * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.
   * @deprecated
   * @ignore
   * @param _type
   * @param _bubbles
   * @param _cancelable
   */ initEvent(_type, _bubbles, _cancelable) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
    }
    /**
   * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.
   * @ignore
   * @deprecated
   * @param _typeArg
   * @param _bubblesArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   */ initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
    }
    /**
   * Prevent default behavior of both PixiJS and the user agent.
   * @example
   * ```ts
   * sprite.on('click', (event) => {
   *     // Prevent both browser's default click behavior
   *     // and PixiJS's default handling
   *     event.preventDefault();
   *
   *     // Custom handling
   *     customClickHandler();
   * });
   * ```
   * @remarks
   * - Only works if the native event is cancelable
   * - Does not stop event propagation
   */ preventDefault() {
        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
            this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = true;
    }
    /**
   * Stop this event from propagating to any additional listeners, including those
   * on the current target and any following targets in the propagation path.
   * @example
   * ```ts
   * container.on('pointerdown', (event) => {
   *     // Stop all further event handling
   *     event.stopImmediatePropagation();
   *
   *     // These handlers won't be called:
   *     // - Other pointerdown listeners on this container
   *     // - Any pointerdown listeners on parent containers
   * });
   * ```
   * @remarks
   * - Immediately stops all event propagation
   * - Prevents other listeners on same target from being called
   * - More aggressive than stopPropagation()
   */ stopImmediatePropagation() {
        this.propagationImmediatelyStopped = true;
    }
    /**
   * Stop this event from propagating to the next target in the propagation path.
   * The rest of the listeners on the current target will still be notified.
   * @example
   * ```ts
   * child.on('pointermove', (event) => {
   *     // Handle event on child
   *     updateChild();
   *
   *     // Prevent parent handlers from being called
   *     event.stopPropagation();
   * });
   *
   * // This won't be called if child handles the event
   * parent.on('pointermove', (event) => {
   *     updateParent();
   * });
   * ```
   * @remarks
   * - Stops event bubbling to parent containers
   * - Does not prevent other listeners on same target
   * - Less aggressive than stopImmediatePropagation()
   */ stopPropagation() {
        this.propagationStopped = true;
    }
}
;
 //# sourceMappingURL=FederatedEvent.mjs.map
}),
"[project]/node_modules/pixi.js/lib/events/EventTicker.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EventsTicker",
    ()=>EventsTicker
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/ticker/const.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/ticker/Ticker.mjs [app-client] (ecmascript)");
;
;
"use strict";
class EventsTickerClass {
    constructor(){
        /** The frequency that fake events will be fired. */ this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
    }
    /**
   * Initializes the event ticker.
   * @param events - The event system.
   */ init(events) {
        this.removeTickerListener();
        this.events = events;
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
    }
    /** Whether to pause the update checks or not. */ get pauseUpdate() {
        return this._pauseUpdate;
    }
    set pauseUpdate(paused) {
        this._pauseUpdate = paused;
    }
    /** Adds the ticker listener. */ addTickerListener() {
        if (this._tickerAdded || !this.domElement) {
            return;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ticker"].system.add(this._tickerUpdate, this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UPDATE_PRIORITY"].INTERACTION);
        this._tickerAdded = true;
    }
    /** Removes the ticker listener. */ removeTickerListener() {
        if (!this._tickerAdded) {
            return;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ticker"].system.remove(this._tickerUpdate, this);
        this._tickerAdded = false;
    }
    /** Sets flag to not fire extra events when the user has already moved there mouse */ pointerMoved() {
        this._didMove = true;
    }
    /** Updates the state of interactive objects. */ _update() {
        if (!this.domElement || this._pauseUpdate) {
            return;
        }
        if (this._didMove) {
            this._didMove = false;
            return;
        }
        const rootPointerEvent = this.events["_rootPointerEvent"];
        if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
            return;
        }
        globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent("pointermove", {
            clientX: rootPointerEvent.clientX,
            clientY: rootPointerEvent.clientY,
            pointerType: rootPointerEvent.pointerType,
            pointerId: rootPointerEvent.pointerId
        }) : new MouseEvent("mousemove", {
            clientX: rootPointerEvent.clientX,
            clientY: rootPointerEvent.clientY
        }));
    }
    /**
   * Updates the state of interactive objects if at least {@link interactionFrequency}
   * milliseconds have passed since the last invocation.
   *
   * Invoked by a throttled ticker update from {@link Ticker.system}.
   * @param ticker - The throttled ticker.
   */ _tickerUpdate(ticker) {
        this._deltaTime += ticker.deltaTime;
        if (this._deltaTime < this.interactionFrequency) {
            return;
        }
        this._deltaTime = 0;
        this._update();
    }
    /** Destroys the event ticker. */ destroy() {
        this.removeTickerListener();
        this.events = null;
        this.domElement = null;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
    }
}
const EventsTicker = new EventsTickerClass();
;
 //# sourceMappingURL=EventTicker.mjs.map
}),
"[project]/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FederatedMouseEvent",
    ()=>FederatedMouseEvent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/FederatedEvent.mjs [app-client] (ecmascript)");
;
;
"use strict";
class FederatedMouseEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedEvent"] {
    constructor(){
        super(...arguments);
        /** The coordinates of the mouse event relative to the canvas. */ this.client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
        /** The movement in this pointer relative to the last `mousemove` event. */ this.movement = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
        /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */ this.offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
        /** The pointer coordinates in world space. */ this.global = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
        /**
     * The pointer coordinates in the renderer's {@link AbstractRenderer.screen screen}. This has slightly
     * different semantics than native PointerEvent screenX/screenY.
     */ this.screen = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
    }
    /** @readonly */ get clientX() {
        return this.client.x;
    }
    /** @readonly */ get clientY() {
        return this.client.y;
    }
    /**
   * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
   * @readonly
   */ get x() {
        return this.clientX;
    }
    /**
   * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
   * @readonly
   */ get y() {
        return this.clientY;
    }
    /** @readonly */ get movementX() {
        return this.movement.x;
    }
    /** @readonly */ get movementY() {
        return this.movement.y;
    }
    /** @readonly */ get offsetX() {
        return this.offset.x;
    }
    /** @readonly */ get offsetY() {
        return this.offset.y;
    }
    /** @readonly */ get globalX() {
        return this.global.x;
    }
    /** @readonly */ get globalY() {
        return this.global.y;
    }
    /**
   * The pointer coordinates in the renderer's screen. Alias for `screen.x`.
   * @readonly
   */ get screenX() {
        return this.screen.x;
    }
    /**
   * The pointer coordinates in the renderer's screen. Alias for `screen.y`.
   * @readonly
   */ get screenY() {
        return this.screen.y;
    }
    /**
   * Converts global coordinates into container-local coordinates.
   *
   * This method transforms coordinates from world space to a container's local space,
   * useful for precise positioning and hit testing.
   * @param container - The Container to get local coordinates for
   * @param point - Optional Point object to store the result. If not provided, a new Point will be created
   * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used
   * @returns The local coordinates as a Point object
   * @example
   * ```ts
   * // Basic usage - get local coordinates relative to a container
   * sprite.on('pointermove', (event: FederatedMouseEvent) => {
   *     // Get position relative to the sprite
   *     const localPos = event.getLocalPosition(sprite);
   *     console.log('Local position:', localPos.x, localPos.y);
   * });
   * // Using custom global coordinates
   * const customGlobal = new Point(100, 100);
   * sprite.on('pointermove', (event: FederatedMouseEvent) => {
   *     // Transform custom coordinates
   *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);
   *     console.log('Custom local position:', localPos.x, localPos.y);
   * });
   * ```
   * @see {@link Container.worldTransform} For the transformation matrix
   * @see {@link Point} For the point class used to store coordinates
   */ getLocalPosition(container, point, globalPos) {
        return container.worldTransform.applyInverse(globalPos || this.global, point);
    }
    /**
   * Whether the modifier key was pressed when this event natively occurred.
   * @param key - The modifier key.
   */ getModifierState(key) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
    }
    /**
   * Not supported.
   * @param _typeArg
   * @param _canBubbleArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   * @param _screenXArg
   * @param _screenYArg
   * @param _clientXArg
   * @param _clientYArg
   * @param _ctrlKeyArg
   * @param _altKeyArg
   * @param _shiftKeyArg
   * @param _metaKeyArg
   * @param _buttonArg
   * @param _relatedTargetArg
   * @deprecated since 7.0.0
   * @ignore
   */ // eslint-disable-next-line max-params
    initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
        throw new Error("Method not implemented.");
    }
}
;
 //# sourceMappingURL=FederatedMouseEvent.mjs.map
}),
"[project]/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FederatedPointerEvent",
    ()=>FederatedPointerEvent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs [app-client] (ecmascript)");
;
"use strict";
class FederatedPointerEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedMouseEvent"] {
    constructor(){
        super(...arguments);
        /**
     * The width of the pointer's contact along the x-axis, measured in CSS pixels.
     * radiusX of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width
     */ this.width = 0;
        /**
     * The height of the pointer's contact along the y-axis, measured in CSS pixels.
     * radiusY of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height
     */ this.height = 0;
        /**
     * Indicates whether or not the pointer device that created the event is the primary pointer.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
     */ this.isPrimary = false;
    }
    /**
   * Only included for completeness for now
   * @ignore
   */ getCoalescedEvents() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
            return [
                this
            ];
        }
        return [];
    }
    /**
   * Only included for completeness for now
   * @ignore
   */ getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
    }
}
;
 //# sourceMappingURL=FederatedPointerEvent.mjs.map
}),
"[project]/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FederatedWheelEvent",
    ()=>FederatedWheelEvent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs [app-client] (ecmascript)");
;
"use strict";
class FederatedWheelEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedMouseEvent"] {
    constructor(){
        super(...arguments);
        /**
     * Units specified in pixels.
     * @ignore
     */ this.DOM_DELTA_PIXEL = 0;
        /**
     * Units specified in lines.
     * @ignore
     */ this.DOM_DELTA_LINE = 1;
        /**
     * Units specified in pages.
     * @ignore
     */ this.DOM_DELTA_PAGE = 2;
    }
}
/**
 * Units specified in pixels.
 * @ignore
 */ FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
/**
 * Units specified in lines.
 * @ignore
 */ FederatedWheelEvent.DOM_DELTA_LINE = 1;
/**
 * Units specified in pages.
 * @ignore
 */ FederatedWheelEvent.DOM_DELTA_PAGE = 2;
;
 //# sourceMappingURL=FederatedWheelEvent.mjs.map
}),
"[project]/node_modules/pixi.js/lib/events/EventBoundary.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EventBoundary",
    ()=>EventBoundary
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/maths/point/Point.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/warn.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/EventTicker.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedWheelEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
const PROPAGATION_LIMIT = 2048;
const tempHitLocation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
const tempLocalMapping = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$maths$2f$point$2f$Point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
class EventBoundary {
    /**
   * @param rootTarget - The holder of the event boundary.
   */ constructor(rootTarget){
        /**
     * Emits events after they were dispatched into the scene graph.
     *
     * This can be used for global events listening, regardless of the scene graph being used. It should
     * not be used by interactive libraries for normal use.
     *
     * Special events that do not bubble all the way to the root target are not emitted from here,
     * e.g. pointerenter, pointerleave, click.
     */ this.dispatch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"]();
        /**
     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.
     *
     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of
     * the Pointer Event API's approach.
     */ this.moveOnAll = false;
        /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */ this.enableGlobalMoveEvents = true;
        /**
     * State object for mapping methods.
     * @see EventBoundary#trackingData
     */ this.mappingState = {
            trackingData: {}
        };
        /**
     * The event pool maps event constructors to an free pool of instances of those specific events.
     * @see EventBoundary#allocateEvent
     * @see EventBoundary#freeEvent
     */ this.eventPool = /* @__PURE__ */ new Map();
        /** Every interactive element gathered from the scene. Only used in `pointermove` */ this._allInteractiveElements = [];
        /** Every element that passed the hit test. Only used in `pointermove` */ this._hitElements = [];
        /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */ this._isPointerMoveEvent = false;
        this.rootTarget = rootTarget;
        this.hitPruneFn = this.hitPruneFn.bind(this);
        this.hitTestFn = this.hitTestFn.bind(this);
        this.mapPointerDown = this.mapPointerDown.bind(this);
        this.mapPointerMove = this.mapPointerMove.bind(this);
        this.mapPointerOut = this.mapPointerOut.bind(this);
        this.mapPointerOver = this.mapPointerOver.bind(this);
        this.mapPointerUp = this.mapPointerUp.bind(this);
        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
        this.mapWheel = this.mapWheel.bind(this);
        this.mappingTable = {};
        this.addEventMapping("pointerdown", this.mapPointerDown);
        this.addEventMapping("pointermove", this.mapPointerMove);
        this.addEventMapping("pointerout", this.mapPointerOut);
        this.addEventMapping("pointerleave", this.mapPointerOut);
        this.addEventMapping("pointerover", this.mapPointerOver);
        this.addEventMapping("pointerup", this.mapPointerUp);
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
        this.addEventMapping("wheel", this.mapWheel);
    }
    /**
   * Adds an event mapping for the event `type` handled by `fn`.
   *
   * Event mappings can be used to implement additional or custom events. They take an event
   * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
   * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
   *
   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
   * instead.
   * @param type - The type of upstream event to map.
   * @param fn - The mapping method. The context of this function must be bound manually, if desired.
   */ addEventMapping(type, fn) {
        if (!this.mappingTable[type]) {
            this.mappingTable[type] = [];
        }
        this.mappingTable[type].push({
            fn,
            priority: 0
        });
        this.mappingTable[type].sort((a, b)=>a.priority - b.priority);
    }
    /**
   * Dispatches the given event
   * @param e - The event to dispatch.
   * @param type - The type of event to dispatch. Defaults to `e.type`.
   */ dispatchEvent(e, type) {
        e.propagationStopped = false;
        e.propagationImmediatelyStopped = false;
        this.propagate(e, type);
        this.dispatch.emit(type || e.type, e);
    }
    /**
   * Maps the given upstream event through the event boundary and propagates it downstream.
   * @param e - The event to map.
   */ mapEvent(e) {
        if (!this.rootTarget) {
            return;
        }
        const mappers = this.mappingTable[e.type];
        if (mappers) {
            for(let i = 0, j = mappers.length; i < j; i++){
                mappers[i].fn(e);
            }
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warn"])(`[EventBoundary]: Event mapping not defined for ${e.type}`);
        }
    }
    /**
   * Finds the Container that is the target of a event at the given coordinates.
   *
   * The passed (x,y) coordinates are in the world space above this event boundary.
   * @param x - The x coordinate of the event.
   * @param y - The y coordinate of the event.
   */ hitTest(x, y) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventsTicker"].pauseUpdate = true;
        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
        const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
        const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x, y), this.hitTestFn, this.hitPruneFn);
        return invertedPath && invertedPath[0];
    }
    /**
   * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
   * target `e.target`.
   * @param e - The event to propagate.
   * @param type - The type of event to propagate. Defaults to `e.type`.
   */ propagate(e, type) {
        if (!e.target) {
            return;
        }
        const composedPath = e.composedPath();
        e.eventPhase = e.CAPTURING_PHASE;
        for(let i = 0, j = composedPath.length - 1; i < j; i++){
            e.currentTarget = composedPath[i];
            this.notifyTarget(e, type);
            if (e.propagationStopped || e.propagationImmediatelyStopped) return;
        }
        e.eventPhase = e.AT_TARGET;
        e.currentTarget = e.target;
        this.notifyTarget(e, type);
        if (e.propagationStopped || e.propagationImmediatelyStopped) return;
        e.eventPhase = e.BUBBLING_PHASE;
        for(let i = composedPath.length - 2; i >= 0; i--){
            e.currentTarget = composedPath[i];
            this.notifyTarget(e, type);
            if (e.propagationStopped || e.propagationImmediatelyStopped) return;
        }
    }
    /**
   * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.
   *
   * This is used in the `globalpointermove` event.
   * @param e - The emitted event.
   * @param type - The listeners to notify.
   * @param targets - The targets to notify.
   */ all(e, type, targets = this._allInteractiveElements) {
        if (targets.length === 0) return;
        e.eventPhase = e.BUBBLING_PHASE;
        const events = Array.isArray(type) ? type : [
            type
        ];
        for(let i = targets.length - 1; i >= 0; i--){
            events.forEach((event)=>{
                e.currentTarget = targets[i];
                this.notifyTarget(e, event);
            });
        }
    }
    /**
   * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
   * `target`. The last element in the path is `target`.
   * @param target - The target to find the propagation path to.
   */ propagationPath(target) {
        const propagationPath = [
            target
        ];
        for(let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget && target.parent; i++){
            if (!target.parent) {
                throw new Error("Cannot find propagation path to disconnected target");
            }
            propagationPath.push(target.parent);
            target = target.parent;
        }
        propagationPath.reverse();
        return propagationPath;
    }
    hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
        let shouldReturn = false;
        if (this._interactivePrune(currentTarget)) return null;
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventsTicker"].pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            for(let i = children.length - 1; i >= 0; i--){
                const child = children[i];
                const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, ignore || pruneFn(currentTarget, location));
                if (nestedHit) {
                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                        continue;
                    }
                    const isInteractive = currentTarget.isInteractive();
                    if (nestedHit.length > 0 || isInteractive) {
                        if (isInteractive) this._allInteractiveElements.push(currentTarget);
                        nestedHit.push(currentTarget);
                    }
                    if (this._hitElements.length === 0) this._hitElements = nestedHit;
                    shouldReturn = true;
                }
            }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);
        if (ignore || this._hitElements.length > 0) return null;
        if (shouldReturn) return this._hitElements;
        if (isInteractiveMode && !pruneFn(currentTarget, location) && testFn(currentTarget, location)) {
            return isInteractiveTarget ? [
                currentTarget
            ] : [];
        }
        return null;
    }
    /**
   * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
   * @param currentTarget - The Container that is to be hit tested.
   * @param eventMode - The event mode for the `currentTarget` or one of its parents.
   * @param location - The location that is being tested for overlap.
   * @param testFn - Callback that determines whether the target passes hit testing. This callback
   *  can assume that `pruneFn` failed to prune the container.
   * @param pruneFn - Callback that determiness whether the target and all of its children
   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
   *  of the scene graph.
   * @returns An array holding the hit testing target and all its ancestors in order. The first element
   *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
   */ hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
            return null;
        }
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventsTicker"].pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            const relativeLocation = location;
            for(let i = children.length - 1; i >= 0; i--){
                const child = children[i];
                const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, relativeLocation, testFn, pruneFn);
                if (nestedHit) {
                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                        continue;
                    }
                    const isInteractive = currentTarget.isInteractive();
                    if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);
                    return nestedHit;
                }
            }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveMode && testFn(currentTarget, location)) {
            return isInteractiveTarget ? [
                currentTarget
            ] : [];
        }
        return null;
    }
    _isInteractive(int) {
        return int === "static" || int === "dynamic";
    }
    _interactivePrune(container) {
        if (!container || !container.visible || !container.renderable || !container.measurable) {
            return true;
        }
        if (container.eventMode === "none") {
            return true;
        }
        if (container.eventMode === "passive" && !container.interactiveChildren) {
            return true;
        }
        return false;
    }
    /**
   * Checks whether the container or any of its children cannot pass the hit test at all.
   *
   * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
   * and {@link Container._maskEffect} for pruning.
   * @param container - The container to prune.
   * @param location - The location to test for overlap.
   */ hitPruneFn(container, location) {
        if (container.hitArea) {
            container.worldTransform.applyInverse(location, tempLocalMapping);
            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
                return true;
            }
        }
        if (container.effects && container.effects.length) {
            for(let i = 0; i < container.effects.length; i++){
                const effect = container.effects[i];
                if (effect.containsPoint) {
                    const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
                    if (!effectContainsPoint) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
   * Checks whether the container passes hit testing for the given location.
   * @param container - The container to test.
   * @param location - The location to test for overlap.
   * @returns - Whether `container` passes hit testing for `location`.
   */ hitTestFn(container, location) {
        if (container.hitArea) {
            return true;
        }
        if (container?.containsPoint) {
            container.worldTransform.applyInverse(location, tempLocalMapping);
            return container.containsPoint(tempLocalMapping);
        }
        return false;
    }
    /**
   * Notify all the listeners to the event's `currentTarget`.
   *
   * If the `currentTarget` contains the property `on<type>`, then it is called here,
   * simulating the behavior from version 6.x and prior.
   * @param e - The event passed to the target.
   * @param type - The type of event to notify. Defaults to `e.type`.
   */ notifyTarget(e, type) {
        if (!e.currentTarget.isInteractive()) {
            return;
        }
        type ?? (type = e.type);
        const handlerKey = `on${type}`;
        e.currentTarget[handlerKey]?.(e);
        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
        this._notifyListeners(e, key);
        if (e.eventPhase === e.AT_TARGET) {
            this._notifyListeners(e, type);
        }
    }
    /**
   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
   *
   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
   * @param from - The upstream `pointerdown` event.
   */ mapPointerDown(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
        }
        const e = this.createPointerEvent(from);
        this.dispatchEvent(e, "pointerdown");
        if (e.pointerType === "touch") {
            this.dispatchEvent(e, "touchstart");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
            const isRightButton = e.button === 2;
            this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
        }
        const trackingData = this.trackingData(from.pointerId);
        trackingData.pressTargetsByButton[from.button] = e.composedPath();
        this.freeEvent(e);
    }
    /**
   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
   *
   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
   * @param from - The upstream `pointermove` event.
   */ mapPointerMove(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        this._isPointerMoveEvent = true;
        const e = this.createPointerEvent(from);
        this._isPointerMoveEvent = false;
        const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
        const trackingData = this.trackingData(from.pointerId);
        const outTarget = this.findMountedTarget(trackingData.overTargets);
        if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {
            const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
            const outEvent = this.createPointerEvent(from, outType, outTarget);
            this.dispatchEvent(outEvent, "pointerout");
            if (isMouse) this.dispatchEvent(outEvent, "mouseout");
            if (!e.composedPath().includes(outTarget)) {
                const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
                leaveEvent.eventPhase = leaveEvent.AT_TARGET;
                while(leaveEvent.target && !e.composedPath().includes(leaveEvent.target)){
                    leaveEvent.currentTarget = leaveEvent.target;
                    this.notifyTarget(leaveEvent);
                    if (isMouse) this.notifyTarget(leaveEvent, "mouseleave");
                    leaveEvent.target = leaveEvent.target.parent;
                }
                this.freeEvent(leaveEvent);
            }
            this.freeEvent(outEvent);
        }
        if (outTarget !== e.target) {
            const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
            const overEvent = this.clonePointerEvent(e, overType);
            this.dispatchEvent(overEvent, "pointerover");
            if (isMouse) this.dispatchEvent(overEvent, "mouseover");
            let overTargetAncestor = outTarget?.parent;
            while(overTargetAncestor && overTargetAncestor !== this.rootTarget.parent){
                if (overTargetAncestor === e.target) break;
                overTargetAncestor = overTargetAncestor.parent;
            }
            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
            if (didPointerEnter) {
                const enterEvent = this.clonePointerEvent(e, "pointerenter");
                enterEvent.eventPhase = enterEvent.AT_TARGET;
                while(enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent){
                    enterEvent.currentTarget = enterEvent.target;
                    this.notifyTarget(enterEvent);
                    if (isMouse) this.notifyTarget(enterEvent, "mouseenter");
                    enterEvent.target = enterEvent.target.parent;
                }
                this.freeEvent(enterEvent);
            }
            this.freeEvent(overEvent);
        }
        const allMethods = [];
        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
        this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove");
        allowGlobalPointerEvents && allMethods.push("globalpointermove");
        if (e.pointerType === "touch") {
            this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove");
            allowGlobalPointerEvents && allMethods.push("globaltouchmove");
        }
        if (isMouse) {
            this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove");
            allowGlobalPointerEvents && allMethods.push("globalmousemove");
            this.cursor = e.target?.cursor;
        }
        if (allMethods.length > 0) {
            this.all(e, allMethods);
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        trackingData.overTargets = e.composedPath();
        this.freeEvent(e);
    }
    /**
   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
   *
   * The tracking data for the specific pointer gets a new `overTarget`.
   * @param from - The upstream `pointerover` event.
   */ mapPointerOver(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const e = this.createPointerEvent(from);
        const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
        this.dispatchEvent(e, "pointerover");
        if (isMouse) this.dispatchEvent(e, "mouseover");
        if (e.pointerType === "mouse") this.cursor = e.target?.cursor;
        const enterEvent = this.clonePointerEvent(e, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while(enterEvent.target && enterEvent.target !== this.rootTarget.parent){
            enterEvent.currentTarget = enterEvent.target;
            this.notifyTarget(enterEvent);
            if (isMouse) this.notifyTarget(enterEvent, "mouseenter");
            enterEvent.target = enterEvent.target.parent;
        }
        trackingData.overTargets = e.composedPath();
        this.freeEvent(e);
        this.freeEvent(enterEvent);
    }
    /**
   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
   *
   * The tracking data for the specific pointer is cleared of a `overTarget`.
   * @param from - The upstream `pointerout` event.
   */ mapPointerOut(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
        }
        const trackingData = this.trackingData(from.pointerId);
        if (trackingData.overTargets) {
            const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
            const outTarget = this.findMountedTarget(trackingData.overTargets);
            const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
            this.dispatchEvent(outEvent);
            if (isMouse) this.dispatchEvent(outEvent, "mouseout");
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while(leaveEvent.target && leaveEvent.target !== this.rootTarget.parent){
                leaveEvent.currentTarget = leaveEvent.target;
                this.notifyTarget(leaveEvent);
                if (isMouse) this.notifyTarget(leaveEvent, "mouseleave");
                leaveEvent.target = leaveEvent.target.parent;
            }
            trackingData.overTargets = null;
            this.freeEvent(outEvent);
            this.freeEvent(leaveEvent);
        }
        this.cursor = null;
    }
    /**
   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
   * and `click`/`rightclick`/`pointertap` events, in that order.
   *
   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
   * specific pointer types.
   * @param from - The upstream `pointerup` event.
   */ mapPointerUp(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
        }
        const now = performance.now();
        const e = this.createPointerEvent(from);
        this.dispatchEvent(e, "pointerup");
        if (e.pointerType === "touch") {
            this.dispatchEvent(e, "touchend");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
            const isRightButton = e.button === 2;
            this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        let clickTarget = pressTarget;
        if (pressTarget && !e.composedPath().includes(pressTarget)) {
            let currentTarget = pressTarget;
            while(currentTarget && !e.composedPath().includes(currentTarget)){
                e.currentTarget = currentTarget;
                this.notifyTarget(e, "pointerupoutside");
                if (e.pointerType === "touch") {
                    this.notifyTarget(e, "touchendoutside");
                } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
                    const isRightButton = e.button === 2;
                    this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
                }
                currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button];
            clickTarget = currentTarget;
        }
        if (clickTarget) {
            const clickEvent = this.clonePointerEvent(e, "click");
            clickEvent.target = clickTarget;
            clickEvent.path = null;
            if (!trackingData.clicksByButton[from.button]) {
                trackingData.clicksByButton[from.button] = {
                    clickCount: 0,
                    target: clickEvent.target,
                    timeStamp: now
                };
            }
            const clickHistory = trackingData.clicksByButton[from.button];
            if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
                ++clickHistory.clickCount;
            } else {
                clickHistory.clickCount = 1;
            }
            clickHistory.target = clickEvent.target;
            clickHistory.timeStamp = now;
            clickEvent.detail = clickHistory.clickCount;
            if (clickEvent.pointerType === "mouse") {
                const isRightButton = clickEvent.button === 2;
                this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
            } else if (clickEvent.pointerType === "touch") {
                this.dispatchEvent(clickEvent, "tap");
            }
            this.dispatchEvent(clickEvent, "pointertap");
            this.freeEvent(clickEvent);
        }
        this.freeEvent(e);
    }
    /**
   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
   * `pointerdown` target to `rootTarget`.
   *
   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
   * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
   *
   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
   * @param from - The upstream `pointerupoutside` event.
   */ mapPointerUpOutside(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        const e = this.createPointerEvent(from);
        if (pressTarget) {
            let currentTarget = pressTarget;
            while(currentTarget){
                e.currentTarget = currentTarget;
                this.notifyTarget(e, "pointerupoutside");
                if (e.pointerType === "touch") {
                    this.notifyTarget(e, "touchendoutside");
                } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
                    this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
                }
                currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button];
        }
        this.freeEvent(e);
    }
    /**
   * Maps the upstream `wheel` event to a downstream `wheel` event.
   * @param from - The upstream `wheel` event.
   */ mapWheel(from) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedWheelEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedWheelEvent"])) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$warn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warn"])("EventBoundary cannot map a non-wheel event as a wheel event");
            return;
        }
        const wheelEvent = this.createWheelEvent(from);
        this.dispatchEvent(wheelEvent);
        this.freeEvent(wheelEvent);
    }
    /**
   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
   *
   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
   * or `pointerover` target was unmounted from the scene graph.
   * @param propagationPath - The propagation path was valid in the past.
   * @returns - The most specific event-target still mounted at the same location in the scene graph.
   */ findMountedTarget(propagationPath) {
        if (!propagationPath) {
            return null;
        }
        let currentTarget = propagationPath[0];
        for(let i = 1; i < propagationPath.length; i++){
            if (propagationPath[i].parent === currentTarget) {
                currentTarget = propagationPath[i];
            } else {
                break;
            }
        }
        return currentTarget;
    }
    /**
   * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The `originalEvent` for the returned event.
   * @param [type=from.type] - The type of the returned event.
   * @param target - The target of the returned event.
   */ createPointerEvent(from, type, target) {
        const event = this.allocateEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedPointerEvent"]);
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
        if (typeof type === "string") {
            event.type = type;
        }
        return event;
    }
    /**
   * Creates a wheel event whose `originalEvent` is `from`.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The upstream wheel event.
   */ createWheelEvent(from) {
        const event = this.allocateEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedWheelEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedWheelEvent"]);
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = this.hitTest(event.global.x, event.global.y);
        return event;
    }
    /**
   * Clones the event `from`, with an optional `type` override.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The event to clone.
   * @param [type=from.type] - The type of the returned event.
   */ clonePointerEvent(from, type) {
        const event = this.allocateEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedPointerEvent"]);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = type ?? event.type;
        return event;
    }
    /**
   * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.
   *
   * The following properties are copied:
   * + deltaMode
   * + deltaX
   * + deltaY
   * + deltaZ
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */ copyWheelData(from, to) {
        to.deltaMode = from.deltaMode;
        to.deltaX = from.deltaX;
        to.deltaY = from.deltaY;
        to.deltaZ = from.deltaZ;
    }
    /**
   * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.
   *
   * The following properties are copied:
   * + pointerId
   * + width
   * + height
   * + isPrimary
   * + pointerType
   * + pressure
   * + tangentialPressure
   * + tiltX
   * + tiltY
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */ copyPointerData(from, to) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedPointerEvent"] && to instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedPointerEvent"])) return;
        to.pointerId = from.pointerId;
        to.width = from.width;
        to.height = from.height;
        to.isPrimary = from.isPrimary;
        to.pointerType = from.pointerType;
        to.pressure = from.pressure;
        to.tangentialPressure = from.tangentialPressure;
        to.tiltX = from.tiltX;
        to.tiltY = from.tiltY;
        to.twist = from.twist;
    }
    /**
   * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.
   *
   * The following properties are copied:
   * + altKey
   * + button
   * + buttons
   * + clientX
   * + clientY
   * + metaKey
   * + movementX
   * + movementY
   * + pageX
   * + pageY
   * + x
   * + y
   * + screen
   * + shiftKey
   * + global
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */ copyMouseData(from, to) {
        if (!(from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedMouseEvent"] && to instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedMouseEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedMouseEvent"])) return;
        to.altKey = from.altKey;
        to.button = from.button;
        to.buttons = from.buttons;
        to.client.copyFrom(from.client);
        to.ctrlKey = from.ctrlKey;
        to.metaKey = from.metaKey;
        to.movement.copyFrom(from.movement);
        to.screen.copyFrom(from.screen);
        to.shiftKey = from.shiftKey;
        to.global.copyFrom(from.global);
    }
    /**
   * Copies base {@link FederatedEvent} data from `from` into `to`.
   *
   * The following properties are copied:
   * + isTrusted
   * + srcElement
   * + timeStamp
   * + type
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */ copyData(from, to) {
        to.isTrusted = from.isTrusted;
        to.srcElement = from.srcElement;
        to.timeStamp = performance.now();
        to.type = from.type;
        to.detail = from.detail;
        to.view = from.view;
        to.which = from.which;
        to.layer.copyFrom(from.layer);
        to.page.copyFrom(from.page);
    }
    /**
   * @param id - The pointer ID.
   * @returns The tracking data stored for the given pointer. If no data exists, a blank
   *  state will be created.
   */ trackingData(id) {
        if (!this.mappingState.trackingData[id]) {
            this.mappingState.trackingData[id] = {
                pressTargetsByButton: {},
                clicksByButton: {},
                overTarget: null
            };
        }
        return this.mappingState.trackingData[id];
    }
    /**
   * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
   *
   * This allocation is constructor-agnostic, as long as it only takes one argument - this event
   * boundary.
   * @param constructor - The event's constructor.
   * @returns An event of the given type.
   */ allocateEvent(constructor) {
        if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
        }
        const event = this.eventPool.get(constructor).pop() || new constructor(this);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.defaultPrevented = false;
        event.path = null;
        event.target = null;
        return event;
    }
    /**
   * Frees the event and puts it back into the event pool.
   *
   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
   *
   * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
   * not be freed. This is because of the possibility that the same event is freed twice, which can cause
   * it to be allocated twice & result in overwriting.
   * @param event - The event to be freed.
   * @throws Error if the event is managed by another event boundary.
   */ freeEvent(event) {
        if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const constructor = event.constructor;
        if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
        }
        this.eventPool.get(constructor).push(event);
    }
    /**
   * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
   * is set on the event.
   * @param e - The event to call each listener with.
   * @param type - The event key.
   */ _notifyListeners(e, type) {
        const listeners = e.currentTarget._events[type];
        if (!listeners) return;
        if ("fn" in listeners) {
            if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, void 0, true);
            listeners.fn.call(listeners.context, e);
        } else {
            for(let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++){
                if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);
                listeners[i].fn.call(listeners[i].context, e);
            }
        }
    }
}
;
 //# sourceMappingURL=EventBoundary.mjs.map
}),
"[project]/node_modules/pixi.js/lib/events/EventSystem.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EventSystem",
    ()=>EventSystem
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventBoundary$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/EventBoundary.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/EventTicker.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedWheelEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs [app-client] (ecmascript)");
;
;
;
;
;
"use strict";
const MOUSE_POINTER_ID = 1;
const TOUCH_TO_POINTER = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
};
const _EventSystem = class _EventSystem {
    /**
   * @param {Renderer} renderer
   */ constructor(renderer){
        /**
     * Indicates whether the current device supports touch events according to the W3C Touch Events spec.
     * This is used to determine the appropriate event handling strategy.
     * @see {@link https://www.w3.org/TR/touch-events/} W3C Touch Events Specification
     * @readonly
     * @default 'ontouchstart' in globalThis
     */ this.supportsTouchEvents = "ontouchstart" in globalThis;
        /**
     * Indicates whether the current device supports pointer events according to the W3C Pointer Events spec.
     * Used to optimize event handling and provide more consistent cross-device interaction.
     * @see {@link https://www.w3.org/TR/pointerevents/} W3C Pointer Events Specification
     * @readonly
     * @default !!globalThis.PointerEvent
     */ this.supportsPointerEvents = !!globalThis.PointerEvent;
        /**
     * The DOM element to which the root event listeners are bound. This is automatically set to
     * the renderer's {@link Renderer#view view}.
     */ this.domElement = null;
        /** The resolution used to convert between the DOM client space into world space. */ this.resolution = 1;
        this.renderer = renderer;
        this.rootBoundary = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventBoundary$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventBoundary"](null);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventsTicker"].init(this);
        this.autoPreventDefault = true;
        this._eventsAdded = false;
        this._rootPointerEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedPointerEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedPointerEvent"](null);
        this._rootWheelEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedWheelEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedWheelEvent"](null);
        this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
        };
        this.features = new Proxy({
            ..._EventSystem.defaultEventFeatures
        }, {
            set: (target, key, value)=>{
                if (key === "globalMove") {
                    this.rootBoundary.enableGlobalMoveEvents = value;
                }
                target[key] = value;
                return true;
            }
        });
        this._onPointerDown = this._onPointerDown.bind(this);
        this._onPointerMove = this._onPointerMove.bind(this);
        this._onPointerUp = this._onPointerUp.bind(this);
        this._onPointerOverOut = this._onPointerOverOut.bind(this);
        this.onWheel = this.onWheel.bind(this);
    }
    /**
   * The default interaction mode for all display objects.
   * @see Container.eventMode
   * @type {EventMode}
   * @readonly
   * @since 7.2.0
   */ static get defaultEventMode() {
        return this._defaultEventMode;
    }
    /**
   * Runner init called, view is available at this point.
   * @ignore
   */ init(options) {
        const { canvas, resolution } = this.renderer;
        this.setTargetElement(canvas);
        this.resolution = resolution;
        _EventSystem._defaultEventMode = options.eventMode ?? "passive";
        Object.assign(this.features, options.eventFeatures ?? {});
        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
    }
    /**
   * Handle changing resolution.
   * @ignore
   */ resolutionChange(resolution) {
        this.resolution = resolution;
    }
    /** Destroys all event listeners and detaches the renderer. */ destroy() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventsTicker"].destroy();
        this.setTargetElement(null);
        this.renderer = null;
        this._currentCursor = null;
    }
    /**
   * Sets the current cursor mode, handling any callbacks or CSS style changes.
   * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.
   * @param mode - Cursor mode to set. Can be:
   * - A CSS cursor string (e.g., 'pointer', 'grab')
   * - A key from the cursorStyles dictionary
   * - null/undefined to reset to default
   * @example
   * ```ts
   * // Using predefined cursor styles
   * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor
   * app.renderer.events.setCursor('grab');       // Set grab cursor
   * app.renderer.events.setCursor(null);         // Reset to default
   *
   * // Using custom cursor styles
   * app.renderer.events.cursorStyles.custom = 'url("cursor.png"), auto';
   * app.renderer.events.setCursor('custom');     // Apply custom cursor
   *
   * // Using callback-based cursor
   * app.renderer.events.cursorStyles.dynamic = (mode) => {
   *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';
   * };
   * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback
   * ```
   * @remarks
   * - Has no effect on OffscreenCanvas except for callback-based cursors
   * - Caches current cursor to avoid unnecessary DOM updates
   * - Supports CSS cursor values, style objects, and callback functions
   * @see {@link EventSystem.cursorStyles} For defining custom cursor styles
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference
   */ setCursor(mode) {
        mode || (mode = "default");
        let applyStyles = true;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
            applyStyles = false;
        }
        if (this._currentCursor === mode) {
            return;
        }
        this._currentCursor = mode;
        const style = this.cursorStyles[mode];
        if (style) {
            switch(typeof style){
                case "string":
                    if (applyStyles) {
                        this.domElement.style.cursor = style;
                    }
                    break;
                case "function":
                    style(mode);
                    break;
                case "object":
                    if (applyStyles) {
                        Object.assign(this.domElement.style, style);
                    }
                    break;
            }
        } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
            this.domElement.style.cursor = mode;
        }
    }
    /**
   * The global pointer event instance containing the most recent pointer state.
   * This is useful for accessing pointer information without listening to events.
   * @example
   * ```ts
   * // Access current pointer position at any time
   * const eventSystem = app.renderer.events;
   * const pointer = eventSystem.pointer;
   *
   * // Get global coordinates
   * console.log('Position:', pointer.global.x, pointer.global.y);
   *
   * // Check button state
   * console.log('Buttons pressed:', pointer.buttons);
   *
   * // Get pointer type and pressure
   * console.log('Type:', pointer.pointerType);
   * console.log('Pressure:', pointer.pressure);
   * ```
   * @readonly
   * @since 7.2.0
   * @see {@link FederatedPointerEvent} For all available pointer properties
   */ get pointer() {
        return this._rootPointerEvent;
    }
    /**
   * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */ _onPointerDown(nativeEvent) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const events = this._normalizeToPointerData(nativeEvent);
        if (this.autoPreventDefault && events[0].isNormalized) {
            const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
            if (cancelable) {
                nativeEvent.preventDefault();
            }
        }
        for(let i = 0, j = events.length; i < j; i++){
            const nativeEvent2 = events[i];
            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
            this.rootBoundary.mapEvent(federatedEvent);
        }
        this.setCursor(this.rootBoundary.cursor);
    }
    /**
   * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch events.
   */ _onPointerMove(nativeEvent) {
        if (!this.features.move) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventsTicker"].pointerMoved();
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for(let i = 0, j = normalizedEvents.length; i < j; i++){
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);
            this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
    }
    /**
   * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */ _onPointerUp(nativeEvent) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let target = nativeEvent.target;
        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
            target = nativeEvent.composedPath()[0];
        }
        const outside = target !== this.domElement ? "outside" : "";
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for(let i = 0, j = normalizedEvents.length; i < j; i++){
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);
            event.type += outside;
            this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
    }
    /**
   * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */ _onPointerOverOut(nativeEvent) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for(let i = 0, j = normalizedEvents.length; i < j; i++){
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);
            this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
    }
    /**
   * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
   * @param nativeEvent - The native wheel event.
   */ onWheel(nativeEvent) {
        if (!this.features.wheel) return;
        const wheelEvent = this.normalizeWheelEvent(nativeEvent);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        this.rootBoundary.mapEvent(wheelEvent);
    }
    /**
   * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
   * This method manages the DOM event bindings for the event system, allowing you to
   * change or remove the target element that receives input events.
   * > [!IMPORTANT] This will default to the canvas element of the renderer, so you
   * > should not need to call this unless you are using a custom element.
   * @param element - The new DOM element to bind events to, or null to remove all event bindings
   * @example
   * ```ts
   * // Set a new canvas element as the target
   * const canvas = document.createElement('canvas');
   * app.renderer.events.setTargetElement(canvas);
   *
   * // Remove all event bindings
   * app.renderer.events.setTargetElement(null);
   *
   * // Switch to a different canvas
   * const newCanvas = document.querySelector('#game-canvas');
   * app.renderer.events.setTargetElement(newCanvas);
   * ```
   * @remarks
   * - Automatically removes event listeners from previous element
   * - Required for the event system to function
   * - Safe to call multiple times
   * @see {@link EventSystem#domElement} The current DOM element
   * @see {@link EventsTicker} For the ticker system that tracks pointer movement
   */ setTargetElement(element) {
        this._removeEvents();
        this.domElement = element;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventsTicker"].domElement = element;
        this._addEvents();
    }
    /** Register event listeners on {@link Renderer#domElement this.domElement}. */ _addEvents() {
        if (this._eventsAdded || !this.domElement) {
            return;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventsTicker"].addTickerListener();
        const style = this.domElement.style;
        if (style) {
            if (globalThis.navigator.msPointerEnabled) {
                style.msContentZooming = "none";
                style.msTouchAction = "none";
            } else if (this.supportsPointerEvents) {
                style.touchAction = "none";
            }
        }
        if (this.supportsPointerEvents) {
            globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
            this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.addEventListener("pointerup", this._onPointerUp, true);
        } else {
            globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
            this.domElement.addEventListener("mousedown", this._onPointerDown, true);
            this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.addEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
                this.domElement.addEventListener("touchstart", this._onPointerDown, true);
                this.domElement.addEventListener("touchend", this._onPointerUp, true);
                this.domElement.addEventListener("touchmove", this._onPointerMove, true);
            }
        }
        this.domElement.addEventListener("wheel", this.onWheel, {
            passive: true,
            capture: true
        });
        this._eventsAdded = true;
    }
    /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */ _removeEvents() {
        if (!this._eventsAdded || !this.domElement) {
            return;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventTicker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventsTicker"].removeTickerListener();
        const style = this.domElement.style;
        if (style) {
            if (globalThis.navigator.msPointerEnabled) {
                style.msContentZooming = "";
                style.msTouchAction = "";
            } else if (this.supportsPointerEvents) {
                style.touchAction = "";
            }
        }
        if (this.supportsPointerEvents) {
            globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
            this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.removeEventListener("pointerup", this._onPointerUp, true);
        } else {
            globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
            this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
            this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.removeEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
                this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
                this.domElement.removeEventListener("touchend", this._onPointerUp, true);
                this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
            }
        }
        this.domElement.removeEventListener("wheel", this.onWheel, true);
        this.domElement = null;
        this._eventsAdded = false;
    }
    /**
   * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.
   * This takes into account the current scale, position, and resolution of the DOM element.
   * @param point - The point to store the mapped coordinates in
   * @param x - The x coordinate in DOM/client space
   * @param y - The y coordinate in DOM/client space
   * @example
   * ```ts
   * // Map mouse coordinates to PixiJS space
   * const point = new Point();
   * app.renderer.events.mapPositionToPoint(
   *     point,
   *     event.clientX,
   *     event.clientY
   * );
   * console.log('Mapped position:', point.x, point.y);
   *
   * // Using with pointer events
   * sprite.on('pointermove', (event) => {
   *     // event.global already contains mapped coordinates
   *     console.log('Global:', event.global.x, event.global.y);
   *
   *     // Map to local coordinates
   *     const local = event.getLocalPosition(sprite);
   *     console.log('Local:', local.x, local.y);
   * });
   * ```
   * @remarks
   * - Accounts for element scaling and positioning
   * - Adjusts for device pixel ratio/resolution
   */ mapPositionToPoint(point, x, y) {
        const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
        };
        const resolutionMultiplier = 1 / this.resolution;
        point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
        point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
    }
    /**
   * Ensures that the original event object contains all data that a regular pointer event would have
   * @param event - The original event data from a touch or mouse event
   * @returns An array containing a single normalized pointer event, in the case of a pointer
   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
   */ _normalizeToPointerData(event) {
        const normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
            for(let i = 0, li = event.changedTouches.length; i < li; i++){
                const touch = event.changedTouches[i];
                if (typeof touch.button === "undefined") touch.button = 0;
                if (typeof touch.buttons === "undefined") touch.buttons = 1;
                if (typeof touch.isPrimary === "undefined") {
                    touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
                }
                if (typeof touch.width === "undefined") touch.width = touch.radiusX || 1;
                if (typeof touch.height === "undefined") touch.height = touch.radiusY || 1;
                if (typeof touch.tiltX === "undefined") touch.tiltX = 0;
                if (typeof touch.tiltY === "undefined") touch.tiltY = 0;
                if (typeof touch.pointerType === "undefined") touch.pointerType = "touch";
                if (typeof touch.pointerId === "undefined") touch.pointerId = touch.identifier || 0;
                if (typeof touch.pressure === "undefined") touch.pressure = touch.force || 0.5;
                if (typeof touch.twist === "undefined") touch.twist = 0;
                if (typeof touch.tangentialPressure === "undefined") touch.tangentialPressure = 0;
                if (typeof touch.layerX === "undefined") touch.layerX = touch.offsetX = touch.clientX;
                if (typeof touch.layerY === "undefined") touch.layerY = touch.offsetY = touch.clientY;
                touch.isNormalized = true;
                touch.type = event.type;
                normalizedEvents.push(touch);
            }
        } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
            const tempEvent = event;
            if (typeof tempEvent.isPrimary === "undefined") tempEvent.isPrimary = true;
            if (typeof tempEvent.width === "undefined") tempEvent.width = 1;
            if (typeof tempEvent.height === "undefined") tempEvent.height = 1;
            if (typeof tempEvent.tiltX === "undefined") tempEvent.tiltX = 0;
            if (typeof tempEvent.tiltY === "undefined") tempEvent.tiltY = 0;
            if (typeof tempEvent.pointerType === "undefined") tempEvent.pointerType = "mouse";
            if (typeof tempEvent.pointerId === "undefined") tempEvent.pointerId = MOUSE_POINTER_ID;
            if (typeof tempEvent.pressure === "undefined") tempEvent.pressure = 0.5;
            if (typeof tempEvent.twist === "undefined") tempEvent.twist = 0;
            if (typeof tempEvent.tangentialPressure === "undefined") tempEvent.tangentialPressure = 0;
            tempEvent.isNormalized = true;
            normalizedEvents.push(tempEvent);
        } else {
            normalizedEvents.push(event);
        }
        return normalizedEvents;
    }
    /**
   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
   *
   * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
   * multiple native wheel events.
   * @param nativeEvent - The native wheel event that occurred on the canvas.
   * @returns A federated wheel event.
   */ normalizeWheelEvent(nativeEvent) {
        const event = this._rootWheelEvent;
        this._transferMouseData(event, nativeEvent);
        event.deltaX = nativeEvent.deltaX;
        event.deltaY = nativeEvent.deltaY;
        event.deltaZ = nativeEvent.deltaZ;
        event.deltaMode = nativeEvent.deltaMode;
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.nativeEvent = nativeEvent;
        event.type = nativeEvent.type;
        return event;
    }
    /**
   * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
   * @param event
   * @param nativeEvent
   */ _bootstrapEvent(event, nativeEvent) {
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = nativeEvent.pointerId;
        event.width = nativeEvent.width;
        event.height = nativeEvent.height;
        event.isPrimary = nativeEvent.isPrimary;
        event.pointerType = nativeEvent.pointerType;
        event.pressure = nativeEvent.pressure;
        event.tangentialPressure = nativeEvent.tangentialPressure;
        event.tiltX = nativeEvent.tiltX;
        event.tiltY = nativeEvent.tiltY;
        event.twist = nativeEvent.twist;
        this._transferMouseData(event, nativeEvent);
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === "pointerleave") {
            event.type = "pointerout";
        }
        if (event.type.startsWith("mouse")) {
            event.type = event.type.replace("mouse", "pointer");
        }
        if (event.type.startsWith("touch")) {
            event.type = TOUCH_TO_POINTER[event.type] || event.type;
        }
        return event;
    }
    /**
   * Transfers base & mouse event data from the `nativeEvent` to the federated event.
   * @param event
   * @param nativeEvent
   */ _transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = performance.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.metaKey = nativeEvent.metaKey;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.relatedTarget = null;
        event.shiftKey = nativeEvent.shiftKey;
    }
};
/** @ignore */ _EventSystem.extension = {
    name: "events",
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].CanvasSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUSystem
    ],
    priority: -1
};
/**
 * The event features that are enabled by the EventSystem
 * @since 7.2.0
 * @example
 * ```ts
 * import { EventSystem, EventSystemFeatures } from 'pixi.js';
 * // Access the default event features
 * EventSystem.defaultEventFeatures = {
 *     // Enable pointer movement events
 *     move: true,
 *     // Enable global pointer move events
 *     globalMove: true,
 *     // Enable click events
 *     click: true,
 *     // Enable wheel events
 *     wheel: true,
 * };
 * ```
 */ _EventSystem.defaultEventFeatures = {
    /** Enables pointer events associated with pointer movement. */ move: true,
    /** Enables global pointer move events. */ globalMove: true,
    /** Enables pointer events associated with clicking. */ click: true,
    /** Enables wheel events. */ wheel: true
};
let EventSystem = _EventSystem;
;
 //# sourceMappingURL=EventSystem.mjs.map
}),
"[project]/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FederatedContainer",
    ()=>FederatedContainer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventSystem$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/EventSystem.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/FederatedEvent.mjs [app-client] (ecmascript)");
;
;
"use strict";
const FederatedContainer = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    get interactive () {
        return this.eventMode === "dynamic" || this.eventMode === "static";
    },
    set interactive (value){
        this.eventMode = value ? "static" : "passive";
    },
    _internalEventMode: void 0,
    get eventMode () {
        return this._internalEventMode ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$EventSystem$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventSystem"].defaultEventMode;
    },
    set eventMode (value){
        this._internalEventMode = value;
    },
    isInteractive () {
        return this.eventMode === "static" || this.eventMode === "dynamic";
    },
    interactiveChildren: true,
    hitArea: null,
    addEventListener (type, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const signal = typeof options === "object" ? options.signal : void 0;
        const once = typeof options === "object" ? options.once === true : false;
        const context = typeof listener === "function" ? void 0 : listener;
        type = capture ? `${type}capture` : type;
        const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
        const emitter = this;
        if (signal) {
            signal.addEventListener("abort", ()=>{
                emitter.off(type, listenerFn, context);
            });
        }
        if (once) {
            emitter.once(type, listenerFn, context);
        } else {
            emitter.on(type, listenerFn, context);
        }
    },
    removeEventListener (type, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const context = typeof listener === "function" ? void 0 : listener;
        type = capture ? `${type}capture` : type;
        listener = typeof listener === "function" ? listener : listener.handleEvent;
        this.off(type, listener, context);
    },
    dispatchEvent (e) {
        if (!(e instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedEvent"])) {
            throw new Error("Container cannot propagate events outside of the Federated Events API");
        }
        e.defaultPrevented = false;
        e.path = null;
        e.target = this;
        e.manager.dispatchEvent(e);
        return !e.defaultPrevented;
    }
};
;
 //# sourceMappingURL=FederatedEventTarget.mjs.map
}),
"[project]/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AccessibilitySystem",
    ()=>AccessibilitySystem
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$dom$2f$CanvasObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/dom/CanvasObserver.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/events/FederatedEvent.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isMobile$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/browser/isMobile.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$removeItems$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/data/removeItems.mjs [app-client] (ecmascript)");
;
;
;
;
;
"use strict";
const KEY_CODE_TAB = 9;
const DIV_TOUCH_SIZE = 100;
const DIV_TOUCH_POS_X = 0;
const DIV_TOUCH_POS_Y = 0;
const DIV_TOUCH_ZINDEX = 2;
const DIV_HOOK_SIZE = 1;
const DIV_HOOK_POS_X = -1e3;
const DIV_HOOK_POS_Y = -1e3;
const DIV_HOOK_ZINDEX = 2;
const _AccessibilitySystem = class _AccessibilitySystem {
    // eslint-disable-next-line jsdoc/require-param
    /**
   * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
   */ constructor(renderer, _mobileInfo = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isMobile$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMobile"]){
        this._mobileInfo = _mobileInfo;
        /** Whether accessibility divs are visible for debugging */ this.debug = false;
        /** Whether to activate on tab key press */ this._activateOnTab = true;
        /** Whether to deactivate accessibility when mouse moves */ this._deactivateOnMouseMove = true;
        /** Internal variable, see isActive getter. */ this._isActive = false;
        /** Internal variable, see isMobileAccessibility getter. */ this._isMobileAccessibility = false;
        /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */ this._div = null;
        /** A simple pool for storing divs. */ this._pools = {};
        /** This is a tick used to check if an object is no longer being rendered. */ this._renderId = 0;
        /** The array of currently active accessible items. */ this._children = [];
        /** Count to throttle div updates on android devices. */ this._androidUpdateCount = 0;
        /**  The frequency to update the div elements. */ this._androidUpdateFrequency = 500;
        // eslint-disable-next-line @typescript-eslint/prefer-readonly
        this._isRunningTests = false;
        /** Bound function references for proper event listener removal */ this._boundOnKeyDown = this._onKeyDown.bind(this);
        this._boundOnMouseMove = this._onMouseMove.bind(this);
        this._hookDiv = null;
        if (_mobileInfo.tablet || _mobileInfo.phone) {
            this._createTouchHook();
        }
        this._renderer = renderer;
    }
    /**
   * Value of `true` if accessibility is currently active and accessibility layers are showing.
   * @type {boolean}
   * @readonly
   */ get isActive() {
        return this._isActive;
    }
    /**
   * Value of `true` if accessibility is enabled for touch devices.
   * @type {boolean}
   * @readonly
   */ get isMobileAccessibility() {
        return this._isMobileAccessibility;
    }
    /**
   * Button element for handling touch hooks.
   * @readonly
   */ get hookDiv() {
        return this._hookDiv;
    }
    /**
   * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.
   * @readonly
   */ get div() {
        return this._div;
    }
    /**
   * Creates the touch hooks.
   * @private
   */ _createTouchHook() {
        const hookDiv = document.createElement("button");
        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.position = "absolute";
        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = "#FF0000";
        hookDiv.title = "select to enable accessibility for this content";
        hookDiv.addEventListener("focus", ()=>{
            this._isMobileAccessibility = true;
            this._activate();
            this._destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
    }
    /**
   * Destroys the touch hooks.
   * @private
   */ _destroyTouchHook() {
        if (!this._hookDiv) {
            return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
    }
    /**
   * Activating will cause the Accessibility layer to be shown.
   * This is called when a user presses the tab key.
   * @private
   */ _activate() {
        if (this._isActive) {
            return;
        }
        this._isActive = true;
        if (!this._div) {
            this._div = document.createElement("div");
            this._div.style.position = "absolute";
            this._div.style.top = `${DIV_TOUCH_POS_X}px`;
            this._div.style.left = `${DIV_TOUCH_POS_Y}px`;
            this._div.style.pointerEvents = "none";
            this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
            this._canvasObserver = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$dom$2f$CanvasObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CanvasObserver"]({
                domElement: this._div,
                renderer: this._renderer
            });
        }
        if (this._activateOnTab) {
            globalThis.addEventListener("keydown", this._boundOnKeyDown, false);
        }
        if (this._deactivateOnMouseMove) {
            globalThis.document.addEventListener("mousemove", this._boundOnMouseMove, true);
        }
        const canvas = this._renderer.view.canvas;
        if (!canvas.parentNode) {
            const observer = new MutationObserver(()=>{
                if (canvas.parentNode) {
                    observer.disconnect();
                    this._canvasObserver.ensureAttached();
                    this._initAccessibilitySetup();
                }
            });
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        } else {
            this._canvasObserver.ensureAttached();
            this._initAccessibilitySetup();
        }
    }
    // New method to handle initialization after div is ready
    _initAccessibilitySetup() {
        this._renderer.runners.postrender.add(this);
        if (this._renderer.lastObjectRendered) {
            this._updateAccessibleObjects(this._renderer.lastObjectRendered);
        }
    }
    /**
   * Deactivates the accessibility system. Removes listeners and accessibility elements.
   * @private
   */ _deactivate() {
        if (!this._isActive || this._isMobileAccessibility) {
            return;
        }
        this._isActive = false;
        globalThis.document.removeEventListener("mousemove", this._boundOnMouseMove, true);
        if (this._activateOnTab) {
            globalThis.addEventListener("keydown", this._boundOnKeyDown, false);
        }
        this._renderer.runners.postrender.remove(this);
        for (const child of this._children){
            if (child._accessibleDiv?.parentNode) {
                child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
                child._accessibleDiv = null;
            }
            child._accessibleActive = false;
        }
        for(const accessibleType in this._pools){
            const pool = this._pools[accessibleType];
            pool.forEach((div)=>{
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
            });
            delete this._pools[accessibleType];
        }
        if (this._div?.parentNode) {
            this._div.parentNode.removeChild(this._div);
        }
        this._pools = {};
        this._children = [];
    }
    /**
   * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
   * @private
   * @param {Container} container - The Container to check.
   */ _updateAccessibleObjects(container) {
        if (!container.visible || !container.accessibleChildren) {
            return;
        }
        if (container.accessible) {
            if (!container._accessibleActive) {
                this._addChild(container);
            }
            container._renderId = this._renderId;
        }
        const children = container.children;
        if (children) {
            for(let i = 0; i < children.length; i++){
                this._updateAccessibleObjects(children[i]);
            }
        }
    }
    /**
   * Runner init called, view is available at this point.
   * @ignore
   */ init(options) {
        const defaultOpts = _AccessibilitySystem.defaultOptions;
        const mergedOptions = {
            accessibilityOptions: {
                ...defaultOpts,
                ...options?.accessibilityOptions || {}
            }
        };
        this.debug = mergedOptions.accessibilityOptions.debug;
        this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;
        this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;
        if (mergedOptions.accessibilityOptions.enabledByDefault) {
            this._activate();
        }
        this._renderer.runners.postrender.remove(this);
    }
    /**
   * Updates the accessibility layer during rendering.
   * - Removes divs for containers no longer in the scene
   * - Updates the position and dimensions of the root div
   * - Updates positions of active accessibility divs
   * Only fires while the accessibility system is active.
   * @ignore
   */ postrender() {
        const now = performance.now();
        if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
            return;
        }
        this._androidUpdateCount = now + this._androidUpdateFrequency;
        if ((!this._renderer.renderingToScreen || !this._renderer.view.canvas) && !this._isRunningTests) {
            return;
        }
        const activeIds = /* @__PURE__ */ new Set();
        if (this._renderer.lastObjectRendered) {
            this._updateAccessibleObjects(this._renderer.lastObjectRendered);
            for (const child of this._children){
                if (child._renderId === this._renderId) {
                    activeIds.add(this._children.indexOf(child));
                }
            }
        }
        for(let i = this._children.length - 1; i >= 0; i--){
            const child = this._children[i];
            if (!activeIds.has(i)) {
                if (child._accessibleDiv && child._accessibleDiv.parentNode) {
                    child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
                    const pool = this._getPool(child.accessibleType);
                    pool.push(child._accessibleDiv);
                    child._accessibleDiv = null;
                }
                child._accessibleActive = false;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$data$2f$removeItems$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["removeItems"])(this._children, i, 1);
            }
        }
        if (this._renderer.renderingToScreen) {
            this._canvasObserver.ensureAttached();
        }
        for(let i = 0; i < this._children.length; i++){
            const child = this._children[i];
            if (!child._accessibleActive || !child._accessibleDiv) {
                continue;
            }
            const div = child._accessibleDiv;
            const hitArea = child.hitArea || child.getBounds().rectangle;
            if (child.hitArea) {
                const wt = child.worldTransform;
                div.style.left = `${wt.tx + hitArea.x * wt.a}px`;
                div.style.top = `${wt.ty + hitArea.y * wt.d}px`;
                div.style.width = `${hitArea.width * wt.a}px`;
                div.style.height = `${hitArea.height * wt.d}px`;
            } else {
                this._capHitArea(hitArea);
                div.style.left = `${hitArea.x}px`;
                div.style.top = `${hitArea.y}px`;
                div.style.width = `${hitArea.width}px`;
                div.style.height = `${hitArea.height}px`;
            }
        }
        this._renderId++;
    }
    /**
   * private function that will visually add the information to the
   * accessibility div
   * @param {HTMLElement} div -
   */ _updateDebugHTML(div) {
        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
    }
    /**
   * Adjust the hit area based on the bounds of a display object
   * @param {Rectangle} hitArea - Bounds of the child
   */ _capHitArea(hitArea) {
        if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
        }
        if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
        }
        const { width: viewWidth, height: viewHeight } = this._renderer;
        if (hitArea.x + hitArea.width > viewWidth) {
            hitArea.width = viewWidth - hitArea.x;
        }
        if (hitArea.y + hitArea.height > viewHeight) {
            hitArea.height = viewHeight - hitArea.y;
        }
    }
    /**
   * Creates or reuses a div element for a Container and adds it to the accessibility layer.
   * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.
   * @private
   * @param {Container} container - The child to make accessible.
   */ _addChild(container) {
        const pool = this._getPool(container.accessibleType);
        let div = pool.pop();
        if (div) {
            div.innerHTML = "";
            div.removeAttribute("title");
            div.removeAttribute("aria-label");
            div.tabIndex = 0;
        } else {
            if (container.accessibleType === "button") {
                div = document.createElement("button");
            } else {
                div = document.createElement(container.accessibleType);
                div.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `;
                if (container.accessibleText) {
                    div.innerText = container.accessibleText;
                }
            }
            div.style.width = `${DIV_TOUCH_SIZE}px`;
            div.style.height = `${DIV_TOUCH_SIZE}px`;
            div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
            div.style.position = "absolute";
            div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
            div.style.borderStyle = "none";
            if (navigator.userAgent.toLowerCase().includes("chrome")) {
                div.setAttribute("aria-live", "off");
            } else {
                div.setAttribute("aria-live", "polite");
            }
            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
                div.setAttribute("aria-relevant", "additions");
            } else {
                div.setAttribute("aria-relevant", "text");
            }
            div.addEventListener("click", this._onClick.bind(this));
            div.addEventListener("focus", this._onFocus.bind(this));
            div.addEventListener("focusout", this._onFocusOut.bind(this));
        }
        div.style.pointerEvents = container.accessiblePointerEvents;
        div.type = container.accessibleType;
        if (container.accessibleTitle && container.accessibleTitle !== null) {
            div.title = container.accessibleTitle;
        } else if (!container.accessibleHint || container.accessibleHint === null) {
            div.title = `container ${container.tabIndex}`;
        }
        if (container.accessibleHint && container.accessibleHint !== null) {
            div.setAttribute("aria-label", container.accessibleHint);
        }
        if (container.interactive) {
            div.tabIndex = container.tabIndex;
        } else {
            div.tabIndex = 0;
        }
        if (this.debug) {
            this._updateDebugHTML(div);
        }
        container._accessibleActive = true;
        container._accessibleDiv = div;
        div.container = container;
        this._children.push(container);
        this._div.appendChild(container._accessibleDiv);
    }
    /**
   * Dispatch events with the EventSystem.
   * @param e
   * @param type
   * @private
   */ _dispatchEvent(e, type) {
        const { container: target } = e.target;
        const boundary = this._renderer.events.rootBoundary;
        const event = Object.assign(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$events$2f$FederatedEvent$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FederatedEvent"](boundary), {
            target
        });
        boundary.rootTarget = this._renderer.lastObjectRendered;
        type.forEach((type2)=>boundary.dispatchEvent(event, type2));
    }
    /**
   * Maps the div button press to pixi's EventSystem (click)
   * @private
   * @param {MouseEvent} e - The click event.
   */ _onClick(e) {
        this._dispatchEvent(e, [
            "click",
            "pointertap",
            "tap"
        ]);
    }
    /**
   * Maps the div focus events to pixi's EventSystem (mouseover)
   * @private
   * @param {FocusEvent} e - The focus event.
   */ _onFocus(e) {
        if (!e.target.getAttribute("aria-live")) {
            e.target.setAttribute("aria-live", "assertive");
        }
        this._dispatchEvent(e, [
            "mouseover"
        ]);
    }
    /**
   * Maps the div focus events to pixi's EventSystem (mouseout)
   * @private
   * @param {FocusEvent} e - The focusout event.
   */ _onFocusOut(e) {
        if (!e.target.getAttribute("aria-live")) {
            e.target.setAttribute("aria-live", "polite");
        }
        this._dispatchEvent(e, [
            "mouseout"
        ]);
    }
    /**
   * Is called when a key is pressed
   * @private
   * @param {KeyboardEvent} e - The keydown event.
   */ _onKeyDown(e) {
        if (e.keyCode !== KEY_CODE_TAB || !this._activateOnTab) {
            return;
        }
        this._activate();
    }
    /**
   * Is called when the mouse moves across the renderer element
   * @private
   * @param {MouseEvent} e - The mouse event.
   */ _onMouseMove(e) {
        if (e.movementX === 0 && e.movementY === 0) {
            return;
        }
        this._deactivate();
    }
    /**
   * Destroys the accessibility system. Removes all elements and listeners.
   * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.
   * > A typically user should not need to call this method directly.
   */ destroy() {
        this._deactivate();
        this._destroyTouchHook();
        this._canvasObserver?.destroy();
        this._canvasObserver = null;
        this._div = null;
        this._pools = null;
        this._children = null;
        this._renderer = null;
        this._hookDiv = null;
        globalThis.removeEventListener("keydown", this._boundOnKeyDown);
        this._boundOnKeyDown = null;
        globalThis.document.removeEventListener("mousemove", this._boundOnMouseMove, true);
        this._boundOnMouseMove = null;
    }
    /**
   * Enables or disables the accessibility system.
   * @param enabled - Whether to enable or disable accessibility.
   * @example
   * ```js
   * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility
   * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility
   * ```
   */ setAccessibilityEnabled(enabled) {
        if (enabled) {
            this._activate();
        } else {
            this._deactivate();
        }
    }
    _getPool(accessibleType) {
        if (!this._pools[accessibleType]) {
            this._pools[accessibleType] = [];
        }
        return this._pools[accessibleType];
    }
};
/** @ignore */ _AccessibilitySystem.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUSystem
    ],
    name: "accessibility"
};
/**
 * The default options used by the system.
 * You can set these before initializing the {@link Application} to change the default behavior.
 * @example
 * ```js
 * import { AccessibilitySystem } from 'pixi.js';
 *
 * AccessibilitySystem.defaultOptions.enabledByDefault = true;
 *
 * const app = new Application()
 * app.init()
 * ```
 */ _AccessibilitySystem.defaultOptions = {
    /**
   * Whether to enable accessibility features on initialization
   * @default false
   */ enabledByDefault: false,
    /**
   * Whether to visually show the accessibility divs for debugging
   * @default false
   */ debug: false,
    /**
   * Whether to activate accessibility when tab key is pressed
   * @default true
   */ activateOnTab: true,
    /**
   * Whether to deactivate accessibility when mouse moves
   * @default true
   */ deactivateOnMouseMove: true
};
let AccessibilitySystem = _AccessibilitySystem;
;
 //# sourceMappingURL=AccessibilitySystem.mjs.map
}),
"[project]/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "accessibilityTarget",
    ()=>accessibilityTarget
]);
"use strict";
const accessibilityTarget = {
    accessible: false,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    accessibleType: "button",
    accessibleText: null,
    accessiblePointerEvents: "auto",
    accessibleChildren: true,
    _accessibleActive: false,
    _accessibleDiv: null,
    _renderId: -1
};
;
 //# sourceMappingURL=accessibilityTarget.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ColorBlend",
    ()=>ColorBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$hls$2f$GLhls$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$hls$2f$GPUhls$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs [app-client] (ecmascript)");
;
;
;
;
"use strict";
class ColorBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$hls$2f$GLhls$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hslgl"]}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                finalColor = vec4(blendColor(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$hls$2f$GPUhls$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hslgpu"]}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
        });
    }
}
/** @ignore */ ColorBlend.extension = {
    name: "color",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=ColorBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ColorBurnBlend",
    ()=>ColorBurnBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class ColorBurnBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                finalColor = vec4(blendColorBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
            },
            gpu: {
                functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
        });
    }
}
/** @ignore */ ColorBurnBlend.extension = {
    name: "color-burn",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=ColorBurnBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ColorDodgeBlend",
    ()=>ColorDodgeBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class ColorDodgeBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                finalColor = vec4(blendColorDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
        });
    }
}
/** @ignore */ ColorDodgeBlend.extension = {
    name: "color-dodge",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=ColorDodgeBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DarkenBlend",
    ()=>DarkenBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class DarkenBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                finalColor = vec4(blendDarken(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
        });
    }
}
/** @ignore */ DarkenBlend.extension = {
    name: "darken",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=DarkenBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DifferenceBlend",
    ()=>DifferenceBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class DifferenceBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                finalColor = vec4(blendDifference(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
            },
            gpu: {
                functions: `
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
        });
    }
}
/** @ignore */ DifferenceBlend.extension = {
    name: "difference",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=DifferenceBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DivideBlend",
    ()=>DivideBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class DivideBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                finalColor = vec4(blendDivide(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
        });
    }
}
/** @ignore */ DivideBlend.extension = {
    name: "divide",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=DivideBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ExclusionBlend",
    ()=>ExclusionBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class ExclusionBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                finalColor = vec4(blendExclusion(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
        });
    }
}
/** @ignore */ ExclusionBlend.extension = {
    name: "exclusion",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=ExclusionBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HardLightBlend",
    ()=>HardLightBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class HardLightBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                finalColor = vec4(blendHardLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
            },
            gpu: {
                functions: `
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
        });
    }
}
/** @ignore */ HardLightBlend.extension = {
    name: "hard-light",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=HardLightBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HardMixBlend",
    ()=>HardMixBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class HardMixBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                finalColor = vec4(blendHardMix(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
            },
            gpu: {
                functions: `
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
        });
    }
}
/** @ignore */ HardMixBlend.extension = {
    name: "hard-mix",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=HardMixBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "LightenBlend",
    ()=>LightenBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class LightenBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                finalColor = vec4(blendLighten(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
        });
    }
}
/** @ignore */ LightenBlend.extension = {
    name: "lighten",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=LightenBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "LinearBurnBlend",
    ()=>LinearBurnBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class LinearBurnBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                finalColor = vec4(blendLinearBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
        });
    }
}
/** @ignore */ LinearBurnBlend.extension = {
    name: "linear-burn",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=LinearBurnBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "LinearDodgeBlend",
    ()=>LinearDodgeBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class LinearDodgeBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                finalColor = vec4(blendLinearDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
        });
    }
}
/** @ignore */ LinearDodgeBlend.extension = {
    name: "linear-dodge",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=LinearDodgeBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "LinearLightBlend",
    ()=>LinearLightBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class LinearLightBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                finalColor = vec4(blendLinearLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
        });
    }
}
/** @ignore */ LinearLightBlend.extension = {
    name: "linear-light",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=LinearLightBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "LuminosityBlend",
    ()=>LuminosityBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$hls$2f$GLhls$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$hls$2f$GPUhls$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs [app-client] (ecmascript)");
;
;
;
;
"use strict";
class LuminosityBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$hls$2f$GLhls$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hslgl"]}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                finalColor = vec4(blendLuminosity(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$hls$2f$GPUhls$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hslgpu"]}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
        });
    }
}
/** @ignore */ LuminosityBlend.extension = {
    name: "luminosity",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=LuminosityBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NegationBlend",
    ()=>NegationBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class NegationBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                finalColor = vec4(blendNegation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
        });
    }
}
/** @ignore */ NegationBlend.extension = {
    name: "negation",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=NegationBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "OverlayBlend",
    ()=>OverlayBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class OverlayBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                float overlay(float base, float blend)
                {
                    return (base < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                finalColor = vec4(blendOverlay(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
        });
    }
}
/** @ignore */ OverlayBlend.extension = {
    name: "overlay",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=OverlayBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PinLightBlend",
    ()=>PinLightBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class PinLightBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                finalColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
        });
    }
}
/** @ignore */ PinLightBlend.extension = {
    name: "pin-light",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=PinLightBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SaturationBlend",
    ()=>SaturationBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$hls$2f$GLhls$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$hls$2f$GPUhls$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs [app-client] (ecmascript)");
;
;
;
;
"use strict";
class SaturationBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$hls$2f$GLhls$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hslgl"]}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                finalColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
            `
            },
            gpu: {
                functions: `
                ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$hls$2f$GPUhls$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hslgpu"]}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
        });
    }
}
/** @ignore */ SaturationBlend.extension = {
    name: "saturation",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=SaturationBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SoftLightBlend",
    ()=>SoftLightBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class SoftLightBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                finalColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
        });
    }
}
/** @ignore */ SoftLightBlend.extension = {
    name: "soft-light",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=SoftLightBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SubtractBlend",
    ()=>SubtractBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class SubtractBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                finalColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
                functions: `
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
        });
    }
}
/** @ignore */ SubtractBlend.extension = {
    name: "subtract",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=SubtractBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VividLightBlend",
    ()=>VividLightBlend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs [app-client] (ecmascript)");
;
;
"use strict";
class VividLightBlend extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$filters$2f$blend$2d$modes$2f$BlendModeFilter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlendModeFilter"] {
    constructor(){
        super({
            gl: {
                functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
                main: `
                finalColor = vec4(blendVividLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
            },
            gpu: {
                functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
                main: `
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
        });
    }
}
/** @ignore */ VividLightBlend.extension = {
    name: "vivid-light",
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].BlendMode
};
;
 //# sourceMappingURL=VividLightBlend.mjs.map
}),
"[project]/node_modules/pixi.js/lib/app/Application.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Application",
    ()=>Application
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$autoDetectRenderer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/Container.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$global$2f$globalHooks$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/global/globalHooks.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/logging/deprecation.mjs [app-client] (ecmascript)");
;
;
;
;
;
"use strict";
const _Application = class _Application {
    constructor(...args){
        /**
     * The root display container for your application.
     * All visual elements should be added to this container or its children.
     * @example
     * ```js
     * // Create a sprite and add it to the stage
     * const sprite = Sprite.from('image.png');
     * app.stage.addChild(sprite);
     *
     * // Create a container for grouping objects
     * const container = new Container();
     * app.stage.addChild(container);
     * ```
     */ this.stage = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Container"]();
        if (args[0] !== void 0) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["v8_0_0"], "Application constructor options are deprecated, please use Application.init() instead.");
        }
    }
    /**
   * Initializes the PixiJS application with the specified options.
   *
   * This method must be called after creating a new Application instance.
   * @param options - Configuration options for the application and renderer
   * @returns A promise that resolves when initialization is complete
   * @example
   * ```js
   * const app = new Application();
   *
   * // Initialize with custom options
   * await app.init({
   *     width: 800,
   *     height: 600,
   *     backgroundColor: 0x1099bb,
   *     preference: 'webgl', // or 'webgpu'
   * });
   * ```
   */ async init(options) {
        options = {
            ...options
        };
        this.stage || (this.stage = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Container"]());
        this.renderer = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$autoDetectRenderer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["autoDetectRenderer"])(options);
        _Application._plugins.forEach((plugin)=>{
            plugin.init.call(this, options);
        });
    }
    /**
   * Renders the current stage to the screen.
   *
   * When using the default setup with {@link TickerPlugin} (enabled by default), you typically don't need to call
   * this method directly as rendering is handled automatically.
   *
   * Only use this method if you've disabled the {@link TickerPlugin} or need custom
   * render timing control.
   * @example
   * ```js
   * // Example 1: Default setup (TickerPlugin handles rendering)
   * const app = new Application();
   * await app.init();
   * // No need to call render() - TickerPlugin handles it
   *
   * // Example 2: Custom rendering loop (if TickerPlugin is disabled)
   * const app = new Application();
   * await app.init({ autoStart: false }); // Disable automatic rendering
   *
   * function animate() {
   *     app.render();
   *     requestAnimationFrame(animate);
   * }
   * animate();
   * ```
   */ render() {
        this.renderer.render({
            container: this.stage
        });
    }
    /**
   * Reference to the renderer's canvas element. This is the HTML element
   * that displays your application's graphics.
   * @readonly
   * @type {HTMLCanvasElement}
   * @example
   * ```js
   * // Create a new application
   * const app = new Application();
   * // Initialize the application
   * await app.init({...});
   * // Add canvas to the page
   * document.body.appendChild(app.canvas);
   *
   * // Access the canvas directly
   * console.log(app.canvas); // HTMLCanvasElement
   * ```
   */ get canvas() {
        return this.renderer.canvas;
    }
    /**
   * Reference to the renderer's canvas element.
   * @type {HTMLCanvasElement}
   * @deprecated since 8.0.0
   * @see {@link Application#canvas}
   */ get view() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deprecation"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$logging$2f$deprecation$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["v8_0_0"], "Application.view is deprecated, please use Application.canvas instead.");
        return this.renderer.canvas;
    }
    /**
   * Reference to the renderer's screen rectangle. This represents the visible area of your application.
   *
   * It's commonly used for:
   * - Setting filter areas for full-screen effects
   * - Defining hit areas for screen-wide interaction
   * - Determining the visible bounds of your application
   * @readonly
   * @example
   * ```js
   * // Use as filter area for a full-screen effect
   * const blurFilter = new BlurFilter();
   * sprite.filterArea = app.screen;
   *
   * // Use as hit area for screen-wide interaction
   * const screenSprite = new Sprite();
   * screenSprite.hitArea = app.screen;
   *
   * // Get screen dimensions
   * console.log(app.screen.width, app.screen.height);
   * ```
   * @see {@link Rectangle} For all available properties and methods
   */ get screen() {
        return this.renderer.screen;
    }
    /**
   * Destroys the application and all of its resources.
   *
   * This method should be called when you want to completely
   * clean up the application and free all associated memory.
   * @param rendererDestroyOptions - Options for destroying the renderer:
   *  - `false` or `undefined`: Preserves the canvas element (default)
   *  - `true`: Removes the canvas element
   *  - `{ removeView: boolean }`: Object with removeView property to control canvas removal
   * @param options - Options for destroying the application:
   *  - `false` or `undefined`: Basic cleanup (default)
   *  - `true`: Complete cleanup including children
   *  - Detailed options object:
   *    - `children`: Remove children
   *    - `texture`: Destroy textures
   *    - `textureSource`: Destroy texture sources
   *    - `context`: Destroy WebGL context
   * @example
   * ```js
   * // Basic cleanup
   * app.destroy();
   *
   * // Remove canvas and do complete cleanup
   * app.destroy(true, true);
   *
   * // Remove canvas with explicit options
   * app.destroy({ removeView: true }, true);
   *
   * // Detailed cleanup with specific options
   * app.destroy(
   *     { removeView: true },
   *     {
   *         children: true,
   *         texture: true,
   *         textureSource: true,
   *         context: true
   *     }
   * );
   * ```
   * > [!WARNING] After calling destroy, the application instance should no longer be used.
   * > All properties will be null and further operations will throw errors.
   */ destroy(rendererDestroyOptions = false, options = false) {
        const plugins = _Application._plugins.slice(0);
        plugins.reverse();
        plugins.forEach((plugin)=>{
            plugin.destroy.call(this);
        });
        this.stage.destroy(options);
        this.stage = null;
        this.renderer.destroy(rendererDestroyOptions);
        this.renderer = null;
    }
};
/**
 * Collection of installed plugins.
 * @internal
 */ _Application._plugins = [];
let Application = _Application;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extensions"].handleByList(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].Application, Application._plugins);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extensions"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$global$2f$globalHooks$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ApplicationInitHook"]);
;
 //# sourceMappingURL=Application.mjs.map
}),
"[project]/node_modules/pixi.js/lib/app/ResizePlugin.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ResizePlugin",
    ()=>ResizePlugin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
;
"use strict";
class ResizePlugin {
    /**
   * Initialize the plugin with scope of application instance
   * @private
   * @param {object} [options] - See application options
   */ static init(options) {
        Object.defineProperty(this, "resizeTo", {
            configurable: true,
            set (dom) {
                globalThis.removeEventListener("resize", this.queueResize);
                this._resizeTo = dom;
                if (dom) {
                    globalThis.addEventListener("resize", this.queueResize);
                    this.resize();
                }
            },
            get () {
                return this._resizeTo;
            }
        });
        this.queueResize = ()=>{
            if (!this._resizeTo) {
                return;
            }
            this._cancelResize();
            this._resizeId = requestAnimationFrame(()=>this.resize());
        };
        this._cancelResize = ()=>{
            if (this._resizeId) {
                cancelAnimationFrame(this._resizeId);
                this._resizeId = null;
            }
        };
        this.resize = ()=>{
            if (!this._resizeTo) {
                return;
            }
            this._cancelResize();
            let width;
            let height;
            if (this._resizeTo === globalThis.window) {
                width = globalThis.innerWidth;
                height = globalThis.innerHeight;
            } else {
                const { clientWidth, clientHeight } = this._resizeTo;
                width = clientWidth;
                height = clientHeight;
            }
            this.renderer.resize(width, height);
            this.render();
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
    }
    /**
   * Clean up the ticker, scoped to application
   * @private
   */ static destroy() {
        globalThis.removeEventListener("resize", this.queueResize);
        this._cancelResize();
        this._cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
    }
}
/** @ignore */ ResizePlugin.extension = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].Application;
;
 //# sourceMappingURL=ResizePlugin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/app/TickerPlugin.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TickerPlugin",
    ()=>TickerPlugin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/ticker/const.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/ticker/Ticker.mjs [app-client] (ecmascript)");
;
;
;
"use strict";
class TickerPlugin {
    /**
   * Initialize the plugin with scope of application instance
   * @private
   * @param {object} [options] - See application options
   */ static init(options) {
        options = Object.assign({
            autoStart: true,
            sharedTicker: false
        }, options);
        Object.defineProperty(this, "ticker", {
            configurable: true,
            set (ticker) {
                if (this._ticker) {
                    this._ticker.remove(this.render, this);
                }
                this._ticker = ticker;
                if (ticker) {
                    ticker.add(this.render, this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UPDATE_PRIORITY"].LOW);
                }
            },
            get () {
                return this._ticker;
            }
        });
        this.stop = ()=>{
            this._ticker.stop();
        };
        this.start = ()=>{
            this._ticker.start();
        };
        this._ticker = null;
        this.ticker = options.sharedTicker ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ticker"].shared : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ticker"]();
        if (options.autoStart) {
            this.start();
        }
    }
    /**
   * Clean up the ticker, scoped to application.
   * @private
   */ static destroy() {
        if (this._ticker) {
            const oldTicker = this._ticker;
            this.ticker = null;
            oldTicker.destroy();
        }
    }
}
/** @ignore */ TickerPlugin.extension = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].Application;
;
 //# sourceMappingURL=TickerPlugin.mjs.map
}),
"[project]/node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>WorkerInstance
]);
const WORKER_CODE = "(function () {\n    'use strict';\n\n    const WHITE_PNG = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\";\n    async function checkImageBitmap() {\n      try {\n        if (typeof createImageBitmap !== \"function\")\n          return false;\n        const response = await fetch(WHITE_PNG);\n        const imageBlob = await response.blob();\n        const imageBitmap = await createImageBitmap(imageBlob);\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\n      } catch (_e) {\n        return false;\n      }\n    }\n    void checkImageBitmap().then((result) => {\n      self.postMessage(result);\n    });\n\n})();\n";
let WORKER_URL = null;
class WorkerInstance {
    constructor(){
        if (!WORKER_URL) {
            WORKER_URL = URL.createObjectURL(new Blob([
                WORKER_CODE
            ], {
                type: 'application/javascript'
            }));
        }
        this.worker = new Worker(WORKER_URL);
    }
}
WorkerInstance.revokeObjectURL = function revokeObjectURL() {
    if (WORKER_URL) {
        URL.revokeObjectURL(WORKER_URL);
        WORKER_URL = null;
    }
};
;
 //# sourceMappingURL=checkImageBitmap.worker.mjs.map
}),
"[project]/node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>WorkerInstance
]);
const WORKER_CODE = "(function () {\n    'use strict';\n\n    async function loadImageBitmap(url, alphaMode) {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n      }\n      const imageBlob = await response.blob();\n      return alphaMode === \"premultiplied-alpha\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \"none\" }) : createImageBitmap(imageBlob);\n    }\n    self.onmessage = async (event) => {\n      try {\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\n        self.postMessage({\n          data: imageBitmap,\n          uuid: event.data.uuid,\n          id: event.data.id\n        }, [imageBitmap]);\n      } catch (e) {\n        self.postMessage({\n          error: e,\n          uuid: event.data.uuid,\n          id: event.data.id\n        });\n      }\n    };\n\n})();\n";
let WORKER_URL = null;
class WorkerInstance {
    constructor(){
        if (!WORKER_URL) {
            WORKER_URL = URL.createObjectURL(new Blob([
                WORKER_CODE
            ], {
                type: 'application/javascript'
            }));
        }
        this.worker = new Worker(WORKER_URL);
    }
}
WorkerInstance.revokeObjectURL = function revokeObjectURL() {
    if (WORKER_URL) {
        URL.revokeObjectURL(WORKER_URL);
        WORKER_URL = null;
    }
};
;
 //# sourceMappingURL=loadImageBitmap.worker.mjs.map
}),
"[project]/node_modules/pixi.js/lib/_virtual/basis.worker.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>WorkerInstance
]);
const WORKER_CODE = "(function () {\n    'use strict';\n\n    function createLevelBuffers(basisTexture, basisTranscoderFormat) {\n      const images = basisTexture.getNumImages();\n      const levels = basisTexture.getNumLevels(0);\n      const success = basisTexture.startTranscoding();\n      if (!success) {\n        throw new Error(\"startTranscoding failed\");\n      }\n      const levelBuffers = [];\n      for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {\n        for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {\n          const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);\n          const levelBuffer = new Uint8Array(transcodeSize);\n          const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);\n          if (!success2) {\n            throw new Error(\"transcodeImage failed\");\n          }\n          levelBuffers.push(levelBuffer);\n        }\n      }\n      return levelBuffers;\n    }\n\n    const gpuFormatToBasisTranscoderFormatMap = {\n      \"bc3-rgba-unorm\": 3,\n      // cTFBC3_RGBA\n      \"bc7-rgba-unorm\": 6,\n      // cTFBC7_RGBA,\n      \"etc2-rgba8unorm\": 1,\n      // cTFETC2_RGBA,\n      \"astc-4x4-unorm\": 10,\n      // cTFASTC_4x4_RGBA,\n      // Uncompressed\n      rgba8unorm: 13,\n      // cTFRGBA32,\n      rgba4unorm: 16\n      // cTFRGBA4444,\n    };\n    function gpuFormatToBasisTranscoderFormat(transcoderFormat) {\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n    }\n\n    const settings = {\n      jsUrl: \"basis/basis_transcoder.js\",\n      wasmUrl: \"basis/basis_transcoder.wasm\"\n    };\n    let basisTranscoderFormat;\n    let basisTranscodedTextureFormat;\n    let basisPromise;\n    async function getBasis() {\n      if (!basisPromise) {\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\n        importScripts(absoluteJsUrl);\n        basisPromise = new Promise((resolve) => {\n          BASIS({\n            locateFile: (_file) => absoluteWasmUrl\n          }).then((module) => {\n            module.initializeBasis();\n            resolve(module.BasisFile);\n          });\n        });\n      }\n      return basisPromise;\n    }\n    async function fetchBasisTexture(url, BasisTexture) {\n      const basisResponse = await fetch(url);\n      if (basisResponse.ok) {\n        const basisArrayBuffer = await basisResponse.arrayBuffer();\n        return new BasisTexture(new Uint8Array(basisArrayBuffer));\n      }\n      throw new Error(`Failed to load Basis texture: ${url}`);\n    }\n    const preferredTranscodedFormat = [\n      \"bc7-rgba-unorm\",\n      \"astc-4x4-unorm\",\n      \"etc2-rgba8unorm\",\n      \"bc3-rgba-unorm\",\n      \"rgba8unorm\"\n    ];\n    async function load(url) {\n      const BasisTexture = await getBasis();\n      const basisTexture = await fetchBasisTexture(url, BasisTexture);\n      const levelBuffers = createLevelBuffers(basisTexture, basisTranscoderFormat);\n      return {\n        width: basisTexture.getImageWidth(0, 0),\n        height: basisTexture.getImageHeight(0, 0),\n        format: basisTranscodedTextureFormat,\n        resource: levelBuffers,\n        alphaMode: \"no-premultiply-alpha\"\n      };\n    }\n    async function init(jsUrl, wasmUrl, supportedTextures) {\n      if (jsUrl)\n        settings.jsUrl = jsUrl;\n      if (wasmUrl)\n        settings.wasmUrl = wasmUrl;\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\n      basisTranscoderFormat = gpuFormatToBasisTranscoderFormat(basisTranscodedTextureFormat);\n      await getBasis();\n    }\n    const messageHandlers = {\n      init: async (data) => {\n        const { jsUrl, wasmUrl, supportedTextures } = data;\n        await init(jsUrl, wasmUrl, supportedTextures);\n      },\n      load: async (data) => {\n        try {\n          const textureOptions = await load(data.url);\n          return {\n            type: \"load\",\n            url: data.url,\n            success: true,\n            textureOptions,\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\n          };\n        } catch (e) {\n          throw e;\n        }\n      }\n    };\n    self.onmessage = async (messageEvent) => {\n      const message = messageEvent.data;\n      const response = await messageHandlers[message.type](message);\n      if (response) {\n        self.postMessage(response, response.transferables);\n      }\n    };\n\n})();\n";
let WORKER_URL = null;
class WorkerInstance {
    constructor(){
        if (!WORKER_URL) {
            WORKER_URL = URL.createObjectURL(new Blob([
                WORKER_CODE
            ], {
                type: 'application/javascript'
            }));
        }
        this.worker = new Worker(WORKER_URL);
    }
}
WorkerInstance.revokeObjectURL = function revokeObjectURL() {
    if (WORKER_URL) {
        URL.revokeObjectURL(WORKER_URL);
        WORKER_URL = null;
    }
};
;
 //# sourceMappingURL=basis.worker.mjs.map
}),
"[project]/node_modules/pixi.js/lib/_virtual/ktx.worker.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>WorkerInstance
]);
const WORKER_CODE = "(function () {\n    'use strict';\n\n    const converters = {\n      rgb8unorm: {\n        convertedFormat: \"rgba8unorm\",\n        convertFunction: convertRGBtoRGBA\n      },\n      \"rgb8unorm-srgb\": {\n        convertedFormat: \"rgba8unorm-srgb\",\n        convertFunction: convertRGBtoRGBA\n      }\n    };\n    function convertFormatIfRequired(textureOptions) {\n      const format = textureOptions.format;\n      if (converters[format]) {\n        const convertFunction = converters[format].convertFunction;\n        const levelBuffers = textureOptions.resource;\n        for (let i = 0; i < levelBuffers.length; i++) {\n          levelBuffers[i] = convertFunction(levelBuffers[i]);\n        }\n        textureOptions.format = converters[format].convertedFormat;\n      }\n    }\n    function convertRGBtoRGBA(levelBuffer) {\n      const pixelCount = levelBuffer.byteLength / 3;\n      const levelBufferWithAlpha = new Uint32Array(pixelCount);\n      for (let i = 0; i < pixelCount; ++i) {\n        levelBufferWithAlpha[i] = levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] << 8) + (levelBuffer[i * 3 + 2] << 16) + 4278190080;\n      }\n      return new Uint8Array(levelBufferWithAlpha.buffer);\n    }\n\n    function createLevelBuffersFromKTX(ktxTexture) {\n      const levelBuffers = [];\n      for (let i = 0; i < ktxTexture.numLevels; i++) {\n        const imageData = ktxTexture.getImageData(i, 0, 0);\n        const levelBuffer = new Uint8Array(imageData.byteLength);\n        levelBuffer.set(imageData);\n        levelBuffers.push(levelBuffer);\n      }\n      return levelBuffers;\n    }\n\n    const glFormatToGPUFormatMap = {\n      6408: \"rgba8unorm\",\n      32856: \"bgra8unorm\",\n      //\n      32857: \"rgb10a2unorm\",\n      33189: \"depth16unorm\",\n      33190: \"depth24plus\",\n      33321: \"r8unorm\",\n      33323: \"rg8unorm\",\n      33325: \"r16float\",\n      33326: \"r32float\",\n      33327: \"rg16float\",\n      33328: \"rg32float\",\n      33329: \"r8sint\",\n      33330: \"r8uint\",\n      33331: \"r16sint\",\n      33332: \"r16uint\",\n      33333: \"r32sint\",\n      33334: \"r32uint\",\n      33335: \"rg8sint\",\n      33336: \"rg8uint\",\n      33337: \"rg16sint\",\n      33338: \"rg16uint\",\n      33339: \"rg32sint\",\n      33340: \"rg32uint\",\n      33778: \"bc2-rgba-unorm\",\n      33779: \"bc3-rgba-unorm\",\n      34836: \"rgba32float\",\n      34842: \"rgba16float\",\n      35056: \"depth24plus-stencil8\",\n      35898: \"rg11b10ufloat\",\n      35901: \"rgb9e5ufloat\",\n      35907: \"rgba8unorm-srgb\",\n      // bgra8unorm-srgb\n      36012: \"depth32float\",\n      36013: \"depth32float-stencil8\",\n      36168: \"stencil8\",\n      36208: \"rgba32uint\",\n      36214: \"rgba16uint\",\n      36220: \"rgba8uint\",\n      36226: \"rgba32sint\",\n      36232: \"rgba16sint\",\n      36238: \"rgba8sint\",\n      36492: \"bc7-rgba-unorm\",\n      36756: \"r8snorm\",\n      36757: \"rg8snorm\",\n      36759: \"rgba8snorm\",\n      37496: \"etc2-rgba8unorm\",\n      37808: \"astc-4x4-unorm\"\n    };\n    function glFormatToGPUFormat(glInternalFormat) {\n      const format = glFormatToGPUFormatMap[glInternalFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);\n    }\n\n    const vkFormatToGPUFormatMap = {\n      23: \"rgb8unorm\",\n      // VK_FORMAT_R8G8B8_UNORM\n      37: \"rgba8unorm\",\n      // VK_FORMAT_R8G8B8A8_UNORM\n      43: \"rgba8unorm-srgb\"\n      // VK_FORMAT_R8G8B8A8_SRGB\n      // TODO add more!\n    };\n    function vkFormatToGPUFormat(vkFormat) {\n      const format = vkFormatToGPUFormatMap[vkFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported VkFormat: ${vkFormat}`);\n    }\n\n    function getTextureFormatFromKTXTexture(ktxTexture) {\n      if (ktxTexture.classId === 2) {\n        return vkFormatToGPUFormat(ktxTexture.vkFormat);\n      }\n      return glFormatToGPUFormat(ktxTexture.glInternalformat);\n    }\n\n    const gpuFormatToBasisTranscoderFormatMap = {\n      \"bc3-rgba-unorm\": \"BC3_RGBA\",\n      \"bc7-rgba-unorm\": \"BC7_M5_RGBA\",\n      \"etc2-rgba8unorm\": \"ETC2_RGBA\",\n      \"astc-4x4-unorm\": \"ASTC_4x4_RGBA\",\n      // Uncompressed\n      rgba8unorm: \"RGBA32\",\n      rg11b10ufloat: \"R11F_G11F_B10F\"\n    };\n    function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n    }\n\n    const settings = {\n      jsUrl: \"\",\n      wasmUrl: \"\"\n    };\n    let basisTranscoderFormat;\n    let basisTranscodedTextureFormat;\n    let ktxPromise;\n    async function getKTX() {\n      if (!ktxPromise) {\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\n        importScripts(absoluteJsUrl);\n        ktxPromise = new Promise((resolve) => {\n          LIBKTX({\n            locateFile: (_file) => absoluteWasmUrl\n          }).then((libktx) => {\n            resolve(libktx);\n          });\n        });\n      }\n      return ktxPromise;\n    }\n    async function fetchKTXTexture(url, ktx) {\n      const ktx2Response = await fetch(url);\n      if (ktx2Response.ok) {\n        const ktx2ArrayBuffer = await ktx2Response.arrayBuffer();\n        return new ktx.ktxTexture(new Uint8Array(ktx2ArrayBuffer));\n      }\n      throw new Error(`Failed to load KTX(2) texture: ${url}`);\n    }\n    const preferredTranscodedFormat = [\n      \"bc7-rgba-unorm\",\n      \"astc-4x4-unorm\",\n      \"etc2-rgba8unorm\",\n      \"bc3-rgba-unorm\",\n      \"rgba8unorm\"\n    ];\n    async function load(url) {\n      const ktx = await getKTX();\n      const ktxTexture = await fetchKTXTexture(url, ktx);\n      let format;\n      if (ktxTexture.needsTranscoding) {\n        format = basisTranscodedTextureFormat;\n        const transcodeFormat = ktx.TranscodeTarget[basisTranscoderFormat];\n        const result = ktxTexture.transcodeBasis(transcodeFormat, 0);\n        if (result !== ktx.ErrorCode.SUCCESS) {\n          throw new Error(\"Unable to transcode basis texture.\");\n        }\n      } else {\n        format = getTextureFormatFromKTXTexture(ktxTexture);\n      }\n      const levelBuffers = createLevelBuffersFromKTX(ktxTexture);\n      const textureOptions = {\n        width: ktxTexture.baseWidth,\n        height: ktxTexture.baseHeight,\n        format,\n        mipLevelCount: ktxTexture.numLevels,\n        resource: levelBuffers,\n        alphaMode: \"no-premultiply-alpha\"\n      };\n      convertFormatIfRequired(textureOptions);\n      return textureOptions;\n    }\n    async function init(jsUrl, wasmUrl, supportedTextures) {\n      if (jsUrl)\n        settings.jsUrl = jsUrl;\n      if (wasmUrl)\n        settings.wasmUrl = wasmUrl;\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\n      basisTranscoderFormat = gpuFormatToKTXBasisTranscoderFormat(basisTranscodedTextureFormat);\n      await getKTX();\n    }\n    const messageHandlers = {\n      init: async (data) => {\n        const { jsUrl, wasmUrl, supportedTextures } = data;\n        await init(jsUrl, wasmUrl, supportedTextures);\n      },\n      load: async (data) => {\n        try {\n          const textureOptions = await load(data.url);\n          return {\n            type: \"load\",\n            url: data.url,\n            success: true,\n            textureOptions,\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\n          };\n        } catch (e) {\n          throw e;\n        }\n      }\n    };\n    self.onmessage = async (messageEvent) => {\n      const message = messageEvent.data;\n      try {\n        const response = await messageHandlers[message.type]?.(message);\n        if (response) {\n          self.postMessage(response, response.transferables);\n        }\n      } catch (err) {\n        self.postMessage({\n          type: \"error\",\n          err,\n          url: message.url\n        });\n      }\n    };\n\n})();\n";
let WORKER_URL = null;
class WorkerInstance {
    constructor(){
        if (!WORKER_URL) {
            WORKER_URL = URL.createObjectURL(new Blob([
                WORKER_CODE
            ], {
                type: 'application/javascript'
            }));
        }
        this.worker = new Worker(WORKER_URL);
    }
}
WorkerInstance.revokeObjectURL = function revokeObjectURL() {
    if (WORKER_URL) {
        URL.revokeObjectURL(WORKER_URL);
        WORKER_URL = null;
    }
};
;
 //# sourceMappingURL=ktx.worker.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "detectBasis",
    ()=>detectBasis
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isWebGLSupported$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isWebGPUSupported$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs [app-client] (ecmascript)");
;
;
;
"use strict";
const detectBasis = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].DetectionParser,
        priority: 3
    },
    test: async ()=>{
        if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isWebGPUSupported$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWebGPUSupported"])()) return true;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isWebGLSupported$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWebGLSupported"])()) return true;
        return false;
    },
    add: async (formats)=>[
            ...formats,
            "basis"
        ],
    remove: async (formats)=>formats.filter((f)=>f !== "basis")
};
;
 //# sourceMappingURL=detectBasis.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "basisTranscoderUrls",
    ()=>basisTranscoderUrls,
    "setBasisTranscoderPath",
    ()=>setBasisTranscoderPath
]);
"use strict";
const basisTranscoderUrls = {
    jsUrl: "https://cdn.jsdelivr.net/npm/pixi.js/transcoders/basis/basis_transcoder.js",
    wasmUrl: "https://cdn.jsdelivr.net/npm/pixi.js/transcoders/basis/basis_transcoder.wasm"
};
function setBasisTranscoderPath(config) {
    Object.assign(basisTranscoderUrls, config);
}
;
 //# sourceMappingURL=setBasisTranscoderPath.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadBasisOnWorker",
    ()=>loadBasisOnWorker
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$_virtual$2f$basis$2e$worker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/_virtual/basis.worker.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$basis$2f$utils$2f$setBasisTranscoderPath$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.mjs [app-client] (ecmascript)");
;
;
"use strict";
let basisWorker;
const urlHash = {};
function getBasisWorker(supportedTextures) {
    if (!basisWorker) {
        basisWorker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$_virtual$2f$basis$2e$worker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]().worker;
        basisWorker.onmessage = (messageEvent)=>{
            const { success, url, textureOptions } = messageEvent.data;
            if (!success) {
                console.warn("Failed to load Basis texture", url);
            }
            urlHash[url](textureOptions);
        };
        basisWorker.postMessage({
            type: "init",
            jsUrl: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$basis$2f$utils$2f$setBasisTranscoderPath$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["basisTranscoderUrls"].jsUrl,
            wasmUrl: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$basis$2f$utils$2f$setBasisTranscoderPath$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["basisTranscoderUrls"].wasmUrl,
            supportedTextures
        });
    }
    return basisWorker;
}
function loadBasisOnWorker(url, supportedTextures) {
    const ktxWorker = getBasisWorker(supportedTextures);
    return new Promise((resolve)=>{
        urlHash[url] = resolve;
        ktxWorker.postMessage({
            type: "load",
            url
        });
    });
}
;
 //# sourceMappingURL=loadBasisOnWorker.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadBasis",
    ()=>loadBasis
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$textures$2f$utils$2f$createTexture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$checkExtension$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$CompressedSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$utils$2f$getSupportedTextureFormats$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$basis$2f$worker$2f$loadBasisOnWorker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
const loadBasis = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].LoadParser,
        priority: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderParserPriority"].High,
        name: "loadBasis"
    },
    /** used for deprecation purposes */ name: "loadBasis",
    id: "basis",
    test (url) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$checkExtension$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkExtension"])(url, [
            ".basis"
        ]);
    },
    async load (url, _asset, loader) {
        const supportedTextures = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$utils$2f$getSupportedTextureFormats$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSupportedTextureFormats"])();
        const textureOptions = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$basis$2f$worker$2f$loadBasisOnWorker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["loadBasisOnWorker"])(url, supportedTextures);
        const compressedTextureSource = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$CompressedSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedSource"](textureOptions);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$textures$2f$utils$2f$createTexture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTexture"])(compressedTextureSource, loader, url);
    },
    unload (texture) {
        if (Array.isArray(texture)) {
            texture.forEach((t)=>t.destroy(true));
        } else {
            texture.destroy(true);
        }
    }
};
;
 //# sourceMappingURL=loadBasis.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createLevelBuffers",
    ()=>createLevelBuffers
]);
"use strict";
function createLevelBuffers(basisTexture, basisTranscoderFormat) {
    const images = basisTexture.getNumImages();
    const levels = basisTexture.getNumLevels(0);
    const success = basisTexture.startTranscoding();
    if (!success) {
        throw new Error("startTranscoding failed");
    }
    const levelBuffers = [];
    for(let levelIndex = 0; levelIndex < levels; ++levelIndex){
        for(let sliceIndex = 0; sliceIndex < images; ++sliceIndex){
            const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);
            const levelBuffer = new Uint8Array(transcodeSize);
            const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);
            if (!success2) {
                throw new Error("transcodeImage failed");
            }
            levelBuffers.push(levelBuffer);
        }
    }
    return levelBuffers;
}
;
 //# sourceMappingURL=createLevelBuffers.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "gpuFormatToBasisTranscoderFormat",
    ()=>gpuFormatToBasisTranscoderFormat
]);
"use strict";
const gpuFormatToBasisTranscoderFormatMap = {
    "bc3-rgba-unorm": 3,
    // cTFBC3_RGBA
    "bc7-rgba-unorm": 6,
    // cTFBC7_RGBA,
    "etc2-rgba8unorm": 1,
    // cTFETC2_RGBA,
    "astc-4x4-unorm": 10,
    // cTFASTC_4x4_RGBA,
    // Uncompressed
    rgba8unorm: 13,
    // cTFRGBA32,
    rgba4unorm: 16
};
function gpuFormatToBasisTranscoderFormat(transcoderFormat) {
    const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];
    if (format) {
        return format;
    }
    throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);
}
;
 //# sourceMappingURL=gpuFormatToBasisTranscoderFormat.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/dds/const.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "D3D10_RESOURCE_DIMENSION",
    ()=>D3D10_RESOURCE_DIMENSION,
    "D3DFMT",
    ()=>D3DFMT,
    "DDS",
    ()=>DDS,
    "DXGI_FORMAT",
    ()=>DXGI_FORMAT,
    "DXGI_TO_TEXTURE_FORMAT",
    ()=>DXGI_TO_TEXTURE_FORMAT,
    "FOURCC_TO_TEXTURE_FORMAT",
    ()=>FOURCC_TO_TEXTURE_FORMAT,
    "TEXTURE_FORMAT_BLOCK_SIZE",
    ()=>TEXTURE_FORMAT_BLOCK_SIZE
]);
"use strict";
const DDS_HEADER_FIELDS = {
    MAGIC: 0,
    SIZE: 1,
    FLAGS: 2,
    HEIGHT: 3,
    WIDTH: 4,
    MIPMAP_COUNT: 7,
    PIXEL_FORMAT: 19,
    PF_FLAGS: 20,
    FOURCC: 21,
    RGB_BITCOUNT: 22,
    R_BIT_MASK: 23,
    G_BIT_MASK: 24,
    B_BIT_MASK: 25,
    A_BIT_MASK: 26
};
const DDS_DX10_FIELDS = {
    DXGI_FORMAT: 0,
    RESOURCE_DIMENSION: 1,
    MISC_FLAG: 2,
    ARRAY_SIZE: 3,
    MISC_FLAGS2: 4
};
var DXGI_FORMAT = /* @__PURE__ */ ((DXGI_FORMAT2)=>{
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
    return DXGI_FORMAT2;
})(DXGI_FORMAT || {});
var D3D10_RESOURCE_DIMENSION = /* @__PURE__ */ ((D3D10_RESOURCE_DIMENSION2)=>{
    D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
    D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
    D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
    return D3D10_RESOURCE_DIMENSION2;
})(D3D10_RESOURCE_DIMENSION || {});
function fourCCToInt32(value) {
    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
}
var D3DFMT = ((D3DFMT2)=>{
    D3DFMT2[D3DFMT2["UNKNOWN"] = 0] = "UNKNOWN";
    D3DFMT2[D3DFMT2["R8G8B8"] = 20] = "R8G8B8";
    D3DFMT2[D3DFMT2["A8R8G8B8"] = 21] = "A8R8G8B8";
    D3DFMT2[D3DFMT2["X8R8G8B8"] = 22] = "X8R8G8B8";
    D3DFMT2[D3DFMT2["R5G6B5"] = 23] = "R5G6B5";
    D3DFMT2[D3DFMT2["X1R5G5B5"] = 24] = "X1R5G5B5";
    D3DFMT2[D3DFMT2["A1R5G5B5"] = 25] = "A1R5G5B5";
    D3DFMT2[D3DFMT2["A4R4G4B4"] = 26] = "A4R4G4B4";
    D3DFMT2[D3DFMT2["R3G3B2"] = 27] = "R3G3B2";
    D3DFMT2[D3DFMT2["A8"] = 28] = "A8";
    D3DFMT2[D3DFMT2["A8R3G3B2"] = 29] = "A8R3G3B2";
    D3DFMT2[D3DFMT2["X4R4G4B4"] = 30] = "X4R4G4B4";
    D3DFMT2[D3DFMT2["A2B10G10R10"] = 31] = "A2B10G10R10";
    D3DFMT2[D3DFMT2["A8B8G8R8"] = 32] = "A8B8G8R8";
    D3DFMT2[D3DFMT2["X8B8G8R8"] = 33] = "X8B8G8R8";
    D3DFMT2[D3DFMT2["G16R16"] = 34] = "G16R16";
    D3DFMT2[D3DFMT2["A2R10G10B10"] = 35] = "A2R10G10B10";
    D3DFMT2[D3DFMT2["A16B16G16R16"] = 36] = "A16B16G16R16";
    D3DFMT2[D3DFMT2["A8P8"] = 40] = "A8P8";
    D3DFMT2[D3DFMT2["P8"] = 41] = "P8";
    D3DFMT2[D3DFMT2["L8"] = 50] = "L8";
    D3DFMT2[D3DFMT2["A8L8"] = 51] = "A8L8";
    D3DFMT2[D3DFMT2["A4L4"] = 52] = "A4L4";
    D3DFMT2[D3DFMT2["V8U8"] = 60] = "V8U8";
    D3DFMT2[D3DFMT2["L6V5U5"] = 61] = "L6V5U5";
    D3DFMT2[D3DFMT2["X8L8V8U8"] = 62] = "X8L8V8U8";
    D3DFMT2[D3DFMT2["Q8W8V8U8"] = 63] = "Q8W8V8U8";
    D3DFMT2[D3DFMT2["V16U16"] = 64] = "V16U16";
    D3DFMT2[D3DFMT2["A2W10V10U10"] = 67] = "A2W10V10U10";
    D3DFMT2[D3DFMT2["Q16W16V16U16"] = 110] = "Q16W16V16U16";
    D3DFMT2[D3DFMT2["R16F"] = 111] = "R16F";
    D3DFMT2[D3DFMT2["G16R16F"] = 112] = "G16R16F";
    D3DFMT2[D3DFMT2["A16B16G16R16F"] = 113] = "A16B16G16R16F";
    D3DFMT2[D3DFMT2["R32F"] = 114] = "R32F";
    D3DFMT2[D3DFMT2["G32R32F"] = 115] = "G32R32F";
    D3DFMT2[D3DFMT2["A32B32G32R32F"] = 116] = "A32B32G32R32F";
    D3DFMT2[D3DFMT2["UYVY"] = fourCCToInt32("UYVY")] = "UYVY";
    D3DFMT2[D3DFMT2["R8G8_B8G8"] = fourCCToInt32("RGBG")] = "R8G8_B8G8";
    D3DFMT2[D3DFMT2["YUY2"] = fourCCToInt32("YUY2")] = "YUY2";
    D3DFMT2[D3DFMT2["D3DFMT_G8R8_G8B8"] = fourCCToInt32("GRGB")] = "D3DFMT_G8R8_G8B8";
    D3DFMT2[D3DFMT2["DXT1"] = fourCCToInt32("DXT1")] = "DXT1";
    D3DFMT2[D3DFMT2["DXT2"] = fourCCToInt32("DXT2")] = "DXT2";
    D3DFMT2[D3DFMT2["DXT3"] = fourCCToInt32("DXT3")] = "DXT3";
    D3DFMT2[D3DFMT2["DXT4"] = fourCCToInt32("DXT4")] = "DXT4";
    D3DFMT2[D3DFMT2["DXT5"] = fourCCToInt32("DXT5")] = "DXT5";
    D3DFMT2[D3DFMT2["ATI1"] = fourCCToInt32("ATI1")] = "ATI1";
    D3DFMT2[D3DFMT2["AT1N"] = fourCCToInt32("AT1N")] = "AT1N";
    D3DFMT2[D3DFMT2["ATI2"] = fourCCToInt32("ATI2")] = "ATI2";
    D3DFMT2[D3DFMT2["AT2N"] = fourCCToInt32("AT2N")] = "AT2N";
    D3DFMT2[D3DFMT2["BC4U"] = fourCCToInt32("BC4U")] = "BC4U";
    D3DFMT2[D3DFMT2["BC4S"] = fourCCToInt32("BC4S")] = "BC4S";
    D3DFMT2[D3DFMT2["BC5U"] = fourCCToInt32("BC5U")] = "BC5U";
    D3DFMT2[D3DFMT2["BC5S"] = fourCCToInt32("BC5S")] = "BC5S";
    D3DFMT2[D3DFMT2["DX10"] = fourCCToInt32("DX10")] = "DX10";
    return D3DFMT2;
})(D3DFMT || {});
const FOURCC_TO_TEXTURE_FORMAT = {
    [D3DFMT.DXT1]: "bc1-rgba-unorm",
    [D3DFMT.DXT2]: "bc2-rgba-unorm",
    [D3DFMT.DXT3]: "bc2-rgba-unorm",
    [D3DFMT.DXT4]: "bc3-rgba-unorm",
    [D3DFMT.DXT5]: "bc3-rgba-unorm",
    [D3DFMT.ATI1]: "bc4-r-unorm",
    [D3DFMT.BC4U]: "bc4-r-unorm",
    [D3DFMT.BC4S]: "bc4-r-snorm",
    [D3DFMT.ATI2]: "bc5-rg-unorm",
    [D3DFMT.BC5U]: "bc5-rg-unorm",
    [D3DFMT.BC5S]: "bc5-rg-snorm",
    [36 /* A16B16G16R16 */ ]: "rgba16uint",
    [110 /* Q16W16V16U16 */ ]: "rgba16sint",
    [111 /* R16F */ ]: "r16float",
    [112 /* G16R16F */ ]: "rg16float",
    [113 /* A16B16G16R16F */ ]: "rgba16float",
    [114 /* R32F */ ]: "r32float",
    [115 /* G32R32F */ ]: "rg32float",
    [116 /* A32B32G32R32F */ ]: "rgba32float"
};
const DXGI_TO_TEXTURE_FORMAT = {
    [70 /* DXGI_FORMAT_BC1_TYPELESS */ ]: "bc1-rgba-unorm",
    [71 /* DXGI_FORMAT_BC1_UNORM */ ]: "bc1-rgba-unorm",
    [72 /* DXGI_FORMAT_BC1_UNORM_SRGB */ ]: "bc1-rgba-unorm-srgb",
    [73 /* DXGI_FORMAT_BC2_TYPELESS */ ]: "bc2-rgba-unorm",
    [74 /* DXGI_FORMAT_BC2_UNORM */ ]: "bc2-rgba-unorm",
    [75 /* DXGI_FORMAT_BC2_UNORM_SRGB */ ]: "bc2-rgba-unorm-srgb",
    [76 /* DXGI_FORMAT_BC3_TYPELESS */ ]: "bc3-rgba-unorm",
    [77 /* DXGI_FORMAT_BC3_UNORM */ ]: "bc3-rgba-unorm",
    [78 /* DXGI_FORMAT_BC3_UNORM_SRGB */ ]: "bc3-rgba-unorm-srgb",
    [79 /* DXGI_FORMAT_BC4_TYPELESS */ ]: "bc4-r-unorm",
    [80 /* DXGI_FORMAT_BC4_UNORM */ ]: "bc4-r-unorm",
    [81 /* DXGI_FORMAT_BC4_SNORM */ ]: "bc4-r-snorm",
    [82 /* DXGI_FORMAT_BC5_TYPELESS */ ]: "bc5-rg-unorm",
    [83 /* DXGI_FORMAT_BC5_UNORM */ ]: "bc5-rg-unorm",
    [84 /* DXGI_FORMAT_BC5_SNORM */ ]: "bc5-rg-snorm",
    [94 /* DXGI_FORMAT_BC6H_TYPELESS */ ]: "bc6h-rgb-ufloat",
    [95 /* DXGI_FORMAT_BC6H_UF16 */ ]: "bc6h-rgb-ufloat",
    [96 /* DXGI_FORMAT_BC6H_SF16 */ ]: "bc6h-rgb-float",
    [97 /* DXGI_FORMAT_BC7_TYPELESS */ ]: "bc7-rgba-unorm",
    [98 /* DXGI_FORMAT_BC7_UNORM */ ]: "bc7-rgba-unorm",
    [99 /* DXGI_FORMAT_BC7_UNORM_SRGB */ ]: "bc7-rgba-unorm-srgb",
    [28 /* DXGI_FORMAT_R8G8B8A8_UNORM */ ]: "rgba8unorm",
    [29 /* DXGI_FORMAT_R8G8B8A8_UNORM_SRGB */ ]: "rgba8unorm-srgb",
    [87 /* DXGI_FORMAT_B8G8R8A8_UNORM */ ]: "bgra8unorm",
    [91 /* DXGI_FORMAT_B8G8R8A8_UNORM_SRGB */ ]: "bgra8unorm-srgb",
    [41 /* DXGI_FORMAT_R32_FLOAT */ ]: "r32float",
    [49 /* DXGI_FORMAT_R8G8_UNORM */ ]: "rg8unorm",
    [56 /* DXGI_FORMAT_R16_UNORM */ ]: "r16uint",
    [61 /* DXGI_FORMAT_R8_UNORM */ ]: "r8unorm",
    [24 /* DXGI_FORMAT_R10G10B10A2_UNORM */ ]: "rgb10a2unorm",
    [11 /* DXGI_FORMAT_R16G16B16A16_UNORM */ ]: "rgba16uint",
    [13 /* DXGI_FORMAT_R16G16B16A16_SNORM */ ]: "rgba16sint",
    [10 /* DXGI_FORMAT_R16G16B16A16_FLOAT */ ]: "rgba16float",
    [54 /* DXGI_FORMAT_R16_FLOAT */ ]: "r16float",
    [34 /* DXGI_FORMAT_R16G16_FLOAT */ ]: "rg16float",
    [16 /* DXGI_FORMAT_R32G32_FLOAT */ ]: "rg32float",
    [2 /* DXGI_FORMAT_R32G32B32A32_FLOAT */ ]: "rgba32float"
};
const DDS = {
    MAGIC_VALUE: 542327876,
    MAGIC_SIZE: 4,
    HEADER_SIZE: 124,
    HEADER_DX10_SIZE: 20,
    PIXEL_FORMAT_FLAGS: {
        // PIXEL_FORMAT flags
        // https://github.com/Microsoft/DirectXTex/blob/main/DirectXTex/DDS.h
        // https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dds-pixelformat
        ALPHAPIXELS: 1,
        ALPHA: 2,
        FOURCC: 4,
        RGB: 64,
        RGBA: 65,
        YUV: 512,
        LUMINANCE: 131072,
        LUMINANCEA: 131073
    },
    RESOURCE_MISC_TEXTURECUBE: 4,
    HEADER_FIELDS: DDS_HEADER_FIELDS,
    HEADER_DX10_FIELDS: DDS_DX10_FIELDS,
    DXGI_FORMAT,
    D3D10_RESOURCE_DIMENSION,
    D3DFMT
};
const TEXTURE_FORMAT_BLOCK_SIZE = {
    "bc1-rgba-unorm": 8,
    "bc1-rgba-unorm-srgb": 8,
    "bc2-rgba-unorm": 16,
    "bc2-rgba-unorm-srgb": 16,
    "bc3-rgba-unorm": 16,
    "bc3-rgba-unorm-srgb": 16,
    "bc4-r-unorm": 8,
    "bc4-r-snorm": 8,
    "bc5-rg-unorm": 16,
    "bc5-rg-snorm": 16,
    "bc6h-rgb-ufloat": 16,
    "bc6h-rgb-float": 16,
    "bc7-rgba-unorm": 16,
    "bc7-rgba-unorm-srgb": 16
};
;
 //# sourceMappingURL=const.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseDDS",
    ()=>parseDDS
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/compressed-textures/dds/const.mjs [app-client] (ecmascript)");
;
"use strict";
function parseDDS(arrayBuffer, supportedFormats) {
    const { format, fourCC, width, height, dataOffset, mipmapCount } = parseDDSHeader(arrayBuffer);
    if (!supportedFormats.includes(format)) {
        throw new Error(`Unsupported texture format: ${fourCC} ${format}, supported: ${supportedFormats}`);
    }
    if (mipmapCount <= 1) {
        return {
            format,
            width,
            height,
            resource: [
                new Uint8Array(arrayBuffer, dataOffset)
            ],
            alphaMode: "no-premultiply-alpha"
        };
    }
    const levelBuffers = getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer);
    const textureOptions = {
        format,
        width,
        height,
        resource: levelBuffers,
        alphaMode: "no-premultiply-alpha"
    };
    return textureOptions;
}
function getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer) {
    const levelBuffers = [];
    const blockBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TEXTURE_FORMAT_BLOCK_SIZE"][format];
    let mipWidth = width;
    let mipHeight = height;
    let offset = dataOffset;
    for(let level = 0; level < mipmapCount; ++level){
        const alignedWidth = Math.ceil(Math.max(4, mipWidth) / 4) * 4;
        const alignedHeight = Math.ceil(Math.max(4, mipHeight) / 4) * 4;
        const byteLength = blockBytes ? alignedWidth / 4 * alignedHeight / 4 * blockBytes : mipWidth * mipHeight * 4;
        const levelBuffer = new Uint8Array(arrayBuffer, offset, byteLength);
        levelBuffers.push(levelBuffer);
        offset += byteLength;
        mipWidth = Math.max(mipWidth >> 1, 1);
        mipHeight = Math.max(mipHeight >> 1, 1);
    }
    return levelBuffers;
}
function parseDDSHeader(buffer) {
    const header = new Uint32Array(buffer, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    if (header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_FIELDS.MAGIC] !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].MAGIC_VALUE) {
        throw new Error("Invalid magic number in DDS header");
    }
    const height = header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_FIELDS.HEIGHT];
    const width = header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_FIELDS.WIDTH];
    const mipmapCount = Math.max(1, header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_FIELDS.MIPMAP_COUNT]);
    const flags = header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_FIELDS.PF_FLAGS];
    const fourCC = header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_FIELDS.FOURCC];
    const format = getTextureFormat(header, flags, fourCC, buffer);
    const dataOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].MAGIC_SIZE + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_SIZE + (fourCC === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].D3DFMT.DX10 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_DX10_SIZE : 0);
    return {
        format,
        fourCC,
        width,
        height,
        dataOffset,
        mipmapCount
    };
}
function getTextureFormat(header, flags, fourCC, buffer) {
    if (flags & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].PIXEL_FORMAT_FLAGS.FOURCC) {
        if (fourCC === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].D3DFMT.DX10) {
            const dx10Header = new Uint32Array(buffer, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].MAGIC_SIZE + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_SIZE, // there is a 20-byte DDS_HEADER_DX10 after DDS_HEADER
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
            const miscFlag = dx10Header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_DX10_FIELDS.MISC_FLAG];
            if (miscFlag === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].RESOURCE_MISC_TEXTURECUBE) {
                throw new Error("DDSParser does not support cubemap textures");
            }
            const resourceDimension = dx10Header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_DX10_FIELDS.RESOURCE_DIMENSION];
            if (resourceDimension === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {
                throw new Error("DDSParser does not supported 3D texture data");
            }
            const dxgiFormat = dx10Header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_DX10_FIELDS.DXGI_FORMAT];
            if (dxgiFormat in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DXGI_TO_TEXTURE_FORMAT"]) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DXGI_TO_TEXTURE_FORMAT"][dxgiFormat];
            }
            throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
        }
        if (fourCC in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FOURCC_TO_TEXTURE_FORMAT"]) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FOURCC_TO_TEXTURE_FORMAT"][fourCC];
        }
        throw new Error(`DDSParser cannot parse texture data with fourCC format ${fourCC}`);
    }
    if (flags & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].PIXEL_FORMAT_FLAGS.RGB || flags & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].PIXEL_FORMAT_FLAGS.RGBA) {
        return getUncompressedTextureFormat(header);
    }
    if (flags & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].PIXEL_FORMAT_FLAGS.YUV) {
        throw new Error("DDSParser does not supported YUV uncompressed texture data.");
    }
    if (flags & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].PIXEL_FORMAT_FLAGS.LUMINANCE || flags & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].PIXEL_FORMAT_FLAGS.LUMINANCEA) {
        throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
    }
    if (flags & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].PIXEL_FORMAT_FLAGS.ALPHA || flags & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].PIXEL_FORMAT_FLAGS.ALPHAPIXELS) {
        throw new Error("DDSParser does not support single-channel (alpha) texture data!");
    }
    throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
function getUncompressedTextureFormat(header) {
    const bitCount = header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_FIELDS.RGB_BITCOUNT];
    const rBitMask = header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_FIELDS.R_BIT_MASK];
    const gBitMask = header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_FIELDS.G_BIT_MASK];
    const bBitMask = header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_FIELDS.B_BIT_MASK];
    const aBitMask = header[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].HEADER_FIELDS.A_BIT_MASK];
    switch(bitCount){
        case 32:
            if (rBitMask === 255 && gBitMask === 65280 && bBitMask === 16711680 && aBitMask === 4278190080) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DXGI_TO_TEXTURE_FORMAT"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM];
            }
            if (rBitMask === 16711680 && gBitMask === 65280 && bBitMask === 255 && aBitMask === 4278190080) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DXGI_TO_TEXTURE_FORMAT"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM];
            }
            if (rBitMask === 1072693248 && gBitMask === 1047552 && bBitMask === 1023 && aBitMask === 3221225472) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DXGI_TO_TEXTURE_FORMAT"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM];
            }
            if (rBitMask === 65535 && gBitMask === 4294901760 && bBitMask === 0 && aBitMask === 0) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DXGI_TO_TEXTURE_FORMAT"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM];
            }
            if (rBitMask === 4294967295 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DXGI_TO_TEXTURE_FORMAT"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT];
            }
            break;
        case 24:
            if (rBitMask === 16711680 && gBitMask === 65280 && bBitMask === 255 && aBitMask === 32768) {}
            break;
        case 16:
            if (rBitMask === 31744 && gBitMask === 992 && bBitMask === 31 && aBitMask === 32768) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DXGI_TO_TEXTURE_FORMAT"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];
            }
            if (rBitMask === 63488 && gBitMask === 2016 && bBitMask === 31 && aBitMask === 0) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DXGI_TO_TEXTURE_FORMAT"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM];
            }
            if (rBitMask === 3840 && gBitMask === 240 && bBitMask === 15 && aBitMask === 61440) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DXGI_TO_TEXTURE_FORMAT"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM];
            }
            if (rBitMask === 255 && gBitMask === 0 && bBitMask === 0 && aBitMask === 65280) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DXGI_TO_TEXTURE_FORMAT"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM];
            }
            if (rBitMask === 65535 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DXGI_TO_TEXTURE_FORMAT"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].DXGI_FORMAT.DXGI_FORMAT_R16_UNORM];
            }
            break;
        case 8:
            if (rBitMask === 255 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DXGI_TO_TEXTURE_FORMAT"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DDS"].DXGI_FORMAT.DXGI_FORMAT_R8_UNORM];
            }
            break;
    }
    throw new Error(`DDSParser does not support uncompressed texture with configuration:
                bitCount = ${bitCount}, rBitMask = ${rBitMask}, gBitMask = ${gBitMask}, aBitMask = ${aBitMask}`);
}
;
 //# sourceMappingURL=parseDDS.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadDDS",
    ()=>loadDDS
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$textures$2f$utils$2f$createTexture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$checkExtension$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$CompressedSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$utils$2f$getSupportedTextureFormats$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$parseDDS$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
const loadDDS = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].LoadParser,
        priority: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderParserPriority"].High,
        name: "loadDDS"
    },
    /** used for deprecation purposes */ name: "loadDDS",
    id: "dds",
    test (url) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$checkExtension$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkExtension"])(url, [
            ".dds"
        ]);
    },
    async load (url, _asset, loader) {
        const supportedTextures = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$utils$2f$getSupportedTextureFormats$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSupportedTextureFormats"])();
        const ddsResponse = await fetch(url);
        const ddsArrayBuffer = await ddsResponse.arrayBuffer();
        const textureOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$dds$2f$parseDDS$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseDDS"])(ddsArrayBuffer, supportedTextures);
        const compressedTextureSource = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$CompressedSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedSource"](textureOptions);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$textures$2f$utils$2f$createTexture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTexture"])(compressedTextureSource, loader, url);
    },
    unload (texture) {
        if (Array.isArray(texture)) {
            texture.forEach((t)=>t.destroy(true));
        } else {
            texture.destroy(true);
        }
    }
};
;
 //# sourceMappingURL=loadDDS.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/const.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GL_INTERNAL_FORMAT",
    ()=>GL_INTERNAL_FORMAT,
    "KTX",
    ()=>KTX
]);
"use strict";
var GL_INTERNAL_FORMAT = /* @__PURE__ */ ((GL_INTERNAL_FORMAT2)=>{
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA"] = 6408] = "RGBA";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8UI"] = 36220] = "RGBA8UI";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8I"] = 36238] = "RGBA8I";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8"] = 32856] = "RGBA8";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
    return GL_INTERNAL_FORMAT2;
})(GL_INTERNAL_FORMAT || {});
var GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2)=>{
    GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
    GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
    GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
    GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
    GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
    GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
    GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
    GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
    GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    return GL_FORMATS2;
})(GL_FORMATS || {});
var GL_TYPES = /* @__PURE__ */ ((GL_TYPES2)=>{
    GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
    GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
    GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
    GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
    GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
    return GL_TYPES2;
})(GL_TYPES || {});
const INTERNAL_FORMAT_TO_TEXTURE_FORMATS = {
    [33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */ ]: "bc1-rgba-unorm",
    // TODO: ???
    [33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */ ]: "bc1-rgba-unorm",
    [33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */ ]: "bc2-rgba-unorm",
    [33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */ ]: "bc3-rgba-unorm",
    [35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */ ]: "bc1-rgba-unorm-srgb",
    // TODO: ???
    [35917 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */ ]: "bc1-rgba-unorm-srgb",
    [35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */ ]: "bc2-rgba-unorm-srgb",
    [35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */ ]: "bc3-rgba-unorm-srgb",
    [36283 /* COMPRESSED_RED_RGTC1_EXT */ ]: "bc4-r-unorm",
    [36284 /* COMPRESSED_SIGNED_RED_RGTC1_EXT */ ]: "bc4-r-snorm",
    [36285 /* COMPRESSED_RED_GREEN_RGTC2_EXT */ ]: "bc5-rg-unorm",
    [36286 /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */ ]: "bc5-rg-snorm",
    [37488 /* COMPRESSED_R11_EAC */ ]: "eac-r11unorm",
    // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_R11_EAC]: 'eac-r11snorm',
    [37490 /* COMPRESSED_RG11_EAC */ ]: "eac-rg11snorm",
    // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_RG11_EAC]: 'eac-rg11unorm',
    [37492 /* COMPRESSED_RGB8_ETC2 */ ]: "etc2-rgb8unorm",
    [37496 /* COMPRESSED_RGBA8_ETC2_EAC */ ]: "etc2-rgba8unorm",
    [37493 /* COMPRESSED_SRGB8_ETC2 */ ]: "etc2-rgb8unorm-srgb",
    [37497 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */ ]: "etc2-rgba8unorm-srgb",
    [37494 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */ ]: "etc2-rgb8a1unorm",
    [37495 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */ ]: "etc2-rgb8a1unorm-srgb",
    [37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */ ]: "astc-4x4-unorm",
    [37840 /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */ ]: "astc-4x4-unorm-srgb",
    [37809 /* COMPRESSED_RGBA_ASTC_5x4_KHR */ ]: "astc-5x4-unorm",
    [37841 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */ ]: "astc-5x4-unorm-srgb",
    [37810 /* COMPRESSED_RGBA_ASTC_5x5_KHR */ ]: "astc-5x5-unorm",
    [37842 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */ ]: "astc-5x5-unorm-srgb",
    [37811 /* COMPRESSED_RGBA_ASTC_6x5_KHR */ ]: "astc-6x5-unorm",
    [37843 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */ ]: "astc-6x5-unorm-srgb",
    [37812 /* COMPRESSED_RGBA_ASTC_6x6_KHR */ ]: "astc-6x6-unorm",
    [37844 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */ ]: "astc-6x6-unorm-srgb",
    [37813 /* COMPRESSED_RGBA_ASTC_8x5_KHR */ ]: "astc-8x5-unorm",
    [37845 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */ ]: "astc-8x5-unorm-srgb",
    [37814 /* COMPRESSED_RGBA_ASTC_8x6_KHR */ ]: "astc-8x6-unorm",
    [37846 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */ ]: "astc-8x6-unorm-srgb",
    [37815 /* COMPRESSED_RGBA_ASTC_8x8_KHR */ ]: "astc-8x8-unorm",
    [37847 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */ ]: "astc-8x8-unorm-srgb",
    [37816 /* COMPRESSED_RGBA_ASTC_10x5_KHR */ ]: "astc-10x5-unorm",
    [37848 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */ ]: "astc-10x5-unorm-srgb",
    [37817 /* COMPRESSED_RGBA_ASTC_10x6_KHR */ ]: "astc-10x6-unorm",
    [37849 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */ ]: "astc-10x6-unorm-srgb",
    [37818 /* COMPRESSED_RGBA_ASTC_10x8_KHR */ ]: "astc-10x8-unorm",
    [37850 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */ ]: "astc-10x8-unorm-srgb",
    [37819 /* COMPRESSED_RGBA_ASTC_10x10_KHR */ ]: "astc-10x10-unorm",
    [37851 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */ ]: "astc-10x10-unorm-srgb",
    [37820 /* COMPRESSED_RGBA_ASTC_12x10_KHR */ ]: "astc-12x10-unorm",
    [37852 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */ ]: "astc-12x10-unorm-srgb",
    [37821 /* COMPRESSED_RGBA_ASTC_12x12_KHR */ ]: "astc-12x12-unorm",
    [37853 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */ ]: "astc-12x12-unorm-srgb",
    [36492 /* COMPRESSED_RGBA_BPTC_UNORM_EXT */ ]: "bc7-rgba-unorm",
    [36493 /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */ ]: "bc7-rgba-unorm-srgb",
    [36494 /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */ ]: "bc6h-rgb-float",
    [36495 /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */ ]: "bc6h-rgb-ufloat",
    [35907 /* SRGB8_ALPHA8 */ ]: "rgba8unorm-srgb",
    [36759 /* RGBA8_SNORM */ ]: "rgba8snorm",
    [36220 /* RGBA8UI */ ]: "rgba8uint",
    [36238 /* RGBA8I */ ]: "rgba8sint",
    [6408 /* RGBA */ ]: "rgba8unorm"
};
const FILE_IDENTIFIER = [
    171,
    75,
    84,
    88,
    32,
    49,
    49,
    187,
    13,
    10,
    26,
    10
];
const FIELDS = {
    FILE_IDENTIFIER: 0,
    ENDIANNESS: 12,
    GL_TYPE: 16,
    GL_TYPE_SIZE: 20,
    GL_FORMAT: 24,
    GL_INTERNAL_FORMAT: 28,
    GL_BASE_INTERNAL_FORMAT: 32,
    PIXEL_WIDTH: 36,
    PIXEL_HEIGHT: 40,
    PIXEL_DEPTH: 44,
    NUMBER_OF_ARRAY_ELEMENTS: 48,
    NUMBER_OF_FACES: 52,
    NUMBER_OF_MIPMAP_LEVELS: 56,
    BYTES_OF_KEY_VALUE_DATA: 60
};
const FILE_HEADER_SIZE = 64;
const ENDIANNESS = 67305985;
const TYPES_TO_BYTES_PER_COMPONENT = {
    [5121 /* UNSIGNED_BYTE */ ]: 1,
    [5123 /* UNSIGNED_SHORT */ ]: 2,
    [5124 /* INT */ ]: 4,
    [5125 /* UNSIGNED_INT */ ]: 4,
    [5126 /* FLOAT */ ]: 4,
    [36193 /* HALF_FLOAT */ ]: 8
};
const FORMATS_TO_COMPONENTS = {
    [6408 /* RGBA */ ]: 4,
    [6407 /* RGB */ ]: 3,
    [33319 /* RG */ ]: 2,
    [6403 /* RED */ ]: 1,
    [6409 /* LUMINANCE */ ]: 1,
    [6410 /* LUMINANCE_ALPHA */ ]: 2,
    [6406 /* ALPHA */ ]: 1
};
const TYPES_TO_BYTES_PER_PIXEL = {
    [32819 /* UNSIGNED_SHORT_4_4_4_4 */ ]: 2,
    [32820 /* UNSIGNED_SHORT_5_5_5_1 */ ]: 2,
    [33635 /* UNSIGNED_SHORT_5_6_5 */ ]: 2
};
const INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
    [33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */ ]: 0.5,
    [33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */ ]: 0.5,
    [33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */ ]: 1,
    [33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */ ]: 1,
    [35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */ ]: 0.5,
    [35917 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */ ]: 0.5,
    [35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */ ]: 1,
    [35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */ ]: 1,
    [36283 /* COMPRESSED_RED_RGTC1_EXT */ ]: 0.5,
    [36284 /* COMPRESSED_SIGNED_RED_RGTC1_EXT */ ]: 0.5,
    [36285 /* COMPRESSED_RED_GREEN_RGTC2_EXT */ ]: 1,
    [36286 /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */ ]: 1,
    [37488 /* COMPRESSED_R11_EAC */ ]: 0.5,
    [37489 /* COMPRESSED_SIGNED_R11_EAC */ ]: 0.5,
    [37490 /* COMPRESSED_RG11_EAC */ ]: 1,
    [37491 /* COMPRESSED_SIGNED_RG11_EAC */ ]: 1,
    [37492 /* COMPRESSED_RGB8_ETC2 */ ]: 0.5,
    [37496 /* COMPRESSED_RGBA8_ETC2_EAC */ ]: 1,
    [37493 /* COMPRESSED_SRGB8_ETC2 */ ]: 0.5,
    [37497 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */ ]: 1,
    [37494 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */ ]: 0.5,
    [37495 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */ ]: 0.5,
    [37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */ ]: 1,
    [37840 /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */ ]: 1,
    [37809 /* COMPRESSED_RGBA_ASTC_5x4_KHR */ ]: 0.8,
    [37841 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */ ]: 0.8,
    [37810 /* COMPRESSED_RGBA_ASTC_5x5_KHR */ ]: 0.64,
    [37842 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */ ]: 0.64,
    [37811 /* COMPRESSED_RGBA_ASTC_6x5_KHR */ ]: 0.53375,
    [37843 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */ ]: 0.53375,
    [37812 /* COMPRESSED_RGBA_ASTC_6x6_KHR */ ]: 0.445,
    [37844 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */ ]: 0.445,
    [37813 /* COMPRESSED_RGBA_ASTC_8x5_KHR */ ]: 0.4,
    [37845 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */ ]: 0.4,
    [37814 /* COMPRESSED_RGBA_ASTC_8x6_KHR */ ]: 0.33375,
    [37846 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */ ]: 0.33375,
    [37815 /* COMPRESSED_RGBA_ASTC_8x8_KHR */ ]: 0.25,
    [37847 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */ ]: 0.25,
    [37816 /* COMPRESSED_RGBA_ASTC_10x5_KHR */ ]: 0.32,
    [37848 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */ ]: 0.32,
    [37817 /* COMPRESSED_RGBA_ASTC_10x6_KHR */ ]: 0.26625,
    [37849 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */ ]: 0.26625,
    [37818 /* COMPRESSED_RGBA_ASTC_10x8_KHR */ ]: 0.2,
    [37850 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */ ]: 0.2,
    [37819 /* COMPRESSED_RGBA_ASTC_10x10_KHR */ ]: 0.16,
    [37851 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */ ]: 0.16,
    [37820 /* COMPRESSED_RGBA_ASTC_12x10_KHR */ ]: 0.13375,
    [37852 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */ ]: 0.13375,
    [37821 /* COMPRESSED_RGBA_ASTC_12x12_KHR */ ]: 0.11125,
    [37853 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */ ]: 0.11125,
    [36492 /* COMPRESSED_RGBA_BPTC_UNORM_EXT */ ]: 1,
    [36493 /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */ ]: 1,
    [36494 /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */ ]: 1,
    [36495 /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */ ]: 1
};
const KTX = {
    FILE_HEADER_SIZE,
    FILE_IDENTIFIER,
    FORMATS_TO_COMPONENTS,
    INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,
    INTERNAL_FORMAT_TO_TEXTURE_FORMATS,
    FIELDS,
    TYPES_TO_BYTES_PER_COMPONENT,
    TYPES_TO_BYTES_PER_PIXEL,
    ENDIANNESS
};
;
 //# sourceMappingURL=const.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseKTX",
    ()=>parseKTX
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/const.mjs [app-client] (ecmascript)");
;
"use strict";
function parseKTX(arrayBuffer, supportedFormats) {
    const dataView = new DataView(arrayBuffer);
    if (!validate(dataView)) {
        throw new Error("Invalid KTX identifier in header");
    }
    const { littleEndian, glType, glFormat, glInternalFormat, pixelWidth, pixelHeight, numberOfMipmapLevels, offset } = parseKTXHeader(dataView);
    const textureFormat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].INTERNAL_FORMAT_TO_TEXTURE_FORMATS[glInternalFormat];
    if (!textureFormat) {
        throw new Error(`Unknown texture format ${glInternalFormat}`);
    }
    if (!supportedFormats.includes(textureFormat)) {
        throw new Error(`Unsupported texture format: ${textureFormat}, supportedFormats: ${supportedFormats}`);
    }
    const imagePixelByteSize = getImagePixelByteSize(glType, glFormat, glInternalFormat);
    const imageBuffers = getImageBuffers(dataView, glType, imagePixelByteSize, pixelWidth, pixelHeight, offset, numberOfMipmapLevels, littleEndian);
    return {
        format: textureFormat,
        width: pixelWidth,
        height: pixelHeight,
        resource: imageBuffers,
        alphaMode: "no-premultiply-alpha"
    };
}
function getImageBuffers(dataView, glType, imagePixelByteSize, pixelWidth, pixelHeight, offset, numberOfMipmapLevels, littleEndian) {
    const alignedWidth = pixelWidth + 3 & ~3;
    const alignedHeight = pixelHeight + 3 & ~3;
    let imagePixels = pixelWidth * pixelHeight;
    if (glType === 0) {
        imagePixels = alignedWidth * alignedHeight;
    }
    let mipByteSize = imagePixels * imagePixelByteSize;
    let mipWidth = pixelWidth;
    let mipHeight = pixelHeight;
    let alignedMipWidth = alignedWidth;
    let alignedMipHeight = alignedHeight;
    let imageOffset = offset;
    const imageBuffers = new Array(numberOfMipmapLevels);
    for(let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++){
        const imageSize = dataView.getUint32(imageOffset, littleEndian);
        let elementOffset = imageOffset + 4;
        imageBuffers[mipmapLevel] = new Uint8Array(dataView.buffer, elementOffset, mipByteSize);
        elementOffset += mipByteSize;
        imageOffset += imageSize + 4;
        imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
        mipWidth = mipWidth >> 1 || 1;
        mipHeight = mipHeight >> 1 || 1;
        alignedMipWidth = mipWidth + 4 - 1 & ~(4 - 1);
        alignedMipHeight = mipHeight + 4 - 1 & ~(4 - 1);
        mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
    }
    return imageBuffers;
}
function getImagePixelByteSize(glType, glFormat, glInternalFormat) {
    let imagePixelByteSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
    if (glType !== 0) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].TYPES_TO_BYTES_PER_COMPONENT[glType]) {
            imagePixelByteSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].TYPES_TO_BYTES_PER_COMPONENT[glType] * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FORMATS_TO_COMPONENTS[glFormat];
        } else {
            imagePixelByteSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].TYPES_TO_BYTES_PER_PIXEL[glType];
        }
    }
    if (imagePixelByteSize === void 0) {
        throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    }
    return imagePixelByteSize;
}
function parseKTXHeader(dataView) {
    const littleEndian = dataView.getUint32(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FIELDS.ENDIANNESS, true) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].ENDIANNESS;
    const glType = dataView.getUint32(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FIELDS.GL_TYPE, littleEndian);
    const glFormat = dataView.getUint32(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FIELDS.GL_FORMAT, littleEndian);
    const glInternalFormat = dataView.getUint32(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FIELDS.GL_INTERNAL_FORMAT, littleEndian);
    const pixelWidth = dataView.getUint32(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FIELDS.PIXEL_WIDTH, littleEndian);
    const pixelHeight = dataView.getUint32(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
    const pixelDepth = dataView.getUint32(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FIELDS.PIXEL_DEPTH, littleEndian) || 1;
    const numberOfArrayElements = dataView.getUint32(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
    const numberOfFaces = dataView.getUint32(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FIELDS.NUMBER_OF_FACES, littleEndian);
    const numberOfMipmapLevels = dataView.getUint32(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
    const bytesOfKeyValueData = dataView.getUint32(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
    if (pixelHeight === 0 || pixelDepth !== 1) {
        throw new Error("Only 2D textures are supported");
    }
    if (numberOfFaces !== 1) {
        throw new Error("CubeTextures are not supported by KTXLoader yet!");
    }
    if (numberOfArrayElements !== 1) {
        throw new Error("WebGL does not support array textures");
    }
    return {
        littleEndian,
        glType,
        glFormat,
        glInternalFormat,
        pixelWidth,
        pixelHeight,
        numberOfMipmapLevels,
        offset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FILE_HEADER_SIZE + bytesOfKeyValueData
    };
}
function validate(dataView) {
    for(let i = 0; i < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FILE_IDENTIFIER.length; i++){
        if (dataView.getUint8(i) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX"].FILE_IDENTIFIER[i]) {
            return false;
        }
    }
    return true;
}
;
 //# sourceMappingURL=parseKTX.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadKTX",
    ()=>loadKTX
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$textures$2f$utils$2f$createTexture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$checkExtension$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$CompressedSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$utils$2f$getSupportedTextureFormats$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx$2f$parseKTX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
const loadKTX = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].LoadParser,
        priority: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderParserPriority"].High,
        name: "loadKTX"
    },
    /** used for deprecation purposes */ name: "loadKTX",
    id: "ktx",
    test (url) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$checkExtension$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkExtension"])(url, ".ktx");
    },
    async load (url, _asset, loader) {
        const supportedTextures = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$utils$2f$getSupportedTextureFormats$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSupportedTextureFormats"])();
        const ktxResponse = await fetch(url);
        const ktxArrayBuffer = await ktxResponse.arrayBuffer();
        const textureOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx$2f$parseKTX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseKTX"])(ktxArrayBuffer, supportedTextures);
        const compressedTextureSource = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$CompressedSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedSource"](textureOptions);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$textures$2f$utils$2f$createTexture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTexture"])(compressedTextureSource, loader, url);
    },
    unload (texture) {
        if (Array.isArray(texture)) {
            texture.forEach((t)=>t.destroy(true));
        } else {
            texture.destroy(true);
        }
    }
};
;
 //# sourceMappingURL=loadKTX.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ktxTranscoderUrls",
    ()=>ktxTranscoderUrls,
    "setKTXTranscoderPath",
    ()=>setKTXTranscoderPath
]);
"use strict";
const ktxTranscoderUrls = {
    jsUrl: "https://cdn.jsdelivr.net/npm/pixi.js/transcoders/ktx/libktx.js",
    wasmUrl: "https://cdn.jsdelivr.net/npm/pixi.js/transcoders/ktx/libktx.wasm"
};
function setKTXTranscoderPath(config) {
    Object.assign(ktxTranscoderUrls, config);
}
;
 //# sourceMappingURL=setKTXTranscoderPath.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadKTX2onWorker",
    ()=>loadKTX2onWorker
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$_virtual$2f$ktx$2e$worker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/_virtual/ktx.worker.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$utils$2f$setKTXTranscoderPath$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs [app-client] (ecmascript)");
;
;
"use strict";
let ktxWorker;
const urlHash = {};
const errorHash = {};
function getKTX2Worker(supportedTextures) {
    if (!ktxWorker) {
        ktxWorker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$_virtual$2f$ktx$2e$worker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]().worker;
        ktxWorker.onmessage = (messageEvent)=>{
            const { err, success, url, textureOptions } = messageEvent.data;
            if (err) {
                errorHash[url](err);
                return;
            }
            if (!success) {
                console.warn("Failed to load KTX texture", url);
            }
            urlHash[url](textureOptions);
        };
        ktxWorker.postMessage({
            type: "init",
            jsUrl: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$utils$2f$setKTXTranscoderPath$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ktxTranscoderUrls"].jsUrl,
            wasmUrl: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$utils$2f$setKTXTranscoderPath$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ktxTranscoderUrls"].wasmUrl,
            supportedTextures
        });
    }
    return ktxWorker;
}
function loadKTX2onWorker(url, supportedTextures) {
    const ktxWorker2 = getKTX2Worker(supportedTextures);
    return new Promise((resolve, reject)=>{
        urlHash[url] = resolve;
        errorHash[url] = reject;
        ktxWorker2.postMessage({
            type: "load",
            url
        });
    });
}
;
 //# sourceMappingURL=loadKTX2onWorker.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadKTX2",
    ()=>loadKTX2
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$textures$2f$utils$2f$createTexture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$checkExtension$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$CompressedSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$utils$2f$getSupportedTextureFormats$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$worker$2f$loadKTX2onWorker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
"use strict";
const loadKTX2 = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].LoadParser,
        priority: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$LoaderParser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderParserPriority"].High,
        name: "loadKTX2"
    },
    /** used for deprecation purposes */ name: "loadKTX2",
    id: "ktx2",
    test (url) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$checkExtension$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkExtension"])(url, ".ktx2");
    },
    async load (url, _asset, loader) {
        const supportedTextures = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$utils$2f$getSupportedTextureFormats$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSupportedTextureFormats"])();
        const textureOptions = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$worker$2f$loadKTX2onWorker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["loadKTX2onWorker"])(url, supportedTextures);
        const compressedTextureSource = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$CompressedSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedSource"](textureOptions);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$loader$2f$parsers$2f$textures$2f$utils$2f$createTexture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTexture"])(compressedTextureSource, loader, url);
    },
    async unload (texture) {
        if (Array.isArray(texture)) {
            texture.forEach((t)=>t.destroy(true));
        } else {
            texture.destroy(true);
        }
    }
};
;
 //# sourceMappingURL=loadKTX2.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "convertFormatIfRequired",
    ()=>convertFormatIfRequired
]);
"use strict";
const converters = {
    rgb8unorm: {
        convertedFormat: "rgba8unorm",
        convertFunction: convertRGBtoRGBA
    },
    "rgb8unorm-srgb": {
        convertedFormat: "rgba8unorm-srgb",
        convertFunction: convertRGBtoRGBA
    }
};
function convertFormatIfRequired(textureOptions) {
    const format = textureOptions.format;
    if (converters[format]) {
        const convertFunction = converters[format].convertFunction;
        const levelBuffers = textureOptions.resource;
        for(let i = 0; i < levelBuffers.length; i++){
            levelBuffers[i] = convertFunction(levelBuffers[i]);
        }
        textureOptions.format = converters[format].convertedFormat;
    }
}
function convertRGBtoRGBA(levelBuffer) {
    const pixelCount = levelBuffer.byteLength / 3;
    const levelBufferWithAlpha = new Uint32Array(pixelCount);
    for(let i = 0; i < pixelCount; ++i){
        levelBufferWithAlpha[i] = levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] << 8) + (levelBuffer[i * 3 + 2] << 16) + 4278190080;
    }
    return new Uint8Array(levelBufferWithAlpha.buffer);
}
;
 //# sourceMappingURL=convertFormatIfRequired.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createLevelBuffersFromKTX",
    ()=>createLevelBuffersFromKTX
]);
"use strict";
function createLevelBuffersFromKTX(ktxTexture) {
    const levelBuffers = [];
    for(let i = 0; i < ktxTexture.numLevels; i++){
        const imageData = ktxTexture.getImageData(i, 0, 0);
        const levelBuffer = new Uint8Array(imageData.byteLength);
        levelBuffer.set(imageData);
        levelBuffers.push(levelBuffer);
    }
    return levelBuffers;
}
;
 //# sourceMappingURL=createLevelBuffersFromKTX.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "glFormatToGPUFormat",
    ()=>glFormatToGPUFormat
]);
"use strict";
const glFormatToGPUFormatMap = {
    6408: "rgba8unorm",
    32856: "bgra8unorm",
    //
    32857: "rgb10a2unorm",
    33189: "depth16unorm",
    33190: "depth24plus",
    33321: "r8unorm",
    33323: "rg8unorm",
    33325: "r16float",
    33326: "r32float",
    33327: "rg16float",
    33328: "rg32float",
    33329: "r8sint",
    33330: "r8uint",
    33331: "r16sint",
    33332: "r16uint",
    33333: "r32sint",
    33334: "r32uint",
    33335: "rg8sint",
    33336: "rg8uint",
    33337: "rg16sint",
    33338: "rg16uint",
    33339: "rg32sint",
    33340: "rg32uint",
    33778: "bc2-rgba-unorm",
    33779: "bc3-rgba-unorm",
    34836: "rgba32float",
    34842: "rgba16float",
    35056: "depth24plus-stencil8",
    35898: "rg11b10ufloat",
    35901: "rgb9e5ufloat",
    35907: "rgba8unorm-srgb",
    // bgra8unorm-srgb
    36012: "depth32float",
    36013: "depth32float-stencil8",
    36168: "stencil8",
    36208: "rgba32uint",
    36214: "rgba16uint",
    36220: "rgba8uint",
    36226: "rgba32sint",
    36232: "rgba16sint",
    36238: "rgba8sint",
    36492: "bc7-rgba-unorm",
    36756: "r8snorm",
    36757: "rg8snorm",
    36759: "rgba8snorm",
    37496: "etc2-rgba8unorm",
    37808: "astc-4x4-unorm"
};
function glFormatToGPUFormat(glInternalFormat) {
    const format = glFormatToGPUFormatMap[glInternalFormat];
    if (format) {
        return format;
    }
    throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);
}
;
 //# sourceMappingURL=glFormatToGPUFormat.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "vkFormatToGPUFormat",
    ()=>vkFormatToGPUFormat
]);
"use strict";
const vkFormatToGPUFormatMap = {
    23: "rgb8unorm",
    // VK_FORMAT_R8G8B8_UNORM
    37: "rgba8unorm",
    // VK_FORMAT_R8G8B8A8_UNORM
    43: "rgba8unorm-srgb"
};
function vkFormatToGPUFormat(vkFormat) {
    const format = vkFormatToGPUFormatMap[vkFormat];
    if (format) {
        return format;
    }
    throw new Error(`Unsupported VkFormat: ${vkFormat}`);
}
;
 //# sourceMappingURL=vkFormatToGPUFormat.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getTextureFormatFromKTXTexture",
    ()=>getTextureFormatFromKTXTexture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$utils$2f$glFormatToGPUFormat$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$utils$2f$vkFormatToGPUFormat$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs [app-client] (ecmascript)");
;
;
"use strict";
function getTextureFormatFromKTXTexture(ktxTexture) {
    if (ktxTexture.classId === 2) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$utils$2f$vkFormatToGPUFormat$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["vkFormatToGPUFormat"])(ktxTexture.vkFormat);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$ktx2$2f$utils$2f$glFormatToGPUFormat$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["glFormatToGPUFormat"])(ktxTexture.glInternalformat);
}
;
 //# sourceMappingURL=getTextureFormatFromKTXTexture.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "gpuFormatToKTXBasisTranscoderFormat",
    ()=>gpuFormatToKTXBasisTranscoderFormat
]);
"use strict";
const gpuFormatToBasisTranscoderFormatMap = {
    "bc3-rgba-unorm": "BC3_RGBA",
    "bc7-rgba-unorm": "BC7_M5_RGBA",
    "etc2-rgba8unorm": "ETC2_RGBA",
    "astc-4x4-unorm": "ASTC_4x4_RGBA",
    // Uncompressed
    rgba8unorm: "RGBA32",
    rg11b10ufloat: "R11F_G11F_B10F"
};
function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {
    const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];
    if (format) {
        return format;
    }
    throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);
}
;
 //# sourceMappingURL=gpuFormatToKTXBasisTranscoderFormat.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "resolveCompressedTextureUrl",
    ()=>resolveCompressedTextureUrl,
    "validFormats",
    ()=>validFormats
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$resolver$2f$Resolver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$checkExtension$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
;
;
;
"use strict";
const validFormats = [
    "basis",
    "bc7",
    "bc6h",
    "astc",
    "etc2",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac"
];
const resolveCompressedTextureUrl = {
    extension: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].ResolveParser,
    test: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$utils$2f$checkExtension$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkExtension"])(value, [
            ".ktx",
            ".ktx2",
            ".dds"
        ]),
    parse: (value)=>{
        let format;
        const splitValue = value.split(".");
        if (splitValue.length > 2) {
            const newFormat = splitValue[splitValue.length - 2];
            if (validFormats.includes(newFormat)) {
                format = newFormat;
            }
        } else {
            format = splitValue[splitValue.length - 1];
        }
        return {
            resolution: parseFloat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$assets$2f$resolver$2f$Resolver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resolver"].RETINA_PREFIX.exec(value)?.[1] ?? "1"),
            format,
            src: value
        };
    }
};
;
 //# sourceMappingURL=resolveCompressedTextureUrl.mjs.map
}),
"[project]/node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "detectCompressed",
    ()=>detectCompressed
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$utils$2f$getSupportedCompressedTextureFormats$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isWebGLSupported$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isWebGPUSupported$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$shared$2f$resolveCompressedTextureUrl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.mjs [app-client] (ecmascript)");
;
;
;
;
;
"use strict";
let compressedTextureExtensions;
const detectCompressed = {
    extension: {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].DetectionParser,
        priority: 2
    },
    test: async ()=>{
        if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isWebGPUSupported$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWebGPUSupported"])()) return true;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$utils$2f$browser$2f$isWebGLSupported$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWebGLSupported"])()) return true;
        return false;
    },
    add: async (formats)=>{
        const supportedCompressedTextureFormats = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$utils$2f$getSupportedCompressedTextureFormats$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSupportedCompressedTextureFormats"])();
        compressedTextureExtensions = extractExtensionsForCompressedTextureFormats(supportedCompressedTextureFormats);
        return [
            ...compressedTextureExtensions,
            ...formats
        ];
    },
    remove: async (formats)=>{
        if (compressedTextureExtensions) {
            return formats.filter((f)=>!(f in compressedTextureExtensions));
        }
        return formats;
    }
};
function extractExtensionsForCompressedTextureFormats(formats) {
    const extensions = [
        "basis"
    ];
    const dupeMap = {};
    formats.forEach((format)=>{
        const extension = format.split("-")[0];
        if (extension && !dupeMap[extension]) {
            dupeMap[extension] = true;
            extensions.push(extension);
        }
    });
    extensions.sort((a, b)=>{
        const aIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$shared$2f$resolveCompressedTextureUrl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validFormats"].indexOf(a);
        const bIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$compressed$2d$textures$2f$shared$2f$resolveCompressedTextureUrl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validFormats"].indexOf(b);
        if (aIndex === -1) {
            return 1;
        }
        if (bIndex === -1) {
            return -1;
        }
        return aIndex - bIndex;
    });
    return extensions;
}
;
 //# sourceMappingURL=detectCompressed.mjs.map
}),
"[project]/node_modules/pixi.js/lib/prepare/PrepareBase.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PrepareBase",
    ()=>PrepareBase
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/Container.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/ticker/const.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/ticker/Ticker.mjs [app-client] (ecmascript)");
;
;
;
"use strict";
const _PrepareBase = class _PrepareBase {
    /**
   * @param {Renderer} renderer - A reference to the current renderer
   */ constructor(renderer){
        /** called per frame by the ticker, defer processing to next tick */ this._tick = ()=>{
            if (this._destroyed) return;
            this.timeout = setTimeout(this._processQueue, 0);
        };
        /** process the queue up to max item limit per frame */ this._processQueue = ()=>{
            if (this._destroyed) return;
            const { queue } = this;
            let itemsProcessed = 0;
            while(queue.length && itemsProcessed < _PrepareBase.uploadsPerFrame){
                const queueItem = queue.shift();
                this.uploadQueueItem(queueItem);
                itemsProcessed++;
            }
            if (queue.length) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ticker"].system.addOnce(this._tick, this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UPDATE_PRIORITY"].UTILITY);
            } else {
                this._resolve();
            }
        };
        this.renderer = renderer;
        this.queue = [];
        this.resolves = [];
    }
    /**
   * Return a copy of the queue
   * @returns {PrepareQueueItem[]} The queue
   */ getQueue() {
        return [
            ...this.queue
        ];
    }
    /**
   * Add a textures or graphics resource to the queue
   * @param {PrepareSourceItem | PrepareSourceItem[]} resource
   */ add(resource) {
        const resourceArray = Array.isArray(resource) ? resource : [
            resource
        ];
        for (const resourceItem of resourceArray){
            if (resourceItem instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Container"]) {
                this._addContainer(resourceItem);
            } else {
                this.resolveQueueItem(resourceItem, this.queue);
            }
        }
        return this;
    }
    /**
   * Recursively add a container and its children to the queue
   * @param {Container} container - The container to add to the queue
   */ _addContainer(container) {
        this.resolveQueueItem(container, this.queue);
        for (const child of container.children){
            this._addContainer(child);
        }
    }
    /**
   * Upload all the textures and graphics to the GPU (optionally add more resources to the queue first)
   * @param {PrepareSourceItem | PrepareSourceItem[] | undefined} resource
   */ upload(resource) {
        if (resource) {
            this.add(resource);
        }
        return new Promise((resolve)=>{
            if (this.queue.length) {
                this.resolves.push(resolve);
                this.dedupeQueue();
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$Ticker$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ticker"].system.addOnce(this._tick, this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$ticker$2f$const$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UPDATE_PRIORITY"].UTILITY);
            } else {
                resolve();
            }
        });
    }
    /** eliminate duplicates before processing */ dedupeQueue() {
        const hash = /* @__PURE__ */ Object.create(null);
        let nextUnique = 0;
        for(let i = 0; i < this.queue.length; i++){
            const current = this.queue[i];
            if (!hash[current.uid]) {
                hash[current.uid] = true;
                this.queue[nextUnique++] = current;
            }
        }
        this.queue.length = nextUnique;
    }
    destroy() {
        this._destroyed = true;
        clearTimeout(this.timeout);
    }
    /** Call all the resolve callbacks */ _resolve() {
        const { resolves } = this;
        const array = resolves.slice(0);
        resolves.length = 0;
        for (const resolve of array){
            resolve();
        }
    }
};
/** The number of uploads to process per frame */ _PrepareBase.uploadsPerFrame = 4;
let PrepareBase = _PrepareBase;
;
 //# sourceMappingURL=PrepareBase.mjs.map
}),
"[project]/node_modules/pixi.js/lib/prepare/PrepareQueue.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PrepareQueue",
    ()=>PrepareQueue
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$TextureSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/container/Container.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$Graphics$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$Mesh$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$Sprite$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$animated$2f$AnimatedSprite$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$TilingSprite$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$Text$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/Text.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$prepare$2f$PrepareBase$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/prepare/PrepareBase.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
"use strict";
class PrepareQueue extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$prepare$2f$PrepareBase$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PrepareBase"] {
    /**
   * Resolve the given resource type and return an item for the queue
   * @param source
   * @param queue
   */ resolveQueueItem(source, queue) {
        if (source instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$container$2f$Container$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Container"]) {
            this.resolveContainerQueueItem(source, queue);
        } else if (source instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$TextureSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureSource"] || source instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$Texture$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]) {
            queue.push(source.source);
        } else if (source instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GraphicsContext"]) {
            queue.push(source);
        }
        return null;
    }
    /**
   * Resolve the given container and return an item for the queue
   * @param container
   * @param queue
   */ resolveContainerQueueItem(container, queue) {
        if (container instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2f$Sprite$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sprite"] || container instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$tiling$2f$TilingSprite$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TilingSprite"] || container instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$mesh$2f$shared$2f$Mesh$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"]) {
            queue.push(container.texture.source);
        } else if (container instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$Text$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"]) {
            queue.push(container);
        } else if (container instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$Graphics$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Graphics"]) {
            queue.push(container.context);
        } else if (container instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$sprite$2d$animated$2f$AnimatedSprite$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimatedSprite"]) {
            container.textures.forEach((textureOrFrame)=>{
                if (textureOrFrame.source) {
                    queue.push(textureOrFrame.source);
                } else {
                    queue.push(textureOrFrame.texture.source);
                }
            });
        }
    }
    /**
   * Resolve the given graphics context and return an item for the queue
   * @param graphicsContext
   */ resolveGraphicsContextQueueItem(graphicsContext) {
        this.renderer.graphicsContext.getGpuContext(graphicsContext);
        const { instructions } = graphicsContext;
        for (const instruction of instructions){
            if (instruction.action === "texture") {
                const { image } = instruction.data;
                return image.source;
            } else if (instruction.action === "fill") {
                const { texture } = instruction.data.style;
                return texture.source;
            }
        }
        return null;
    }
}
;
 //# sourceMappingURL=PrepareQueue.mjs.map
}),
"[project]/node_modules/pixi.js/lib/prepare/PrepareUpload.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PrepareUpload",
    ()=>PrepareUpload
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$TextureSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$Text$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text/Text.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapText$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$HTMLText$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/scene/text-html/HTMLText.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$prepare$2f$PrepareQueue$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/prepare/PrepareQueue.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
"use strict";
class PrepareUpload extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$prepare$2f$PrepareQueue$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PrepareQueue"] {
    /**
   * Upload the given queue item
   * @param item
   */ uploadQueueItem(item) {
        if (item instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$rendering$2f$renderers$2f$shared$2f$texture$2f$sources$2f$TextureSource$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureSource"]) {
            this.uploadTextureSource(item);
        } else if (item instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2f$Text$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"]) {
            this.uploadText(item);
        } else if (item instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$html$2f$HTMLText$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HTMLText"]) {
            this.uploadHTMLText(item);
        } else if (item instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$text$2d$bitmap$2f$BitmapText$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BitmapText"]) {
            this.uploadBitmapText(item);
        } else if (item instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$scene$2f$graphics$2f$shared$2f$GraphicsContext$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GraphicsContext"]) {
            this.uploadGraphicsContext(item);
        }
    }
    uploadTextureSource(textureSource) {
        this.renderer.texture.initSource(textureSource);
    }
    uploadText(_text) {
        this.renderer.renderPipes.text.initGpuText(_text);
    }
    uploadBitmapText(_text) {
        this.renderer.renderPipes.bitmapText.initGpuText(_text);
    }
    uploadHTMLText(_text) {
        this.renderer.renderPipes.htmlText.initGpuText(_text);
    }
    /**
   * Resolve the given graphics context and return an item for the queue
   * @param graphicsContext
   */ uploadGraphicsContext(graphicsContext) {
        this.renderer.graphicsContext.getGpuContext(graphicsContext);
        const { instructions } = graphicsContext;
        for (const instruction of instructions){
            if (instruction.action === "texture") {
                const { image } = instruction.data;
                this.uploadTextureSource(image.source);
            } else if (instruction.action === "fill") {
                const { texture } = instruction.data.style;
                this.uploadTextureSource(texture.source);
            }
        }
        return null;
    }
}
;
 //# sourceMappingURL=PrepareUpload.mjs.map
}),
"[project]/node_modules/pixi.js/lib/prepare/PrepareSystem.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PrepareSystem",
    ()=>PrepareSystem
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/extensions/Extensions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$prepare$2f$PrepareUpload$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pixi.js/lib/prepare/PrepareUpload.mjs [app-client] (ecmascript)");
;
;
"use strict";
class PrepareSystem extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$prepare$2f$PrepareUpload$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PrepareUpload"] {
    /** Destroys the plugin, don't use after this. */ destroy() {
        super.destroy();
        clearTimeout(this.timeout);
        this.renderer = null;
        this.queue = null;
        this.resolves = null;
    }
}
/** @ignore */ PrepareSystem.extension = {
    type: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].WebGLSystem,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pixi$2e$js$2f$lib$2f$extensions$2f$Extensions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtensionType"].WebGPUSystem
    ],
    name: "prepare"
};
;
 //# sourceMappingURL=PrepareSystem.mjs.map
}),
]);

//# sourceMappingURL=node_modules_pixi_js_lib_bb05e0f4._.js.map