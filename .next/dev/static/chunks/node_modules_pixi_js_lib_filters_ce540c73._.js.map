{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/FilterEffect.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/FilterEffect.ts"],"sourcesContent":["import type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { Effect } from '../scene/container/Effect';\nimport type { Filter } from './Filter';\n\n/**\n * A filter effect is an effect that can be applied to a container that involves applying special pixel effects\n * to that container as it is rendered. Used internally when the filters property is modified on a container.\n * @internal\n */\nexport class FilterEffect implements Effect\n{\n    /** read only filters array - to modify, set it again! */\n    public filters: readonly Filter[];\n    /**\n     * If specified, rather than calculating the bounds of the container that the filter\n     * will apply to, we use this rect instead. This is a local rect - so will have the containers transform\n     * applied to it\n     */\n    public filterArea?: Rectangle;\n\n    /** the pipe that knows how to handle this effect */\n    public pipe = 'filter';\n    /** the priority of this effect */\n    public priority = 1;\n\n    public destroy(): void\n    {\n        for (let i = 0; i < this.filters.length; i++)\n        {\n            this.filters[i].destroy();\n        }\n\n        this.filters = null;\n        this.filterArea = null;\n    }\n}\n"],"names":[],"mappings":";;;;;AASO,MAAM,YACb,CAAA;IADO,WAAA,EAAA;QAYH,kDAAA,GAAA,IAAA,CAAO,IAAO,GAAA,QAAA,CAAA;QAEd,gCAAA,GAAA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;IAAA,CAAA;IAEX,OACP,GAAA;QACI,IAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,OAAA,CAAQ,MAAA,EAAQ,CACzC,EAAA,CAAA;YACS,IAAA,CAAA,OAAA,CAAQ,CAAC,CAAA,CAAE,OAAQ,EAAA,CAAA;QAAA,CAC5B;QAEA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;QACf,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;IAAA,CACtB;AACJ"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/Filter.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/Filter.ts"],"sourcesContent":["import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader';\nimport { State } from '../rendering/renderers/shared/state/State';\n\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type {\n    IShaderWithResources,\n    ShaderFromResources,\n    ShaderWithResources\n} from '../rendering/renderers/shared/shader/Shader';\nimport type { BLEND_MODES } from '../rendering/renderers/shared/state/const';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { FilterSystem } from './FilterSystem';\n\n/**\n * The options to use when creating a new filter.\n * @category filters\n * @advanced\n */\nexport interface FilterOptions\n{\n    /** optional blend mode used by the filter when rendering (defaults to 'normal') */\n    blendMode?: BLEND_MODES;\n    /**\n     * the resolution the filter should be rendered at. The lower the resolution, the more performant\n     * the filter will be, but the lower the quality of the output. (default 1)\n     * If 'inherit', the resolution of the render target is used.\n     * Consider lowering this for things like blurs filters\n     */\n    resolution?: number | 'inherit';\n    /**\n     * the amount of pixels to pad the container with when applying the filter. For example a blur extends the\n     * container out as it blurs, so padding is applied to ensure that extra detail is rendered as well\n     * without clipping occurring. (default 0)\n     */\n    padding?: number;\n    /**\n     * If true the filter will make use of antialiasing. Although it looks better this can have a performance impact.\n     * If set to 'inherit', the filter will detect the antialiasing of the render target and change this automatically.\n     * Definitely don't set this to true if the render target has antialiasing set to false. As it will antialias,\n     * but you won't see the difference. (default 'off')\n     *\n     * This can be a boolean or [FilterAntialias]{@link FilterAntialias} string.\n     */\n    antialias?: FilterAntialias | boolean;\n    /**\n     * If this is set to true, the filter system will grab a snap shot of the area being rendered\n     * to and pass this into the shader. This is useful for blend modes that need to be aware of the pixels\n     * they are rendering to. Only use if you need that data, otherwise its an extra gpu copy you don't need!\n     * (default false)\n     *\n     * If given, the shader should have a uniform named `uBackTexture`, which is where the pixels of the\n     * area being rendered to can be sampled from.\n     */\n    blendRequired?: boolean;\n    /**\n     * If this is set to true, the filter system will clip filter texture into viewport\n     * This is useful for filters that applied to whole texture.\n     * (default true)\n     */\n    clipToViewport?: boolean;\n}\n\n/**\n * Filter options mixed with shader resources. A filter needs a shader and some resources to work.\n * @category filters\n * @advanced\n * @see {@link FilterOptions}\n */\nexport type FilterWithShader = FilterOptions & IShaderWithResources;\n\n/**\n * The antialiasing mode of the filter. This can be either:\n * - `on` - the filter is always antialiased regardless of the render target settings\n * - `off` - (default) the filter is never antialiased regardless of the render target settings\n * - `inherit` - the filter uses the antialias settings of the render target\n * @category filters\n * @advanced\n */\nexport type FilterAntialias = 'on' | 'off' | 'inherit';\n\n/**\n * The Filter class is the base for all filter effects used in Pixi.js\n * As it extends a shader, it requires that a glProgram is parsed in to work with WebGL and a gpuProgram for WebGPU.\n * If you don't proved one, then the filter is skipped and just rendered as if it wasn't there for that renderer.\n *\n * A filter can be applied to anything that extends Container in Pixi.js which also includes Sprites, Graphics etc.\n *\n * Its worth noting Performance-wise filters can be pretty expensive if used too much in a single scene.\n * The following happens under the hood when a filter is applied:\n *\n * .1. Break the current batch\n * <br>\n * .2. The target is measured using getGlobalBounds\n * (recursively go through all children and figure out how big the object is)\n * <br>\n * .3. Get the closest Po2 Textures from the texture pool\n * <br>\n * .4. Render the target to that texture\n * <br>\n * .5. Render that texture back to the main frame buffer as a quad using the filters program.\n * <br>\n * <br>\n * Some filters (such as blur) require multiple passes too which can result in an even bigger performance hit. So be careful!\n * Its not generally the complexity of the shader that is the bottle neck,\n * but all the framebuffer / shader switching that has to take place.\n * One filter applied to a container with many objects is MUCH faster than many filter applied to many objects.\n * @category filters\n * @advanced\n * @example\n * import { Filter } from 'pixi.js';\n *\n * const customFilter = new Filter({\n *     glProgram: new GlProgram({\n *         fragment,\n *         vertex,\n *     }),\n *     resources: {\n *         timeUniforms: {\n *             uTime: { value: 0.0, type: 'f32' },\n *         },\n *     },\n * });\n *\n * // Apply the filter\n * sprite.filters = [customFilter];\n *\n * // Update uniform\n * app.ticker.add((ticker) => {\n *     filter.resources.timeUniforms.uniforms.uTime += 0.04 * ticker.deltaTime;\n * });\n */\nexport class Filter extends Shader\n{\n    /** The default filter settings */\n    public static defaultOptions: FilterOptions = {\n        blendMode: 'normal',\n        resolution: 1,\n        padding: 0,\n        antialias: 'off',\n        blendRequired: false,\n        clipToViewport: true,\n    };\n\n    /**\n     * The padding of the filter. Some filters require extra space to breath such as a blur.\n     * Increasing this will add extra width and height to the bounds of the object that the\n     * filter is applied to.\n     * @default 0\n     */\n    public padding: number;\n\n    /**\n     * should the filter use antialiasing?\n     * @default inherit\n     */\n    public antialias: FilterAntialias;\n\n    /** If enabled is true the filter is applied, if false it will not. */\n    public enabled = true;\n\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     */\n    public _state = State.for2d();\n\n    /**\n     * The resolution of the filter. Setting this to be lower will lower the quality but\n     * increase the performance of the filter.\n     * @default 1\n     */\n    public resolution: number | 'inherit';\n\n    /**\n     * Whether or not this filter requires the previous render texture for blending.\n     * @default false\n     */\n    public blendRequired: boolean;\n\n    /**\n     * Clip texture into viewport or not\n     * @default true\n     */\n    public clipToViewport: boolean;\n\n    /**\n     * @param options - The optional parameters of this filter.\n     */\n    constructor(options: FilterWithShader)\n    {\n        options = { ...Filter.defaultOptions, ...options };\n\n        super(options as ShaderWithResources);\n\n        this.blendMode = options.blendMode;\n        this.padding = options.padding;\n\n        // check if is boolean\n        if (typeof options.antialias === 'boolean')\n        {\n            this.antialias = options.antialias ? 'on' : 'off';\n        }\n        else\n        {\n            this.antialias = options.antialias;\n        }\n\n        this.resolution = options.resolution;\n        this.blendRequired = options.blendRequired;\n        this.clipToViewport = options.clipToViewport;\n\n        // this is where the filter system will attach the filter texture\n        this.addResource('uTexture', 0, 1);\n\n        if (options.blendRequired)\n        {\n            // this is where the filter system will attach the back texture\n            this.addResource('uBackTexture', 0, 3);\n        }\n    }\n\n    /**\n     * Applies the filter\n     * @param filterManager - The renderer to retrieve the filter from\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Get the blend mode of the filter.\n     * @default \"normal\"\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._state.blendMode;\n    }\n\n    /** Sets the blend mode of the filter. */\n    set blendMode(value: BLEND_MODES)\n    {\n        this._state.blendMode = value;\n    }\n\n    /**\n     * A short hand function to create a filter based of a vertex and fragment shader src.\n     * @param options\n     * @returns A shiny new PixiJS filter!\n     */\n    public static from(options: FilterOptions & ShaderFromResources): Filter\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Filter({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAqIO,MAAM,OAAA,GAAN,MAAM,OAAA,SAAe,uMAC5B,CAAA;IAAA;;GAAA,GAwDI,YAAY,OACZ,CAAA;QACI,OAAA,GAAU;YAAE,GAAG,OAAO,CAAA,cAAA;YAAgB,GAAG,OAAQ;QAAA,CAAA,CAAA;QAEjD,KAAA,CAAM,OAA8B,CAAA,CAAA;QAlCxC,oEAAA,GAAA,IAAA,CAAO,OAAU,GAAA,IAAA,CAAA;QAMjB;;;KAAA,GAAO,IAAA,CAAA,MAAA,GAAS,oMAAA,CAAM,KAAM,EAAA,CAAA;QA8BxB,IAAA,CAAK,SAAA,GAAY,OAAQ,CAAA,SAAA,CAAA;QACzB,IAAA,CAAK,OAAA,GAAU,OAAQ,CAAA,OAAA,CAAA;QAGnB,IAAA,OAAO,OAAQ,CAAA,SAAA,KAAc,SACjC,EAAA;YACS,IAAA,CAAA,SAAA,GAAY,OAAQ,CAAA,SAAA,GAAY,IAAO,GAAA,KAAA,CAAA;QAAA,CAGhD,MAAA;YACI,IAAA,CAAK,SAAA,GAAY,OAAQ,CAAA,SAAA,CAAA;QAAA,CAC7B;QAEA,IAAA,CAAK,UAAA,GAAa,OAAQ,CAAA,UAAA,CAAA;QAC1B,IAAA,CAAK,aAAA,GAAgB,OAAQ,CAAA,aAAA,CAAA;QAC7B,IAAA,CAAK,cAAA,GAAiB,OAAQ,CAAA,cAAA,CAAA;QAGzB,IAAA,CAAA,WAAA,CAAY,UAAY,EAAA,CAAA,EAAG,CAAC,CAAA,CAAA;QAEjC,IAAI,QAAQ,aACZ,EAAA;YAES,IAAA,CAAA,WAAA,CAAY,cAAgB,EAAA,CAAA,EAAG,CAAC,CAAA,CAAA;QAAA,CACzC;IAAA,CACJ;IAAA;;;;;;GAAA,GASO,KACH,CAAA,aAAA,EACA,KACA,EAAA,MAAA,EACA,SAEJ,EAAA;QACI,aAAA,CAAc,WAAY,CAAA,IAAA,EAAM,KAAO,EAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;IAAA,CAC5D;IAAA;;;GAAA,GAMA,IAAI,SACJ,GAAA;QACI,OAAO,IAAA,CAAK,MAAO,CAAA,SAAA,CAAA;IAAA,CACvB;IAAA,uCAAA,GAGA,IAAI,UAAU,KACd,EAAA;QACI,IAAA,CAAK,MAAA,CAAO,SAAY,GAAA,KAAA,CAAA;IAAA,CAC5B;IAAA;;;;GAAA,GAOA,OAAc,KAAK,OACnB,EAAA;QACI,MAAM,EAAE,GAAA,EAAK,EAAI,EAAA,GAAG,MAAS,GAAA,OAAA,CAAA;QAEzB,IAAA,UAAA,CAAA;QACA,IAAA,SAAA,CAAA;QAEJ,IAAI,GACJ,EAAA;YACiB,UAAA,GAAA,4MAAA,CAAW,IAAA,CAAK,GAAG,CAAA,CAAA;QAAA,CACpC;QAEA,IAAI,EACJ,EAAA;YACgB,SAAA,GAAA,yMAAA,CAAU,IAAA,CAAK,EAAE,CAAA,CAAA;QAAA,CACjC;QAEA,OAAO,IAAI,OAAO,CAAA;YACd,UAAA;YACA,SAAA;YACA,GAAG,IAAA;QAAA,CACN,CAAA,CAAA;IAAA,CACL;AACJ,CAAA,CAAA;AAAA,gCAAA,GAtJa,OAAA,CAGK,cAAgC,GAAA;IAC1C,SAAW,EAAA,QAAA;IACX,UAAY,EAAA,CAAA;IACZ,OAAS,EAAA,CAAA;IACT,SAAW,EAAA,KAAA;IACX,aAAe,EAAA,KAAA;IACf,cAAgB,EAAA,IAAA;AACpB,CAAA,CAAA;AAVG,IAAM,MAAN,GAAA"}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 135, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 146, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/blend-modes/BlendModeFilter.ts"],"sourcesContent":["import { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { Filter } from '../Filter';\nimport blendTemplateFrag from './blend-template.frag';\nimport blendTemplateVert from './blend-template.vert';\nimport blendTemplate from './blend-template.wgsl';\n\n/** @internal */\nexport interface BlendModeFilterOptions\n{\n    source?: string;\n    gpu?: {\n        functions?: string;\n        main?: string;\n    }\n    gl?: {\n        functions?: string;\n        main?: string;\n    }\n}\n\n/** @internal */\nexport class BlendModeFilter extends Filter\n{\n    constructor(options: BlendModeFilterOptions)\n    {\n        const gpuOptions = options.gpu;\n\n        const gpuSource = compileBlendModeShader({ source: blendTemplate, ...gpuOptions });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: gpuSource,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source: gpuSource,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glOptions = options.gl;\n\n        const glSource = compileBlendModeShader({ source: blendTemplateFrag, ...glOptions });\n\n        const glProgram = GlProgram.from({\n            vertex: blendTemplateVert,\n            fragment: glSource\n        });\n\n        const uniformGroup = new UniformGroup({\n            uBlend: {\n                value: 1,\n                type: 'f32'\n            }\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            blendRequired: true,\n            resources: {\n                blendUniforms: uniformGroup,\n                uBackTexture: Texture.EMPTY\n            }\n        });\n    }\n}\n\nfunction compileBlendModeShader(options: {source: string, functions?: string, main?: string}): string\n{\n    const { source, functions, main } = options;\n\n    return source.replace('{FUNCTIONS}', functions).replace('{MAIN}', main);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAwBO,MAAM,wBAAwB,oKACrC,CAAA;IACI,YAAY,OACZ,CAAA;QACI,MAAM,aAAa,OAAQ,CAAA,GAAA,CAAA;QAE3B,MAAM,YAAY,sBAAuB,CAAA;YAAE,QAAQ,0MAAe;YAAA,GAAG,UAAA;QAAA,CAAY,CAAA,CAAA;QAE3E,MAAA,UAAA,GAAa,4MAAA,CAAW,IAAK,CAAA;YAC/B,MAAQ,EAAA;gBACJ,MAAQ,EAAA,SAAA;gBACR,UAAY,EAAA,YAAA;YAAA,CAChB;YACA,QAAU,EAAA;gBACN,MAAQ,EAAA,SAAA;gBACR,UAAY,EAAA,cAAA;YAAA,CAChB;QAAA,CACH,CAAA,CAAA;QAED,MAAM,YAAY,OAAQ,CAAA,EAAA,CAAA;QAE1B,MAAM,WAAW,sBAAuB,CAAA;YAAE,QAAQ,0MAAmB;YAAA,GAAG,SAAA;QAAA,CAAW,CAAA,CAAA;QAE7E,MAAA,SAAA,GAAY,yMAAA,CAAU,IAAK,CAAA;YAC7B,MAAQ,EAAA,0MAAA;YACR,QAAU,EAAA,QAAA;QAAA,CACb,CAAA,CAAA;QAEK,MAAA,YAAA,GAAe,IAAI,mNAAa,CAAA;YAClC,MAAQ,EAAA;gBACJ,KAAO,EAAA,CAAA;gBACP,IAAM,EAAA,KAAA;YAAA,CACV;QAAA,CACH,CAAA,CAAA;QAEK,KAAA,CAAA;YACF,UAAA;YACA,SAAA;YACA,aAAe,EAAA,IAAA;YACf,SAAW,EAAA;gBACP,aAAe,EAAA,YAAA;gBACf,cAAc,0MAAQ,CAAA,KAAA;YAAA,CAC1B;QAAA,CACH,CAAA,CAAA;IAAA,CACL;AACJ,CAAA;AAEA,SAAS,uBAAuB,OAChC,EAAA;IACI,MAAM,EAAE,MAAA,EAAQ,SAAW,EAAA,IAAA,EAAS,GAAA,OAAA,CAAA;IAEpC,OAAO,OAAO,OAAQ,CAAA,aAAA,EAAe,SAAS,CAAE,CAAA,OAAA,CAAQ,UAAU,IAAI,CAAA,CAAA;AAC1E"}},
    {"offset": {"line": 231, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/blend-modes/hls/GLhls.ts"],"sourcesContent":["/**\n * A helper object containing the hsl shader code for both glsl\n * @internal\n */\nexport const hslgl = `\n\tfloat getLuminosity(vec3 c) {\n\t\treturn 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\n\t}\n\n\tvec3 setLuminosity(vec3 c, float lum) {\n\t\tfloat modLum = lum - getLuminosity(c);\n\t\tvec3 color = c.rgb + vec3(modLum);\n\n\t\t// clip back into legal range\n\t\tmodLum = getLuminosity(color);\n\t\tvec3 modLumVec = vec3(modLum);\n\n\t\tfloat cMin = min(color.r, min(color.g, color.b));\n\t\tfloat cMax = max(color.r, max(color.g, color.b));\n\n\t\tif(cMin < 0.0) {\n\t\t\tcolor = mix(modLumVec, color, modLum / (modLum - cMin));\n\t\t}\n\n\t\tif(cMax > 1.0) {\n\t\t\tcolor = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));\n\t\t}\n\n\t\treturn color;\n\t}\n\n\tfloat getSaturation(vec3 c) {\n\t\treturn max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n\t}\n\n\tvec3 setSaturationMinMidMax(vec3 cSorted, float s) {\n\t\tvec3 colorSorted = cSorted;\n\n\t\tif(colorSorted.z > colorSorted.x) {\n\t\t\tcolorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));\n\t\t\tcolorSorted.z = s;\n\t\t}\n\t\telse {\n\t\t\tcolorSorted.y = 0.0;\n\t\t\tcolorSorted.z = 0.0;\n\t\t}\n\n\t\tcolorSorted.x = 0.0;\n\n\t\treturn colorSorted;\n\t}\n\n\tvec3 setSaturation(vec3 c, float s) {\n\t\tvec3 color = c;\n\n\t\tif(color.r <= color.g && color.r <= color.b) {\n\t\t\tif(color.g <= color.b) {\n\t\t\t\tcolor = setSaturationMinMidMax(color.rgb, s).rgb;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolor = setSaturationMinMidMax(color.rbg, s).rbg;\n\t\t\t}\n\t\t}\n\t\telse if(color.g <= color.r && color.g <= color.b) {\n\t\t\tif(color.r <= color.b) {\n\t\t\t\tcolor = setSaturationMinMidMax(color.grb, s).grb;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolor = setSaturationMinMidMax(color.gbr, s).gbr;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Using bgr for both fixes part of hue\n\t\t\tif(color.r <= color.g) {\n\t\t\t\tcolor = setSaturationMinMidMax(color.brg, s).brg;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolor = setSaturationMinMidMax(color.bgr, s).bgr;\n\t\t\t}\n\t\t}\n\n\t\treturn color;\n\t}\n    `;\n"],"names":[],"mappings":";;;;;AAIO,MAAM,KAAQ,GAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAAA,CAAA"}},
    {"offset": {"line": 322, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/blend-modes/hls/GPUhls.ts"],"sourcesContent":["/**\n * A helper object containing the hsl shader code for wgsl\n * @internal\n */\nexport const hslgpu = `\n\tfn getLuminosity(c: vec3<f32>) -> f32\n\t{\n\t\treturn 0.3*c.r + 0.59*c.g + 0.11*c.b;\n\t}\n\n\tfn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>\n\t{\n\t\tvar modLum: f32 = lum - getLuminosity(c);\n\t\tvar color: vec3<f32> = c.rgb + modLum;\n\n\t\t// clip back into legal range\n\t\tmodLum = getLuminosity(color);\n\t\tlet modLumVec = vec3<f32>(modLum);\n\n\t\tlet cMin: f32 = min(color.r, min(color.g, color.b));\n\t\tlet cMax: f32 = max(color.r, max(color.g, color.b));\n\n\t\tif(cMin < 0.0)\n\t\t{\n\t\t\tcolor = mix(modLumVec, color, modLum / (modLum - cMin));\n\t\t}\n\n\t\tif(cMax > 1.0)\n\t\t{\n\t\t\tcolor = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));\n\t\t}\n\n\t\treturn color;\n\t}\n\n\tfn getSaturation(c: vec3<f32>) -> f32\n\t{\n\t\treturn max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n\t}\n\n\tfn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>\n\t{\n\t\tvar colorSorted = cSorted;\n\n\t\tif(colorSorted.z > colorSorted.x)\n\t\t{\n\t\t\tcolorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));\n\t\t\tcolorSorted.z = s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolorSorted.y = 0;\n\t\t\tcolorSorted.z = 0;\n\t\t}\n\n\t\tcolorSorted.x = 0;\n\n\t\treturn colorSorted;\n\t}\n\n\tfn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>\n\t{\n\t\tvar color = c;\n\n\t\tif (color.r <= color.g && color.r <= color.b)\n\t\t{\n\t\t\tif (color.g <= color.b)\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;\n\t\t\t}\n\t\t}\n\t\telse if (color.g <= color.r && color.g <= color.b)\n\t\t{\n\t\t\tif (color.r <= color.b)\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Using bgr for both fixes part of hue\n\t\t\tif (color.r <= color.g)\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolor  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;\n\t\t\t}\n\t\t}\n\n\t\treturn color;\n\t}\n\t`;\n"],"names":[],"mappings":";;;;;AAIO,MAAM,MAAS,GAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAA,CAAA"}},
    {"offset": {"line": 431, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 442, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 453, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 464, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 475, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 486, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 497, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 508, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 519, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 530, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 541, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 552, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 563, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.frag.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 574, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.wgsl.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 585, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/mask/mask.frag.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 596, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/mask/mask.vert.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 607, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 618, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/defaults/alpha/AlphaFilter.ts"],"sourcesContent":["import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Filter } from '../../Filter';\nimport vertex from '../defaultFilter.vert';\nimport fragment from './alpha.frag';\nimport source from './alpha.wgsl';\n\nimport type { FilterOptions } from '../../Filter';\n\n/**\n * Options for AlphaFilter\n * @category filters\n * @standard\n */\nexport interface AlphaFilterOptions extends FilterOptions\n{\n    /**\n     * Amount of alpha from 0 to 1, where 0 is transparent\n     * @default 1\n     */\n    alpha: number;\n}\n\n/**\n * Simplest filter - applies alpha.\n *\n * Use this instead of Container's alpha property to avoid visual layering of individual elements.\n * AlphaFilter applies alpha evenly across the entire display object and any opaque elements it contains.\n * If elements are not opaque, they will blend with each other anyway.\n *\n * Very handy if you want to use common features of all filters:\n *\n * 1. Assign a blendMode to this filter, blend all elements inside display object with background.\n *\n * 2. To use clipping in display coordinates, assign a filterArea to the same container that has this filter.\n * @category filters\n * @standard\n * @noInheritDoc\n * @example\n * import { AlphaFilter } from 'pixi.js';\n *\n * const filter = new AlphaFilter({ alpha: 0.5 });\n * sprite.filters = filter;\n *\n * // update alpha\n * filter.alpha = 0.8;\n */\nexport class AlphaFilter extends Filter\n{\n    /**\n     * Default options for the AlphaFilter.\n     * @example\n     * ```ts\n     * AlphaFilter.defaultOptions = {\n     *     alpha: 0.5, // Default alpha value\n     * };\n     * // Use default options\n     * const filter = new AlphaFilter(); // Uses default alpha of 0.5\n     * ```\n     */\n    public static defaultOptions: AlphaFilterOptions = {\n        /**\n         * Amount of alpha transparency to apply.\n         * - 0 = fully transparent\n         * - 1 = fully opaque (default)\n         * @default 1\n         */\n        alpha: 1,\n    };\n\n    constructor(options?: AlphaFilterOptions)\n    {\n        options = { ...AlphaFilter.defaultOptions, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'alpha-filter'\n        });\n\n        const { alpha, ...rest } = options;\n\n        const alphaUniforms = new UniformGroup({\n            uAlpha: { value: alpha, type: 'f32' },\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                alphaUniforms\n            },\n        });\n    }\n\n    /**\n     * The alpha value of the filter.\n     * Controls the transparency of the filtered display object.\n     * @example\n     * ```ts\n     * // Create filter with initial alpha\n     * const filter = new AlphaFilter({ alpha: 0.5 });\n     *\n     * // Update alpha value dynamically\n     * filter.alpha = 0.8;\n     * ```\n     * @default 1\n     * @remarks\n     * - 0 = fully transparent\n     * - 1 = fully opaque\n     * - Values are clamped between 0 and 1\n     */\n    get alpha(): number { return this.resources.alphaUniforms.uniforms.uAlpha; }\n    set alpha(value: number) { this.resources.alphaUniforms.uniforms.uAlpha = value; }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAgDO,MAAM,YAAA,GAAN,MAAM,YAAA,SAAoB,oKACjC,CAAA;IAsBI,YAAY,OACZ,CAAA;QACI,OAAA,GAAU;YAAE,GAAG,YAAY,CAAA,cAAA;YAAgB,GAAG,OAAQ;QAAA,CAAA,CAAA;QAEhD,MAAA,UAAA,GAAa,4MAAA,CAAW,IAAK,CAAA;YAC/B,MAAQ,EAAA;wBACJ,iMAAA;gBACA,UAAY,EAAA,YAAA;YAAA,CAChB;YACA,QAAU,EAAA;wBACN,iMAAA;gBACA,UAAY,EAAA,cAAA;YAAA,CAChB;QAAA,CACH,CAAA,CAAA;QAEK,MAAA,SAAA,GAAY,yMAAA,CAAU,IAAK,CAAA;oBAC7B,gMAAA;sBACA,iMAAA;YACA,IAAM,EAAA,cAAA;QAAA,CACT,CAAA,CAAA;QAED,MAAM,EAAE,KAAA,EAAO,GAAG,IAAA,EAAS,GAAA,OAAA,CAAA;QAErB,MAAA,aAAA,GAAgB,IAAI,mNAAa,CAAA;YACnC,MAAQ,EAAA;gBAAE,KAAO,EAAA,KAAA;gBAAO,MAAM,KAAM;YAAA,CAAA;QAAA,CACvC,CAAA,CAAA;QAEK,KAAA,CAAA;YACF,GAAG,IAAA;YACH,UAAA;YACA,SAAA;YACA,SAAW,EAAA;gBACP,aAAA;YAAA,CACJ;QAAA,CACH,CAAA,CAAA;IAAA,CACL;IAAA;;;;;;;;;;;;;;;;GAAA,GAmBA,IAAI,KAAgB,GAAA;QAAS,OAAA,IAAA,CAAK,SAAU,CAAA,aAAA,CAAc,QAAS,CAAA,MAAA,CAAA;IAAA,CAAQ;IAC3E,IAAI,MAAM,KAAe,EAAA;QAAO,IAAA,CAAA,SAAA,CAAU,aAAc,CAAA,QAAA,CAAS,MAAS,GAAA,KAAA,CAAA;IAAA,CAAO;AACrF,CAAA,CAAA;AAAA;;;;;;;;;;CAAA,GA/Ea,YAAA,CAaK,cAAqC,GAAA;IAAA;;;;;GAAA,GAO/C,KAAO,EAAA,CAAA;AACX,CAAA,CAAA;AArBG,IAAM,WAAN,GAAA"}},
    {"offset": {"line": 722, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/blur/const.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/defaults/blur/const.ts"],"sourcesContent":["interface IGAUSSIAN_VALUES\n{\n    [x: number]: number[];\n}\n\n/** @internal */\nexport const GAUSSIAN_VALUES: IGAUSSIAN_VALUES = {\n    5: [0.153388, 0.221461, 0.250301],\n    7: [0.071303, 0.131514, 0.189879, 0.214607],\n    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n    11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n    13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n    15: [0.000489, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448],\n};\n"],"names":[],"mappings":";;;;;AAMO,MAAM,eAAoC,GAAA;IAC7C,CAAG,EAAA;QAAC,QAAU;QAAA,QAAA;QAAU,QAAQ;KAAA;IAChC,CAAG,EAAA;QAAC,QAAU;QAAA,QAAA;QAAU;QAAU,QAAQ;KAAA;IAC1C,GAAG;QAAC,QAAA;QAAU,QAAU;QAAA,QAAA;QAAU;QAAU,OAAO;KAAA;IACnD,IAAI;QAAC,KAAA;QAAQ;QAAU,QAAU;QAAA,QAAA;QAAU;QAAU,QAAQ;KAAA;IAC7D,EAAA,EAAI;QAAC,OAAU;QAAA,OAAA;QAAU;QAAU,QAAU;QAAA,QAAA;QAAU;QAAU,QAAQ;KAAA;IACzE,EAAA,EAAI;QAAC,MAAU;QAAA,OAAA;QAAU;QAAU,OAAS;QAAA,QAAA;QAAU,QAAU;QAAA,QAAA;QAAU,QAAQ;KAAA;AACtF"}},
    {"offset": {"line": 780, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/defaults/blur/gl/generateBlurFragSource.ts"],"sourcesContent":["import { GAUSSIAN_VALUES } from '../const';\n\nconst fragTemplate = [\n    'in vec2 vBlurTexCoords[%size%];',\n    'uniform sampler2D uTexture;',\n    'out vec4 finalColor;',\n\n    'void main(void)',\n    '{',\n    '    finalColor = vec4(0.0);',\n    '    %blur%',\n    '}',\n\n].join('\\n');\n\n/**\n * @internal\n * @param kernelSize - The size of the kernel.\n */\nexport function generateBlurFragSource(kernelSize: number): string\n{\n    const kernel = GAUSSIAN_VALUES[kernelSize];\n    const halfLength = kernel.length;\n\n    let fragSource = fragTemplate;\n\n    let blurLoop = '';\n    const template = 'finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;';\n    let value: number;\n\n    for (let i = 0; i < kernelSize; i++)\n    {\n        let blur = template.replace('%index%', i.toString());\n\n        value = i;\n\n        if (i >= halfLength)\n        {\n            value = kernelSize - i - 1;\n        }\n\n        blur = blur.replace('%value%', kernel[value].toString());\n\n        blurLoop += blur;\n        blurLoop += '\\n';\n    }\n\n    fragSource = fragSource.replace('%blur%', blurLoop);\n    fragSource = fragSource.replace('%size%', kernelSize.toString());\n\n    return fragSource;\n}\n"],"names":[],"mappings":";;;;;;;AAEA,MAAM,YAAe,GAAA;IACjB,iCAAA;IACA,6BAAA;IACA,sBAAA;IAEA,iBAAA;IACA,GAAA;IACA,6BAAA;IACA,YAAA;IACA,GAAA;CAEJ,CAAE,IAAA,CAAK,IAAI,CAAA,CAAA;AAMJ,SAAS,uBAAuB,UACvC,EAAA;IACU,MAAA,MAAA,GAAS,gMAAA,CAAgB,UAAU,CAAA,CAAA;IACzC,MAAM,aAAa,MAAO,CAAA,MAAA,CAAA;IAE1B,IAAI,UAAa,GAAA,YAAA,CAAA;IAEjB,IAAI,QAAW,GAAA,EAAA,CAAA;IACf,MAAM,QAAW,GAAA,qEAAA,CAAA;IACb,IAAA,KAAA,CAAA;IAEJ,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,UAAA,EAAY,CAChC,EAAA,CAAA;QACI,IAAI,OAAO,QAAS,CAAA,OAAA,CAAQ,SAAW,EAAA,CAAA,CAAE,QAAA,EAAU,CAAA,CAAA;QAE3C,KAAA,GAAA,CAAA,CAAA;QAER,IAAI,KAAK,UACT,EAAA;YACI,KAAA,GAAQ,aAAa,CAAI,GAAA,CAAA,CAAA;QAAA,CAC7B;QAEA,IAAA,GAAO,KAAK,OAAQ,CAAA,SAAA,EAAW,MAAA,CAAO,KAAK,CAAA,CAAE,QAAA,EAAU,CAAA,CAAA;QAE3C,QAAA,IAAA,IAAA,CAAA;QACA,QAAA,IAAA,IAAA,CAAA;IAAA,CAChB;IAEa,UAAA,GAAA,UAAA,CAAW,OAAQ,CAAA,QAAA,EAAU,QAAQ,CAAA,CAAA;IAClD,UAAA,GAAa,UAAW,CAAA,OAAA,CAAQ,QAAU,EAAA,UAAA,CAAW,QAAA,EAAU,CAAA,CAAA;IAExD,OAAA,UAAA,CAAA;AACX"}},
    {"offset": {"line": 824, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/defaults/blur/gl/generateBlurVertSource.ts"],"sourcesContent":["const vertTemplate = `\n    in vec2 aPosition;\n\n    uniform float uStrength;\n\n    out vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 uInputSize;\n    uniform vec4 uOutputFrame;\n    uniform vec4 uOutputTexture;\n\n    vec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\n    vec2 filterTextureCoord( void )\n    {\n        return aPosition * (uOutputFrame.zw * uInputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        float pixelStrength = uInputSize.%dimension% * uStrength;\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }`;\n\n/**\n * @internal\n * @param kernelSize - The size of the kernel.\n * @param x - Whether to generate a horizontal or vertical blur program.\n */\nexport function generateBlurVertSource(kernelSize: number, x: boolean): string\n{\n    const halfLength = Math.ceil(kernelSize / 2);\n\n    let vertSource = vertTemplate;\n\n    let blurLoop = '';\n    let template;\n\n    if (x)\n    {\n        template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);';\n    }\n    else\n    {\n        template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);';\n    }\n\n    for (let i = 0; i < kernelSize; i++)\n    {\n        let blur = template.replace('%index%', i.toString());\n\n        blur = blur.replace('%sampleIndex%', `${i - (halfLength - 1)}.0`);\n\n        blurLoop += blur;\n        blurLoop += '\\n';\n    }\n\n    vertSource = vertSource.replace('%blur%', blurLoop);\n    vertSource = vertSource.replace('%size%', kernelSize.toString());\n    vertSource = vertSource.replace('%dimension%', x ? 'z' : 'w');\n\n    return vertSource;\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAM,YAAe,GAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAAA,CAAA,CAAA;AAyCL,SAAA,sBAAA,CAAuB,UAAA,EAAoB,CAC3D,EAAA;IACI,MAAM,UAAa,GAAA,IAAA,CAAK,IAAK,CAAA,UAAA,GAAa,CAAC,CAAA,CAAA;IAE3C,IAAI,UAAa,GAAA,YAAA,CAAA;IAEjB,IAAI,QAAW,GAAA,EAAA,CAAA;IACX,IAAA,QAAA,CAAA;IAEJ,IAAI,CACJ,EAAA;QACe,QAAA,GAAA,qFAAA,CAAA;IAAA,CAGf,MAAA;QACe,QAAA,GAAA,qFAAA,CAAA;IAAA,CACf;IAEA,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,UAAA,EAAY,CAChC,EAAA,CAAA;QACI,IAAI,OAAO,QAAS,CAAA,OAAA,CAAQ,SAAW,EAAA,CAAA,CAAE,QAAA,EAAU,CAAA,CAAA;QAEnD,IAAA,GAAO,KAAK,OAAQ,CAAA,eAAA,EAAiB,GAAG,CAAK,GAAA,CAAA,UAAA,GAAa,CAAA,CAAE,CAAI,EAAA,CAAA,CAAA,CAAA;QAEpD,QAAA,IAAA,IAAA,CAAA;QACA,QAAA,IAAA,IAAA,CAAA;IAAA,CAChB;IAEa,UAAA,GAAA,UAAA,CAAW,OAAQ,CAAA,QAAA,EAAU,QAAQ,CAAA,CAAA;IAClD,UAAA,GAAa,UAAW,CAAA,OAAA,CAAQ,QAAU,EAAA,UAAA,CAAW,QAAA,EAAU,CAAA,CAAA;IAC/D,UAAA,GAAa,UAAW,CAAA,OAAA,CAAQ,aAAe,EAAA,CAAA,GAAI,MAAM,GAAG,CAAA,CAAA;IAErD,OAAA,UAAA,CAAA;AACX"}},
    {"offset": {"line": 891, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/defaults/blur/gl/generateBlurGlProgram.ts"],"sourcesContent":["import { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { generateBlurFragSource } from './generateBlurFragSource';\nimport { generateBlurVertSource } from './generateBlurVertSource';\n\n/**\n * @internal\n * @param horizontal - Whether to generate a horizontal or vertical blur program.\n * @param kernelSize - The size of the kernel.\n */\nexport function generateBlurGlProgram(horizontal: boolean, kernelSize: number)\n{\n    const vertex = generateBlurVertSource(kernelSize, horizontal);\n    const fragment = generateBlurFragSource(kernelSize);\n\n    return GlProgram.from({\n        vertex,\n        fragment,\n        name: `blur-${horizontal ? 'horizontal' : 'vertical'}-pass-filter`\n    });\n}\n"],"names":[],"mappings":";;;;;;;;;;;AASgB,SAAA,qBAAA,CAAsB,UAAA,EAAqB,UAC3D,EAAA;IACU,MAAA,MAAA,OAAS,8NAAuB,EAAA,UAAA,EAAY,UAAU,CAAA,CAAA;IACtD,MAAA,QAAA,OAAW,8NAAA,EAAuB,UAAU,CAAA,CAAA;IAElD,OAAO,yMAAA,CAAU,IAAK,CAAA;QAClB,MAAA;QACA,QAAA;QACA,IAAM,EAAA,CAAA,KAAA,EAAQ,UAAa,GAAA,YAAA,GAAe,UAAU,CAAA,YAAA,CAAA;IAAA,CACvD,CAAA,CAAA;AACL"}},
    {"offset": {"line": 917, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/defaults/blur/gpu/generateBlurProgram.ts"],"sourcesContent":["import { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { GAUSSIAN_VALUES } from '../const';\nimport source from './blur-template.wgsl';\n\n/**\n * @internal\n * @param horizontal - Whether to generate a horizontal or vertical blur program.\n * @param kernelSize - The size of the kernel.\n */\nexport function generateBlurProgram(horizontal: boolean, kernelSize: number)\n{\n    const kernel = GAUSSIAN_VALUES[kernelSize];\n    const halfLength = kernel.length;\n\n    const blurStructSource: string[] = [];\n    const blurOutSource: string[] = [];\n    const blurSamplingSource: string[] = [];\n\n    for (let i = 0; i < kernelSize; i++)\n    {\n        blurStructSource[i] = `@location(${i}) offset${i}: vec2<f32>,`;\n\n        if (horizontal)\n        {\n            blurOutSource[i] = `filteredCord + vec2(${i - halfLength + 1} * pixelStrength, 0.0),`;\n        }\n        else\n        {\n            blurOutSource[i] = `filteredCord + vec2(0.0, ${i - halfLength + 1} * pixelStrength),`;\n        }\n\n        const kernelIndex = i < halfLength ? i : (kernelSize - i - 1);\n        const kernelValue = kernel[kernelIndex].toString();\n\n        blurSamplingSource[i] = `finalColor += textureSample(uTexture, uSampler, offset${i}) * ${kernelValue};`;\n    }\n\n    const blurStruct = blurStructSource.join('\\n');\n    const blurOut = blurOutSource.join('\\n');\n    const blurSampling = blurSamplingSource.join('\\n');\n\n    const finalSource = source\n        .replace('%blur-struct%', blurStruct)\n        .replace('%blur-vertex-out%', blurOut)\n        .replace('%blur-fragment-in%', blurStruct)\n        .replace('%blur-sampling%', blurSampling)\n        .replace('%dimension%', horizontal ? 'z' : 'w');\n\n    return GpuProgram.from({\n        vertex: {\n            source: finalSource,\n            entryPoint: 'mainVertex',\n        },\n        fragment: {\n            source: finalSource,\n            entryPoint: 'mainFragment',\n        },\n    });\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;AASgB,SAAA,mBAAA,CAAoB,UAAA,EAAqB,UACzD,EAAA;IACU,MAAA,MAAA,GAAS,gMAAA,CAAgB,UAAU,CAAA,CAAA;IACzC,MAAM,aAAa,MAAO,CAAA,MAAA,CAAA;IAE1B,MAAM,mBAA6B,EAAC,CAAA;IACpC,MAAM,gBAA0B,EAAC,CAAA;IACjC,MAAM,qBAA+B,EAAC,CAAA;IAEtC,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,UAAA,EAAY,CAChC,EAAA,CAAA;QACI,gBAAA,CAAiB,CAAC,CAAA,GAAI,CAAa,UAAA,EAAA,CAAC,CAAA,QAAA,EAAW,CAAC,CAAA,YAAA,CAAA,CAAA;QAEhD,IAAI,UACJ,EAAA;YACI,aAAA,CAAc,CAAC,CAAA,GAAI,CAAuB,oBAAA,EAAA,CAAA,GAAI,aAAa,CAAC,CAAA,uBAAA,CAAA,CAAA;QAAA,CAGhE,MAAA;YACI,aAAA,CAAc,CAAC,CAAA,GAAI,CAA4B,yBAAA,EAAA,CAAA,GAAI,aAAa,CAAC,CAAA,kBAAA,CAAA,CAAA;QAAA,CACrE;QAEA,MAAM,WAAc,GAAA,CAAA,GAAI,UAAa,GAAA,CAAA,GAAK,aAAa,CAAI,GAAA,CAAA,CAAA;QAC3D,MAAM,WAAc,GAAA,MAAA,CAAO,WAAW,CAAA,CAAE,QAAS,EAAA,CAAA;QAEjD,kBAAA,CAAmB,CAAC,CAAA,GAAI,CAAyD,sDAAA,EAAA,CAAC,CAAA,IAAA,EAAO,WAAW,CAAA,CAAA,CAAA,CAAA;IAAA,CACxG;IAEM,MAAA,UAAA,GAAa,gBAAiB,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;IACvC,MAAA,OAAA,GAAU,aAAc,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;IACjC,MAAA,YAAA,GAAe,kBAAmB,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;IAE3C,MAAA,WAAA,GAAc,kNAAA,CACf,OAAQ,CAAA,eAAA,EAAiB,UAAU,CACnC,CAAA,OAAA,CAAQ,mBAAqB,EAAA,OAAO,CACpC,CAAA,OAAA,CAAQ,sBAAsB,UAAU,CAAA,CACxC,OAAA,CAAQ,iBAAmB,EAAA,YAAY,EACvC,OAAQ,CAAA,aAAA,EAAe,UAAa,GAAA,GAAA,GAAM,GAAG,CAAA,CAAA;IAElD,OAAO,4MAAA,CAAW,IAAK,CAAA;QACnB,MAAQ,EAAA;YACJ,MAAQ,EAAA,WAAA;YACR,UAAY,EAAA,YAAA;QAAA,CAChB;QACA,QAAU,EAAA;YACN,MAAQ,EAAA,WAAA;YACR,UAAY,EAAA,cAAA;QAAA,CAChB;IAAA,CACH,CAAA,CAAA;AACL"}},
    {"offset": {"line": 966, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/defaults/blur/BlurFilterPass.ts"],"sourcesContent":["import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../../rendering/renderers/types';\nimport { Filter } from '../../Filter';\nimport { generateBlurGlProgram } from './gl/generateBlurGlProgram';\nimport { generateBlurProgram } from './gpu/generateBlurProgram';\n\nimport type { RenderSurface } from '../../../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { FilterSystem } from '../../FilterSystem';\nimport type { BlurFilterOptions } from './BlurFilter';\n\n/**\n * Options for BlurFilterPass\n * @category filters\n * @internal\n */\nexport interface BlurFilterPassOptions extends BlurFilterOptions\n{\n    /** Do pass along the x-axis (`true`) or y-axis (`false`). */\n    horizontal: boolean;\n}\n\n/**\n * The BlurFilterPass applies a horizontal or vertical Gaussian blur to an object.\n * @category filters\n * @advanced\n * @example\n * import { BlurFilterPass } from 'pixi.js';\n *\n * const filter = new BlurFilterPass({ horizontal: true, strength: 8 });\n * sprite.filters = filter;\n *\n * // update blur\n * filter.blur = 16;\n */\nexport class BlurFilterPass extends Filter\n{\n    /** Default blur filter pass options */\n    public static defaultOptions: Partial<BlurFilterPassOptions> = {\n        /** The strength of the blur filter. */\n        strength: 8,\n        /** The quality of the blur filter. */\n        quality: 4,\n        /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */\n        kernelSize: 5,\n    };\n\n    /** Do pass along the x-axis (`true`) or y-axis (`false`). */\n    public horizontal: boolean;\n    /** The number of passes to run the filter. */\n    public passes!: number;\n    /** The strength of the blur filter. */\n    public strength!: number;\n\n    private _quality: number;\n    private readonly _uniforms: any;\n\n    /**\n     * @param options\n     * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).\n     * @param options.strength - The strength of the blur filter.\n     * @param options.quality - The quality of the blur filter.\n     * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.\n     */\n    constructor(options: BlurFilterPassOptions)\n    {\n        options = { ...BlurFilterPass.defaultOptions, ...options };\n\n        const glProgram = generateBlurGlProgram(options.horizontal, options.kernelSize);\n        const gpuProgram = generateBlurProgram(options.horizontal, options.kernelSize);\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                blurUniforms: {\n                    uStrength: { value: 0, type: 'f32' },\n                }\n            },\n            ...options\n        });\n\n        this.horizontal = options.horizontal;\n\n        this._quality = 0;\n\n        this.quality = options.quality;\n\n        this.blur = options.strength;\n\n        this._uniforms = this.resources.blurUniforms.uniforms;\n    }\n\n    /**\n     * Applies the filter.\n     * @param filterManager - The manager.\n     * @param input - The input target.\n     * @param output - The output target.\n     * @param clearMode - How to clear\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        this._uniforms.uStrength = this.strength / this.passes;\n\n        if (this.passes === 1)\n        {\n            filterManager.applyFilter(this, input, output, clearMode);\n        }\n        else\n        {\n            const tempTexture = TexturePool.getSameSizeTexture(input);\n\n            let flip = input;\n            let flop = tempTexture;\n\n            this._state.blend = false;\n\n            const shouldClear = filterManager.renderer.type === RendererType.WEBGPU;\n\n            for (let i = 0; i < this.passes - 1; i++)\n            {\n                filterManager.applyFilter(this, flip, flop, i === 0 ? true : shouldClear);\n\n                const temp = flop;\n\n                flop = flip;\n                flip = temp;\n            }\n\n            this._state.blend = true;\n            filterManager.applyFilter(this, flip, output, clearMode);\n            TexturePool.returnTexture(tempTexture);\n        }\n    }\n\n    /**\n     * Sets the strength of both the blur.\n     * @default 16\n     */\n    get blur(): number\n    {\n        return this.strength;\n    }\n\n    set blur(value: number)\n    {\n        this.padding = 1 + (Math.abs(value) * 2);\n        this.strength = value;\n    }\n\n    /**\n     * Sets the quality of the blur by modifying the number of passes. More passes means higher\n     * quality blurring but the lower the performance.\n     * @default 4\n     */\n    get quality(): number\n    {\n        return this._quality;\n    }\n\n    set quality(value: number)\n    {\n        this._quality = value;\n        this.passes = value;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1075, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/defaults/blur/BlurFilter.ts"],"sourcesContent":["import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../../rendering/renderers/types';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Filter } from '../../Filter';\nimport { BlurFilterPass } from './BlurFilterPass';\n\nimport type { RenderSurface } from '../../../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { FilterOptions } from '../../Filter';\nimport type { FilterSystem } from '../../FilterSystem';\n\n/**\n * Configuration options for the BlurFilter.\n * Controls how the Gaussian blur effect is applied.\n * @example\n * ```ts\n * // Basic blur with default values\n * const filter = new BlurFilter();\n *\n * // Custom blur configuration\n * const filter = new BlurFilter({\n *     strength: 8,        // Overall blur strength\n *     quality: 4,         // Higher quality = better blur\n *     kernelSize: 5      // Size of blur kernel\n * });\n *\n * // Different horizontal/vertical blur\n * const filter = new BlurFilter({\n *     strengthX: 4,      // Horizontal blur only\n *     strengthY: 12,     // Stronger vertical blur\n *     quality: 2         // Lower quality for better performance\n * });\n * ```\n * @remarks\n * - Higher quality values produce better blur but impact performance\n * - KernelSize affects blur precision and performance\n * - Strength values determine blur intensity\n * @see {@link BlurFilter} The filter that uses these options\n * @see {@link FilterOptions} Base filter options\n * @category filters\n * @standard\n */\nexport interface BlurFilterOptions extends FilterOptions\n{\n    /**\n     * The strength of the blur filter.\n     * Applied to both horizontal and vertical blur if strengthX/Y not set.\n     * @default 8\n     */\n    strength?: number;\n\n    /**\n     * The horizontal strength of the blur.\n     * Overrides strength parameter for x-axis.\n     * @default 8\n     */\n    strengthX?: number;\n\n    /**\n     * The vertical strength of the blur.\n     * Overrides strength parameter for y-axis.\n     * @default 8\n     */\n    strengthY?: number;\n\n    /**\n     * The quality of the blur filter.\n     * Higher values mean better quality but slower performance.\n     * @default 4\n     */\n    quality?: number;\n\n    /**\n     * The kernelSize of the blur filter.\n     * Larger values create more precise blur but impact performance.\n     * Options: 5, 7, 9, 11, 13, 15.\n     * @default 5\n     */\n    kernelSize?: number;\n}\n\n/**\n * The BlurFilter applies a Gaussian blur to an object.\n * The strength of the blur can be set for the x-axis and y-axis separately.\n * @example\n * ```ts\n * import { BlurFilter } from 'pixi.js';\n *\n * // Create with default settings\n * const filter = new BlurFilter();\n *\n * // Create with custom settings\n * const filter = new BlurFilter({\n *     strength: 8,      // Overall blur strength\n *     quality: 4,       // Blur quality (higher = better but slower)\n *     kernelSize: 5     // Size of blur kernel matrix\n * });\n *\n * // Apply to a display object\n * sprite.filters = [filter];\n *\n * // Update properties\n * filter.strength = 10;          // Set both X and Y blur\n * filter.strengthX = 5;          // Set only horizontal blur\n * filter.strengthY = 15;         // Set only vertical blur\n * filter.quality = 2;            // Adjust quality\n *\n * // Enable edge pixel clamping\n * filter.repeatEdgePixels = true;\n * ```\n * @remarks\n * - Higher quality values produce better blur but impact performance\n * - Strength controls blur intensity independently for X and Y\n * - Can be optimized using quality and kernelSize settings\n * - Supports edge pixel clamping for special effects\n * @see {@link BlurFilterPass} For single-direction blur\n * @see {@link FilterOptions} For base filter options\n * @category filters\n * @standard\n * @noInheritDoc\n */\nexport class BlurFilter extends Filter\n{\n    /**\n     * Default blur filter options\n     * @example\n     * ```ts\n     * // Set default options for all BlurFilters\n     * BlurFilter.defaultOptions = {\n     *     strength: 10,       // Default blur strength\n     *     quality: 2,        // Default blur quality\n     *     kernelSize: 7      // Default kernel size\n     * };\n     * // Create a filter with these defaults\n     * const filter = new BlurFilter(); // Uses default options\n     * ```\n     * @remarks\n     * - These options are used when creating a new BlurFilter without specific parameters\n     * - Can be overridden by passing options to the constructor\n     * - Useful for setting global defaults for all blur filters in your application\n     * @see {@link BlurFilterOptions} For detailed options\n     * @see {@link BlurFilter} The filter that uses these options\n     */\n    public static defaultOptions: Partial<BlurFilterOptions> = {\n        /** The strength of the blur filter. */\n        strength: 8,\n        /** The quality of the blur filter. */\n        quality: 4,\n        /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */\n        kernelSize: 5,\n    };\n\n    /**\n     * The horizontal blur filter\n     * @advanced\n     */\n    public blurXFilter: BlurFilterPass;\n    /**\n     * The vertical blur filter\n     * @advanced\n     */\n    public blurYFilter: BlurFilterPass;\n\n    private _repeatEdgePixels = false;\n\n    /**\n     * @param {filters.BlurFilterOptions} options - The options of the blur filter.\n     */\n    constructor(options?: BlurFilterOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(strength?: number, quality?: number, resolution?: number | null, kernelSize?: number);\n    constructor(...args: [BlurFilterOptions?] | [number?, number?, number?, number?])\n    {\n        let options = args[0] ?? {};\n\n        // if options is a number)\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }');\n            // #endif\n\n            options = { strength: options };\n\n            if (args[1] !== undefined)options.quality = args[1];\n            if (args[2] !== undefined)options.resolution = args[2] || 'inherit';\n            if (args[3] !== undefined)options.kernelSize = args[3];\n        }\n\n        options = { ...BlurFilterPass.defaultOptions, ...options };\n\n        const { strength, strengthX, strengthY, quality, ...rest } = options;\n\n        super({\n            ...rest,\n            compatibleRenderers: RendererType.BOTH,\n            resources: {}\n        });\n\n        this.blurXFilter = new BlurFilterPass({ horizontal: true, ...options });\n        this.blurYFilter = new BlurFilterPass({ horizontal: false, ...options });\n\n        this.quality = quality;\n        this.strengthX = strengthX ?? strength;\n        this.strengthY = strengthY ?? strength;\n        this.repeatEdgePixels = false;\n    }\n\n    /**\n     * Applies the filter.\n     * @param filterManager - The manager.\n     * @param input - The input target.\n     * @param output - The output target.\n     * @param clearMode - How to clear\n     * @advanced\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        const xStrength = Math.abs(this.blurXFilter.strength);\n        const yStrength = Math.abs(this.blurYFilter.strength);\n\n        if (xStrength && yStrength)\n        {\n            const tempTexture = TexturePool.getSameSizeTexture(input);\n\n            this.blurXFilter.blendMode = 'normal';\n            this.blurXFilter.apply(filterManager, input, tempTexture, true);\n            this.blurYFilter.blendMode = this.blendMode;\n            this.blurYFilter.apply(filterManager, tempTexture, output, clearMode);\n\n            TexturePool.returnTexture(tempTexture);\n        }\n        else if (yStrength)\n        {\n            this.blurYFilter.blendMode = this.blendMode;\n            this.blurYFilter.apply(filterManager, input, output, clearMode);\n        }\n        else\n        {\n            this.blurXFilter.blendMode = this.blendMode;\n            this.blurXFilter.apply(filterManager, input, output, clearMode);\n        }\n    }\n\n    protected updatePadding(): void\n    {\n        if (this._repeatEdgePixels)\n        {\n            this.padding = 0;\n        }\n        else\n        {\n            this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;\n        }\n    }\n\n    /**\n     * Sets the strength of both the blurX and blurY properties simultaneously.\n     * Controls the overall intensity of the Gaussian blur effect.\n     * @example\n     * ```ts\n     * // Set equal blur strength for both axes\n     * filter.strength = 8;\n     *\n     * // Will throw error if X and Y are different\n     * filter.strengthX = 4;\n     * filter.strengthY = 8;\n     * filter.strength; // Error: BlurFilter's strengthX and strengthY are different\n     * ```\n     * @default 8\n     * @throws {Error} If strengthX and strengthY are different values\n     */\n    get strength(): number\n    {\n        if (this.strengthX !== this.strengthY)\n        {\n            throw new Error('BlurFilter\\'s strengthX and strengthY are different');\n        }\n\n        return this.strengthX;\n    }\n\n    set strength(value: number)\n    {\n        this.blurXFilter.blur = this.blurYFilter.blur = value;\n        this.updatePadding();\n    }\n\n    /**\n     * Sets the number of passes for blur. More passes means higher quality blurring.\n     * Controls the precision and smoothness of the blur effect at the cost of performance.\n     * @example\n     * ```ts\n     * // High quality blur (slower)\n     * filter.quality = 8;\n     *\n     * // Low quality blur (faster)\n     * filter.quality = 2;\n     * ```\n     * @default 4\n     * @remarks Higher values produce better quality but impact performance\n     */\n    get quality(): number\n    {\n        return this.blurXFilter.quality;\n    }\n\n    set quality(value: number)\n    {\n        this.blurXFilter.quality = this.blurYFilter.quality = value;\n    }\n\n    /**\n     * Sets the strength of horizontal blur.\n     * Controls the blur intensity along the x-axis independently.\n     * @example\n     * ```ts\n     * // Apply horizontal-only blur\n     * filter.strengthX = 8;\n     * filter.strengthY = 0;\n     *\n     * // Create motion blur effect\n     * filter.strengthX = 16;\n     * filter.strengthY = 2;\n     * ```\n     * @default 8\n     */\n    get strengthX(): number\n    {\n        return this.blurXFilter.blur;\n    }\n\n    set strengthX(value: number)\n    {\n        this.blurXFilter.blur = value;\n        this.updatePadding();\n    }\n\n    /**\n     * Sets the strength of the vertical blur.\n     * Controls the blur intensity along the y-axis independently.\n     * @example\n     * ```ts\n     * // Apply vertical-only blur\n     * filter.strengthX = 0;\n     * filter.strengthY = 8;\n     *\n     * // Create radial blur effect\n     * filter.strengthX = 8;\n     * filter.strengthY = 8;\n     * ```\n     * @default 8\n     */\n    get strengthY(): number\n    {\n        return this.blurYFilter.blur;\n    }\n\n    set strengthY(value: number)\n    {\n        this.blurYFilter.blur = value;\n        this.updatePadding();\n    }\n\n    /**\n     * Sets the strength of both the blurX and blurY properties simultaneously\n     * @default 2\n     * @deprecated since 8.3.0\n     * @see BlurFilter.strength\n     */\n    get blur(): number\n    {\n        // #if _DEBUG\n        deprecation('8.3.0', 'BlurFilter.blur is deprecated, please use BlurFilter.strength instead.');\n        // #endif\n\n        return this.strength;\n    }\n\n    set blur(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.3.0', 'BlurFilter.blur is deprecated, please use BlurFilter.strength instead.');\n        // #endif\n        this.strength = value;\n    }\n\n    /**\n     * Sets the strength of the blurX property\n     * @default 2\n     * @deprecated since 8.3.0\n     * @see BlurFilter.strengthX\n     */\n    get blurX(): number\n    {\n        // #if _DEBUG\n        deprecation('8.3.0', 'BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.');\n        // #endif\n\n        return this.strengthX;\n    }\n\n    set blurX(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.3.0', 'BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.');\n        // #endif\n        this.strengthX = value;\n    }\n\n    /**\n     * Sets the strength of the blurY property\n     * @default 2\n     * @deprecated since 8.3.0\n     * @see BlurFilter.strengthY\n     */\n    get blurY(): number\n    {\n        // #if _DEBUG\n        deprecation('8.3.0', 'BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.');\n        // #endif\n\n        return this.strengthY;\n    }\n\n    set blurY(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.3.0', 'BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.');\n        // #endif\n        this.strengthY = value;\n    }\n\n    /**\n     * If set to true the edge of the target will be clamped\n     * @default false\n     */\n    get repeatEdgePixels(): boolean\n    {\n        return this._repeatEdgePixels;\n    }\n\n    set repeatEdgePixels(value: boolean)\n    {\n        this._repeatEdgePixels = value;\n        this.updatePadding();\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1324, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/defaults/color-matrix/ColorMatrixFilter.ts"],"sourcesContent":["import { Color } from '../../../color/Color';\nimport { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Filter } from '../../Filter';\nimport vertex from '../defaultFilter.vert';\nimport fragment from './colorMatrixFilter.frag';\nimport source from './colorMatrixFilter.wgsl';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { ArrayFixed } from '../../../utils/types';\nimport type { FilterOptions } from '../../Filter';\n\n/**\n * 5x4 matrix for transforming RGBA color and alpha\n * @category filters\n * @standard\n */\nexport type ColorMatrix = ArrayFixed<number, 20>;\n\n/**\n * The ColorMatrixFilter class lets you apply color transformations to display objects using a 5x4 matrix.\n * The matrix transforms the RGBA color and alpha values of every pixel to produce a new set of values.\n *\n * The class provides convenient methods for common color adjustments like brightness, contrast, saturation,\n * and various photo filter effects.\n * @example\n * ```js\n * import { ColorMatrixFilter } from 'pixi.js';\n *\n * // Create a new color matrix filter\n * const colorMatrix = new ColorMatrixFilter();\n *\n * // Apply it to a container\n * container.filters = [colorMatrix];\n *\n * // Adjust contrast\n * colorMatrix.contrast(2);\n *\n * // Chain multiple effects\n * colorMatrix\n *     .saturate(0.5)     // 50% saturation\n *     .brightness(1.2)    // 20% brighter\n *     .hue(90);          // 90 degree hue rotation\n * ```\n *\n * Common use cases:\n * - Adjusting brightness, contrast, or saturation\n * - Applying color tints or color grading\n * - Creating photo filter effects (sepia, negative, etc.)\n * - Converting to grayscale\n * - Implementing dynamic day/night transitions\n * @author Clment Chenebault <clement@goodboydigital.com>\n * @category filters\n * @standard\n * @noInheritDoc\n */\nexport class ColorMatrixFilter extends Filter\n{\n    constructor(options: FilterOptions = {})\n    {\n        const colorMatrixUniforms = new UniformGroup({\n            uColorMatrix: {\n                value: [\n                    1, 0, 0, 0, 0,\n                    0, 1, 0, 0, 0,\n                    0, 0, 1, 0, 0,\n                    0, 0, 0, 1, 0,\n                ],\n                type: 'f32',\n                size: 20,\n            },\n            uAlpha: {\n                value: 1,\n                type: 'f32'\n            }\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'color-matrix-filter'\n        });\n\n        super({\n            ...options,\n            gpuProgram,\n            glProgram,\n            resources: {\n                colorMatrixUniforms\n            },\n        });\n\n        this.alpha = 1;\n    }\n\n    /**\n     * Transforms current matrix and set the new one\n     * @param {number[]} matrix - 5x4 matrix\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with matrix\n     */\n    private _loadMatrix(matrix: ColorMatrix, multiply = false): void\n    {\n        let newMatrix = matrix;\n\n        if (multiply)\n        {\n            this._multiply(newMatrix, this.matrix, matrix);\n            newMatrix = this._colorMatrix(newMatrix) as any;\n        }\n\n        // set the new matrix\n\n        this.resources.colorMatrixUniforms.uniforms.uColorMatrix = newMatrix;\n        this.resources.colorMatrixUniforms.update();\n    }\n\n    /**\n     * Multiplies two mat5's\n     * @private\n     * @param out - 5x4 matrix the receiving matrix\n     * @param a - 5x4 matrix the first operand\n     * @param b - 5x4 matrix the second operand\n     * @returns {number[]} 5x4 matrix\n     */\n    private _multiply(out: ColorMatrix, a: ColorMatrix, b: ColorMatrix): ColorMatrix\n    {\n        // Red Channel\n        out[0] = (a[0] * b[0]) + (a[1] * b[5]) + (a[2] * b[10]) + (a[3] * b[15]);\n        out[1] = (a[0] * b[1]) + (a[1] * b[6]) + (a[2] * b[11]) + (a[3] * b[16]);\n        out[2] = (a[0] * b[2]) + (a[1] * b[7]) + (a[2] * b[12]) + (a[3] * b[17]);\n        out[3] = (a[0] * b[3]) + (a[1] * b[8]) + (a[2] * b[13]) + (a[3] * b[18]);\n        out[4] = (a[0] * b[4]) + (a[1] * b[9]) + (a[2] * b[14]) + (a[3] * b[19]) + a[4];\n\n        // Green Channel\n        out[5] = (a[5] * b[0]) + (a[6] * b[5]) + (a[7] * b[10]) + (a[8] * b[15]);\n        out[6] = (a[5] * b[1]) + (a[6] * b[6]) + (a[7] * b[11]) + (a[8] * b[16]);\n        out[7] = (a[5] * b[2]) + (a[6] * b[7]) + (a[7] * b[12]) + (a[8] * b[17]);\n        out[8] = (a[5] * b[3]) + (a[6] * b[8]) + (a[7] * b[13]) + (a[8] * b[18]);\n        out[9] = (a[5] * b[4]) + (a[6] * b[9]) + (a[7] * b[14]) + (a[8] * b[19]) + a[9];\n\n        // Blue Channel\n        out[10] = (a[10] * b[0]) + (a[11] * b[5]) + (a[12] * b[10]) + (a[13] * b[15]);\n        out[11] = (a[10] * b[1]) + (a[11] * b[6]) + (a[12] * b[11]) + (a[13] * b[16]);\n        out[12] = (a[10] * b[2]) + (a[11] * b[7]) + (a[12] * b[12]) + (a[13] * b[17]);\n        out[13] = (a[10] * b[3]) + (a[11] * b[8]) + (a[12] * b[13]) + (a[13] * b[18]);\n        out[14] = (a[10] * b[4]) + (a[11] * b[9]) + (a[12] * b[14]) + (a[13] * b[19]) + a[14];\n\n        // Alpha Channel\n        out[15] = (a[15] * b[0]) + (a[16] * b[5]) + (a[17] * b[10]) + (a[18] * b[15]);\n        out[16] = (a[15] * b[1]) + (a[16] * b[6]) + (a[17] * b[11]) + (a[18] * b[16]);\n        out[17] = (a[15] * b[2]) + (a[16] * b[7]) + (a[17] * b[12]) + (a[18] * b[17]);\n        out[18] = (a[15] * b[3]) + (a[16] * b[8]) + (a[17] * b[13]) + (a[18] * b[18]);\n        out[19] = (a[15] * b[4]) + (a[16] * b[9]) + (a[17] * b[14]) + (a[18] * b[19]) + a[19];\n\n        return out;\n    }\n\n    /**\n     * Create a Float32 Array and normalize the offset component to 0-1\n     * @param {number[]} matrix - 5x4 matrix\n     * @returns {number[]} 5x4 matrix with all values between 0-1\n     */\n    private _colorMatrix(matrix: ColorMatrix): ColorMatrix\n    {\n        // Create a Float32 Array and normalize the offset component to 0-1\n        const m = new Float32Array(matrix);\n\n        m[4] /= 255;\n        m[9] /= 255;\n        m[14] /= 255;\n        m[19] /= 255;\n\n        return m as any;\n    }\n\n    /**\n     * Adjusts the brightness of a display object.\n     *\n     * The brightness adjustment works by multiplying the RGB channels by a scalar value while keeping\n     * the alpha channel unchanged. Values below 1 darken the image, while values above 1 brighten it.\n     * @param b - The brightness multiplier to apply. Values between 0-1 darken the image (0 being black),\n     *           while values > 1 brighten it (2.0 would make it twice as bright)\n     * @param multiply - When true, the new matrix is multiplied with the current one instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * // Create a new color matrix filter\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Darken the image to 50% brightness\n     * colorMatrix.brightness(0.5, false);\n     *\n     * // Chain with other effects by using multiply\n     * colorMatrix\n     *     .brightness(1.2, true)  // Brighten by 20%\n     *     .saturate(1.1, true);   // Increase saturation by 10%\n     * ```\n     */\n    public brightness(b: number, multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            b, 0, 0, 0, 0,\n            0, b, 0, 0, 0,\n            0, 0, b, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Sets each channel on the diagonal of the color matrix to apply a color tint.\n     *\n     * This method provides a way to tint display objects using the color matrix filter, similar to\n     * the tint property available on Sprites and other display objects. The tint is applied by\n     * scaling the RGB channels of each pixel.\n     * @param color - The color to use for tinting, this can be any valid color source.\n     * @param multiply - When true, the new tint matrix is multiplied with the current matrix instead\n     *                  of replacing it. This allows for combining tints with other color effects.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Apply a red tint\n     * colorMatrix.tint(0xff0000);\n     *\n     * // Layer a green tint on top of existing effects\n     * colorMatrix.tint('green', true);\n     *\n     * // Chain with other color adjustments\n     * colorMatrix\n     *     .tint('blue')       // Blue tint\n     *     .brightness(1.2, true) // Increase brightness\n     * ```\n     */\n    public tint(color: ColorSource, multiply?: boolean): void\n    {\n        const [r, g, b] = Color.shared.setValue(color).toArray();\n        const matrix: ColorMatrix = [\n            r, 0, 0, 0, 0,\n            0, g, 0, 0, 0,\n            0, 0, b, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Converts the display object to greyscale by applying a weighted matrix transformation.\n     *\n     * The greyscale effect works by setting equal RGB values for each pixel based on the scale parameter,\n     * effectively removing color information while preserving luminance.\n     * @param scale - The intensity of the greyscale effect. Value between 0-1, where:\n     *               - 0 produces black\n     *               - 0.5 produces 50% grey\n     *               - 1 produces white\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Convert to 50% grey\n     * colorMatrix.greyscale(0.5, false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .greyscale(0.6, true)    // Add grey tint\n     *     .brightness(1.2, true);   // Brighten the result\n     * ```\n     */\n    public greyscale(scale: number, multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            scale, scale, scale, 0, 0,\n            scale, scale, scale, 0, 0,\n            scale, scale, scale, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Converts the display object to grayscale by applying a weighted matrix transformation.\n     *\n     * The grayscale effect works by setting equal RGB values for each pixel based on the scale parameter,\n     * effectively removing color information while preserving luminance.\n     * @param scale - The intensity of the grayscale effect. Value between 0-1, where:\n     *               - 0 produces black\n     *               - 0.5 produces 50% grey\n     *               - 1 produces white\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Convert to 50% grey\n     * colorMatrix.grayscale(0.5, false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .grayscale(0.6, true)    // Add grey tint\n     *     .brightness(1.2, true);   // Brighten the result\n     * ```\n     */\n    public grayscale(scale: number, multiply: boolean): void\n    {\n        this.greyscale(scale, multiply);\n    }\n\n    /**\n     * Converts the display object to pure black and white using a luminance-based threshold.\n     *\n     * This method applies a matrix transformation that removes all color information and reduces\n     * the image to just black and white values based on the luminance of each pixel. The transformation\n     * uses standard luminance weightings: 30% red, 60% green, and 10% blue.\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Convert to black and white\n     * colorMatrix.blackAndWhite(false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .blackAndWhite(true)     // Apply B&W effect\n     *     .brightness(1.2, true);   // Then increase brightness\n     * ```\n     */\n    public blackAndWhite(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            0.3, 0.6, 0.1, 0, 0,\n            0.3, 0.6, 0.1, 0, 0,\n            0.3, 0.6, 0.1, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Adjusts the hue of the display object by rotating the color values around the color wheel.\n     *\n     * This method uses an optimized matrix transformation that accurately rotates the RGB color space\n     * around its luminance axis. The implementation is based on RGB cube rotation in 3D space, providing\n     * better results than traditional matrices with magic luminance constants.\n     * @param rotation - The angle of rotation in degrees around the color wheel:\n     *                  - 0 = no change\n     *                  - 90 = rotate colors 90 clockwise\n     *                  - 180 = invert all colors\n     *                  - 270 = rotate colors 90 counter-clockwise\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Rotate hue by 90 degrees\n     * colorMatrix.hue(90, false);\n     *\n     * // Chain multiple color adjustments\n     * colorMatrix\n     *     .hue(45, true)          // Rotate colors by 45\n     *     .saturate(1.2, true)    // Increase saturation\n     *     .brightness(1.1, true); // Slightly brighten\n     * ```\n     */\n    public hue(rotation: number, multiply: boolean): void\n    {\n        rotation = (rotation || 0) / 180 * Math.PI;\n\n        const cosR = Math.cos(rotation);\n        const sinR = Math.sin(rotation);\n        const sqrt = Math.sqrt;\n\n        /* a good approximation for hue rotation\n         This matrix is far better than the versions with magic luminance constants\n         formerly used here, but also used in the starling framework (flash) and known from this\n         old part of the internet: quasimondo.com/archives/000565.php\n\n         This new matrix is based on rgb cube rotation in space. Look here for a more descriptive\n         implementation as a shader not a general matrix:\n         https://github.com/evanw/glfx.js/blob/58841c23919bd59787effc0333a4897b43835412/src/filters/adjust/huesaturation.js\n\n         This is the source for the code:\n         see http://stackoverflow.com/questions/8507885/shift-hue-of-an-rgb-color/8510751#8510751\n         */\n\n        const w = 1 / 3;\n        const sqrW = sqrt(w); // weight is\n\n        const a00 = cosR + ((1.0 - cosR) * w);\n        const a01 = (w * (1.0 - cosR)) - (sqrW * sinR);\n        const a02 = (w * (1.0 - cosR)) + (sqrW * sinR);\n\n        const a10 = (w * (1.0 - cosR)) + (sqrW * sinR);\n        const a11 = cosR + (w * (1.0 - cosR));\n        const a12 = (w * (1.0 - cosR)) - (sqrW * sinR);\n\n        const a20 = (w * (1.0 - cosR)) - (sqrW * sinR);\n        const a21 = (w * (1.0 - cosR)) + (sqrW * sinR);\n        const a22 = cosR + (w * (1.0 - cosR));\n\n        const matrix: ColorMatrix = [\n            a00, a01, a02, 0, 0,\n            a10, a11, a12, 0, 0,\n            a20, a21, a22, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Adjusts the contrast of the display object by modifying the separation between dark and bright values.\n     *\n     * This method applies a matrix transformation that affects the difference between dark and light areas\n     * in the image. Increasing contrast makes shadows darker and highlights brighter, while decreasing\n     * contrast brings shadows up and highlights down, reducing the overall dynamic range.\n     * @param amount - The contrast adjustment value. Range is 0 to 1, where:\n     *                - 0 represents minimum contrast (flat gray)\n     *                - 0.5 represents normal contrast\n     *                - 1 represents maximum contrast\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Increase contrast by 50%\n     * colorMatrix.contrast(0.75, false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .contrast(0.6, true)     // Boost contrast\n     *     .brightness(1.1, true)   // Slightly brighten\n     *     .saturate(1.2, true);    // Increase color intensity\n     * ```\n     */\n    public contrast(amount: number, multiply: boolean): void\n    {\n        const v = (amount || 0) + 1;\n        const o = -0.5 * (v - 1);\n\n        const matrix: ColorMatrix = [\n            v, 0, 0, 0, o,\n            0, v, 0, 0, o,\n            0, 0, v, 0, o,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Adjusts the saturation of the display object by modifying color separation.\n     *\n     * This method applies a matrix transformation that affects the intensity of colors.\n     * Increasing saturation makes colors more vivid and intense, while decreasing saturation\n     * moves colors toward grayscale.\n     * @param amount - The saturation adjustment value. Range is -1 to 1, where:\n     *                - -1 produces grayscale\n     *                - 0 represents no change\n     *                - 1 produces maximum saturation\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Double the saturation\n     * colorMatrix.saturate(1, false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .saturate(0.5, true)     // Increase saturation by 50%\n     *     .brightness(1.1, true)    // Slightly brighten\n     *     .contrast(0.8, true);     // Reduce contrast\n     * ```\n     */\n    public saturate(amount = 0, multiply?: boolean): void\n    {\n        const x = (amount * 2 / 3) + 1;\n        const y = ((x - 1) * -0.5);\n\n        const matrix: ColorMatrix = [\n            x, y, y, 0, 0,\n            y, x, y, 0, 0,\n            y, y, x, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Completely removes color information from the display object, creating a grayscale version.\n     *\n     * This is a convenience method that calls `saturate(-1)` internally. The transformation preserves\n     * the luminance of the original image while removing all color information.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Convert image to grayscale\n     * colorMatrix.desaturate();\n     *\n     * // Can be chained with other effects\n     * colorMatrix\n     *     .desaturate()         // Remove all color\n     *     .brightness(1.2);     // Then increase brightness\n     * ```\n     */\n    public desaturate(): void\n    {\n        this.saturate(-1);\n    }\n\n    /**\n     * Creates a negative effect by inverting all colors in the display object.\n     *\n     * This method applies a matrix transformation that inverts the RGB values of each pixel\n     * while preserving the alpha channel. The result is similar to a photographic negative.\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Create negative effect\n     * colorMatrix.negative(false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .negative(true)       // Apply negative effect\n     *     .brightness(1.2, true) // Increase brightness\n     *     .contrast(0.8, true);  // Reduce contrast\n     * ```\n     */\n    public negative(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            -1, 0, 0, 1, 0,\n            0, -1, 0, 1, 0,\n            0, 0, -1, 1, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Applies a sepia tone effect to the display object, creating a warm brown tint reminiscent of vintage photographs.\n     *\n     * This method applies a matrix transformation that converts colors to various shades of brown while\n     * preserving the original luminance values.\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Apply sepia effect\n     * colorMatrix.sepia(false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .sepia(true)           // Add sepia tone\n     *     .brightness(1.1, true)  // Slightly brighten\n     *     .contrast(0.9, true);   // Reduce contrast\n     * ```\n     */\n    public sepia(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            0.393, 0.7689999, 0.18899999, 0, 0,\n            0.349, 0.6859999, 0.16799999, 0, 0,\n            0.272, 0.5339999, 0.13099999, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Applies a Technicolor-style effect that simulates the early color motion picture process.\n     *\n     * This method applies a matrix transformation that recreates the distinctive look of the\n     * Technicolor process. The effect produces highly\n     * saturated colors with a particular emphasis on reds, greens, and blues.\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Apply Technicolor effect\n     * colorMatrix.technicolor(false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .technicolor(true)      // Add Technicolor effect\n     *     .contrast(1.1, true)    // Boost contrast\n     *     .brightness(0.9, true); // Slightly darken\n     * ```\n     */\n    public technicolor(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337,\n            -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398,\n            -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Applies a vintage Polaroid camera effect to the display object.\n     *\n     * This method applies a matrix transformation that simulates the distinctive look of\n     * Polaroid instant photographs, characterized by slightly enhanced contrast, subtle color shifts,\n     * and a warm overall tone.\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Apply Polaroid effect\n     * colorMatrix.polaroid(false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .polaroid(true)         // Add Polaroid effect\n     *     .brightness(1.1, true)  // Slightly brighten\n     *     .contrast(1.1, true);   // Boost contrast\n     * ```\n     */\n    public polaroid(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            1.438, -0.062, -0.062, 0, 0,\n            -0.122, 1.378, -0.122, 0, 0,\n            -0.016, -0.016, 1.483, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Swaps the red and blue color channels in the display object.\n     *\n     * This method applies a matrix transformation that exchanges the red and blue color values\n     * while keeping the green channel and alpha unchanged.\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Swap red and blue channels\n     * colorMatrix.toBGR(false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .toBGR(true)           // Swap R and B channels\n     *     .brightness(1.1, true)  // Slightly brighten\n     *     .contrast(0.9, true);   // Reduce contrast\n     * ```\n     */\n    public toBGR(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            0, 0, 1, 0, 0,\n            0, 1, 0, 0, 0,\n            1, 0, 0, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Applies a Kodachrome color effect that simulates the iconic film stock.\n     *\n     * This method applies a matrix transformation that recreates the distinctive look of Kodachrome film,\n     * known for its rich, vibrant colors and excellent image preservation qualities. The effect emphasizes\n     * reds and blues while producing deep, true blacks.\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Apply Kodachrome effect\n     * colorMatrix.kodachrome(false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .kodachrome(true)       // Add Kodachrome effect\n     *     .contrast(1.1, true)    // Boost contrast\n     *     .brightness(0.9, true); // Slightly darken\n     * ```\n     */\n    public kodachrome(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,\n            -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,\n            -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Applies a stylized brown-tinted effect to the display object.\n     *\n     * This method applies a matrix transformation that creates a rich, warm brown tone\n     * with enhanced contrast and subtle color shifts.\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Apply browni effect\n     * colorMatrix.browni(false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .browni(true)          // Add brown tint\n     *     .brightness(1.1, true)  // Slightly brighten\n     *     .contrast(1.2, true);   // Boost contrast\n     * ```\n     */\n    public browni(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873,\n            -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127,\n            0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Applies a vintage photo effect that simulates old photography techniques.\n     *\n     * This method applies a matrix transformation that creates a nostalgic, aged look\n     * with muted colors, enhanced warmth, and subtle vignetting.\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Apply vintage effect\n     * colorMatrix.vintage(false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .vintage(true)          // Add vintage look\n     *     .brightness(0.9, true)  // Slightly darken\n     *     .contrast(1.1, true);   // Boost contrast\n     * ```\n     */\n    public vintage(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123,\n            0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591,\n            0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * We don't know exactly what it does, kind of gradient map, but funny to play with!\n     * @param desaturation - Tone values.\n     * @param toned - Tone values.\n     * @param lightColor - Tone values, example: `0xFFE580`\n     * @param darkColor - Tone values, example: `0xFFE580`\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with matrix\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Create sepia-like effect with custom colors\n     * colorMatrix.colorTone(\n     *     0.3,        // Moderate desaturation\n     *     0.2,        // Moderate toning\n     *     0xFFE580,   // Warm highlight color\n     *     0x338000,   // Dark green shadows\n     *     false\n     * );\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .colorTone(0.2, 0.15, 0xFFE580, 0x338000, true)\n     *     .brightness(1.1, true);  // Slightly brighten\n     * ```\n     */\n    public colorTone(\n        desaturation: number,\n        toned: number,\n        lightColor: ColorSource,\n        darkColor: ColorSource,\n        multiply: boolean\n    ): void\n    {\n        desaturation ||= 0.2;\n        toned ||= 0.15;\n        lightColor ||= 0xFFE580;\n        darkColor ||= 0x338000;\n\n        const temp = Color.shared;\n        const [lR, lG, lB] = temp.setValue(lightColor).toArray();\n        const [dR, dG, dB] = temp.setValue(darkColor).toArray();\n\n        const matrix: ColorMatrix = [\n            0.3, 0.59, 0.11, 0, 0,\n            lR, lG, lB, desaturation, 0,\n            dR, dG, dB, toned, 0,\n            lR - dR, lG - dG, lB - dB, 0, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Applies a night vision effect to the display object.\n     *\n     * This method applies a matrix transformation that simulates night vision by enhancing\n     * certain color channels while suppressing others, creating a green-tinted effect\n     * similar to night vision goggles.\n     * @param intensity - The intensity of the night effect (0-1):\n     *                   - 0 produces no effect\n     *                   - 0.1 produces a subtle night vision effect (default)\n     *                   - 1 produces maximum night vision effect\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Apply night vision effect\n     * colorMatrix.night(0.3, false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .night(0.2, true)        // Add night vision\n     *     .brightness(1.1, true)    // Slightly brighten\n     *     .contrast(1.2, true);     // Boost contrast\n     * ```\n     */\n    public night(intensity: number, multiply: boolean): void\n    {\n        intensity ||= 0.1;\n\n        const matrix: ColorMatrix = [\n            intensity * (-2.0), -intensity, 0, 0, 0,\n            -intensity, 0, intensity, 0, 0,\n            0, intensity, intensity * 2.0, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Predator effect\n     *\n     * Erase the current matrix by setting a new independent one\n     * @param amount - how much the predator feels his future victim\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with matrix\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Apply thermal vision effect\n     * colorMatrix.predator(0.5, false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .predator(0.3, true)      // Add thermal effect\n     *     .contrast(1.2, true)      // Boost contrast\n     *     .brightness(1.1, true);   // Slightly brighten\n     * ```\n     */\n    public predator(amount: number, multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            // row 1\n            11.224130630493164 * amount,\n            -4.794486999511719 * amount,\n            -2.8746118545532227 * amount,\n            0 * amount,\n            0.40342438220977783 * amount,\n            // row 2\n            -3.6330697536468506 * amount,\n            9.193157196044922 * amount,\n            -2.951810836791992 * amount,\n            0 * amount,\n            -1.316135048866272 * amount,\n            // row 3\n            -3.2184197902679443 * amount,\n            -4.2375030517578125 * amount,\n            7.476448059082031 * amount,\n            0 * amount,\n            0.8044459223747253 * amount,\n            // row 4\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Applies a psychedelic color effect that creates dramatic color shifts.\n     *\n     * This method applies a matrix transformation that produces vibrant colors\n     * through channel mixing and amplification. Creates an effect reminiscent of\n     * color distortions in psychedelic art.\n     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n     *                  This allows for cumulative effects when calling multiple color adjustments.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Apply psychedelic effect\n     * colorMatrix.lsd(false);\n     *\n     * // Chain with other effects\n     * colorMatrix\n     *     .lsd(true)             // Add color distortion\n     *     .brightness(0.9, true)  // Slightly darken\n     *     .contrast(1.2, true);   // Boost contrast\n     * ```\n     */\n    public lsd(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            2, -0.4, 0.5, 0, 0,\n            -0.5, 2, -0.4, 0, 0,\n            -0.4, -0.5, 3, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Resets the color matrix filter to its default state.\n     *\n     * This method resets all color transformations by setting the matrix back to its identity state.\n     * The identity matrix leaves colors unchanged, effectively removing all previously applied effects.\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Apply some effects\n     * colorMatrix\n     *     .sepia(true)\n     *     .brightness(1.2, true);\n     *\n     * // Reset back to original colors\n     * colorMatrix.reset();\n     * ```\n     */\n    public reset(): void\n    {\n        const matrix: ColorMatrix = [\n            1, 0, 0, 0, 0,\n            0, 1, 0, 0, 0,\n            0, 0, 1, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, false);\n    }\n\n    /**\n     * The current color transformation matrix of the filter.\n     *\n     * This 5x4 matrix transforms RGBA color and alpha values of each pixel. The matrix is stored\n     * as a 20-element array in row-major order.\n     * @type {ColorMatrix}\n     * @default [\n     *     1, 0, 0, 0, 0,  // Red channel\n     *     0, 1, 0, 0, 0,  // Green channel\n     *     0, 0, 1, 0, 0,  // Blue channel\n     *     0, 0, 0, 1, 0   // Alpha channel\n     * ]\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     * // Get the current color matrix\n     * const currentMatrix = colorMatrix.matrix;\n     * // Modify the matrix\n     * colorMatrix.matrix = [\n     *     1, 0, 0, 0, 0,\n     *     0, 1, 0, 0, 0,\n     *     0, 0, 1, 0, 0,\n     *     0, 0, 0, 1, 0\n     * ];\n     */\n    get matrix(): ColorMatrix\n    {\n        return this.resources.colorMatrixUniforms.uniforms.uColorMatrix;\n    }\n\n    set matrix(value: ColorMatrix)\n    {\n        this.resources.colorMatrixUniforms.uniforms.uColorMatrix = value;\n    }\n\n    /**\n     * The opacity value used to blend between the original and transformed colors.\n     *\n     * This value controls how much of the color transformation is applied:\n     * - 0 = Original color only (no effect)\n     * - 0.5 = 50% blend of original and transformed colors\n     * - 1 = Fully transformed color (default)\n     * @default 1\n     * @example\n     * ```ts\n     * const colorMatrix = new ColorMatrixFilter();\n     *\n     * // Apply sepia at 50% strength\n     * colorMatrix.sepia(false);\n     * colorMatrix.alpha = 0.5;\n     *\n     * // Fade between effects\n     * colorMatrix\n     *     .saturate(1.5)      // Increase saturation\n     *     .contrast(1.2);     // Boost contrast\n     * colorMatrix.alpha = 0.7; // Apply at 70% strength\n     * ```\n     */\n    get alpha(): number\n    {\n        return this.resources.colorMatrixUniforms.uniforms.uAlpha;\n    }\n\n    set alpha(value: number)\n    {\n        this.resources.colorMatrixUniforms.uniforms.uAlpha = value;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2540, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/defaults/displacement/DisplacementFilter.ts"],"sourcesContent":["import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Filter } from '../../Filter';\nimport fragment from './displacement.frag';\nimport vertex from './displacement.vert';\nimport source from './displacement.wgsl';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { FilterOptions } from '../../Filter';\nimport type { FilterSystem } from '../../FilterSystem';\n\n/**\n * Configuration options for the DisplacementFilter.\n *\n * A displacement filter uses a sprite's texture as a displacement map,\n * moving pixels of the target based on the color values of corresponding\n * pixels in the displacement sprite.\n * @example\n * ```ts\n * const options: DisplacementFilterOptions = {\n *     sprite: displacementSprite,\n *     scale: { x: 20, y: 20 }\n * };\n *\n * const filter = new DisplacementFilter(options);\n * ```\n * @category filters\n * @standard\n */\nexport interface DisplacementFilterOptions extends FilterOptions\n{\n    /**\n     * The sprite whose texture will be used as the displacement map.\n     * Red channel = horizontal displacement\n     * Green channel = vertical displacement\n     * @example\n     * ```ts\n     * const displacementSprite = new Sprite(texture);\n     * const filter = new DisplacementFilter({ sprite: displacementSprite });\n     * ```\n     */\n    sprite: Sprite;\n\n    /**\n     * The scale of the displacement effect. Can be a single number for uniform\n     * scaling or a point-like object for separate x/y scaling.\n     * @default 20\n     * @example\n     * ```ts\n     * // Uniform scaling\n     * new DisplacementFilter({ sprite, scale: 20 });\n     * // Separate scaling\n     * new DisplacementFilter({ sprite, scale: { x: 10, y: 15 } });\n     * ```\n     */\n    scale?: number | PointData;\n}\n\n/**\n * A filter that applies a displacement map effect using a sprite's texture.\n *\n * The DisplacementFilter uses another texture (from a sprite) as a displacement map,\n * where the red and green channels of each pixel in the map determine how the corresponding\n * pixel in the filtered object should be offset:\n * - Red channel controls horizontal displacement\n * - Green channel controls vertical displacement\n *\n * Common use cases:\n * - Creating ripple or wave effects\n * - Distorting images dynamically\n * - Implementing heat haze effects\n * - Creating transition effects\n * @example\n * ```ts\n * import { Sprite, DisplacementFilter } from 'pixi.js';\n *\n * // Create a sprite to use as the displacement map\n * const displacementSprite = Sprite.from('displacement-map.png');\n *\n * // Create and configure the filter\n * const displacementFilter = new DisplacementFilter({\n *     sprite: displacementSprite,\n *     scale: { x: 20, y: 20 }\n * });\n *\n * // Apply to any display object\n * container.filters = [displacementFilter];\n * ```\n * @category filters\n * @author Vico: vicocotea\n * @standard\n * @noInheritDoc\n */\nexport class DisplacementFilter extends Filter\n{\n    private readonly _sprite: Sprite;\n\n    /**\n     * @param {Sprite | DisplacementFilterOptions} options - The sprite or options object.\n     * @param {Sprite} options.sprite - The texture used for the displacement map.\n     * @param {number | PointData} options.scale - The scale of the displacement.\n     */\n    constructor(options: Sprite | DisplacementFilterOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(sprite: Sprite, scale?: number | PointData);\n    constructor(...args: [Sprite | DisplacementFilterOptions] | [Sprite, (number | PointData)?])\n    {\n        let options = args[0];\n\n        if (options instanceof Sprite)\n        {\n            // #if _DEBUG\n            if (args[1])\n            {\n                deprecation(v8_0_0, 'DisplacementFilter now uses options object instead of params. {sprite, scale}');\n            }\n            // #endif\n\n            options = { sprite: options, scale: args[1] };\n        }\n\n        const { sprite, scale: scaleOption, ...rest } = options;\n\n        let scale = scaleOption ?? 20;\n\n        // check if is a number or a point\n        if (typeof scale === 'number')\n        {\n            scale = new Point(scale, scale);\n        }\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uScale: { value: scale, type: 'vec2<f32>' },\n            uRotation: { value: new Float32Array([0, 0, 0, 0]), type: 'mat2x2<f32>' },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'displacement-filter'\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const textureSource = sprite.texture.source;\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                filterUniforms,\n                uMapTexture: textureSource,\n                uMapSampler: textureSource.style,\n            },\n        });\n\n        this._sprite = options.sprite;\n        this._sprite.renderable = false;\n    }\n\n    /**\n     * Applies the filter.\n     * @param filterManager - The manager.\n     * @param input - The input target.\n     * @param output - The output target.\n     * @param clearMode - clearMode.\n     * @advanced\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        const uniforms = this.resources.filterUniforms.uniforms;\n\n        filterManager.calculateSpriteMatrix(\n            uniforms.uFilterMatrix,\n            this._sprite\n        );\n\n        // Extract rotation from world transform\n        const wt = this._sprite.worldTransform;\n        const lenX = Math.sqrt((wt.a * wt.a) + (wt.b * wt.b));\n        const lenY = Math.sqrt((wt.c * wt.c) + (wt.d * wt.d));\n\n        if (lenX !== 0 && lenY !== 0)\n        {\n            uniforms.uRotation[0] = wt.a / lenX;\n            uniforms.uRotation[1] = wt.b / lenX;\n            uniforms.uRotation[2] = wt.c / lenY;\n            uniforms.uRotation[3] = wt.d / lenY;\n        }\n\n        this.resources.uMapTexture = this._sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * The scale of the displacement effect.\n     *\n     * Gets the current x and y scaling values used for the displacement mapping.\n     * - x: Horizontal displacement scale\n     * - y: Vertical displacement scale\n     * @returns {Point} The current scale as a Point object\n     * @example\n     * ```ts\n     * const filter = new DisplacementFilter({ sprite });\n     *\n     * // Get current scale\n     * console.log(filter.scale.x, filter.scale.y);\n     *\n     * // Update scale\n     * filter.scale.x = 100;\n     * filter.scale.y = 50;\n     * ```\n     */\n    get scale(): Point\n    {\n        return this.resources.filterUniforms.uniforms.uScale as Point;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2682, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/defaults/noise/NoiseFilter.ts"],"sourcesContent":["import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Filter } from '../../Filter';\nimport vertex from '../defaultFilter.vert';\nimport fragment from './noise.frag';\nimport source from './noise.wgsl';\n\nimport type { FilterOptions } from '../../Filter';\n\n/**\n * Configuration options for the NoiseFilter.\n *\n * The NoiseFilter adds random noise to the rendered content. The noise effect can be\n * controlled through the noise intensity and an optional seed value for reproducible results.\n * @example\n * ```ts\n * // Basic noise effect\n * const options: NoiseFilterOptions = {\n *     noise: 0.5,\n *     seed: Math.random()\n * };\n *\n * // Create filter with options\n * const noiseFilter = new NoiseFilter(options);\n * ```\n * @category filters\n * @standard\n */\nexport interface NoiseFilterOptions extends FilterOptions\n{\n    /**\n     * The amount of noise to apply. Should be in range (0, 1]:\n     * - 0.1 = subtle noise\n     * - 0.5 = moderate noise (default)\n     * - 1.0 = maximum noise\n     * @default 0.5\n     * @example\n     * ```ts\n     * // Moderate noise effect\n     * const noiseFilter = new NoiseFilter({ noise: 0.5 });\n     * ```\n     */\n    noise?: number;\n    /**\n     * A seed value to apply to the random noise generation.\n     * Using the same seed will generate the same noise pattern.\n     * @default Math.random()\n     * @example\n     * ```ts\n     * // Using a fixed seed for reproducible noise\n     * const noiseFilter = new NoiseFilter({ seed: 12345 });\n     * ```\n     */\n    seed?: number;\n}\n\n/**\n * A filter that adds configurable random noise to rendered content.\n *\n * This filter generates pixel noise based on a noise intensity value and an optional seed.\n * It can be used to create various effects like film grain, static, or texture variation.\n *\n * Based on: https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js\n * @example\n * ```ts\n * import { NoiseFilter } from 'pixi.js';\n *\n * // Create with options\n * const filter = new NoiseFilter({\n *     noise: 0.5,    // 50% noise intensity\n *     seed: 12345    // Fixed seed for consistent noise\n * });\n *\n * // Apply to a display object\n * sprite.filters = [filter];\n *\n * // Adjust noise dynamically\n * filter.noise = 0.8;    // Increase noise\n * filter.seed = Math.random(); // New random pattern\n * ```\n * @category filters\n * @author Vico: vicocotea\n * @standard\n * @noInheritDoc\n */\nexport class NoiseFilter extends Filter\n{\n    /**\n     * The default configuration options for the NoiseFilter.\n     *\n     * These values will be used when no specific options are provided to the constructor.\n     * You can override any of these values by passing your own options object.\n     * @example\n     * ```ts\n     * NoiseFilter.defaultOptions.noise = 0.7; // Change default noise to 0.7\n     * const filter = new NoiseFilter(); // Will use noise 0.7 by default\n     * ```\n     */\n    public static defaultOptions: NoiseFilterOptions = {\n        noise: 0.5,\n    };\n\n    /**\n     * @param options - The options of the noise filter.\n     */\n    constructor(options: NoiseFilterOptions = {})\n    {\n        options = { ...NoiseFilter.defaultOptions, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'noise-filter'\n        });\n\n        const { noise, seed, ...rest } = options;\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                noiseUniforms: new UniformGroup({\n                    uNoise: { value: 1, type: 'f32' },\n                    uSeed: { value: 1, type: 'f32' },\n                })\n            },\n        });\n\n        this.noise = noise;\n        this.seed = seed ?? Math.random();\n    }\n\n    /**\n     * The amount of noise to apply to the filtered content.\n     *\n     * This value controls the intensity of the random noise effect:\n     * - Values close to 0 produce subtle noise\n     * - Values around 0.5 produce moderate noise\n     * - Values close to 1 produce strong noise\n     * @default 0.5\n     * @example\n     * ```ts\n     * const noiseFilter = new NoiseFilter();\n     *\n     * // Set to subtle noise\n     * noiseFilter.noise = 0.2;\n     *\n     * // Set to maximum noise\n     * noiseFilter.noise = 1.0;\n     * ```\n     */\n    get noise(): number\n    {\n        return this.resources.noiseUniforms.uniforms.uNoise;\n    }\n\n    set noise(value: number)\n    {\n        this.resources.noiseUniforms.uniforms.uNoise = value;\n    }\n\n    /**\n     * The seed value used for random noise generation.\n     *\n     * This value determines the noise pattern:\n     * - Using the same seed will generate identical noise patterns\n     * - Different seeds produce different but consistent patterns\n     * - `Math.random()` can be used for random patterns\n     * @default Math.random()\n     * @example\n     * ```ts\n     * const noiseFilter = new NoiseFilter();\n     *\n     * // Use a fixed seed for consistent noise\n     * noiseFilter.seed = 12345;\n     *\n     * // Generate new random pattern\n     * noiseFilter.seed = Math.random();\n     * ```\n     */\n    get seed(): number\n    {\n        return this.resources.noiseUniforms.uniforms.uSeed;\n    }\n\n    set seed(value: number)\n    {\n        this.resources.noiseUniforms.uniforms.uSeed = value;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAsFO,MAAM,YAAA,GAAN,MAAM,YAAA,SAAoB,oKACjC,CAAA;IAAA;;GAAA,GAmBI,WAAA,CAAY,OAA8B,GAAA,CAAA,CAC1C,CAAA;QACI,OAAA,GAAU;YAAE,GAAG,YAAY,CAAA,cAAA;YAAgB,GAAG,OAAQ;QAAA,CAAA,CAAA;QAEhD,MAAA,UAAA,GAAa,4MAAA,CAAW,IAAK,CAAA;YAC/B,MAAQ,EAAA;wBACJ,iMAAA;gBACA,UAAY,EAAA,YAAA;YAAA,CAChB;YACA,QAAU,EAAA;wBACN,iMAAA;gBACA,UAAY,EAAA,cAAA;YAAA,CAChB;QAAA,CACH,CAAA,CAAA;QAEK,MAAA,SAAA,GAAY,yMAAA,CAAU,IAAK,CAAA;oBAC7B,gMAAA;sBACA,iMAAA;YACA,IAAM,EAAA,cAAA;QAAA,CACT,CAAA,CAAA;QAED,MAAM,EAAE,KAAA,EAAO,IAAM,EAAA,GAAG,MAAS,GAAA,OAAA,CAAA;QAE3B,KAAA,CAAA;YACF,GAAG,IAAA;YACH,UAAA;YACA,SAAA;YACA,SAAW,EAAA;gBACP,aAAA,EAAe,IAAI,mNAAa,CAAA;oBAC5B,MAAQ,EAAA;wBAAE,KAAO,EAAA,CAAA;wBAAG,MAAM,KAAM;oBAAA,CAAA;oBAChC,KAAO,EAAA;wBAAE,KAAO,EAAA,CAAA;wBAAG,MAAM,KAAM;oBAAA,CAAA;gBAAA,CAClC,CAAA;YAAA,CACL;QAAA,CACH,CAAA,CAAA;QAED,IAAA,CAAK,KAAQ,GAAA,KAAA,CAAA;QACR,IAAA,CAAA,IAAA,GAAO,IAAQ,IAAA,IAAA,CAAK,MAAO,EAAA,CAAA;IAAA,CACpC;IAAA;;;;;;;;;;;;;;;;;;GAAA,GAqBA,IAAI,KACJ,GAAA;QACW,OAAA,IAAA,CAAK,SAAU,CAAA,aAAA,CAAc,QAAS,CAAA,MAAA,CAAA;IAAA,CACjD;IAEA,IAAI,MAAM,KACV,EAAA;QACS,IAAA,CAAA,SAAA,CAAU,aAAc,CAAA,QAAA,CAAS,MAAS,GAAA,KAAA,CAAA;IAAA,CACnD;IAAA;;;;;;;;;;;;;;;;;;GAAA,GAqBA,IAAI,IACJ,GAAA;QACW,OAAA,IAAA,CAAK,SAAU,CAAA,aAAA,CAAc,QAAS,CAAA,KAAA,CAAA;IAAA,CACjD;IAEA,IAAI,KAAK,KACT,EAAA;QACS,IAAA,CAAA,SAAA,CAAU,aAAc,CAAA,QAAA,CAAS,KAAQ,GAAA,KAAA,CAAA;IAAA,CAClD;AACJ,CAAA,CAAA;AAAA;;;;;;;;;;CAAA,GApHa,YAAA,CAaK,cAAqC,GAAA;IAC/C,KAAO,EAAA,GAAA;AACX,CAAA,CAAA;AAfG,IAAM,WAAN,GAAA"}},
    {"offset": {"line": 2814, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/defaults/passthrough/PassthroughFilter.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/defaults/passthrough/PassthroughFilter.ts"],"sourcesContent":["import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Filter } from '../../Filter';\nimport vertex from '../defaultFilter.vert';\nimport fragment from './passthrough.frag';\nimport source from './passthrough.wgsl';\n\n/**\n * The PassthroughFilter passes the input data through without altering it.\n * It serves as a basic filter, performing no graphical alterations.\n * @category filters\n * @internal\n */\nexport class PassthroughFilter extends Filter\n{\n    constructor()\n    {\n        const gpuProgram = GpuProgram.from({\n            vertex: { source, entryPoint: 'mainVertex' },\n            fragment: { source, entryPoint: 'mainFragment' },\n            name: 'passthrough-filter'\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'passthrough-filter'\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAaO,MAAM,0BAA0B,oKACvC,CAAA;IACI,WACA,EAAA;QACU,MAAA,UAAA,GAAa,4MAAA,CAAW,IAAK,CAAA;YAC/B,MAAQ,EAAA;wBAAE,6MAAQ;gBAAA,UAAA,EAAY,YAAa;YAAA,CAAA;YAC3C,QAAU,EAAA;wBAAE,6MAAQ;gBAAA,UAAA,EAAY,cAAe;YAAA,CAAA;YAC/C,IAAM,EAAA,oBAAA;QAAA,CACT,CAAA,CAAA;QAEK,MAAA,SAAA,GAAY,yMAAA,CAAU,IAAK,CAAA;oBAC7B,gMAAA;sBACA,6MAAA;YACA,IAAM,EAAA,oBAAA;QAAA,CACT,CAAA,CAAA;QAEK,KAAA,CAAA;YACF,UAAA;YACA,SAAA;QAAA,CACH,CAAA,CAAA;IAAA,CACL;AACJ"}},
    {"offset": {"line": 2861, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/FilterPipe.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/FilterPipe.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n/** @internal */\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAUO,MAAM,UACb,CAAA;IAYI,YAAY,QACZ,CAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,IAAA,CAAK,YAAsB,EAAA,SAAA,EAAsB,cACxD,EAAA;QACU,MAAA,WAAA,GAAc,IAAA,CAAK,SAAU,CAAA,WAAA,CAAA;QAEvB,WAAA,CAAA,KAAA,CAAM,KAAA,CAAM,cAAc,CAAA,CAAA;QAEtC,cAAA,CAAe,GAAI,CAAA;YACf,YAAc,EAAA,QAAA;YACd,SAAW,EAAA,KAAA;YACX,MAAQ,EAAA,YAAA;YACR,SAAA;YACA,YAAA;QAAA,CACkB,CAAA,CAAA;IAAA,CAC1B;IAEO,GAAA,CAAI,aAAuB,EAAA,UAAA,EAAuB,cACzD,EAAA;QACI,IAAA,CAAK,SAAU,CAAA,WAAA,CAAY,KAAM,CAAA,KAAA,CAAM,cAAc,CAAA,CAAA;QAErD,cAAA,CAAe,GAAI,CAAA;YACf,YAAc,EAAA,QAAA;YACd,MAAQ,EAAA,WAAA;YACR,SAAW,EAAA,KAAA;QAAA,CACd,CAAA,CAAA;IAAA,CACL;IAEO,QAAQ,WACf,EAAA;QACQ,IAAA,WAAA,CAAY,MAAA,KAAW,YAC3B,EAAA;YACS,IAAA,CAAA,SAAA,CAAU,MAAO,CAAA,IAAA,CAAK,WAAW,CAAA,CAAA;QAAA,CAC1C,MAAA,IACS,WAAY,CAAA,MAAA,KAAW,WAChC,EAAA;YACS,IAAA,CAAA,SAAA,CAAU,MAAA,CAAO,GAAI,EAAA,CAAA;QAAA,CAC9B;IAAA,CACJ;IAEO,OACP,GAAA;QACI,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;IAAA,CACrB;AACJ,CAAA;AA5Da,UAAA,CAEK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,kLAAc,CAAA,UAAA;QACd,kLAAc,CAAA,WAAA;QACd,kLAAc,CAAA,WAAA;KAClB;IACA,IAAM,EAAA,QAAA;AACV,CAAA"}},
    {"offset": {"line": 2916, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/FilterSystem.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/FilterSystem.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\nimport { PassthroughFilter } from '../filters/defaults/passthrough/PassthroughFilter';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { type Rectangle } from '../maths/shapes/Rectangle';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n * @internal\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: 'pushFilter' | 'popFilter',\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\n/**\n * Class representing the data required for applying filters.\n * This class holds various properties that are used during the filter application process.\n * @internal\n */\nclass FilterData\n{\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    public skip = false;\n\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    public inputTexture: Texture = null;\n\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    public backTexture?: Texture = null;\n\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    public filters: Filter[] = null;\n\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    public bounds = new Bounds();\n\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    public container: Container = null;\n\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    public blendRequired: boolean = false;\n\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    public outputRenderSurface: RenderSurface = null;\n\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    public globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n\n    /**\n     * Indicates whether antialiasing is enabled for the filter.\n     * @type {boolean}\n     */\n    public antialias: boolean;\n\n    /**\n     * The resolution of the filter.\n     * @type {number}\n     */\n    public resolution: number;\n\n    /** The first enabled filter index in the current filter list. */\n    public firstEnabledIndex = -1;\n\n    /** The last enabled filter index in the current filter list. */\n    public lastEnabledIndex = -1;\n}\n\n/**\n * System that manages the filter pipeline\n * @category rendering\n * @advanced\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n    private _passthroughFilter: Filter;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    /**\n     * Pushes a filter instruction onto the filter stack.\n     * @param instruction - The instruction containing the filter effect and container.\n     * @internal\n     */\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        filterData.skip = false;\n\n        filterData.filters = filters as Filter[];\n        filterData.container = instruction.container;\n        filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, or all of them disabled, we skip the pass\n        if (filters.every((filter) => !filter.enabled))\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds = filterData.bounds;\n\n        this._calculateFilterArea(instruction, bounds);\n\n        this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        const previousFilterData = this._getPreviousFilterData();\n\n        const globalResolution = this._findFilterResolution(rootResolution);\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (previousFilterData)\n        {\n            offsetX = previousFilterData.bounds.minX;\n            offsetY = previousFilterData.bounds.minY;\n        }\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        // set all the filter data\n\n        this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n    }\n\n    /**\n     * Applies filters to a texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture.\n     * @param {object} params - The parameters for applying filters.\n     * @param {Texture} params.texture - The texture to apply filters to.\n     * @param {Filter[]} params.filters - The filters to apply.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     * @example\n     *\n     * ```ts\n     * // Create a texture and a list of filters\n     * const texture = new Texture(...);\n     * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n     *\n     * // Apply the filters to the texture\n     * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n     *\n     * // Use the resulting texture\n     * sprite.texture = resultTexture;\n     * ```\n     *\n     * Key Points:\n     * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n     * 2. If all filters are disabled or skipped, the original texture is returned.\n     */\n    public generateFilteredTexture({ texture, filters }: {texture: Texture, filters: Filter[]}): Texture\n    {\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        this._activeFilterData = filterData;\n        filterData.skip = false;\n\n        filterData.filters = filters;\n\n        const colorTextureSource = texture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, or all of them disabled, we skip the pass\n        if (filters.every((filter) => !filter.enabled))\n        {\n            filterData.skip = true;\n\n            return texture;\n        }\n\n        const bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n\n        bounds.addRect(texture.frame);\n\n        this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n\n        if (filterData.skip)\n        {\n            return texture;\n        }\n\n        const globalResolution = rootResolution;\n        const offsetX = 0;\n        const offsetY = 0;\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        /// /////////\n\n        // set all the filter data\n        // get a P02 texture from our pool...\n        filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // TODO this might need looking at for padding!\n        filterData.inputTexture = texture;\n\n        /// ////////////// PART 2 POP //////////////////////\n\n        const renderer = this.renderer;\n\n        // TODO required? check with AA\n        renderer.renderTarget.finishRenderPass();\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        this._applyFiltersToTexture(filterData, true);\n\n        const outputTexture = filterData.outputRenderSurface as Texture;\n\n        outputTexture.source.alphaMode = 'premultiplied-alpha';\n\n        return outputTexture;\n    }\n\n    /** @internal */\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._popFilterData();\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        renderer.globalUniforms.pop();\n\n        renderer.renderTarget.finishRenderPass();\n\n        this._activeFilterData = filterData;\n\n        this._applyFiltersToTexture(filterData, false);\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(filterData.backTexture);\n        }\n\n        // return the texture to the pool so we can reuse the next frame\n        TexturePool.returnTexture(filterData.inputTexture);\n    }\n\n    /**\n     * Copies the last render surface to a texture.\n     * @param lastRenderSurface - The last render surface to copy from.\n     * @param bounds - The bounds of the area to copy.\n     * @param previousBounds - The previous bounds to use for offsetting the copy.\n     */\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    /**\n     * Applies a filter to a texture.\n     * @param filter - The filter to apply.\n     * @param input - The input texture.\n     * @param output - The output render surface.\n     * @param clear - Whether to clear the output surface before applying the filter.\n     */\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._activeFilterData;\n\n        const outputRenderSurface = filterData.outputRenderSurface;\n\n        const isFinalTarget = outputRenderSurface === output;\n\n        // Find the correct resolution by looking back through the filter stack\n        const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n        const resolution = this._findFilterResolution(rootResolution);\n\n        // Calculate the offset for both outputFrame and globalFrame\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (isFinalTarget)\n        {\n            const offset = this._findPreviousFilterOffset();\n\n            offsetX = offset.x;\n            offsetY = offset.y;\n        }\n\n        this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n\n        // If the filter is disabled, we still need to write something into the output surface.\n        // Render a pass-through (copy) so the pipeline remains intact.\n        const filterToApply = filter.enabled\n            ? filter\n            : this._getPassthroughFilter();\n\n        this._setupBindGroupsAndRender(filterToApply, input, renderer);\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n\n        if (renderGroup && renderGroup.cacheToLocalTransform)\n        {\n            // get the matrix relative to the render group..\n            worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        }\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.orig.width,\n            1.0 / sprite.texture.orig.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy(): void\n    {\n        this._passthroughFilter?.destroy(true);\n        (this._passthroughFilter as null) = null;\n    }\n\n    private _getPassthroughFilter(): Filter\n    {\n        this._passthroughFilter ??= new PassthroughFilter();\n\n        return this._passthroughFilter;\n    }\n\n    /**\n     * Sets up the bind groups and renders the filter.\n     * @param filter - The filter to apply\n     * @param input - The input texture\n     * @param renderer - The renderer instance\n     */\n    private _setupBindGroupsAndRender(filter: Filter, input: Texture, renderer: Renderer): void\n    {\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(this._filterGlobalUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    /**\n     * Sets up the filter textures including input texture and back texture if needed.\n     * @param filterData - The filter data to update\n     * @param bounds - The bounds for the texture\n     * @param renderer - The renderer instance\n     * @param previousFilterData - The previous filter data for back texture calculation\n     */\n    private _setupFilterTextures(\n        filterData: FilterData,\n        bounds: Bounds,\n        renderer: Renderer,\n        previousFilterData: FilterData | null\n    ): void\n    {\n        // set all the filter data\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        // Very cryptic, but important(!) moment.\n        //\n        // If we try to pull texture from the pool for backTexture before inputTexture,\n        // it will be unbounded later by startRenderPass. It happens because in such a case - the current backTexture\n        // is actually inputTexture from the previous filter application (check `pop` method).\n        //\n        // So maintaining the order (inputTexture -> backTexture) helps us to prevent unwanted texture unbinding.\n        if (filterData.blendRequired)\n        {\n            renderer.renderTarget.finishRenderPass();\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n\n            filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n        }\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n\n        // set the global uniforms to take into account the bounds offset required\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    /**\n     * Calculates and sets the global frame for the filter.\n     * @param filterData - The filter data to update\n     * @param offsetX - The X offset\n     * @param offsetY - The Y offset\n     * @param globalResolution - The global resolution\n     * @param sourceWidth - The source texture width\n     * @param sourceHeight - The source texture height\n     */\n    private _calculateGlobalFrame(\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        globalResolution: number,\n        sourceWidth: number,\n        sourceHeight: number\n    ): void\n    {\n        const globalFrame = filterData.globalFrame;\n\n        globalFrame.x = offsetX * globalResolution;\n        globalFrame.y = offsetY * globalResolution;\n        globalFrame.width = sourceWidth * globalResolution;\n        globalFrame.height = sourceHeight * globalResolution;\n    }\n\n    /**\n     * Updates the filter uniforms with the current filter state.\n     * @param input - The input texture\n     * @param output - The output render surface\n     * @param filterData - The current filter data\n     * @param offsetX - The X offset for positioning\n     * @param offsetY - The Y offset for positioning\n     * @param resolution - The current resolution\n     * @param isFinalTarget - Whether this is the final render target\n     * @param clear - Whether to clear the output surface\n     */\n    private _updateFilterUniforms(\n        input: Texture,\n        output: RenderSurface,\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        resolution: number,\n        isFinalTarget: boolean,\n        clear: boolean\n    ): void\n    {\n        const uniforms = this._filterGlobalUniforms.uniforms;\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            outputFrame[0] = filterData.bounds.minX - offsetX;\n            outputFrame[1] = filterData.bounds.minY - offsetY;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offsetX * resolution;\n        globalFrame[1] = offsetY * resolution;\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // we are going to overwrite resource we can set it to null!\n        if (output instanceof Texture) output.source.resource = null;\n\n        // set the output texture - this is where we are going to render to\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        this.renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n\n        this._filterGlobalUniforms.update();\n    }\n\n    /**\n     * Finds the correct resolution by looking back through the filter stack.\n     * @param rootResolution - The fallback root resolution to use\n     * @returns The resolution from the previous filter or root resolution\n     */\n    private _findFilterResolution(rootResolution: number): number\n    {\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        return currentIndex > 0 && this._filterStack[currentIndex].inputTexture\n            ? this._filterStack[currentIndex].inputTexture.source._resolution\n            : rootResolution;\n    }\n\n    /**\n     * Finds the offset from the previous non-skipped filter in the stack.\n     * @returns The offset coordinates from the previous filter\n     */\n    private _findPreviousFilterOffset(): { x: number, y: number }\n    {\n        let offsetX = 0;\n        let offsetY = 0;\n        let lastIndex = this._filterStackIndex;\n\n        while (lastIndex > 0)\n        {\n            lastIndex--;\n            const prevFilterData = this._filterStack[lastIndex];\n\n            if (!prevFilterData.skip)\n            {\n                offsetX = prevFilterData.bounds.minX;\n                offsetY = prevFilterData.bounds.minY;\n                break;\n            }\n        }\n\n        return { x: offsetX, y: offsetY };\n    }\n\n    /**\n     * Calculates the filter area bounds based on the instruction type.\n     * @param instruction - The filter instruction\n     * @param bounds - The bounds object to populate\n     */\n    private _calculateFilterArea(instruction: FilterInstruction, bounds: Bounds): void\n    {\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            // we want to factor render layers to get the real visual bounds of this container.\n            // so the last param is true..\n            instruction.container.getFastGlobalBounds(true, bounds);\n        }\n\n        if (instruction.container)\n        {\n            // When a container is cached as a texture, its filters need to be applied relative to its\n            // cached parent's coordinate space rather than world space. This transform adjustment ensures\n            // filters are applied in the correct coordinate system.\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n\n            if (filterFrameTransform)\n            {\n                bounds.applyMatrix(filterFrameTransform);\n            }\n        }\n    }\n\n    private _applyFiltersToTexture(filterData: FilterData, clear: boolean)\n    {\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        const filters = filterData.filters;\n        const firstEnabled = filterData.firstEnabledIndex;\n        const lastEnabled = filterData.lastEnabledIndex;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n\n        if (firstEnabled === lastEnabled)\n        {\n            // render a single filter...\n            filters[firstEnabled].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            const tempTexture = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            // get another texture that we will render the next filter too\n            let flop = tempTexture;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (let i = firstEnabled; i < lastEnabled; i++)\n            {\n                const filter = filters[i];\n\n                if (!filter.enabled) continue;\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n            // apply the last enabled filter to the output\n            filters[lastEnabled].apply(this, flip, filterData.outputRenderSurface, clear);\n\n            // return those textures for later!\n            TexturePool.returnTexture(tempTexture);\n        }\n    }\n\n    private _calculateFilterBounds(\n        filterData: FilterData,\n        viewPort: Rectangle,\n        rootAntialias: boolean,\n        rootResolution: number,\n        // a multiplier padding for the bounds calculation\n        // this prop is used when applying filters to textures\n        // as the should have padding applied to them already (until we fix padding when applying them to textures)\n        // set to 0 to remove padding from the bounds calculation\n        paddingMultiplier: number\n    )\n    {\n        const renderer = this.renderer;\n\n        const bounds = filterData.bounds;\n        const filters = filterData.filters;\n\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n        // cache first/last enabled indices for later passes\n        let firstEnabledIndex = -1;\n        let lastEnabledIndex = -1;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            // Only enabled filters should influence pipeline characteristics\n            if (!filter.enabled) continue;\n\n            if (firstEnabledIndex === -1) firstEnabledIndex = i;\n            lastEnabledIndex = i;\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? rootResolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= rootAntialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = true;\n            blendRequired ||= filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        if (clipToViewport)\n        {\n            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        }\n\n        // round the bounds to the nearest pixel\n        bounds\n            .scale(resolution)\n            .ceil()\n            .scale(1 / resolution)\n            .pad((padding | 0) * paddingMultiplier);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set the global frame to the root texture\n\n        // get previous bounds.. we must take into account skipped filters also..\n\n        // // to find the previous resolution we need to account for the skipped filters\n        // // the following will find the last non skipped filter...\n\n        // store the values that will be used to apply the filters\n        filterData.antialias = antialias;\n        filterData.resolution = resolution;\n        filterData.blendRequired = blendRequired;\n        filterData.firstEnabledIndex = firstEnabledIndex;\n        filterData.lastEnabledIndex = lastEnabledIndex;\n    }\n\n    private _popFilterData(): FilterData\n    {\n        this._filterStackIndex--;\n\n        return this._filterStack[this._filterStackIndex];\n    }\n\n    private _getPreviousFilterData(): FilterData | null\n    {\n        let previousFilterData: FilterData;\n\n        let index = this._filterStackIndex - 1;\n\n        while (index > 0)\n        {\n            index--;\n            previousFilterData = this._filterStack[index];\n\n            if (!previousFilterData.skip)\n            {\n                break;\n            }\n        }\n\n        return previousFilterData;\n    }\n\n    private _pushFilterData(): FilterData\n    {\n        let filterData = this._filterStack[this._filterStackIndex];\n\n        if (!filterData)\n        {\n            filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n        }\n\n        this._filterStackIndex++;\n\n        return filterData;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3542, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/filters/mask/MaskFilter.ts"],"sourcesContent":["import { Matrix } from '../../maths/matrix/Matrix';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix';\nimport { Filter } from '../Filter';\nimport fragment from './mask.frag';\nimport vertex from './mask.vert';\nimport source from './mask.wgsl';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Sprite } from '../../scene/sprite/Sprite';\nimport type { FilterOptions } from '../Filter';\nimport type { FilterSystem } from '../FilterSystem';\n\n/** @internal */\nexport interface MaskFilterOptions extends FilterOptions\n{\n    sprite: Sprite,\n    inverse?: boolean;\n    scale?: number | { x: number, y: number },\n}\n\n/** @internal */\nexport class MaskFilter extends Filter\n{\n    public sprite: Sprite;\n    private readonly _textureMatrix: TextureMatrix;\n\n    constructor(options: MaskFilterOptions)\n    {\n        const { sprite, ...rest } = options;\n\n        const textureMatrix = new TextureMatrix(sprite.texture);\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uMaskClamp: { value: textureMatrix.uClampFrame, type: 'vec4<f32>' },\n            uAlpha: { value: 1, type: 'f32' },\n            uInverse: { value: options.inverse ? 1 : 0, type: 'f32' },\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'mask-filter',\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            clipToViewport: false,\n            resources: {\n                filterUniforms,\n                uMaskTexture: sprite.texture.source,\n            },\n        });\n\n        this.sprite = sprite;\n\n        this._textureMatrix = textureMatrix;\n    }\n\n    set inverse(value: boolean)\n    {\n        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n    }\n\n    get inverse(): boolean\n    {\n        return this.resources.filterUniforms.uniforms.uInverse === 1;\n    }\n\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        // will trigger an update if the texture changed..\n        this._textureMatrix.texture = this.sprite.texture;\n\n        filterManager.calculateSpriteMatrix(\n            this.resources.filterUniforms.uniforms.uFilterMatrix as Matrix,\n            this.sprite\n        ).prepend(this._textureMatrix.mapCoord);\n\n        this.resources.uMaskTexture = this.sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAwBO,MAAM,mBAAmB,oKAChC,CAAA;IAII,YAAY,OACZ,CAAA;QACI,MAAM,EAAE,MAAA,EAAQ,GAAG,IAAA,EAAS,GAAA,OAAA,CAAA;QAE5B,MAAM,aAAgB,GAAA,IAAI,sNAAc,CAAA,MAAA,CAAO,OAAO,CAAA,CAAA;QAEhD,MAAA,cAAA,GAAiB,IAAI,mNAAa,CAAA;YACpC,eAAe;gBAAE,KAAA,EAAO,IAAI,4KAAO,EAAA;gBAAG,MAAM,aAAc;YAAA,CAAA;YAC1D,YAAY;gBAAE,KAAA,EAAO,aAAc,CAAA,WAAA;gBAAa,MAAM,WAAY;YAAA,CAAA;YAClE,MAAQ,EAAA;gBAAE,KAAO,EAAA,CAAA;gBAAG,MAAM,KAAM;YAAA,CAAA;YAChC,QAAA,EAAU;gBAAE,KAAO,EAAA,OAAA,CAAQ,OAAA,GAAU,CAAI,GAAA,CAAA;gBAAG,MAAM,KAAM;YAAA,CAAA;QAAA,CAC3D,CAAA,CAAA;QAEK,MAAA,UAAA,GAAa,4MAAA,CAAW,IAAK,CAAA;YAC/B,MAAQ,EAAA;wBACJ,mLAAA;gBACA,UAAY,EAAA,YAAA;YAAA,CAChB;YACA,QAAU,EAAA;wBACN,mLAAA;gBACA,UAAY,EAAA,cAAA;YAAA,CAChB;QAAA,CACH,CAAA,CAAA;QAEK,MAAA,SAAA,GAAY,yMAAA,CAAU,IAAK,CAAA;oBAC7B,mLAAA;sBACA,mLAAA;YACA,IAAM,EAAA,aAAA;QAAA,CACT,CAAA,CAAA;QAEK,KAAA,CAAA;YACF,GAAG,IAAA;YACH,UAAA;YACA,SAAA;YACA,cAAgB,EAAA,KAAA;YAChB,SAAW,EAAA;gBACP,cAAA;gBACA,YAAA,EAAc,OAAO,OAAQ,CAAA,MAAA;YAAA,CACjC;QAAA,CACH,CAAA,CAAA;QAED,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;QAEd,IAAA,CAAK,cAAiB,GAAA,aAAA,CAAA;IAAA,CAC1B;IAEA,IAAI,QAAQ,KACZ,EAAA;QACI,IAAA,CAAK,SAAU,CAAA,cAAA,CAAe,QAAS,CAAA,QAAA,GAAW,QAAQ,CAAI,GAAA,CAAA,CAAA;IAAA,CAClE;IAEA,IAAI,OACJ,GAAA;QACI,OAAO,IAAK,CAAA,SAAA,CAAU,cAAe,CAAA,QAAA,CAAS,QAAa,KAAA,CAAA,CAAA;IAAA,CAC/D;IAEO,KACH,CAAA,aAAA,EACA,KACA,EAAA,MAAA,EACA,SAEJ,EAAA;QAES,IAAA,CAAA,cAAA,CAAe,OAAU,GAAA,IAAA,CAAK,MAAO,CAAA,OAAA,CAAA;QAE5B,aAAA,CAAA,qBAAA,CACV,IAAA,CAAK,SAAU,CAAA,cAAA,CAAe,QAAS,CAAA,aAAA,EACvC,IAAK,CAAA,MAAA,EACP,OAAA,CAAQ,IAAK,CAAA,cAAA,CAAe,QAAQ,CAAA,CAAA;QAEtC,IAAA,CAAK,SAAU,CAAA,YAAA,GAAe,IAAK,CAAA,MAAA,CAAO,OAAQ,CAAA,MAAA,CAAA;QAElD,aAAA,CAAc,WAAY,CAAA,IAAA,EAAM,KAAO,EAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;IAAA,CAC5D;AACJ"}}]
}