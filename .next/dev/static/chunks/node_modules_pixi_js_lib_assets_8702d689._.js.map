{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/utils/convertToList.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/utils/convertToList.ts"],"sourcesContent":["/**\n * @param input\n * @param transform\n * @param forceTransform\n * @internal\n */\nexport const convertToList = <T>(\n    input: string | T | (string | T)[],\n    transform?: (input: string) => T,\n    forceTransform = false\n): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string' || forceTransform)\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n"],"names":[],"mappings":";;;;;AAMO,MAAM,aAAgB,GAAA,CACzB,KACA,EAAA,SAAA,EACA,iBAAiB,KAErB,KAAA;IACI,IAAI,CAAC,KAAA,CAAM,OAAQ,CAAA,KAAK,CACxB,EAAA;QACI,KAAA,GAAQ;YAAC,KAAU;SAAA,CAAA;IAAA,CACvB;IAEA,IAAI,CAAC,SACL,EAAA;QACW,OAAA,KAAA,CAAA;IAAA,CACX;IAEQ,OAAA,KAAA,CAAyB,GAAI,CAAA,CAAC,IACtC,KAAA;QACQ,IAAA,OAAO,IAAS,KAAA,QAAA,IAAY,cAChC,EAAA;YACI,OAAO,UAAU,IAAc,CAAA,CAAA;QAAA,CACnC;QAEO,OAAA,IAAA,CAAA;IAAA,CACV,CAAA,CAAA;AACL"}},
    {"offset": {"line": 31, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/cache/Cache.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/cache/Cache.ts"],"sourcesContent":["import { warn } from '../../utils/logging/warn';\nimport { convertToList } from '../utils/convertToList';\n\nimport type { CacheParser } from './CacheParser';\n\n/** @internal */\nclass CacheClass\n{\n    private readonly _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<any, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: any): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: any): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set<T = any>(key: any | any[], value: T): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        // convert cacheable assets to a map of key-value pairs\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n\n        if (!cacheableAssets)\n        {\n            keys.forEach((key) =>\n            {\n                cacheableMap.set(key, value);\n            });\n        }\n\n        const cacheKeys = [...cacheableMap.keys()];\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets as any);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            const val = cacheableAssets ? cacheableAssets[key] : value;\n\n            if (this._cache.has(key) && this._cache.get(key) !== val)\n            {\n                // #if _DEBUG\n                warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableMap.get(key));\n        });\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: any): void\n    {\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /**\n     * All loader parsers registered\n     * @advanced\n     */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\n/**\n * A global cache for all assets in your PixiJS application. The cache system provides fast\n * access to loaded assets and prevents duplicate loading.\n *\n * Key Features:\n * - Automatic caching of loaded assets\n * - Support for custom cache parsers\n * - Automatic parsing of complex assets (e.g., spritesheets)\n * - Memory management utilities\n * > [!IMPORTANT] You typically do not need to use this class directly.\n * > Use the main {@link Assets} class for high-level asset management.\n * > `Assets.get(key)` will automatically use the cache.\n * @example\n * ```ts\n * import { Cache } from 'pixi.js';\n *\n * // Store an asset in the cache\n * Cache.set('myTexture', texture);\n *\n * // Retrieve an asset\n * const texture = Cache.get('myTexture');\n *\n * // Check if an asset exists\n * if (Cache.has('myTexture')) {\n *     // Use the cached asset\n *     const sprite = new Sprite(Cache.get('myTexture'));\n * }\n *\n * // Remove an asset from cache\n * Cache.remove('myTexture');\n *\n * // Clear all cached assets\n * Cache.reset();\n * ```\n * @remarks\n * The Cache is a core component of PixiJS' asset management system:\n * - Used internally by the {@link Assets} class\n * - Supports automatic parsing via {@link CacheParser}\n * - Handles complex asset types like spritesheets\n * - Manages memory through asset removal\n *\n * > [!IMPORTANT]\n * > This is a singleton class and should not be instantiated directly.\n * > Use the exported `Cache` instance instead.\n * @see {@link Assets} For high-level asset management\n * @see {@link CacheParser} For custom cache parsing\n * @category assets\n * @class\n * @advanced\n */\nexport const Cache = new CacheClass();\n"],"names":["key"],"mappings":"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"}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/loader/parsers/LoaderParser.ts"],"sourcesContent":["import type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { ResolvedAsset } from '../../types';\nimport type { Loader } from '../Loader';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension test.\n * The higher priority parsers will be checked first.\n * @category assets\n * @advanced\n */\nexport enum LoaderParserPriority\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/**\n * A more verbose version of the LoaderParser, allowing you to set the loaded, parsed, and unloaded asset separately\n * @category assets\n * @advanced\n */\nexport interface LoaderParserAdvanced<\n    ASSET = any,\n    PARSED_ASSET = ASSET,\n    UNLOAD_ASSET = ASSET,\n    META_DATA = any,\n    CONFIG = Record<string, any>\n>\n{\n    /** Should be ExtensionType.LoaderParser */\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: CONFIG;\n\n    /**\n     * @deprecated Use `id` instead.\n     */\n    name?: string;\n    /** The name of the parser (this can be used when specifying parser in a ResolvedAsset) */\n    id: string;\n\n    /**\n     * Each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<ASSET | T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<PARSED_ASSET | T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: UNLOAD_ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<void> | void;\n}\n\n/**\n * The interface to define a loader parser *(all functions are optional)*.\n *\n * When you create a `parser` object, the flow for every asset loaded is:\n *\n * 1. `parser.test()` - Each URL to load will be tested here, if the test is passed the assets are\n * loaded using the load function below. Good place to test for things like file extensions!\n * 2. `parser.load()` - This is the promise that loads the URL provided resolves with a loaded asset\n * if returned by the parser.\n * 3. `parser.testParse()` - This function is used to test if the parse function should be run on the\n *  asset If this returns true then parse is called with the asset\n * 4. `parse.parse()` - Gets called on the asset it testParse passes. Useful to convert a raw asset\n *  into something more useful\n *\n * <br/>\n * Some loaders may only be used for parsing, some only for loading, and some for both!\n * @category assets\n * @advanced\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface LoaderParser<ASSET = any, META_DATA = any, CONFIG = Record<string, any>>\n    extends LoaderParserAdvanced<ASSET, ASSET, ASSET, META_DATA, CONFIG> {}\n"],"names":["LoaderParserPriority"],"mappings":";;;;;AAWY,IAAA,oBAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,qBAAL,KAAA;IAGHA,qBAAAA,CAAAA,qBAAAA,CAAA,MAAA,GAAM,CAAN,CAAA,GAAA,KAAA,CAAA;IAEAA,qBAAAA,CAAAA,qBAAAA,CAAA,SAAA,GAAS,CAAT,CAAA,GAAA,QAAA,CAAA;IAEAA,qBAAAA,CAAAA,qBAAAA,CAAA,OAAA,GAAO,CAAP,CAAA,GAAA,MAAA,CAAA;IAPQA,OAAAA,qBAAAA,CAAAA;AAAA,CAAA,EAAA,oBAAA,IAAA,CAAA,CAAA"}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/utils/createStringVariations.ts"],"sourcesContent":["function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n * @internal\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,QAAS,CAAA,IAAA,EAAc,GAAiB,EAAA,KAAA,EAAe,MAAA,EAAkB,IAClF,EAAA;IACU,MAAA,EAAA,GAAK,GAAA,CAAI,KAAK,CAAA,CAAA;IAEpB,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,EAAA,CAAG,MAAA,EAAQ,CAC/B,EAAA,CAAA;QACU,MAAA,KAAA,GAAQ,EAAA,CAAG,CAAC,CAAA,CAAA;QAEd,IAAA,KAAA,GAAQ,GAAI,CAAA,MAAA,GAAS,CACzB,EAAA;YACa,QAAA,CAAA,IAAA,CAAK,OAAQ,CAAA,MAAA,CAAO,KAAK,CAAA,EAAG,KAAK,CAAA,EAAG,GAAK,EAAA,KAAA,GAAQ,CAAG,EAAA,MAAA,EAAQ,IAAI,CAAA,CAAA;QAAA,CAG7E,MAAA;YACI,IAAA,CAAK,IAAA,CAAK,IAAK,CAAA,OAAA,CAAQ,MAAA,CAAO,KAAK,CAAA,EAAG,KAAK,CAAC,CAAA,CAAA;QAAA,CAChD;IAAA,CACJ;AACJ,CAAA;AAUO,SAAS,uBAAuB,MACvC,EAAA;IACI,MAAM,KAAQ,GAAA,YAAA,CAAA;IAER,MAAA,MAAA,GAAS,MAAO,CAAA,KAAA,CAAM,KAAK,CAAA,CAAA;IAEjC,MAAM,OAAiB,EAAC,CAAA;IAExB,IAAI,MACJ,EAAA;QACI,MAAM,MAAkB,EAAC,CAAA;QAElB,MAAA,CAAA,OAAA,CAAQ,CAAC,IAChB,KAAA;YAEU,MAAA,KAAA,GAAQ,KAAK,SAAU,CAAA,CAAA,EAAG,KAAK,MAAS,GAAA,CAAC,CAAE,CAAA,KAAA,CAAM,GAAG,CAAA,CAAA;YAE1D,GAAA,CAAI,IAAA,CAAK,KAAK,CAAA,CAAA;QAAA,CACjB,CAAA,CAAA;QAED,QAAA,CAAS,MAAQ,EAAA,GAAA,EAAK,CAAG,EAAA,MAAA,EAAQ,IAAI,CAAA,CAAA;IAAA,CAGzC,MAAA;QACI,IAAA,CAAK,IAAA,CAAK,MAAM,CAAA,CAAA;IAAA,CACpB;IAEO,OAAA,IAAA,CAAA;AACX"}},
    {"offset": {"line": 192, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/utils/isSingleItem.ts"],"sourcesContent":["/**\n * Checks if the given value is an array.\n * @param item - The item to test\n * @internal\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n"],"names":[],"mappings":";;;;;AAKO,MAAM,eAAe,CAAC,IAAA,GAA4B,CAAC,KAAA,CAAM,OAAA,CAAQ,IAAI"}},
    {"offset": {"line": 204, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/resolver/Resolver.ts"],"sourcesContent":["import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\n/**\n * Options for how the resolver deals with generating bundle ids\n * @category assets\n * @advanced\n */\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @category assets\n * @advanced\n */\nexport class Resolver\n{\n    /**\n     * The prefix that denotes a URL is for a retina asset.\n     * @default /@([0-9\\.]+)x/\n     * @example `@2x`\n     */\n    public static RETINA_PREFIX = /@([0-9\\.]+)x/;\n\n    private readonly _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private readonly _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, src } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || src, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? v);\n\n                if (value?.src) return value.src;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n        let convertedAssets: UnresolvedAsset[] = assets as UnresolvedAsset[];\n\n        if (!Array.isArray(assets))\n        {\n            // convert to array...\n            convertedAssets = Object.entries(assets).map(([alias, src]) =>\n            {\n                if (typeof src === 'string' || Array.isArray(src))\n                {\n                    return { alias, src };\n                }\n\n                return { alias, ...src };\n            });\n        }\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n\n        convertedAssets.forEach((asset) =>\n        {\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids: string[];\n\n            if (typeof aliases === 'string')\n            {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                assetNames.push(bundleAssetId);\n                ids = [aliases, bundleAssetId];\n            }\n            else\n            {\n                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                assetNames.push(...bundleIds);\n                ids = [...aliases, ...bundleIds];\n            }\n\n            this.add({\n                ...asset,\n                ...{\n                    alias: ids,\n                    src: srcs,\n                }\n            });\n        });\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n     */\n    public add(\n        aliases: ArrayOr<UnresolvedAsset>,\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        // #if _DEBUG\n        // eslint-disable-next-line prefer-const\n        keyCheck = (key: string) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        };\n        // #endif\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src } = asset;\n            let {\n                data,\n                format,\n                loadParser: userDefinedLoadParser,\n                parser: userDefinedParser,\n            } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            // #if _DEBUG\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            // #endif\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            // Helper function to parse a URL string using registered parsers\n            const parseUrl = (url: string): ResolvedAsset =>\n            {\n                const parser = this._parsers.find((p) => p.test(url));\n\n                return {\n                    ...parser?.parse(url),\n                    src: url,\n                };\n            };\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        // first see if it contains any {} tags...\n                        formattedAsset = parseUrl(src);\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        if (src.loadParser || src.parser)\n                        {\n                            userDefinedLoadParser = src.loadParser ?? userDefinedLoadParser;\n                            userDefinedParser = src.parser ?? userDefinedParser;\n                        }\n\n                        formattedAsset = {\n                            ...parseUrl(src.src),\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser: userDefinedLoadParser,\n                        parser: userDefinedParser,\n                        progressSize: asset.progressSize,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = assets[0];\n                }\n                else\n                {\n                    this._resolverHash[key] = this._buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[i];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private _buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        parser?: string,\n        format?: string,\n        progressSize?: number,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, parser, format, progressSize } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.parser = parser ?? formattedAsset.parser;\n        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n        if (progressSize !== undefined)\n        {\n            formattedAsset.progressSize = progressSize;\n        }\n\n        return formattedAsset;\n    }\n}\n\n/**\n * @param url\n * @internal\n */\nexport function getUrlExtension(url: string)\n{\n    return url.split('.').pop().split('?').shift()\n        .split('#')\n        .shift();\n}\n"],"names":["src"],"mappings":"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"}},
    {"offset": {"line": 741, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/utils/copySearchParams.ts"],"sourcesContent":["/**\n * Copies the search params from one url to another\n * @param targetUrl - the url to copy the search params to\n * @param sourceUrl - the url container the search params we want to copy\n * @returns the url with the search params copied\n * @internal\n */\nexport const copySearchParams = (targetUrl: string, sourceUrl: string) =>\n{\n    const searchParams = sourceUrl.split('?')[1];\n\n    if (searchParams)\n    {\n        targetUrl += `?${searchParams}`;\n    }\n\n    return targetUrl;\n};\n"],"names":[],"mappings":";;;;;AAOa,MAAA,gBAAA,GAAmB,CAAC,SAAA,EAAmB,SACpD,KAAA;IACI,MAAM,YAAe,GAAA,SAAA,CAAU,KAAM,CAAA,GAAG,CAAA,CAAE,CAAC,CAAA,CAAA;IAE3C,IAAI,YACJ,EAAA;QACI,SAAA,IAAa,CAAA,CAAA,EAAI,YAAY,CAAA,CAAA,CAAA;IAAA,CACjC;IAEO,OAAA,SAAA,CAAA;AACX"}},
    {"offset": {"line": 759, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/BackgroundLoader.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/BackgroundLoader.ts"],"sourcesContent":["import type { Loader } from './loader/Loader';\nimport type { ResolvedAsset } from './types';\n\n/**\n * The BackgroundLoader handles loading assets passively in the background to prepare them for future use.\n * It loads one asset at a time to minimize impact on application performance.\n *\n * Key features:\n * - Sequential loading of assets\n * - Automatic pause when high-priority loads occur\n * - Configurable concurrency\n * @example\n * ```ts\n * import { Assets } from 'pixi.js';\n *\n * // Background load level assets while in menu\n * Assets.backgroundLoad([\n *     'level1/background.png',\n *     'level1/sprites.json',\n *     'level1/music.mp3'\n * ]);\n *\n * // Assets will be instantly available when needed\n * const assets = await Assets.load([\n *     'level1/background.png',\n *     'level1/sprites.json'\n * ]);\n *\n * // Background load bundles\n * Assets.backgroundLoadBundle('level2');\n *\n * // Later, instant access\n * const level2 = await Assets.loadBundle('level2');\n * ```\n * > [!NOTE] You typically do not need to use this class directly. Use the main {@link Assets.backgroundLoad} API instead.\n * @remarks\n * - Background loading is automatically paused when `Assets.load()` is called\n * - Assets are loaded sequentially to minimize performance impact\n * - Assets are cached as they complete loading\n * - No progress tracking is available for background loading\n * @see {@link Assets.backgroundLoad} For the main background loading API\n * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n * @category assets\n * @advanced\n */\nexport class BackgroundLoader\n{\n    /** Whether or not the loader should continue loading. */\n    private _isActive: boolean;\n\n    /** Assets to load. */\n    private readonly _assetList: ResolvedAsset[];\n\n    /** Whether or not the loader is loading. */\n    private _isLoading: boolean;\n\n    /** Number of assets to load at a time. */\n    private readonly _maxConcurrent: number;\n\n    /**\n     * Should the loader log to the console.\n     * @advanced\n     */\n    public verbose: boolean;\n    private readonly _loader: Loader;\n\n    /**\n     * @param loader\n     * @param verbose - should the loader log to the console\n     */\n    constructor(loader: Loader, verbose = false)\n    {\n        this._loader = loader;\n        this._assetList = [];\n        this._isLoading = false;\n        this._maxConcurrent = 1;\n        this.verbose = verbose;\n    }\n\n    /**\n     * Adds assets to the background loading queue. Assets are loaded one at a time to minimize\n     * performance impact.\n     * @param assetUrls - Array of resolved assets to load in the background\n     * @example\n     * ```ts\n     * // Add assets to background load queue\n     * backgroundLoader.add([\n     *     { src: 'images/level1/bg.png' },\n     *     { src: 'images/level1/characters.json' }\n     * ]);\n     *\n     * // Assets will load sequentially in the background\n     * // The loader automatically pauses when high-priority loads occur\n     * // e.g. Assets.load() is called\n     * ```\n     * @remarks\n     * - Assets are loaded one at a time to minimize performance impact\n     * - Loading automatically pauses when Assets.load() is called\n     * - No progress tracking is available for background loading\n     * - Assets are cached as they complete loading\n     * @internal\n     */\n    public add(assetUrls: ResolvedAsset[]): void\n    {\n        assetUrls.forEach((a) =>\n        {\n            this._assetList.push(a);\n        });\n\n        if (this.verbose)\n        {\n            // eslint-disable-next-line no-console\n            console.log('[BackgroundLoader] assets: ', this._assetList);\n        }\n\n        if (this._isActive && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n\n    /**\n     * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n     *\n     * The max assets it will try to load at one time will be 4.\n     */\n    private async _next(): Promise<void>\n    {\n        if (this._assetList.length && this._isActive)\n        {\n            this._isLoading = true;\n\n            const toLoad = [];\n\n            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n\n            for (let i = 0; i < toLoadAmount; i++)\n            {\n                toLoad.push(this._assetList.pop());\n            }\n\n            await this._loader.load(toLoad);\n\n            this._isLoading = false;\n\n            void this._next();\n        }\n    }\n\n    /**\n     * Controls the active state of the background loader. When active, the loader will\n     * continue processing its queue. When inactive, loading is paused.\n     * @returns Whether the background loader is currently active\n     * @example\n     * ```ts\n     * // Pause background loading\n     * backgroundLoader.active = false;\n     *\n     * // Resume background loading\n     * backgroundLoader.active = true;\n     *\n     * // Check current state\n     * console.log(backgroundLoader.active); // true/false\n     *\n     * // Common use case: Pause during intensive operations\n     * backgroundLoader.active = false;  // Pause background loading\n     * ... // Perform high-priority tasks\n     * backgroundLoader.active = true;   // Resume background loading\n     * ```\n     * @remarks\n     * - Setting to true resumes loading immediately\n     * - Setting to false pauses after current asset completes\n     * - Background loading is automatically paused during `Assets.load()`\n     * - Assets already being loaded will complete even when set to false\n     */\n    public get active(): boolean\n    {\n        return this._isActive;\n    }\n\n    set active(value: boolean)\n    {\n        if (this._isActive === value) return;\n\n        this._isActive = value;\n\n        if (value && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n}\n"],"names":[],"mappings":";;;;;AA6CO,MAAM,gBACb,CAAA;IAAA;;;GAAA,GAwBI,WAAA,CAAY,MAAgB,EAAA,OAAA,GAAU,KACtC,CAAA;QACI,IAAA,CAAK,OAAU,GAAA,MAAA,CAAA;QACf,IAAA,CAAK,UAAA,GAAa,EAAC,CAAA;QACnB,IAAA,CAAK,UAAa,GAAA,KAAA,CAAA;QAClB,IAAA,CAAK,cAAiB,GAAA,CAAA,CAAA;QACtB,IAAA,CAAK,OAAU,GAAA,OAAA,CAAA;IAAA,CACnB;IAAA;;;;;;;;;;;;;;;;;;;;;;GAAA,GAyBO,IAAI,SACX,EAAA;QACc,SAAA,CAAA,OAAA,CAAQ,CAAC,CACnB,KAAA;YACS,IAAA,CAAA,UAAA,CAAW,IAAA,CAAK,CAAC,CAAA,CAAA;QAAA,CACzB,CAAA,CAAA;QAED,IAAI,IAAA,CAAK,OACT,EAAA;YAEY,OAAA,CAAA,GAAA,CAAI,6BAA+B,EAAA,IAAA,CAAK,UAAU,CAAA,CAAA;QAAA,CAC9D;QAEA,IAAI,IAAK,CAAA,SAAA,IAAa,CAAC,IAAA,CAAK,UAC5B,EAAA;YACI,KAAK,IAAA,CAAK,KAAM,EAAA,CAAA;QAAA,CACpB;IAAA,CACJ;IAAA;;;;GAAA,GAOA,MAAc,KACd,GAAA;QACI,IAAI,IAAK,CAAA,UAAA,CAAW,MAAU,IAAA,IAAA,CAAK,SACnC,EAAA;YACI,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;YAElB,MAAM,SAAS,EAAC,CAAA;YAEhB,MAAM,eAAe,IAAK,CAAA,GAAA,CAAI,IAAA,CAAK,UAAW,CAAA,MAAA,EAAQ,IAAA,CAAK,cAAc,CAAA,CAAA;YAEzE,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,YAAA,EAAc,CAClC,EAAA,CAAA;gBACI,MAAA,CAAO,IAAK,CAAA,IAAA,CAAK,UAAW,CAAA,GAAA,EAAK,CAAA,CAAA;YAAA,CACrC;YAEM,MAAA,IAAA,CAAK,OAAQ,CAAA,IAAA,CAAK,MAAM,CAAA,CAAA;YAE9B,IAAA,CAAK,UAAa,GAAA,KAAA,CAAA;YAElB,KAAK,IAAA,CAAK,KAAM,EAAA,CAAA;QAAA,CACpB;IAAA,CACJ;IAAA;;;;;;;;;;;;;;;;;;;;;;;;;GAAA,GA4BA,IAAW,MACX,GAAA;QACI,OAAO,IAAK,CAAA,SAAA,CAAA;IAAA,CAChB;IAEA,IAAI,OAAO,KACX,EAAA;QACI,IAAI,IAAA,CAAK,SAAc,KAAA,KAAA,EAAO,OAAA;QAE9B,IAAA,CAAK,SAAY,GAAA,KAAA,CAAA;QAEb,IAAA,KAAA,IAAS,CAAC,IAAA,CAAK,UACnB,EAAA;YACI,KAAK,IAAA,CAAK,KAAM,EAAA,CAAA;QAAA,CACpB;IAAA,CACJ;AACJ"}},
    {"offset": {"line": 867, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/cache/parsers/cacheTextureArray.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nimport type { CacheParser } from '../CacheParser';\n\n/**\n * Returns an object of textures from an array of textures to be cached\n * @category assets\n * @internal\n */\nexport const cacheTextureArray: CacheParser<Texture[]> = {\n    extension: {\n        type: ExtensionType.CacheParser,\n        name: 'cacheTextureArray',\n    },\n\n    test: (asset: any[]) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),\n\n    getCacheableAssets: (keys: string[], asset: Texture[]) =>\n    {\n        const out: Record<string, Texture> = {};\n\n        keys.forEach((key: string) =>\n        {\n            asset.forEach((item: Texture, i: number) =>\n            {\n                out[key + (i === 0 ? '' : i + 1)] = item;\n            });\n        });\n\n        return out;\n    }\n};\n"],"names":[],"mappings":";;;;;;;;;AAUO,MAAM,iBAA4C,GAAA;IACrD,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,WAAA;QACpB,IAAM,EAAA,mBAAA;IAAA,CACV;IAEA,IAAM,EAAA,CAAC,KAAiB,GAAA,KAAA,CAAM,OAAQ,CAAA,KAAK,CAAK,IAAA,KAAA,CAAM,KAAM,CAAA,CAAC,CAAM,GAAA,CAAA,YAAa,0MAAO,CAAA;IAEvF,kBAAA,EAAoB,CAAC,IAAA,EAAgB,KACrC,KAAA;QACI,MAAM,MAA+B,CAAA,CAAC,CAAA;QAEjC,IAAA,CAAA,OAAA,CAAQ,CAAC,GACd,KAAA;YACU,KAAA,CAAA,OAAA,CAAQ,CAAC,IAAA,EAAe,CAC9B,KAAA;gBACI,GAAA,CAAI,MAAA,CAAO,CAAM,KAAA,CAAA,GAAI,EAAK,GAAA,CAAA,GAAI,CAAA,CAAE,CAAI,GAAA,IAAA,CAAA;YAAA,CACvC,CAAA,CAAA;QAAA,CACJ,CAAA,CAAA;QAEM,OAAA,GAAA,CAAA;IAAA,CACX;AACJ"}},
    {"offset": {"line": 898, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/detections/utils/testImageFormat.ts"],"sourcesContent":["/**\n * @param imageData\n * @internal\n */\nexport async function testImageFormat(imageData: string): Promise<boolean>\n{\n    // Some browsers currently do not support createImageBitmap with Blob, so new Image() is preferred when exist.\n    // See https://caniuse.com/createimagebitmap for more information.\n\n    if ('Image' in globalThis)\n    {\n        return new Promise<boolean>((resolve) =>\n        {\n            // eslint-disable-next-line no-restricted-globals\n            const image = new Image();\n\n            image.onload = () =>\n            {\n                resolve(true);\n            };\n            image.onerror = () =>\n            {\n                resolve(false);\n            };\n            image.src = imageData;\n        });\n    }\n\n    if ('createImageBitmap' in globalThis && 'fetch' in globalThis)\n    {\n        try\n        {\n            const blob = await (await fetch(imageData)).blob();\n\n            await createImageBitmap(blob);\n        }\n        catch (_e)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n"],"names":[],"mappings":";;;;;AAIA,eAAsB,gBAAgB,SACtC,EAAA;IAII,IAAI,WAAW,UACf,EAAA;QACW,OAAA,IAAI,OAAiB,CAAA,CAAC,OAC7B,KAAA;YAEU,MAAA,KAAA,GAAQ,IAAI,KAAM,EAAA,CAAA;YAExB,KAAA,CAAM,MAAA,GAAS,MACf;gBACI,OAAA,CAAQ,IAAI,CAAA,CAAA;YAAA,CAChB,CAAA;YACA,KAAA,CAAM,OAAA,GAAU,MAChB;gBACI,OAAA,CAAQ,KAAK,CAAA,CAAA;YAAA,CACjB,CAAA;YACA,KAAA,CAAM,GAAM,GAAA,SAAA,CAAA;QAAA,CACf,CAAA,CAAA;IAAA,CACL;IAEI,IAAA,mBAAA,IAAuB,UAAc,IAAA,OAAA,IAAW,UACpD,EAAA;QAEI,IAAA;YACI,MAAM,OAAO,MAAO,CAAA,MAAM,KAAM,CAAA,SAAS,CAAA,EAAG,IAAK,EAAA,CAAA;YAEjD,MAAM,kBAAkB,IAAI,CAAA,CAAA;QAAA,EAAA,OAEzB,EACP,EAAA;YACW,OAAA,KAAA,CAAA;QAAA,CACX;QAEO,OAAA,IAAA,CAAA;IAAA,CACX;IAEO,OAAA,KAAA,CAAA;AACX"}},
    {"offset": {"line": 933, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/detections/parsers/detectAvif.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the AVIF image format.\n * @category assets\n * @internal\n */\nexport const detectAvif: FormatDetectionParser = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 1,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        // eslint-disable-next-line max-len\n        'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A='\n    ),\n    add: async (formats) => [...formats, 'avif'],\n    remove: async (formats) => formats.filter((f) => f !== 'avif'),\n};\n"],"names":[],"mappings":";;;;;;;;;AAUO,MAAM,UAAoC,GAAA;IAC7C,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,eAAA;QACpB,QAAU,EAAA,CAAA;IAAA,CACd;IACA,MAAM,cAA8B,4MAAA,EAAA,mCAAA;QAEhC,ybAAA;IAEJ,KAAK,OAAO,OAAA,GAAY,CAAC;eAAG;YAAS,MAAM;SAAA;IAC3C,MAAA,EAAQ,OAAO,OAAY,GAAA,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA,GAAM,MAAM,MAAM,CAAA;AACjE"}},
    {"offset": {"line": 961, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/detections/parsers/detectDefaults.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { FormatDetectionParser } from '../types';\n\nconst imageFormats = ['png', 'jpg', 'jpeg'];\n\n/**\n * Adds some default image formats to the detection parser\n * @category assets\n * @internal\n */\nexport const detectDefaults = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: -1,\n    },\n    test: (): Promise<boolean> => Promise.resolve(true),\n    add: async (formats) => [...formats, ...imageFormats],\n    remove: async (formats) => formats.filter((f) => !imageFormats.includes(f)),\n} as FormatDetectionParser;\n"],"names":[],"mappings":";;;;;;;AAIA,MAAM,YAAe,GAAA;IAAC,KAAO;IAAA,KAAA;IAAO,MAAM;CAAA,CAAA;AAOnC,MAAM,cAAiB,GAAA;IAC1B,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,eAAA;QACpB,QAAU,EAAA,CAAA,CAAA;IAAA,CACd;IACA,IAAM,EAAA,IAAwB,OAAQ,CAAA,OAAA,CAAQ,IAAI,CAAA;IAClD,KAAK,OAAO,OAAA,GAAY,CAAC;eAAG,OAAA,EAAS;eAAG,YAAY;SAAA;IACpD,MAAA,EAAQ,OAAO,OAAA,GAAY,OAAQ,CAAA,MAAA,CAAO,CAAC,CAAA,GAAM,CAAC,YAAA,CAAa,QAAS,CAAA,CAAC,CAAC,CAAA;AAC9E"}},
    {"offset": {"line": 991, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/detections/utils/testVideoFormat.ts"],"sourcesContent":["/* eslint-disable no-restricted-globals */\nconst inWorker = 'WorkerGlobalScope' in globalThis\n    && globalThis instanceof (globalThis as any).WorkerGlobalScope;\n\n/**\n * @param mimeType\n * @internal\n */\nexport function testVideoFormat(mimeType: string): boolean\n{\n    if (inWorker)\n    {\n        return false;\n    }\n\n    const video = document.createElement('video');\n\n    return video.canPlayType(mimeType) !== '';\n}\n"],"names":[],"mappings":";;;;;AACA,MAAM,QAAW,GAAA,mBAAA,IAAuB,UACjC,IAAA,UAAA,YAAuB,UAAmB,CAAA,iBAAA,CAAA;AAM1C,SAAS,gBAAgB,QAChC,EAAA;IACI,IAAI,QACJ,EAAA;QACW,OAAA,KAAA,CAAA;IAAA,CACX;IAEM,MAAA,KAAA,GAAQ,QAAS,CAAA,aAAA,CAAc,OAAO,CAAA,CAAA;IAErC,OAAA,KAAA,CAAM,WAAY,CAAA,QAAQ,CAAM,KAAA,EAAA,CAAA;AAC3C"}},
    {"offset": {"line": 1010, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/detections/parsers/detectMp4.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the MP4 video format.\n * @category assets\n * @internal\n */\nexport const detectMp4 = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/mp4'),\n    add: async (formats) => [...formats, 'mp4', 'm4v'],\n    remove: async (formats) => formats.filter((f) => f !== 'mp4' && f !== 'm4v'),\n} as FormatDetectionParser;\n"],"names":[],"mappings":";;;;;;;;;AAUO,MAAM,SAAY,GAAA;IACrB,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,eAAA;QACpB,QAAU,EAAA,CAAA;IAAA,CACd;IACA,IAAA,EAAM,cAA8B,4MAAA,EAAgB,WAAW,CAAA;IAC/D,KAAK,OAAO,OAAA,GAAY,CAAC;eAAG,OAAA;YAAS;YAAO,KAAK;SAAA;IACjD,MAAA,EAAQ,OAAO,OAAA,GAAY,OAAQ,CAAA,MAAA,CAAO,CAAC,CAAM,GAAA,CAAA,KAAM,KAAS,IAAA,CAAA,KAAM,KAAK,CAAA;AAC/E"}},
    {"offset": {"line": 1038, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/detections/parsers/detectOgv.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the OGV video format.\n * @category assets\n * @internal\n */\nexport const detectOgv = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/ogg'),\n    add: async (formats) => [...formats, 'ogv'],\n    remove: async (formats) => formats.filter((f) => f !== 'ogv'),\n} as FormatDetectionParser;\n"],"names":[],"mappings":";;;;;;;;;AAUO,MAAM,SAAY,GAAA;IACrB,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,eAAA;QACpB,QAAU,EAAA,CAAA;IAAA,CACd;IACA,IAAA,EAAM,cAA8B,4MAAA,EAAgB,WAAW,CAAA;IAC/D,KAAK,OAAO,OAAA,GAAY,CAAC;eAAG;YAAS,KAAK;SAAA;IAC1C,MAAA,EAAQ,OAAO,OAAY,GAAA,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA,GAAM,MAAM,KAAK,CAAA;AAChE"}},
    {"offset": {"line": 1065, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/detections/parsers/detectWebm.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebM video format.\n * @category assets\n * @internal\n */\nexport const detectWebm = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/webm'),\n    add: async (formats) => [...formats, 'webm'],\n    remove: async (formats) => formats.filter((f) => f !== 'webm'),\n} as FormatDetectionParser;\n"],"names":[],"mappings":";;;;;;;;;AAUO,MAAM,UAAa,GAAA;IACtB,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,eAAA;QACpB,QAAU,EAAA,CAAA;IAAA,CACd;IACA,IAAA,EAAM,cAA8B,4MAAA,EAAgB,YAAY,CAAA;IAChE,KAAK,OAAO,OAAA,GAAY,CAAC;eAAG;YAAS,MAAM;SAAA;IAC3C,MAAA,EAAQ,OAAO,OAAY,GAAA,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA,GAAM,MAAM,MAAM,CAAA;AACjE"}},
    {"offset": {"line": 1092, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/detections/parsers/detectWebp.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebP image format.\n * @category assets\n * @internal\n */\nexport const detectWebp = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA='\n    ),\n    add: async (formats) => [...formats, 'webp'],\n    remove: async (formats) => formats.filter((f) => f !== 'webp'),\n} as FormatDetectionParser;\n"],"names":[],"mappings":";;;;;;;;;AAUO,MAAM,UAAa,GAAA;IACtB,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,eAAA;QACpB,QAAU,EAAA,CAAA;IAAA,CACd;IACA,MAAM,cAA8B,4MAAA,EAChC,6EAAA;IAEJ,KAAK,OAAO,OAAA,GAAY,CAAC;eAAG;YAAS,MAAM;SAAA;IAC3C,MAAA,EAAQ,OAAO,OAAY,GAAA,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA,GAAM,MAAM,MAAM,CAAA;AACjE"}},
    {"offset": {"line": 1119, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/loader/Loader.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/loader/Loader.ts"],"sourcesContent":["import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { type ProgressCallback } from '../Assets';\nimport { convertToList } from '../utils/convertToList';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type { ResolvedAsset } from '../types';\nimport type { LoaderParser } from './parsers/LoaderParser';\nimport type { PromiseAndParser } from './types';\n\n/**\n * Options for loading assets with the Loader\n * @example\n * ```ts\n * await Assets.load(['file1.png', 'file2.png'], {\n *   onProgress: (progress) => console.log(`Progress: ${progress * 100}%`),\n *   onError: (error, url) => console.error(`Error loading ${url}: ${error.message}`),\n *   strategy: 'retry', // 'throw' | 'skip' | 'retry'\n *   retryCount: 5, // Number of retry attempts if strategy is 'retry'\n *   retryDelay: 500, // Delay in ms between retries\n * });\n * ```\n * @category assets\n * @standard\n */\nexport interface LoadOptions\n{\n    /**\n     * Callback for progress updates during loading\n     * @param progress - A number between 0 and 1 indicating the load progress\n     * @example\n     * ```ts\n     * const options: LoadOptions = {\n     *   onProgress: (progress) => {\n     *     console.log(`Loading progress: ${progress * 100}%`);\n     *   },\n     * };\n     * await Assets.load('image.png', options);\n     * ```\n     */\n    onProgress?: (progress: number) => void;\n    /**\n     * Callback for handling errors during loading\n     * @param error - The error that occurred\n     * @param url - The URL of the asset that failed to load\n     * @example\n     * ```ts\n     * const options: LoadOptions = {\n     *   onError: (error, url) => {\n     *     console.error(`Failed to load ${url}: ${error.message}`);\n     *   },\n     * };\n     * await Assets.load('missing-file.png', options);\n     * ```\n     */\n    onError?: (error: Error, url: string | ResolvedAsset) => void;\n    /**\n     * Strategy to handle load failures\n     * - 'throw': Immediately throw an error and stop loading (default)\n     * - 'skip': Skip the failed asset and continue loading others\n     * - 'retry': Retry loading the asset a specified number of times\n     * @default 'throw'\n     * @example\n     * ```ts\n     * const options: LoadOptions = {\n     *   strategy: 'skip',\n     * };\n     * await Assets.load('sometimes-fails.png', options);\n     * ```\n     */\n    strategy?: 'throw' | 'skip' | 'retry';\n    /**\n     * Number of retry attempts if strategy is 'retry'\n     * @default 3\n     * @example\n     * ```ts\n     * const options: LoadOptions = {\n     *   strategy: 'retry',\n     *   retryCount: 5, // Retry up to 5 times\n     * };\n     * await Assets.load('unstable-asset.png', options);\n     * ```\n     */\n    retryCount?: number;\n    /**\n     * Delay in milliseconds between retry attempts\n     * @default 250\n     * @example\n     * ```ts\n     * const options: LoadOptions = {\n     *   strategy: 'retry',\n     *   retryDelay: 1000, // Wait 1 second between retries\n     * };\n     * await Assets.load('sometimes-fails.png', options);\n     * ```\n     */\n    retryDelay?: number;\n}\n\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @category assets\n * @advanced\n */\nexport class Loader\n{\n    /**\n     * Default options for loading assets\n     * @example\n     * ```ts\n     * // Change default load options globally\n     * Loader.defaultOptions = {\n     *   strategy: 'skip', // Change default strategy to 'skip'\n     *   retryCount: 5,   // Change default retry count to 5\n     *   retryDelay: 500, // Change default retry delay to 500ms\n     * };\n     * ```\n     */\n    public static defaultOptions: LoadOptions = {\n        onProgress: undefined,\n        onError: undefined,\n        strategy: 'throw',\n        retryCount: 3,\n        retryDelay: 250,\n    };\n    /**\n     * Options for loading assets with the loader.\n     * These options will be used as defaults for all load calls made with this loader instance.\n     * They can be overridden by passing options directly to the load method.\n     * @example\n     * ```ts\n     * // Create a loader with custom default options\n     * const loader = new Loader();\n     * loader.loadOptions = {\n     *   strategy: 'skip', // Default strategy to 'skip'\n     *   retryCount: 5,   // Default retry count to 5\n     *   retryDelay: 500, // Default retry delay to 500ms\n     * };\n     *\n     * // This load call will use the loader's default options\n     * await loader.load('image1.png');\n     */\n    public loadOptions: LoadOptions = { ...Loader.defaultOptions };\n    private readonly _parsers: LoaderParser[] = [];\n    private _parserHash: Record<string, LoaderParser>;\n\n    private _parsersValidated = false;\n\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    public parsers = new Proxy(this._parsers, {\n        set: (target, key, value) =>\n        {\n            this._parsersValidated = false;\n\n            target[key as any as number] = value;\n\n            return true;\n        }\n    });\n\n    /** Cache loading promises that ae currently active */\n    public promiseCache: Record<string, PromiseAndParser> = {};\n\n    /** function used for testing */\n    public reset(): void\n    {\n        this._parsersValidated = false;\n        this.promiseCache = {};\n    }\n\n    /**\n     * Used internally to generate a promise for the asset to be loaded.\n     * @param url - The URL to be loaded\n     * @param data - any custom additional information relevant to the asset being loaded\n     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n     */\n    private _getLoadPromiseAndParser(url: string, data?: ResolvedAsset): PromiseAndParser\n    {\n        const result: PromiseAndParser = {\n            promise: null,\n            parser: null\n        };\n\n        result.promise = (async () =>\n        {\n            let asset = null;\n\n            let parser: LoaderParser = null;\n\n            // first check to see if the user has specified a parser\n            if (data.parser || data.loadParser)\n            {\n                // they have? lovely, lets use it\n                parser = this._parserHash[data.parser || data.loadParser];\n\n                // #if _DEBUG\n                if (data.loadParser)\n                {\n                    warn(\n                        `[Assets] \"loadParser\" is deprecated, use \"parser\" instead for ${url}`\n                    );\n                }\n                // #endif\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    warn(\n                        `[Assets] specified load parser \"${data.parser || data.loadParser}\" not found while loading ${url}`\n                    );\n                    // #endif\n                }\n            }\n\n            // no parser specified, so lets try and find one using the tests\n            if (!parser)\n            {\n                for (let i = 0; i < this.parsers.length; i++)\n                {\n                    const parserX = this.parsers[i];\n\n                    if (parserX.load && parserX.test?.(url, data, this))\n                    {\n                        parser = parserX;\n                        break;\n                    }\n                }\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    // eslint-disable-next-line max-len\n                    warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n                    // #endif\n\n                    return null;\n                }\n            }\n\n            asset = await parser.load(url, data, this);\n            result.parser = parser;\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.parse)\n                {\n                    if (parser.parse && await parser.testParse?.(asset, data, this))\n                    {\n                        // transform the asset..\n                        asset = await parser.parse(asset, data, this) || asset;\n\n                        result.parser = parser;\n                    }\n                }\n            }\n\n            return asset;\n        })();\n\n        return result;\n    }\n\n    /**\n     * Loads one or more assets using the parsers added to the Loader.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     * console.log(asset);\n     *\n     * // Multiple assets:\n     * const assets = await Loader.load(['cool.png', 'cooler.png']);\n     * console.log(assets);\n     * @param assetsToLoadIn - urls that you want to load, or a single one!\n     * @param onProgress - For multiple asset loading only, an optional function that is called\n     * when progress on asset loading is made. The function is passed a single parameter, `progress`,\n     * which represents the percentage (0.0 - 1.0) of the assets loaded. Do not use this function\n     * to detect when assets are complete and available, instead use the Promise returned by this function.\n     */\n    public async load<T = any>(\n        assetsToLoadIn: string | ResolvedAsset,\n        onProgress?: ProgressCallback | LoadOptions,\n    ): Promise<T>;\n    public async load<T = any>(\n        assetsToLoadIn: string[] | ResolvedAsset[],\n        onProgress?: ProgressCallback | LoadOptions,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        assetsToLoadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n        onProgressOrOptions?: ProgressCallback | LoadOptions,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._parsersValidated)\n        {\n            this._validateParsers();\n        }\n\n        const options: LoadOptions = typeof onProgressOrOptions === 'function'\n            ? { ...Loader.defaultOptions, ...this.loadOptions, onProgress: onProgressOrOptions }\n            : { ...Loader.defaultOptions, ...this.loadOptions, ...(onProgressOrOptions || {}) };\n        const { onProgress, onError, strategy, retryCount, retryDelay } = options;\n\n        let count = 0;\n\n        const assets: Record<string, Promise<any>> = {};\n\n        const singleAsset = isSingleItem(assetsToLoadIn);\n\n        const assetsToLoad = convertToList<ResolvedAsset>(assetsToLoadIn, (item) => ({\n            alias: [item],\n            src: item,\n            data: {}\n        }));\n\n        const total = assetsToLoad.reduce((sum, asset) => sum + (asset.progressSize || 1), 0);\n\n        const promises: Promise<void>[] = assetsToLoad.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            if (assets[asset.src]) return;\n\n            await this._loadAssetWithRetry(url, asset, { onProgress, onError, strategy, retryCount, retryDelay }, assets);\n\n            count += (asset.progressSize || 1);\n            if (onProgress) onProgress(count / total);\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n\n    /**\n     * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n     * The parser that created the asset, will be the one that unloads it.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     *\n     * await Loader.unload('cool.png');\n     *\n     * console.log(asset.destroyed); // true\n     * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n     */\n    public async unload(\n        assetsToUnloadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n    ): Promise<void>\n    {\n        const assetsToUnload = convertToList<ResolvedAsset>(assetsToUnloadIn, (item) => ({\n            alias: [item],\n            src: item,\n        }));\n\n        const promises: Promise<void>[] = assetsToUnload.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            const loadPromise = this.promiseCache[url];\n\n            if (loadPromise)\n            {\n                const loadedAsset = await loadPromise.promise;\n\n                delete this.promiseCache[url];\n\n                await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n    private _validateParsers()\n    {\n        this._parsersValidated = true;\n\n        this._parserHash = this._parsers\n            .filter((parser) => parser.name || parser.id)\n            .reduce((hash, parser) =>\n            {\n                if (!parser.name && !parser.id)\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] parser should have an id`);\n                    // #endif\n                }\n                else if (hash[parser.name] || hash[parser.id])\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] parser id conflict \"${parser.id}\"`);\n                    // #endif\n                }\n\n                // add both name and id to the hash\n                hash[parser.name] = parser;\n                if (parser.id) hash[parser.id] = parser;\n\n                return hash;\n            }, {} as Record<string, LoaderParser>);\n    }\n\n    private async _loadAssetWithRetry(\n        url: string,\n        asset: ResolvedAsset,\n        options: LoadOptions,\n        assets: Record<string, Promise<any>>\n    )\n    {\n        let attempt = 0;\n        const { onError, strategy, retryCount, retryDelay } = options;\n        const wait = (ms: number) => new Promise((r) => setTimeout(r, ms));\n\n        while (true)\n        {\n            try\n            {\n                if (!this.promiseCache[url])\n                {\n                    this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                }\n\n                assets[asset.src] = await this.promiseCache[url].promise;\n\n                return;\n            }\n            catch (e)\n            {\n                // clear cache for a new attempt\n                delete this.promiseCache[url];\n                delete assets[asset.src];\n\n                attempt++;\n\n                const isLast = strategy !== 'retry' || attempt > retryCount;\n\n                if (strategy === 'retry' && !isLast)\n                {\n                    if (onError) onError(e as Error, asset);\n                    await wait(retryDelay);\n                    continue;\n                }\n\n                if (strategy === 'skip')\n                {\n                    if (onError) onError(e as Error, asset);\n\n                    return;\n                }\n\n                // strategy 'throw' or exhausted 'retry'\n                if (onError) onError(e as Error, asset);\n                const error = new Error(`[Loader.load] Failed to load ${url}.\\n${e}`);\n\n                if (e instanceof Error && e.stack)\n                {\n                    error.stack = e.stack;\n                }\n                throw error;\n            }\n        }\n    }\n}\n"],"names":["parser"],"mappings":"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"}},
    {"offset": {"line": 1365, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/utils/checkDataUrl.ts"],"sourcesContent":["/**\n * @param url\n * @param mimes\n * @internal\n */\nexport function checkDataUrl(url: string, mimes: string | string[]): boolean\n{\n    if (Array.isArray(mimes))\n    {\n        for (const mime of mimes)\n        {\n            if (url.startsWith(`data:${mime}`)) return true;\n        }\n\n        return false;\n    }\n\n    return url.startsWith(`data:${mimes}`);\n}\n"],"names":[],"mappings":";;;;;AAKgB,SAAA,YAAA,CAAa,GAAA,EAAa,KAC1C,EAAA;IACQ,IAAA,KAAA,CAAM,OAAQ,CAAA,KAAK,CACvB,EAAA;QACI,KAAA,MAAW,QAAQ,KACnB,CAAA;YACI,IAAI,GAAI,CAAA,UAAA,CAAW,CAAQ,KAAA,EAAA,IAAI,CAAE,CAAA,CAAA,EAAU,OAAA,IAAA,CAAA;QAAA,CAC/C;QAEO,OAAA,KAAA,CAAA;IAAA,CACX;IAEA,OAAO,GAAI,CAAA,UAAA,CAAW,CAAQ,KAAA,EAAA,KAAK,CAAE,CAAA,CAAA,CAAA;AACzC"}},
    {"offset": {"line": 1385, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/utils/checkExtension.ts"],"sourcesContent":["import { path } from '../../utils/path';\n\n/**\n * @param url\n * @param extension\n * @internal\n */\nexport function checkExtension(url: string, extension: string | string[]): boolean\n{\n    const tempURL = url.split('?')[0];\n    const ext = path.extname(tempURL).toLowerCase();\n\n    if (Array.isArray(extension))\n    {\n        return extension.includes(ext);\n    }\n\n    return ext === extension;\n}\n\n"],"names":[],"mappings":";;;;;;;AAOgB,SAAA,cAAA,CAAe,GAAA,EAAa,SAC5C,EAAA;IACI,MAAM,OAAU,GAAA,GAAA,CAAI,KAAM,CAAA,GAAG,CAAA,CAAE,CAAC,CAAA,CAAA;IAChC,MAAM,GAAM,GAAA,8JAAA,CAAK,OAAQ,CAAA,OAAO,EAAE,WAAY,EAAA,CAAA;IAE1C,IAAA,KAAA,CAAM,OAAQ,CAAA,SAAS,CAC3B,EAAA;QACW,OAAA,SAAA,CAAU,QAAA,CAAS,GAAG,CAAA,CAAA;IAAA,CACjC;IAEA,OAAO,GAAQ,KAAA,SAAA,CAAA;AACnB"}},
    {"offset": {"line": 1406, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/loader/parsers/loadJson.ts"],"sourcesContent":["import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validJSONExtension = '.json';\nconst validJSONMIME = 'application/json';\n\n/**\n * A simple loader plugin for loading json data\n * @category assets\n * @advanced\n */\nexport const loadJson = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    /** used for deprecation purposes */\n    name: 'loadJson',\n    id: 'json',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n    },\n\n    async load<T>(url: string): Promise<T>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const json = await response.json();\n\n        return json as T;\n    },\n} satisfies LoaderParser<string>;\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAQA,MAAM,kBAAqB,GAAA,OAAA,CAAA;AAC3B,MAAM,aAAgB,GAAA,kBAAA,CAAA;AAOf,MAAM,QAAW,GAAA;IACpB,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,UAAA;QACpB,UAAU,4MAAqB,CAAA,GAAA;IAAA,CACnC;IAAA,kCAAA,GAGA,IAAM,EAAA,UAAA;IACN,EAAI,EAAA,MAAA;IAEJ,MAAK,GACL,EAAA;QACI,WAAO,wLAAA,EAAa,GAAK,EAAA,aAAa,CAAK,QAAA,4LAAA,EAAe,KAAK,kBAAkB,CAAA,CAAA;IAAA,CACrF;IAEA,MAAM,MAAQ,GACd,EAAA;QACI,MAAM,WAAW,MAAM,6KAAA,CAAW,GAAI,EAAA,CAAE,KAAA,CAAM,GAAG,CAAA,CAAA;QAE3C,MAAA,IAAA,GAAO,MAAM,QAAA,CAAS,IAAK,EAAA,CAAA;QAE1B,OAAA,IAAA,CAAA;IAAA,CACX;AACJ"}},
    {"offset": {"line": 1445, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/loader/parsers/loadTxt.ts"],"sourcesContent":["import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validTXTExtension = '.txt';\nconst validTXTMIME = 'text/plain';\n\n/**\n * A simple loader plugin for loading text data\n * @category assets\n * @advanced\n */\nexport const loadTxt = {\n\n    /** used for deprecation purposes */\n    name: 'loadTxt',\n    id: 'text',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n        name: 'loadTxt',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n    },\n\n    async load(url: string): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const txt = await response.text();\n\n        return txt;\n    },\n} satisfies LoaderParser<string>;\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAQA,MAAM,iBAAoB,GAAA,MAAA,CAAA;AAC1B,MAAM,YAAe,GAAA,YAAA,CAAA;AAOd,MAAM,OAAU,GAAA;IAAA,kCAAA,GAGnB,IAAM,EAAA,SAAA;IACN,EAAI,EAAA,MAAA;IAEJ,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,UAAA;QACpB,UAAU,4MAAqB,CAAA,GAAA;QAC/B,IAAM,EAAA,SAAA;IAAA,CACV;IAEA,MAAK,GACL,EAAA;QACI,WAAO,wLAAA,EAAa,GAAK,EAAA,YAAY,CAAK,QAAA,4LAAA,EAAe,KAAK,iBAAiB,CAAA,CAAA;IAAA,CACnF;IAEA,MAAM,MAAK,GACX,EAAA;QACI,MAAM,WAAW,MAAM,6KAAA,CAAW,GAAI,EAAA,CAAE,KAAA,CAAM,GAAG,CAAA,CAAA;QAE3C,MAAA,GAAA,GAAM,MAAM,QAAA,CAAS,IAAK,EAAA,CAAA;QAEzB,OAAA,GAAA,CAAA;IAAA,CACX;AACJ"}},
    {"offset": {"line": 1485, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/loader/parsers/loadWebFont.ts"],"sourcesContent":["import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { path } from '../../../utils/path';\nimport { Cache } from '../../cache/Cache';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { ResolvedAsset } from '../../types';\nimport type { LoaderParser } from './LoaderParser';\n\nconst validWeights = [\n    'normal', 'bold',\n    '100', '200', '300', '400', '500', '600', '700', '800', '900',\n];\nconst validFontExtensions = ['.ttf', '.otf', '.woff', '.woff2'];\nconst validFontMIMEs = [\n    'font/ttf',\n    'font/otf',\n    'font/woff',\n    'font/woff2',\n];\n\n/**\n * Cache for font faces\n * @internal\n */\nexport interface FontFaceCache\n{\n    entries: {url: string, faces: FontFace[]}[]\n}\n\n/**\n * Data for loading a font\n * @category assets\n * @advanced\n */\nexport type LoadFontData = {\n    /** Font family name */\n    family: string;\n    /** A set of optional descriptors passed as an object. It can contain any of the descriptors available for @font-face: */\n    display: string;\n    /**\n     * The featureSettings property of the FontFace interface retrieves or sets infrequently used\n     * font features that are not available from a font's variant properties.\n     */\n    featureSettings: string;\n    /** The stretch property of the FontFace interface retrieves or sets how the font stretches. */\n    stretch: string;\n    /** The style property of the FontFace interface retrieves or sets the font's style. */\n    style: string;\n    /**\n     * The unicodeRange property of the FontFace interface retrieves or sets the range of\n     * unicode code points encompassing the font.\n     */\n    unicodeRange: string;\n    /** The variant property of the FontFace interface programmatically retrieves or sets font variant values. */\n    variant: string;\n    /** The weight property of the FontFace interface retrieves or sets the weight of the font. */\n    weights: string[];\n};\n\n/**\n * RegExp for matching CSS <ident-token>. It doesn't consider escape and non-ASCII characters, but enough for us.\n * @see {@link https://www.w3.org/TR/css-syntax-3/#ident-token-diagram}\n */\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\n\n/**\n * Return font face name from a file name\n * Ex.: 'fonts/titan-one.woff' turns into 'Titan One'\n * @param url - File url\n * @category assets\n * @internal\n */\nexport function getFontFamilyName(url: string): string\n{\n    const ext = path.extname(url);\n    const name = path.basename(url, ext);\n\n    // Replace dashes by white spaces\n    const nameWithSpaces = name.replace(/(-|_)/g, ' ');\n\n    // Upper case first character of each word\n    const nameTokens = nameWithSpaces.toLowerCase()\n        .split(' ')\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n\n    let valid = nameTokens.length > 0;\n\n    for (const token of nameTokens)\n    {\n        if (!token.match(CSS_IDENT_TOKEN_REGEX))\n        {\n            valid = false;\n            break;\n        }\n    }\n\n    let fontFamilyName = nameTokens.join(' ');\n\n    if (!valid)\n    {\n        fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, '\\\\$&')}\"`;\n    }\n\n    return fontFamilyName;\n}\n\n// See RFC 3986 Chapter 2. Characters\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&'()\\*\\+,;=\\-._~]*$/;\n\n/**\n * Encode URI only when it contains invalid characters.\n * @param uri - URI to encode.\n */\nfunction encodeURIWhenNeeded(uri: string)\n{\n    if (validURICharactersRegex.test(uri))\n    {\n        return uri;\n    }\n\n    return encodeURI(uri);\n}\n\n/**\n * A loader plugin for handling web fonts\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *   alias: 'font',\n *   src: 'fonts/titan-one.woff',\n *   data: {\n *     family: 'Titan One',\n *     weights: ['normal', 'bold'],\n *   }\n * })\n * @category assets\n * @advanced\n */\nexport const loadWebFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    /** used for deprecation purposes */\n    name: 'loadWebFont',\n    id: 'web-font',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n    },\n\n    async load(url: string, options?: ResolvedAsset<LoadFontData>): Promise<FontFace | FontFace[]>\n    {\n        const fonts = DOMAdapter.get().getFontFaceSet();\n\n        if (fonts)\n        {\n            const fontFaces: FontFace[] = [];\n            const name = options.data?.family ?? getFontFamilyName(url);\n            const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ['normal'];\n            const data = options.data ?? {};\n\n            for (let i = 0; i < weights.length; i++)\n            {\n                const weight = weights[i];\n\n                const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n                    ...data,\n                    weight,\n                });\n\n                await font.load();\n\n                fonts.add(font);\n\n                fontFaces.push(font);\n            }\n\n            if (Cache.has(`${name}-and-url`))\n            {\n                const cached = Cache.get<FontFaceCache>(`${name}-and-url`);\n\n                // If the URL is already cached, we just add the new font faces to the existing cache\n                cached.entries.push({ url, faces: fontFaces });\n            }\n            else\n            {\n                Cache.set<FontFaceCache>(`${name}-and-url`, {\n                    entries: [{ url, faces: fontFaces }],\n                });\n            }\n\n            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n        }\n\n        // #if _DEBUG\n        warn('[loadWebFont] FontFace API is not supported. Skipping loading font');\n        // #endif\n\n        return null;\n    },\n\n    unload(font: FontFace | FontFace[]): void\n    {\n        const fonts = Array.isArray(font) ? font : [font];\n\n        // you can only load 1 family at a time, so we can use the first one\n        const fontFamily = fonts[0].family;\n        const cached = Cache.get<FontFaceCache>(`${fontFamily}-and-url`);\n\n        // find the entry that contains the font faces we want to remove\n        const entry = cached.entries.find((f) => f.faces.some((t) => fonts.indexOf(t) !== -1));\n\n        // remove the font faces from the cache\n        entry.faces = entry.faces.filter((f) => fonts.indexOf(f) === -1);\n\n        // if faces are empty, remove the entry\n        if (entry.faces.length === 0)\n        {\n            cached.entries = cached.entries.filter((f) => f !== entry);\n        }\n\n        // finally remove the font faces from the FontFaceSet\n        fonts.forEach((t) =>\n        {\n            DOMAdapter.get().getFontFaceSet().delete(t);\n        });\n\n        // Clean up cache if no entries remain\n        if (cached.entries.length === 0)\n        {\n            Cache.remove(`${fontFamily}-and-url`);\n        }\n    }\n} satisfies LoaderParser<FontFace | FontFace[]>;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1634, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/loader/parsers/textures/utils/createTexture.ts"],"sourcesContent":["import { Texture } from '../../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../../utils/logging/warn';\nimport { Cache } from '../../../../cache/Cache';\n\nimport type { TextureSource } from '../../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Loader } from '../../../Loader';\n\n/**\n * Creates a texture from a source and adds it to the cache.\n * @param source - source of the texture\n * @param loader - loader\n * @param url - url of the texture\n * @ignore\n */\nexport function createTexture(source: TextureSource, loader: Loader, url: string)\n{\n    source.label = url;\n    source._sourceOrigin = url;\n\n    const texture = new Texture({\n        source,\n        label: url,\n    });\n\n    const unload = () =>\n    {\n        delete loader.promiseCache[url];\n\n        if (Cache.has(url))\n        {\n            Cache.remove(url);\n        }\n    };\n\n    // remove the promise from the loader and the url from the cache when the texture is destroyed\n    texture.source.once('destroy', () =>\n    {\n        if (loader.promiseCache[url])\n        {\n            // #if _DEBUG\n            warn('[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! '\n           + 'Use Assets.unload() instead of destroying the TextureSource.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    texture.once('destroy', () =>\n    {\n        if (!source.destroyed)\n        {\n            // #if _DEBUG\n            warn('[Assets] A Texture managed by Assets was destroyed instead of unloaded! '\n             + 'Use Assets.unload() instead of destroying the Texture.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    return texture;\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAcgB,SAAA,aAAA,CAAc,MAAuB,EAAA,MAAA,EAAgB,GACrE,EAAA;IACI,MAAA,CAAO,KAAQ,GAAA,GAAA,CAAA;IACf,MAAA,CAAO,aAAgB,GAAA,GAAA,CAAA;IAEjB,MAAA,OAAA,GAAU,IAAI,0MAAQ,CAAA;QACxB,MAAA;QACA,KAAO,EAAA,GAAA;IAAA,CACV,CAAA,CAAA;IAED,MAAM,SAAS,MACf;QACW,OAAA,MAAA,CAAO,YAAA,CAAa,GAAG,CAAA,CAAA;QAE1B,IAAA,0KAAA,CAAM,GAAI,CAAA,GAAG,CACjB,EAAA;YACI,0KAAA,CAAM,MAAA,CAAO,GAAG,CAAA,CAAA;QAAA,CACpB;IAAA,CACJ,CAAA;IAGQ,OAAA,CAAA,MAAA,CAAO,IAAK,CAAA,SAAA,EAAW,MAC/B;QACQ,IAAA,MAAA,CAAO,YAAa,CAAA,GAAG,CAC3B,EAAA;gBAEI,yKAAA,EAAK,4IAC0D,CAAA,CAAA;YAGxD,MAAA,EAAA,CAAA;QAAA,CACX;IAAA,CACH,CAAA,CAAA;IAEO,OAAA,CAAA,IAAA,CAAK,WAAW,MACxB;QACQ,IAAA,CAAC,OAAO,SACZ,EAAA;gBAEI,yKAAA,EAAK,gIACsD,CAAA,CAAA;YAGpD,MAAA,EAAA,CAAA;QAAA,CACX;IAAA,CACH,CAAA,CAAA;IAEM,OAAA,OAAA,CAAA;AACX"}},
    {"offset": {"line": 1678, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/loader/parsers/textures/loadSVG.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { GraphicsContext } from '../../../../scene/graphics/shared/GraphicsContext';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { type LoaderParser, LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\n\n/**\n * Configuration for the {@link loadSvg} plugin.\n * @see loadSvg\n * @category assets\n * @advanced\n */\nexport interface LoadSVGConfig\n{\n    /**\n     * The crossOrigin value to use for loading the SVG as an image.\n     * @default 'anonymous'\n     */\n    crossOrigin: ImageLike['crossOrigin'];\n    /**\n     * When set to `true`, loading and decoding images will happen with `new Image()`,\n     * @default false\n     */\n    parseAsGraphicsContext: boolean;\n}\n\n/**\n * Regular expression for SVG XML document.\n * @example &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!-- image/svg --&gt;&lt;svg\n * @readonly\n */\nconst validSVGExtension = '.svg';\nconst validSVGMIME = 'image/svg+xml';\n\n/**\n * A simple loader plugin for loading json data\n * @category assets\n * @advanced\n */\nexport const loadSvg: LoaderParser<Texture | GraphicsContext, TextureSourceOptions & LoadSVGConfig, LoadSVGConfig> = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n        name: 'loadSVG',\n    },\n\n    /** used for deprecation purposes */\n    name: 'loadSVG',\n    id: 'svg',\n\n    config: {\n        crossOrigin: 'anonymous',\n        parseAsGraphicsContext: false,\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n    },\n\n    async load(\n        url: string,\n        asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n        loader: Loader\n    ): Promise<Texture | GraphicsContext>\n    {\n        if (asset.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext)\n        {\n            return loadAsGraphics(url);\n        }\n\n        return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n    },\n\n    unload(asset: Texture | GraphicsContext): void\n    {\n        asset.destroy(true);\n    }\n\n};\n\nasync function loadAsTexture(\n    url: string,\n    asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n    loader: Loader,\n    crossOrigin: ImageLike['crossOrigin']\n): Promise<Texture>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const image = DOMAdapter.get().createImage();\n\n    image.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(await response.text())}`;\n    image.crossOrigin = crossOrigin;\n    await image.decode();\n\n    // convert to canvas...\n    const width = asset.data?.width ?? image.width;\n    const height = asset.data?.height ?? image.height;\n    const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n\n    // Ensure canvas dimensions are integers to prevent edge trimming\n    const canvasWidth = Math.ceil(width * resolution);\n    const canvasHeight = Math.ceil(height * resolution);\n\n    const canvas = DOMAdapter.get().createCanvas(canvasWidth, canvasHeight);\n    const context = canvas.getContext('2d');\n\n    // Improve rendering quality for decimal resolutions\n    context.imageSmoothingEnabled = true;\n    context.imageSmoothingQuality = 'high';\n\n    // Draw image with exact scaled dimensions to prevent trimming\n    context.drawImage(image as CanvasImageSource, 0, 0, width * resolution, height * resolution);\n\n    const { parseAsGraphicsContext: _p, ...rest } = asset.data ?? {};\n    const base = new ImageSource({\n        resource: canvas,\n        alphaMode: 'premultiply-alpha-on-upload',\n        resolution,\n        ...rest,\n    });\n\n    return createTexture(base, loader, url);\n}\n\nasync function loadAsGraphics(url: string): Promise<GraphicsContext>\n{\n    const response = await DOMAdapter.get().fetch(url);\n    const svgSource = await response.text();\n\n    const context = new GraphicsContext();\n\n    context.svg(svgSource);\n\n    return context;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAyCA,MAAM,iBAAoB,GAAA,MAAA,CAAA;AAC1B,MAAM,YAAe,GAAA,eAAA,CAAA;AAOd,MAAM,OAAwG,GAAA;IACjH,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,UAAA;QACpB,UAAU,4MAAqB,CAAA,GAAA;QAC/B,IAAM,EAAA,SAAA;IAAA,CACV;IAAA,kCAAA,GAGA,IAAM,EAAA,SAAA;IACN,EAAI,EAAA,KAAA;IAEJ,MAAQ,EAAA;QACJ,WAAa,EAAA,WAAA;QACb,sBAAwB,EAAA,KAAA;IAAA,CAC5B;IAEA,MAAK,GACL,EAAA;QACI,WAAO,wLAAA,EAAa,GAAK,EAAA,YAAY,CAAK,QAAA,4LAAA,EAAe,KAAK,iBAAiB,CAAA,CAAA;IAAA,CACnF;IAEA,MAAM,IAAA,EACF,GACA,EAAA,KAAA,EACA,MAEJ,EAAA;QACI,IAAI,KAAM,CAAA,IAAA,EAAM,sBAA0B,IAAA,IAAA,CAAK,MAAA,CAAO,sBACtD,EAAA;YACI,OAAO,eAAe,GAAG,CAAA,CAAA;QAAA,CAC7B;QAEA,OAAO,cAAc,GAAK,EAAA,KAAA,EAAO,MAAQ,EAAA,IAAA,CAAK,MAAA,CAAO,WAAW,CAAA,CAAA;IAAA,CACpE;IAEA,QAAO,KACP,EAAA;QACI,KAAA,CAAM,OAAA,CAAQ,IAAI,CAAA,CAAA;IAAA,CACtB;AAEJ,EAAA;AAEA,eAAe,aACX,CAAA,GAAA,EACA,KACA,EAAA,MAAA,EACA,WAEJ,EAAA;IACI,MAAM,WAAW,MAAM,6KAAA,CAAW,GAAI,EAAA,CAAE,KAAA,CAAM,GAAG,CAAA,CAAA;IAEjD,MAAM,KAAQ,GAAA,6KAAA,CAAW,GAAI,EAAA,CAAE,WAAY,EAAA,CAAA;IAE3C,KAAA,CAAM,GAAA,GAAM,CAAoC,iCAAA,EAAA,kBAAA,CAAmB,MAAM,QAAS,CAAA,IAAA,EAAM,CAAC,CAAA,CAAA,CAAA;IACzF,KAAA,CAAM,WAAc,GAAA,WAAA,CAAA;IACpB,MAAM,MAAM,MAAO,EAAA,CAAA;IAGnB,MAAM,KAAQ,GAAA,KAAA,CAAM,IAAM,EAAA,KAAA,IAAS,KAAM,CAAA,KAAA,CAAA;IACzC,MAAM,MAAS,GAAA,KAAA,CAAM,IAAM,EAAA,MAAA,IAAU,KAAM,CAAA,MAAA,CAAA;IAC3C,MAAM,UAAa,GAAA,KAAA,CAAM,IAAM,EAAA,UAAA,QAAc,qMAAA,EAAmB,GAAG,CAAA,CAAA;IAGnE,MAAM,WAAc,GAAA,IAAA,CAAK,IAAK,CAAA,KAAA,GAAQ,UAAU,CAAA,CAAA;IAChD,MAAM,YAAe,GAAA,IAAA,CAAK,IAAK,CAAA,MAAA,GAAS,UAAU,CAAA,CAAA;IAElD,MAAM,SAAS,6KAAW,CAAA,GAAA,EAAM,CAAA,YAAA,CAAa,aAAa,YAAY,CAAA,CAAA;IAChE,MAAA,OAAA,GAAU,MAAO,CAAA,UAAA,CAAW,IAAI,CAAA,CAAA;IAGtC,OAAA,CAAQ,qBAAwB,GAAA,IAAA,CAAA;IAChC,OAAA,CAAQ,qBAAwB,GAAA,MAAA,CAAA;IAGhC,OAAA,CAAQ,SAAA,CAAU,KAA4B,EAAA,CAAA,EAAG,GAAG,KAAQ,GAAA,UAAA,EAAY,SAAS,UAAU,CAAA,CAAA;IAErF,MAAA,EAAE,wBAAwB,EAAI,EAAA,GAAG,MAAS,GAAA,KAAA,CAAM,IAAA,IAAQ,CAAA,CAAC,CAAA;IACzD,MAAA,IAAA,GAAO,IAAI,6NAAY,CAAA;QACzB,QAAU,EAAA,MAAA;QACV,SAAW,EAAA,6BAAA;QACX,UAAA;QACA,GAAG,IAAA;IAAA,CACN,CAAA,CAAA;IAEM,WAAA,2NAAA,EAAc,IAAM,EAAA,MAAA,EAAQ,GAAG,CAAA,CAAA;AAC1C,CAAA;AAEA,eAAe,eAAe,GAC9B,EAAA;IACI,MAAM,WAAW,MAAM,6KAAA,CAAW,GAAI,EAAA,CAAE,KAAA,CAAM,GAAG,CAAA,CAAA;IAC3C,MAAA,SAAA,GAAY,MAAM,QAAA,CAAS,IAAK,EAAA,CAAA;IAEhC,MAAA,OAAA,GAAU,IAAI,0MAAgB,EAAA,CAAA;IAEpC,OAAA,CAAQ,GAAA,CAAI,SAAS,CAAA,CAAA;IAEd,OAAA,OAAA,CAAA;AACX"}},
    {"offset": {"line": 1766, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/loader/workers/WorkerManager.ts"],"sourcesContent":["import CheckImageBitmapWorker from 'worker:./checkImageBitmap.worker.ts';\nimport LoadImageBitmapWorker from 'worker:./loadImageBitmap.worker.ts';\n\nimport type { TextureSourceOptions } from '../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { ResolvedAsset } from '../../types';\n\nlet UUID = 0;\nlet MAX_WORKERS: number;\n\ntype LoadImageBitmapResult = {\n    data?: ImageBitmap,\n    error?: Error,\n    uuid: number,\n    id: string,\n};\n\n/** @internal */\nclass WorkerManagerClass\n{\n    /**\n     * Hash map storing resolve/reject functions for pending worker requests.\n     * Keyed by UUID to match responses with their corresponding promises.\n     */\n    private _resolveHash: {\n        [key: string]: {\n            resolve: (...param: any[]) => void;\n            reject: (...param: any[]) => void;\n        }\n    };\n    /** Pool of available workers ready for use */\n    private readonly _workerPool: Worker[];\n    /** Queue of pending work items waiting for available workers */\n    private readonly _queue: {\n        id: string;\n        arguments: any[];\n        resolve: (...param: any[]) => void;\n        reject: (...param: any[]) => void;\n    }[];\n\n    /** Whether the worker manager has been initialized */\n    private _initialized = false;\n\n    /** Current number of created workers (used to enforce MAX_WORKERS limit) */\n    private _createdWorkers = 0;\n    /** Cached promise for ImageBitmap support check */\n    private _isImageBitmapSupported?: Promise<boolean>;\n\n    constructor()\n    {\n        this._workerPool = [];\n        this._queue = [];\n\n        this._resolveHash = {};\n    }\n\n    /**\n     * Checks if ImageBitmap is supported in the current environment.\n     *\n     * This method uses a dedicated worker to test ImageBitmap support\n     * and caches the result for subsequent calls.\n     * @returns Promise that resolves to true if ImageBitmap is supported, false otherwise\n     */\n    public isImageBitmapSupported(): Promise<boolean>\n    {\n        if (this._isImageBitmapSupported !== undefined) return this._isImageBitmapSupported;\n\n        this._isImageBitmapSupported = new Promise((resolve) =>\n        {\n            const { worker } = new CheckImageBitmapWorker();\n\n            worker.addEventListener('message', (event: MessageEvent<boolean>) =>\n            {\n                worker.terminate();\n                CheckImageBitmapWorker.revokeObjectURL();\n                resolve(event.data);\n            });\n        });\n\n        return this._isImageBitmapSupported;\n    }\n\n    /**\n     * Loads an image as an ImageBitmap using a web worker.\n     * @param src - The source URL or path of the image to load\n     * @param asset - Optional resolved asset containing additional texture source options\n     * @returns Promise that resolves to the loaded ImageBitmap\n     * @example\n     * ```typescript\n     * const bitmap = await WorkerManager.loadImageBitmap('image.png');\n     * const bitmapWithOptions = await WorkerManager.loadImageBitmap('image.png', asset);\n     * ```\n     */\n    public loadImageBitmap(src: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>\n    {\n        return this._run('loadImageBitmap', [src, asset?.data?.alphaMode]) as Promise<ImageBitmap>;\n    }\n\n    /**\n     * Initializes the worker pool if not already initialized.\n     * Currently a no-op but reserved for future initialization logic.\n     */\n    private async _initWorkers()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n    }\n\n    /**\n     * Gets an available worker from the pool or creates a new one if needed.\n     *\n     * Workers are created up to the MAX_WORKERS limit (based on navigator.hardwareConcurrency).\n     * Each worker is configured with a message handler for processing results.\n     * @returns Available worker or undefined if pool is at capacity and no workers are free\n     */\n    private _getWorker(): Worker\n    {\n        if (MAX_WORKERS === undefined)\n        {\n            MAX_WORKERS = navigator.hardwareConcurrency || 4;\n        }\n        let worker = this._workerPool.pop();\n\n        if (!worker && this._createdWorkers < MAX_WORKERS)\n        {\n            // only create as many as MAX_WORKERS allows..\n            this._createdWorkers++;\n            worker = new LoadImageBitmapWorker().worker;\n\n            worker.addEventListener('message', (event: MessageEvent) =>\n            {\n                this._complete(event.data);\n\n                this._returnWorker(event.target as Worker);\n                this._next();\n            });\n        }\n\n        return worker;\n    }\n\n    /**\n     * Returns a worker to the pool after completing a task.\n     * @param worker - The worker to return to the pool\n     */\n    private _returnWorker(worker: Worker)\n    {\n        this._workerPool.push(worker);\n    }\n\n    /**\n     * Handles completion of a worker task by resolving or rejecting the corresponding promise.\n     * @param data - Result data from the worker containing uuid, data, and optional error\n     */\n    private _complete(data: LoadImageBitmapResult): void\n    {\n        if (!this._resolveHash[data.uuid])\n        {\n            // this can happen if the worker manager is reset before a task completes\n            return;\n        }\n\n        if (data.error !== undefined)\n        {\n            this._resolveHash[data.uuid].reject(data.error);\n        }\n        else\n        {\n            this._resolveHash[data.uuid].resolve(data.data);\n        }\n\n        delete this._resolveHash[data.uuid];\n    }\n\n    /**\n     * Executes a task using the worker pool system.\n     *\n     * Queues the task and processes it when a worker becomes available.\n     * @param id - Identifier for the type of task to run\n     * @param args - Arguments to pass to the worker\n     * @returns Promise that resolves with the worker's result\n     */\n    private async _run(id: string, args: any[]): Promise<any>\n    {\n        await this._initWorkers();\n        // push into the queue...\n\n        const promise = new Promise((resolve, reject) =>\n        {\n            this._queue.push({ id, arguments: args, resolve, reject });\n        });\n\n        this._next();\n\n        return promise;\n    }\n\n    /**\n     * Processes the next item in the queue if workers are available.\n     *\n     * This method is called after worker initialization and when workers\n     * complete tasks to continue processing the queue.\n     */\n    private _next(): void\n    {\n        // nothing to do\n        if (!this._queue.length) return;\n\n        const worker = this._getWorker();\n\n        // no workers available...\n        if (!worker)\n        {\n            return;\n        }\n\n        const toDo = this._queue.pop();\n\n        const id = toDo.id;\n\n        this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n\n        worker.postMessage({\n            data: toDo.arguments,\n            uuid: UUID++,\n            id,\n        });\n    }\n\n    /**\n     * Resets the worker manager, terminating all workers and clearing the queue.\n     *\n     * This method:\n     * - Terminates all active workers\n     * - Rejects all pending promises with an error\n     * - Clears all internal state\n     * - Resets initialization flags\n     *\n     * This should be called when the worker manager is no longer needed\n     * to prevent memory leaks and ensure proper cleanup.\n     * @example\n     * ```typescript\n     * // Clean up when shutting down\n     * WorkerManager.reset();\n     * ```\n     */\n    public reset(): void\n    {\n        // Terminate all workers\n        this._workerPool.forEach((worker) => worker.terminate());\n        this._workerPool.length = 0;\n\n        // Reject pending promises\n        Object.values(this._resolveHash).forEach(({ reject }) =>\n        {\n            reject?.(new Error('WorkerManager has been reset before completion'));\n        });\n        this._resolveHash = {};\n        this._queue.length = 0;\n\n        this._initialized = false;\n        this._createdWorkers = 0;\n    }\n}\n\n/**\n * Manages a pool of web workers for loading ImageBitmap objects asynchronously.\n *\n * This class provides a thread-safe way to load images using web workers,\n * automatically managing worker creation, pooling, and cleanup. It supports\n * checking ImageBitmap support and queuing multiple load requests.\n *\n * > [!IMPORTANT] You should not need to use this class directly\n * > However, you can call `WorkerManager.reset()` to clean up all workers when they are no longer needed.\n * @category Assets\n * @advanced\n */\nconst WorkerManager = new WorkerManagerClass();\n\nexport {\n    WorkerManager,\n};\n"],"names":["CheckImageBitmapWorker","LoadImageBitmapWorker"],"mappings":"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"}},
    {"offset": {"line": 1946, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/loader/parsers/textures/loadTextures.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { WorkerManager } from '../../workers/WorkerManager';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImageExtensions = ['.jpeg', '.jpg', '.png', '.webp', '.avif'];\nconst validImageMIMEs = [\n    'image/jpeg',\n    'image/png',\n    'image/webp',\n    'image/avif',\n];\n\n/**\n * Configuration for the [loadTextures]{@link loadTextures} plugin.\n * @see loadTextures\n * @category assets\n * @advanced\n */\nexport interface LoadTextureConfig\n{\n    /**\n     * When set to `true`, loading and decoding images will happen with Worker thread,\n     * if available on the browser. This is much more performant as network requests\n     * and decoding can be expensive on the CPU. However, not all environments support\n     * Workers, in some cases it can be helpful to disable by setting to `false`.\n     * @default true\n     */\n    preferWorkers: boolean;\n    /**\n     * When set to `true`, loading and decoding images will happen with `createImageBitmap`,\n     * otherwise it will use `new Image()`.\n     * @default true\n     */\n    preferCreateImageBitmap: boolean;\n    /**\n     * The crossOrigin value to use for images when `preferCreateImageBitmap` is `false`.\n     * @default 'anonymous'\n     */\n    crossOrigin: ImageLike['crossOrigin'];\n}\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n * @ignore\n */\nexport async function loadImageBitmap(url: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n\n    return asset?.data?.alphaMode === 'premultiplied-alpha'\n        ? createImageBitmap(imageBlob, { premultiplyAlpha: 'none' })\n        : createImageBitmap(imageBlob);\n}\n\n/**\n * A simple plugin to load our textures!\n * This makes use of imageBitmaps where available.\n * We load the `ImageBitmap` on a different thread using workers if possible.\n * We can then use the `ImageBitmap` as a source for a Pixi texture\n *\n * You can customize the behavior of this loader by setting the `config` property.\n * Which can be found [here]{@link LoadTextureConfig}\n * ```js\n * // Set the config\n * import { loadTextures } from 'pixi.js';\n *\n * loadTextures.config = {\n *    // If true we will use a worker to load the ImageBitmap\n *    preferWorkers: true,\n *    // If false we will use new Image() instead of createImageBitmap,\n *    // we'll also disable the use of workers as it requires createImageBitmap\n *    preferCreateImageBitmap: true,\n *    crossOrigin: 'anonymous',\n * };\n * ```\n * @category assets\n * @advanced\n */\nexport const loadTextures: LoaderParser<Texture, TextureSourceOptions, LoadTextureConfig> = {\n\n    /** used for deprecation purposes */\n    name: 'loadTextures',\n    id: 'texture',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n        name: 'loadTextures',\n    },\n\n    config: {\n        preferWorkers: true,\n        preferCreateImageBitmap: true,\n        crossOrigin: 'anonymous',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n    },\n\n    async load(url: string, asset: ResolvedAsset<TextureSourceOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url, asset);\n            }\n            else\n            {\n                src = await loadImageBitmap(url, asset);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve, reject) =>\n            {\n                src = DOMAdapter.get().createImage();\n                src.crossOrigin = this.config.crossOrigin;\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                    src.onerror = reject;\n                }\n            });\n        }\n\n        const base = new ImageSource({\n            resource: src,\n            alphaMode: 'premultiply-alpha-on-upload',\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAiBA,MAAM,uBAAuB;IAAC,OAAA;IAAS,MAAQ;IAAA,MAAA;IAAQ;IAAS,OAAO;CAAA,CAAA;AACvE,MAAM,eAAkB,GAAA;IACpB,YAAA;IACA,WAAA;IACA,YAAA;IACA,YAAA;CACJ,CAAA;AAsCsB,eAAA,eAAA,CAAgB,GAAA,EAAa,KACnD,EAAA;IACI,MAAM,WAAW,MAAM,6KAAA,CAAW,GAAI,EAAA,CAAE,KAAA,CAAM,GAAG,CAAA,CAAA;IAE7C,IAAA,CAAC,SAAS,EACd,EAAA;QACU,MAAA,IAAI,KAAM,CAAA,CAAA,kCAAA,EAAqC,GAAG,CAAA,EAAA,EAC/C,SAAS,MAAM,CAAA,CAAA,EAAI,QAAS,CAAA,UAAU,CAAE,CAAA,CAAA,CAAA;IAAA,CACrD;IAEM,MAAA,SAAA,GAAY,MAAM,QAAA,CAAS,IAAK,EAAA,CAAA;IAEtC,OAAO,KAAO,EAAA,IAAA,EAAM,SAAc,KAAA,qBAAA,GAC5B,iBAAkB,CAAA,SAAA,EAAW;QAAE,gBAAA,EAAkB,MAAO;IAAA,CAAC,CACzD,GAAA,iBAAA,CAAkB,SAAS,CAAA,CAAA;AACrC,CAAA;AA0BO,MAAM,YAA+E,GAAA;IAAA,kCAAA,GAGxF,IAAM,EAAA,cAAA;IACN,EAAI,EAAA,SAAA;IAEJ,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,UAAA;QACpB,UAAU,4MAAqB,CAAA,IAAA;QAC/B,IAAM,EAAA,cAAA;IAAA,CACV;IAEA,MAAQ,EAAA;QACJ,aAAe,EAAA,IAAA;QACf,uBAAyB,EAAA,IAAA;QACzB,WAAa,EAAA,WAAA;IAAA,CACjB;IAEA,MAAK,GACL,EAAA;QACI,WAAO,wLAAA,EAAa,GAAK,EAAA,eAAe,CAAK,QAAA,4LAAA,EAAe,KAAK,oBAAoB,CAAA,CAAA;IAAA,CACzF;IAEA,MAAM,IAAA,EAAK,GAAa,EAAA,KAAA,EAA4C,MACpE,EAAA;QACI,IAAI,GAAW,GAAA,IAAA,CAAA;QAEf,IAAI,UAAW,CAAA,iBAAA,IAAqB,IAAK,CAAA,MAAA,CAAO,uBAChD,EAAA;YACI,IAAI,IAAA,CAAK,MAAO,CAAA,aAAA,IAAiB,MAAM,sMAAA,CAAc,sBAAA,EACrD,EAAA;gBACI,GAAA,GAAM,MAAM,sMAAA,CAAc,eAAgB,CAAA,GAAA,EAAK,KAAK,CAAA,CAAA;YAAA,CAGxD,MAAA;gBACU,GAAA,GAAA,MAAM,eAAgB,CAAA,GAAA,EAAK,KAAK,CAAA,CAAA;YAAA,CAC1C;QAAA,CAGJ,MAAA;YACI,GAAA,GAAM,MAAM,IAAI,OAAQ,CAAA,CAAC,SAAS,MAClC,KAAA;gBACU,GAAA,GAAA,6KAAA,CAAW,GAAI,EAAA,CAAE,WAAY,EAAA,CAAA;gBAC/B,GAAA,CAAA,WAAA,GAAc,IAAA,CAAK,MAAO,CAAA,WAAA,CAAA;gBAE9B,GAAA,CAAI,GAAM,GAAA,GAAA,CAAA;gBACV,IAAI,IAAI,QACR,EAAA;oBACI,OAAA,CAAQ,GAAG,CAAA,CAAA;gBAAA,CAGf,MAAA;oBACI,GAAA,CAAI,MAAA,GAAS,MACb;wBACI,OAAA,CAAQ,GAAG,CAAA,CAAA;oBAAA,CACf,CAAA;oBACA,GAAA,CAAI,OAAU,GAAA,MAAA,CAAA;gBAAA,CAClB;YAAA,CACH,CAAA,CAAA;QAAA,CACL;QAEM,MAAA,IAAA,GAAO,IAAI,6NAAY,CAAA;YACzB,QAAU,EAAA,GAAA;YACV,SAAW,EAAA,6BAAA;YACX,UAAY,EAAA,KAAA,CAAM,IAAM,EAAA,UAAA,QAAc,qMAAA,EAAmB,GAAG,CAAA;YAC5D,GAAG,KAAM,CAAA,IAAA;QAAA,CACZ,CAAA,CAAA;QAEM,WAAA,2NAAA,EAAc,IAAM,EAAA,MAAA,EAAQ,GAAG,CAAA,CAAA;IAAA,CAC1C;IAEA,QAAO,OACP,EAAA;QACI,OAAA,CAAQ,OAAA,CAAQ,IAAI,CAAA,CAAA;IAAA,CACxB;AACJ"}},
    {"offset": {"line": 2051, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/loader/parsers/textures/loadVideoTextures.ts"],"sourcesContent":["/* eslint-disable no-restricted-globals */\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { testVideoFormat } from '../../../detections/utils/testVideoFormat';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { createTexture } from './utils/createTexture';\n\nimport type { VideoSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst potentialVideoExtensions = ['.mp4', '.m4v', '.webm', '.ogg', '.ogv', '.h264', '.avi', '.mov'];\nlet validVideoExtensions: string[];\nlet validVideoMIMEs: string[];\n\n/**\n * Set cross origin based detecting the url and the crossorigin\n * @param element - Element to apply crossOrigin\n * @param url - URL to check\n * @param crossorigin - Cross origin value to use\n * @category assets\n * @advanced\n */\nexport function crossOrigin(element: ImageLike | HTMLVideoElement, url: string, crossorigin?: boolean | string): void\n{\n    if (crossorigin === undefined && !url.startsWith('data:'))\n    {\n        element.crossOrigin = determineCrossOrigin(url);\n    }\n    else if (crossorigin !== false)\n    {\n        element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n    }\n}\n\n/**\n * Preload a video element\n * @param element - Video element to preload\n * @internal\n */\nexport function preloadVideo(element: HTMLVideoElement): Promise<void>\n{\n    return new Promise((resolve, reject) =>\n    {\n        element.addEventListener('canplaythrough', loaded);\n        element.addEventListener('error', error);\n\n        element.load();\n\n        function loaded(): void\n        {\n            cleanup();\n            resolve();\n        }\n\n        function error(err: ErrorEvent): void\n        {\n            cleanup();\n            reject(err);\n        }\n\n        function cleanup(): void\n        {\n            element.removeEventListener('canplaythrough', loaded);\n            element.removeEventListener('error', error);\n        }\n    });\n}\n\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n * Nipped from the resource loader!\n * @ignore\n * @param url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @returns The crossOrigin value to use (or empty string for none).\n * @category assets\n */\nexport function determineCrossOrigin(url: string, loc: Location = globalThis.location): string\n{\n    // data: and javascript: urls are considered same-origin\n    if (url.startsWith('data:'))\n    {\n        return '';\n    }\n\n    // default is window.location\n    loc ||= globalThis.location;\n\n    const parsedUrl = new URL(url, document.baseURI);\n\n    // if cross origin\n    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol)\n    {\n        return 'anonymous';\n    }\n\n    return '';\n}\n\ntype LoadVideoData = VideoSourceOptions & {\n    mime?: string;\n};\n\n/**\n * Get the supported video extensions and MIME types based on the browser's capabilities.\n * This function checks the potential video extensions against the browser's supported formats.\n * @returns An object containing valid video extensions and MIME types.\n * @internal\n */\nfunction getBrowserSupportedVideoExtensions()\n{\n    const supportedExtensions: string[] = [];\n    const supportedMimes: string[] = [];\n\n    for (const ext of potentialVideoExtensions)\n    {\n        const mimeType = VideoSource.MIME_TYPES[ext.substring(1)] || `video/${ext.substring(1)}`;\n\n        if (testVideoFormat(mimeType))\n        {\n            supportedExtensions.push(ext);\n            if (!supportedMimes.includes(mimeType))\n            {\n                supportedMimes.push(mimeType);\n            }\n        }\n    }\n\n    return {\n        validVideoExtensions: supportedExtensions,\n        validVideoMime: supportedMimes\n    };\n}\n\n/**\n * A simple plugin to load video textures.\n *\n * You can pass VideoSource options to the loader via the .data property of the asset descriptor\n * when using Assets.load().\n * ```js\n * // Set the data\n * const texture = await Assets.load({\n *     src: './assets/city.mp4',\n *     data: {\n *         preload: true,\n *         autoPlay: true,\n *     },\n * });\n * ```\n * @category assets\n * @advanced\n */\nexport const loadVideoTextures = {\n\n    /** used for deprecation purposes */\n    name: 'loadVideo',\n    id: 'video',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        name: 'loadVideo',\n    },\n\n    test(url: string): boolean\n    {\n        if (!validVideoExtensions || !validVideoMIMEs)\n        {\n            const { validVideoExtensions: ve, validVideoMime: vm } = getBrowserSupportedVideoExtensions();\n\n            validVideoExtensions = ve;\n            validVideoMIMEs = vm;\n        }\n        const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n        const isValidExtension = checkExtension(url, validVideoExtensions);\n\n        return isValidDataUrl || isValidExtension;\n    },\n\n    async load(url: string, asset: ResolvedAsset<LoadVideoData>, loader: Loader): Promise<Texture>\n    {\n        // --- Merge default and provided options ---\n        const options: LoadVideoData = {\n            ...VideoSource.defaultOptions,\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),\n            ...asset.data,\n        };\n\n        // --- Create and configure HTMLVideoElement ---\n        const videoElement = document.createElement('video');\n\n        // Set attributes based on options\n        const attributeMap = {\n            preload: options.autoLoad !== false ? 'auto' : undefined,\n            'webkit-playsinline': options.playsinline !== false ? '' : undefined,\n            playsinline: options.playsinline !== false ? '' : undefined,\n            muted: options.muted === true ? '' : undefined,\n            loop: options.loop === true ? '' : undefined,\n            autoplay: options.autoPlay !== false ? '' : undefined\n        };\n\n        Object.keys(attributeMap).forEach((key) =>\n        {\n            const value = attributeMap[key as keyof typeof attributeMap];\n\n            if (value !== undefined) videoElement.setAttribute(key, value);\n        });\n\n        if (options.muted === true)\n        {\n            videoElement.muted = true;\n        }\n\n        crossOrigin(videoElement, url, options.crossorigin); // Assume crossOrigin is globally available\n\n        // --- Set up source and MIME type ---\n        const sourceElement = document.createElement('source');\n\n        // Determine MIME type\n        let mime: string | undefined;\n\n        if (options.mime)\n        {\n            mime = options.mime;\n        }\n        else if (url.startsWith('data:'))\n        {\n            mime = url.slice(5, url.indexOf(';'));\n        }\n        else if (!url.startsWith('blob:'))\n        {\n            const ext = url.split('?')[0].slice(url.lastIndexOf('.') + 1).toLowerCase();\n\n            mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n        }\n\n        sourceElement.src = url;\n\n        if (mime)\n        {\n            sourceElement.type = mime;\n        }\n\n        // this promise will make sure that video is ready to play - as in we have a valid width, height and it can be\n        // uploaded to the GPU. Our textures are kind of dumb now, and don't want to handle resizing right now.\n        return new Promise((resolve) =>\n        {\n            const onCanPlay = async () =>\n            {\n                const base = new VideoSource({ ...options, resource: videoElement });\n\n                videoElement.removeEventListener('canplay', onCanPlay);\n\n                if (asset.data.preload)\n                {\n                    await preloadVideo(videoElement);\n                }\n\n                resolve(createTexture(base, loader, url));\n            };\n\n            if (options.preload && !options.autoPlay)\n            {\n                videoElement.load();\n            }\n\n            videoElement.addEventListener('canplay', onCanPlay);\n            videoElement.appendChild(sourceElement);\n        });\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} satisfies LoaderParser<Texture, LoadVideoData>;\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA,MAAM,wBAAA,GAA2B;IAAC,MAAQ;IAAA,MAAA;IAAQ;IAAS,MAAQ;IAAA,MAAA;IAAQ,OAAS;IAAA,MAAA;IAAQ,MAAM;CAAA,CAAA;AAClG,IAAI,oBAAA,CAAA;AACJ,IAAI,eAAA,CAAA;AAUY,SAAA,WAAA,CAAY,OAAuC,EAAA,GAAA,EAAa,WAChF,EAAA;IACI,IAAI,gBAAgB,KAAa,CAAA,IAAA,CAAC,GAAI,CAAA,UAAA,CAAW,OAAO,CACxD,EAAA;QACY,OAAA,CAAA,WAAA,GAAc,qBAAqB,GAAG,CAAA,CAAA;IAAA,CAClD,MAAA,IACS,gBAAgB,KACzB,EAAA;QACI,OAAA,CAAQ,WAAc,GAAA,OAAO,WAAgB,KAAA,QAAA,GAAW,WAAc,GAAA,WAAA,CAAA;IAAA,CAC1E;AACJ,CAAA;AAOO,SAAS,aAAa,OAC7B,EAAA;IACI,OAAO,IAAI,OAAA,CAAQ,CAAC,OAAA,EAAS,MAC7B,KAAA;QACY,OAAA,CAAA,gBAAA,CAAiB,kBAAkB,MAAM,CAAA,CAAA;QACzC,OAAA,CAAA,gBAAA,CAAiB,SAAS,KAAK,CAAA,CAAA;QAEvC,OAAA,CAAQ,IAAK,EAAA,CAAA;QAEb,SAAS,MACT,GAAA;YACY,OAAA,EAAA,CAAA;YACA,OAAA,EAAA,CAAA;QAAA,CACZ;QAEA,SAAS,MAAM,GACf,EAAA;YACY,OAAA,EAAA,CAAA;YACR,MAAA,CAAO,GAAG,CAAA,CAAA;QAAA,CACd;QAEA,SAAS,OACT,GAAA;YACY,OAAA,CAAA,mBAAA,CAAoB,kBAAkB,MAAM,CAAA,CAAA;YAC5C,OAAA,CAAA,mBAAA,CAAoB,SAAS,KAAK,CAAA,CAAA;QAAA,CAC9C;IAAA,CACH,CAAA,CAAA;AACL,CAAA;AAaO,SAAS,oBAAqB,CAAA,GAAA,EAAa,GAAgB,GAAA,UAAA,CAAW,QAC7E,EAAA;IAEQ,IAAA,GAAA,CAAI,UAAW,CAAA,OAAO,CAC1B,EAAA;QACW,OAAA,EAAA,CAAA;IAAA,CACX;IAGA,GAAA,IAAA,CAAA,GAAA,GAAQ,UAAW,CAAA,QAAA,CAAA,CAAA;IAEnB,MAAM,SAAY,GAAA,IAAI,GAAI,CAAA,GAAA,EAAK,SAAS,OAAO,CAAA,CAAA;IAG3C,IAAA,SAAA,CAAU,QAAa,KAAA,GAAA,CAAI,QAAY,IAAA,SAAA,CAAU,IAAS,KAAA,GAAA,CAAI,IAAQ,IAAA,SAAA,CAAU,QAAa,KAAA,GAAA,CAAI,QACrG,EAAA;QACW,OAAA,WAAA,CAAA;IAAA,CACX;IAEO,OAAA,EAAA,CAAA;AACX,CAAA;AAYA,SAAS,kCACT,GAAA;IACI,MAAM,sBAAgC,EAAC,CAAA;IACvC,MAAM,iBAA2B,EAAC,CAAA;IAElC,KAAA,MAAW,OAAO,wBAClB,CAAA;QACI,MAAM,QAAW,GAAA,6NAAA,CAAY,UAAW,CAAA,GAAA,CAAI,SAAU,CAAA,CAAC,CAAC,CAAA,IAAK,CAAS,MAAA,EAAA,GAAA,CAAI,SAAU,CAAA,CAAC,CAAC,CAAA,CAAA,CAAA;QAElF,QAAA,4MAAA,EAAgB,QAAQ,CAC5B,EAAA;YACI,mBAAA,CAAoB,IAAA,CAAK,GAAG,CAAA,CAAA;YAC5B,IAAI,CAAC,cAAA,CAAe,QAAS,CAAA,QAAQ,CACrC,EAAA;gBACI,cAAA,CAAe,IAAA,CAAK,QAAQ,CAAA,CAAA;YAAA,CAChC;QAAA,CACJ;IAAA,CACJ;IAEO,OAAA;QACH,oBAAsB,EAAA,mBAAA;QACtB,cAAgB,EAAA,cAAA;IAAA,CACpB,CAAA;AACJ,CAAA;AAoBO,MAAM,iBAAoB,GAAA;IAAA,kCAAA,GAG7B,IAAM,EAAA,WAAA;IACN,EAAI,EAAA,OAAA;IAEJ,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,UAAA;QACpB,IAAM,EAAA,WAAA;IAAA,CACV;IAEA,MAAK,GACL,EAAA;QACQ,IAAA,CAAC,oBAAwB,IAAA,CAAC,eAC9B,EAAA;YACI,MAAM,EAAE,oBAAsB,EAAA,EAAA,EAAI,cAAgB,EAAA,EAAA,EAAA,GAAO,kCAAmC,EAAA,CAAA;YAErE,oBAAA,GAAA,EAAA,CAAA;YACL,eAAA,GAAA,EAAA,CAAA;QAAA,CACtB;QACM,MAAA,cAAA,OAAiB,wLAAa,EAAA,GAAA,EAAK,eAAe,CAAA,CAAA;QAClD,MAAA,gBAAA,OAAmB,4LAAe,EAAA,GAAA,EAAK,oBAAoB,CAAA,CAAA;QAEjE,OAAO,cAAkB,IAAA,gBAAA,CAAA;IAAA,CAC7B;IAEA,MAAM,IAAA,EAAK,GAAa,EAAA,KAAA,EAAqC,MAC7D,EAAA;QAEI,MAAM,OAAyB,GAAA;YAC3B,GAAG,6NAAY,CAAA,cAAA;YACf,UAAY,EAAA,KAAA,CAAM,IAAM,EAAA,UAAA,QAAc,qMAAA,EAAmB,GAAG,CAAA;YAC5D,SAAW,EAAA,KAAA,CAAM,IAAM,EAAA,SAAA,IAAa,UAAM,yMAAqB,EAAA;YAC/D,GAAG,KAAM,CAAA,IAAA;QAAA,CACb,CAAA;QAGM,MAAA,YAAA,GAAe,QAAS,CAAA,aAAA,CAAc,OAAO,CAAA,CAAA;QAGnD,MAAM,YAAe,GAAA;YACjB,OAAS,EAAA,OAAA,CAAQ,QAAa,KAAA,KAAA,GAAQ,MAAS,GAAA,KAAA,CAAA;YAC/C,oBAAsB,EAAA,OAAA,CAAQ,WAAgB,KAAA,KAAA,GAAQ,EAAK,GAAA,KAAA,CAAA;YAC3D,WAAa,EAAA,OAAA,CAAQ,WAAgB,KAAA,KAAA,GAAQ,EAAK,GAAA,KAAA,CAAA;YAClD,KAAO,EAAA,OAAA,CAAQ,KAAU,KAAA,IAAA,GAAO,EAAK,GAAA,KAAA,CAAA;YACrC,IAAM,EAAA,OAAA,CAAQ,IAAS,KAAA,IAAA,GAAO,EAAK,GAAA,KAAA,CAAA;YACnC,QAAU,EAAA,OAAA,CAAQ,QAAa,KAAA,KAAA,GAAQ,EAAK,GAAA,KAAA,CAAA;QAAA,CAChD,CAAA;QAEA,MAAA,CAAO,IAAK,CAAA,YAAY,CAAE,CAAA,OAAA,CAAQ,CAAC,GACnC,KAAA;YACU,MAAA,KAAA,GAAQ,YAAA,CAAa,GAAgC,CAAA,CAAA;YAE3D,IAAI,KAAU,KAAA,KAAA,CAAA,EAAwB,YAAA,CAAA,YAAA,CAAa,KAAK,KAAK,CAAA,CAAA;QAAA,CAChE,CAAA,CAAA;QAEG,IAAA,OAAA,CAAQ,KAAA,KAAU,IACtB,EAAA;YACI,YAAA,CAAa,KAAQ,GAAA,IAAA,CAAA;QAAA,CACzB;QAEY,WAAA,CAAA,YAAA,EAAc,GAAK,EAAA,OAAA,CAAQ,WAAW,CAAA,CAAA;QAG5C,MAAA,aAAA,GAAgB,QAAS,CAAA,aAAA,CAAc,QAAQ,CAAA,CAAA;QAGjD,IAAA,IAAA,CAAA;QAEJ,IAAI,QAAQ,IACZ,EAAA;YACI,IAAA,GAAO,OAAQ,CAAA,IAAA,CAAA;QAAA,CAEV,MAAA,IAAA,GAAA,CAAI,UAAW,CAAA,OAAO,CAC/B,EAAA;YACI,IAAA,GAAO,IAAI,KAAM,CAAA,CAAA,EAAG,GAAI,CAAA,OAAA,CAAQ,GAAG,CAAC,CAAA,CAAA;QAAA,CAE/B,MAAA,IAAA,CAAC,GAAI,CAAA,UAAA,CAAW,OAAO,CAChC,EAAA;YACI,MAAM,GAAM,GAAA,GAAA,CAAI,KAAM,CAAA,GAAG,CAAA,CAAE,CAAC,CAAA,CAAE,KAAM,CAAA,GAAA,CAAI,WAAY,CAAA,GAAG,CAAI,GAAA,CAAC,EAAE,WAAY,EAAA,CAAA;YAE1E,IAAA,GAAO,6NAAY,CAAA,UAAA,CAAW,GAAG,CAAA,IAAK,CAAA,MAAA,EAAS,GAAG,CAAA,CAAA,CAAA;QAAA,CACtD;QAEA,aAAA,CAAc,GAAM,GAAA,GAAA,CAAA;QAEpB,IAAI,IACJ,EAAA;YACI,aAAA,CAAc,IAAO,GAAA,IAAA,CAAA;QAAA,CACzB;QAIO,OAAA,IAAI,OAAQ,CAAA,CAAC,OACpB,KAAA;YACI,MAAM,YAAY,YAClB;gBACU,MAAA,IAAA,GAAO,IAAI,6NAAY,CAAA;oBAAE,GAAG,OAAS;oBAAA,QAAA,EAAU;gBAAA,CAAc,CAAA,CAAA;gBAEtD,YAAA,CAAA,mBAAA,CAAoB,WAAW,SAAS,CAAA,CAAA;gBAEjD,IAAA,KAAA,CAAM,IAAA,CAAK,OACf,EAAA;oBACI,MAAM,aAAa,YAAY,CAAA,CAAA;gBAAA,CACnC;gBAEA,OAAA,KAAQ,2NAAc,EAAA,IAAA,EAAM,MAAQ,EAAA,GAAG,CAAC,CAAA,CAAA;YAAA,CAC5C,CAAA;YAEA,IAAI,OAAQ,CAAA,OAAA,IAAW,CAAC,OAAA,CAAQ,QAChC,EAAA;gBACI,YAAA,CAAa,IAAK,EAAA,CAAA;YAAA,CACtB;YAEa,YAAA,CAAA,gBAAA,CAAiB,WAAW,SAAS,CAAA,CAAA;YAClD,YAAA,CAAa,WAAA,CAAY,aAAa,CAAA,CAAA;QAAA,CACzC,CAAA,CAAA;IAAA,CACL;IAEA,QAAO,OACP,EAAA;QACI,OAAA,CAAQ,OAAA,CAAQ,IAAI,CAAA,CAAA;IAAA,CACxB;AACJ"}},
    {"offset": {"line": 2228, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/resolver/parsers/resolveTextureUrl.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { loadTextures } from '../../loader/parsers/textures/loadTextures';\nimport { Resolver } from '../Resolver';\n\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a texture url\n * @category assets\n * @internal\n */\nexport const resolveTextureUrl = {\n    extension: {\n        type: ExtensionType.ResolveParser,\n        name: 'resolveTexture',\n    },\n    test: loadTextures.test,\n    parse: (value: string) =>\n        ({\n            resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n            format: value.split('.').pop(),\n            src: value,\n        }),\n} satisfies ResolveURLParser;\n"],"names":[],"mappings":";;;;;;;;;;;AAWO,MAAM,iBAAoB,GAAA;IAC7B,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,aAAA;QACpB,IAAM,EAAA,gBAAA;IAAA,CACV;IACA,MAAM,gNAAa,CAAA,IAAA;IACnB,KAAA,EAAO,CAAC,KACH,GAAA,CAAA;YACG,UAAA,EAAY,WAAW,mLAAS,CAAA,aAAA,CAAc,IAAA,CAAK,KAAK,CAAA,EAAA,CAAI,CAAC,CAAA,IAAK,GAAG,CAAA;YACrE,MAAQ,EAAA,KAAA,CAAM,KAAM,CAAA,GAAG,EAAE,GAAI,EAAA;YAC7B,GAAK,EAAA,KAAA;QAAA,CACT,CAAA;AACR"}},
    {"offset": {"line": 2257, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/resolver/parsers/resolveJsonUrl.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Resolver } from '../Resolver';\nimport { resolveTextureUrl } from './resolveTextureUrl';\n\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a json urls resolution for spritesheets\n * e.g. `assets/spritesheet@1x.json`\n * @category assets\n * @internal\n */\nexport const resolveJsonUrl = {\n    extension: {\n        type: ExtensionType.ResolveParser,\n        priority: -2,\n        name: 'resolveJson',\n    },\n    test: (value: string): boolean =>\n        Resolver.RETINA_PREFIX.test(value) && value.endsWith('.json'),\n    parse: resolveTextureUrl.parse,\n} satisfies ResolveURLParser;\n"],"names":[],"mappings":";;;;;;;;;;;AAYO,MAAM,cAAiB,GAAA;IAC1B,SAAW,EAAA;QACP,MAAM,kLAAc,CAAA,aAAA;QACpB,QAAU,EAAA,CAAA,CAAA;QACV,IAAM,EAAA,aAAA;IAAA,CACV;IACA,IAAA,EAAM,CAAC,KAAA,GACH,mLAAS,CAAA,aAAA,CAAc,IAAA,CAAK,KAAK,CAAA,IAAK,KAAM,CAAA,QAAA,CAAS,OAAO,CAAA;IAChE,OAAO,gNAAkB,CAAA,KAAA;AAC7B"}},
    {"offset": {"line": 2283, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/assets/Assets.mjs","sources":["file:///C:/Users/temir/Desktop/osmosis/node_modules/pixi.js/src/assets/Assets.ts"],"sourcesContent":["/* eslint-disable max-len */\nimport { extensions, ExtensionType } from '../extensions/Extensions';\nimport { bitmapFontCachePlugin, loadBitmapFont } from '../scene/text-bitmap/asset/loadBitmapFont';\nimport { warn } from '../utils/logging/warn';\nimport { BackgroundLoader } from './BackgroundLoader';\nimport { Cache } from './cache/Cache';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray';\nimport { detectAvif } from './detections/parsers/detectAvif';\nimport { detectDefaults } from './detections/parsers/detectDefaults';\nimport { detectMp4 } from './detections/parsers/detectMp4';\nimport { detectOgv } from './detections/parsers/detectOgv';\nimport { detectWebm } from './detections/parsers/detectWebm';\nimport { detectWebp } from './detections/parsers/detectWebp';\nimport { Loader, type LoadOptions } from './loader/Loader';\nimport { loadJson } from './loader/parsers/loadJson';\nimport { loadTxt } from './loader/parsers/loadTxt';\nimport { loadWebFont } from './loader/parsers/loadWebFont';\nimport { loadSvg } from './loader/parsers/textures/loadSVG';\nimport { type LoadTextureConfig, loadTextures } from './loader/parsers/textures/loadTextures';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl';\nimport { Resolver } from './resolver/Resolver';\nimport { convertToList } from './utils/convertToList';\nimport { isSingleItem } from './utils/isSingleItem';\n\nimport type { AssetExtension } from './AssetExtension';\nimport type { FormatDetectionParser } from './detections/types';\nimport type { LoadSVGConfig } from './loader/parsers/textures/loadSVG';\nimport type { BundleIdentifierOptions } from './resolver/Resolver';\nimport type { ArrayOr, AssetsBundle, AssetsManifest, ResolvedAsset, UnresolvedAsset } from './types';\n\n/**\n * Callback function for tracking asset loading progress. The function is called repeatedly\n * during the loading process with a progress value between 0.0 and 1.0.\n * @param progress - The loading progress from 0.0 (started) to 1.0 (complete)\n * @returns void\n * @example\n * ```ts\n * // Basic progress logging\n * const onProgress = (progress: number) => {\n *     console.log(`Loading: ${Math.round(progress * 100)}%`);\n * };\n *\n * // Update loading bar\n * const onProgress = (progress: number) => {\n *     loadingBar.width = progress * 100;\n *     loadingText.text = `${Math.round(progress * 100)}%`;\n * };\n *\n * // Load assets with progress tracking\n * await Assets.load(['sprite1.png', 'sprite2.png'], onProgress);\n *\n * // Load bundle with progress tracking\n * await Assets.loadBundle('levelAssets', (progress) => {\n *     // Progress is normalized (0.0 - 1.0)\n *     updateLoadingScreen(progress);\n * });\n * ```\n * > [!IMPORTANT] Do not rely on the progress callback to determine when all assets are loaded.\n * > Use the returned promise from `Assets.load()` or `Assets.loadBundle()` to know when loading is complete.\n * @category assets\n * @standard\n */\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * Extensible preferences that can be used, for instance, when configuring loaders.\n * @since 7.2.0\n * @advanced\n * @category assets\n */\nexport interface AssetsPreferences extends LoadTextureConfig, LoadSVGConfig, PixiMixins.AssetsPreferences {}\n\n/**\n * Options for initializing the Assets class. These options configure how assets are loaded,\n * resolved, and managed in your PixiJS application.\n * @category assets\n * @standard\n */\nexport interface AssetInitOptions\n{\n    /**\n     * Base path prepended to all asset URLs. Useful for CDN hosting.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     basePath: 'https://my-cdn.com/assets/'\n     * });\n     *\n     * // Now you can load assets like this:\n     * // Will load from: https://my-cdn.com/assets/images/sprite.png\n     * const texture = await Assets.load('images/sprite.png');\n     * ```\n     */\n    basePath?: string;\n\n    /**\n     * URL parameters to append to all asset URLs.\n     * Useful for cache-busting or version control.\n     * @example\n     * ```ts\n     * // As a string\n     * await Assets.init({\n     *     defaultSearchParams: 'version=1.0.0'\n     * });\n     *\n     * // As an object\n     * await Assets.init({\n     *     defaultSearchParams: {\n     *         version: '1.0.0',\n     *         t: Date.now()\n     *     }\n     * });\n     * ```\n     * @advanced\n     */\n    defaultSearchParams?: string | Record<string, any>;\n\n    /**\n     * A manifest defining all your application's assets.\n     * Can be a URL to a JSON file or a manifest object.\n     * @example\n     * ```ts\n     * // Using a manifest object\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [{\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'hero',\n     *                     src: 'hero.{png,webp}'\n     *                 },\n     *                 {\n     *                     alias: 'map',\n     *                     src: 'map.json'\n     *                 }\n     *             ]\n     *         }]\n     *     }\n     * });\n     *\n     * // Using a URL to manifest\n     * await Assets.init({\n     *     manifest: 'assets/manifest.json'\n     * });\n     *\n     * // loading a bundle from the manifest\n     * await Assets.loadBundle('game-screen');\n     *\n     * // load individual assets from the manifest\n     * const heroTexture = await Assets.load('hero');\n     * ```\n     */\n    manifest?: string | AssetsManifest;\n    /**\n     * Configure texture loading preferences.\n     * Useful for optimizing asset delivery based on device capabilities.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     texturePreference: {\n     *         // Prefer high-res textures on retina displays\n     *         resolution: window.devicePixelRatio,\n     *\n     *         // Prefer modern formats, fallback to traditional\n     *         format: ['avif', 'webp', 'png']\n     *     }\n     * });\n     * ```\n     */\n    texturePreference?: {\n        /** Preferred texture resolution(s). Can be a single number or array of resolutions in order of preference. */\n        resolution?: number | number[];\n\n        /** Preferred texture formats in order of preference. Default: ['avif', 'webp', 'png', 'jpg', 'jpeg'] */\n        format?: ArrayOr<string>;\n    };\n\n    /**\n     * Skip browser format detection for faster initialization.\n     * Only use if you know exactly what formats your target browsers support.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     skipDetections: true,\n     *     texturePreference: {\n     *         format: ['webp', 'png'] // Must explicitly set formats\n     *     }\n     * });\n     * ```\n     * @advanced\n     */\n    skipDetections?: boolean;\n\n    /**\n     * Override how bundle IDs are generated and resolved.\n     *\n     * This allows you to customize how assets are grouped and accessed via bundles and allow for\n     * multiple bundles to share the same asset keys.\n     * @advanced\n     * @example\n     * ```ts\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'bunny1',\n     *             assets: [\n     *                 {\n     *                     alias: ['character', 'character2'],\n     *                     src: 'textures/bunny.png',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'bunny2',\n     *             assets: [\n     *                 {\n     *                     alias: ['character', 'character2'],\n     *                     src: 'textures/bunny-2.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * const bundleIdentifier: BundleIdentifierOptions = {\n     *     connector: ':',\n     * };\n     *\n     * await Assets.init({ manifest, basePath, bundleIdentifier });\n     *\n     * const resources = await Assets.loadBundle('bunny1');\n     * const resources2 = await Assets.loadBundle('bunny2');\n     *\n     * console.log(resources.character === resources2.character); // false\n     * ```\n     */\n    bundleIdentifier?: BundleIdentifierOptions;\n\n    /**\n     * Optional preferences for asset loading behavior.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     preferences: {\n     *         crossOrigin: 'anonymous',\n     *         parseAsGraphicsContext: false\n     *     }\n     * });\n     * ```\n     */\n    preferences?: Partial<AssetsPreferences>;\n\n    /**\n     * Options for defining the loading behavior of assets.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *    loadOptions: {\n     *       onProgress: (progress) => console.log(`Loading: ${Math.round(progress * 100)}%`),\n     *       onError: (error, asset) => console.error(`Error loading ${asset.src}: ${error.message}`),\n     *       strategy: 'retry',\n     *       retryCount: 5,\n     *       retryDelay: 500,\n     *   }\n     * });\n     * ```\n     * @remarks\n     * - `onProgress` callback receives values from 0.0 to 1.0\n     * - `onError` callback is invoked for individual asset load failures\n     * - `strategy` can be 'throw' (default), 'retry', or 'skip'\n     * - `retryCount` sets how many times to retry failed assets (default 3)\n     * - `retryDelay` sets the delay between retries in milliseconds (default 250ms)\n     * @see {@link LoadOptions} For all available load options\n     */\n    loadOptions?: Partial<LoadOptions>;\n}\n\n/** @internal */\nexport class AssetsClass\n{\n    /**\n     * The URL resolver for assets. Maps various asset keys and URLs to their final loadable form.\n     * @advanced\n     */\n    public resolver: Resolver;\n    /**\n     *  The loader responsible for loading all assets. Handles different file types\n     * and transformations.\n     * @advanced\n     */\n    public loader: Loader;\n    /**\n     * The global cache for all loaded assets. Manages storage and retrieval of\n     * processed assets.\n     * @example\n     * ```ts\n     * // Check if an asset is cached\n     * if (Assets.cache.has('myTexture')) {\n     *     const texture = Assets.cache.get('myTexture');\n     * }\n     * ```\n     * @see {@link Cache} For detailed cache documentation\n     */\n    public cache: typeof Cache;\n\n    /** takes care of loading assets in the background */\n    private readonly _backgroundLoader: BackgroundLoader;\n\n    private readonly _detections: FormatDetectionParser[] = [];\n\n    private _initialized = false;\n\n    constructor()\n    {\n        this.resolver = new Resolver();\n        this.loader = new Loader();\n        this.cache = Cache;\n\n        this._backgroundLoader = new BackgroundLoader(this.loader);\n        this._backgroundLoader.active = true;\n\n        this.reset();\n    }\n\n    /**\n     * Initializes the Assets class with configuration options. While not required,\n     * calling this before loading assets is recommended to set up default behaviors.\n     * @param options - Configuration options for the Assets system\n     * @example\n     * ```ts\n     * // Basic initialization (optional as Assets.load will call this automatically)\n     * await Assets.init();\n     *\n     * // With CDN configuration\n     * await Assets.init({\n     *     basePath: 'https://my-cdn.com/assets/',\n     *     defaultSearchParams: { version: '1.0.0' }\n     * });\n     *\n     * // With manifest and preferences\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [{\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'hero',\n     *                     src: 'hero.{png,webp}',\n     *                     data: { scaleMode: SCALE_MODES.NEAREST }\n     *                 },\n     *                 {\n     *                     alias: 'map',\n     *                     src: 'map.json'\n     *                 }\n     *             ]\n     *         }]\n     *     },\n     *     // Optimize for device capabilities\n     *     texturePreference: {\n     *         resolution: window.devicePixelRatio,\n     *         format: ['webp', 'png']\n     *     },\n     *     // Set global preferences\n     *     preferences: {\n     *         crossOrigin: 'anonymous',\n     *     }\n     * });\n     *\n     * // Load assets after initialization\n     * const heroTexture = await Assets.load('hero');\n     * ```\n     * @remarks\n     * - Can be called only once; subsequent calls will be ignored with a warning\n     * - Format detection runs automatically unless `skipDetections` is true\n     * - The manifest can be a URL to a JSON file or an inline object\n     * @see {@link AssetInitOptions} For all available initialization options\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public async init(options: AssetInitOptions = {}): Promise<void>\n    {\n        if (this._initialized)\n        {\n            // #if _DEBUG\n            warn('[Assets]AssetManager already initialized, did you load before calling this Assets.init()?');\n            // #endif\n\n            return;\n        }\n\n        this._initialized = true;\n\n        if (options.defaultSearchParams)\n        {\n            this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n        }\n\n        if (options.basePath)\n        {\n            this.resolver.basePath = options.basePath;\n        }\n\n        if (options.bundleIdentifier)\n        {\n            this.resolver.setBundleIdentifier(options.bundleIdentifier);\n        }\n\n        if (options.manifest)\n        {\n            let manifest = options.manifest;\n\n            if (typeof manifest === 'string')\n            {\n                manifest = await this.load<AssetsManifest>(manifest);\n            }\n\n            this.resolver.addManifest(manifest);\n        }\n\n        const resolutionPref = options.texturePreference?.resolution ?? 1;\n        const resolution = (typeof resolutionPref === 'number') ? [resolutionPref] : resolutionPref;\n\n        const formats = await this._detectFormats({\n            preferredFormats: options.texturePreference?.format,\n            skipDetections: options.skipDetections,\n            detections: this._detections\n        });\n\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution,\n            },\n        });\n\n        if (options.preferences)\n        {\n            this.setPreferences(options.preferences);\n        }\n\n        // set load options on the loader\n        if (options.loadOptions)\n        {\n            this.loader.loadOptions = {\n                ...this.loader.loadOptions,\n                ...options.loadOptions\n            };\n        }\n    }\n\n    /**\n     * Registers assets with the Assets resolver. This method maps keys (aliases) to asset sources,\n     * allowing you to load assets using friendly names instead of direct URLs.\n     * @param assets - The unresolved assets to add to the resolver\n     * @example\n     * ```ts\n     * // Basic usage - single asset\n     * Assets.add({\n     *     alias: 'myTexture',\n     *     src: 'assets/texture.png'\n     * });\n     * const texture = await Assets.load('myTexture');\n     *\n     * // Multiple aliases for the same asset\n     * Assets.add({\n     *     alias: ['hero', 'player'],\n     *     src: 'hero.png'\n     * });\n     * const hero1 = await Assets.load('hero');\n     * const hero2 = await Assets.load('player'); // Same texture\n     *\n     * // Multiple format support\n     * Assets.add({\n     *     alias: 'character',\n     *     src: 'character.{webp,png}' // Will choose best format\n     * });\n     * Assets.add({\n     *     alias: 'character',\n     *     src: ['character.webp', 'character.png'], // Explicitly specify formats\n     * });\n     *\n     * // With texture options\n     * Assets.add({\n     *     alias: 'sprite',\n     *     src: 'sprite.png',\n     *     data: { scaleMode: 'nearest' }\n     * });\n     *\n     * // Multiple assets at once\n     * Assets.add([\n     *     { alias: 'bg', src: 'background.png' },\n     *     { alias: 'music', src: 'music.mp3' },\n     *     { alias: 'spritesheet', src: 'sheet.json', data: { ignoreMultiPack: false } }\n     * ]);\n     * ```\n     * @remarks\n     * - Assets are resolved when loaded, not when added\n     * - Multiple formats use the best available format for the browser\n     * - Adding with same alias overwrites previous definition\n     * - The `data` property is passed to the asset loader\n     * @see {@link Resolver} For details on asset resolution\n     * @see {@link LoaderParser} For asset-specific data options\n     * @advanced\n     */\n    public add(assets: (ArrayOr<UnresolvedAsset>)): void\n    {\n        this.resolver.add(assets);\n    }\n\n    /**\n     * Loads one or more assets and returns a promise that resolves with the loaded content.\n     * Assets are cached, so subsequent loads will return the same instance of the asset without re-fetching.\n     * @param urls - Single URL/alias or array of URLs/aliases to load\n     * @param onProgress - Optional callback for load progress (0.0 to 1.0)\n     * @returns Promise that resolves with loaded asset(s)\n     * @example\n     * ```ts\n     * // Load a single asset\n     * const texture = await Assets.load('images/sprite.png');\n     *\n     * // Load using an alias\n     * const heroTexture = await Assets.load({ alias: 'hero', src: 'images/hero.png' });\n     *\n     * // Load multiple assets\n     * const assets = await Assets.load([\n     *     'images/background.png',\n     *     'images/character.png',\n     *     'fonts/game.fnt'\n     * ]);\n     * console.log(assets['images/background.png']); // Access by URL\n     *\n     * // Load with progress tracking\n     * const textures = await Assets.load(['sprite1.png', 'sprite2.png'],\n     *     (progress) => console.log(`Loading: ${Math.round(progress * 100)}%`)\n     * );\n     *\n     * // Load with format preference\n     * const characterTexture = await Assets.load({\n     *     alias: 'character',\n     *     src: 'character.{webp,png}' // Will choose best format\n     * });\n     *\n     * // Load with custom options\n     * const spriteTexture = await Assets.load({\n     *     alias: 'sprite',\n     *     src: 'sprite.png',\n     *     data: {\n     *         scaleMode: SCALE_MODES.NEAREST,\n     *         mipmap: MIPMAP_MODES.ON\n     *     }\n     * });\n     *\n     * // Load with a specific loader, can be useful if your asset does not have an extension\n     * const image = await Assets.load({\n     *    alias: 'imageWithoutExtension',\n     *    src: 'images/imageWithoutExtension',\n     *    parser: 'texture' // Use the JSON loader\n     * });\n     * ```\n     * @remarks\n     * - Assets are cached automatically to prevent duplicate loading\n     * - URLs are resolved to the best format for the current browser\n     * - Asset types are detected automatically based on file extension\n     * - Progress callback receives values from 0.0 to 1.0\n     * - You can define with loader to use for an asset by specifying the `parser` property, which is useful for assets that do not have a file extension.\n     * @throws {Error} If the asset cannot be loaded or parsed\n     * @see {@link Assets.add} For registering assets with aliases\n     * @see {@link Assets.backgroundLoad} For loading assets in the background\n     * @see {@link Assets.unload} For releasing loaded assets\n     */\n    public async load<T = any>(\n        urls: string | UnresolvedAsset,\n        onProgress?: ProgressCallback | LoadOptions,\n    ): Promise<T>;\n    public async load<T = any>(\n        urls: string[] | UnresolvedAsset[],\n        onProgress?: ProgressCallback | LoadOptions,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        urls: ArrayOr<string> | ArrayOr<UnresolvedAsset>,\n        onProgress?: ProgressCallback | LoadOptions,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const singleAsset = isSingleItem(urls);\n\n        const urlArray: string[] = convertToList<UnresolvedAsset | string>(urls)\n            .map((url) =>\n            {\n                if (typeof url !== 'string')\n                {\n                    const aliases = this.resolver.getAlias(url);\n\n                    if (aliases.some((alias) => !this.resolver.hasKey(alias)))\n                    {\n                        this.add(url);\n                    }\n\n                    return Array.isArray(aliases) ? aliases[0] : aliases;\n                }\n\n                // if it hasn't been added, add it now\n                if (!this.resolver.hasKey(url)) this.add({ alias: url, src: url });\n\n                return url;\n            }) as string[];\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        // remap to the keys used..\n        const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress);\n\n        return singleAsset ? out[urlArray[0] as string] : out;\n    }\n\n    /**\n     * Registers a bundle of assets that can be loaded as a group. Bundles are useful for organizing\n     * assets into logical groups, such as game levels or UI screens.\n     * @param bundleId - Unique identifier for the bundle\n     * @param assets - Assets to include in the bundle\n     * @example\n     * ```ts\n     * // Add a bundle using array format\n     * Assets.addBundle('animals', [\n     *     { alias: 'bunny', src: 'bunny.png' },\n     *     { alias: 'chicken', src: 'chicken.png' },\n     *     { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     *\n     * // Add a bundle using object format\n     * Assets.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * // Add a bundle with advanced options\n     * Assets.addBundle('ui', [\n     *     {\n     *         alias: 'button',\n     *         src: 'button.{webp,png}',\n     *         data: { scaleMode: 'nearest' }\n     *     },\n     *     {\n     *         alias: ['logo', 'brand'],  // Multiple aliases\n     *         src: 'logo.svg',\n     *         data: { resolution: 2 }\n     *     }\n     * ]);\n     *\n     * // Load the bundle\n     * await Assets.loadBundle('animals');\n     *\n     * // Use the loaded assets\n     * const bunny = Sprite.from('bunny');\n     * const chicken = Sprite.from('chicken');\n     * ```\n     * @remarks\n     * - Bundle IDs must be unique\n     * - Assets in bundles are not loaded until `loadBundle` is called\n     * - Bundles can be background loaded using `backgroundLoadBundle`\n     * - Assets in bundles can be loaded individually using their aliases\n     * @see {@link Assets.loadBundle} For loading bundles\n     * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n     * @see {@link Assets.unloadBundle} For unloading bundles\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        this.resolver.addBundle(bundleId, assets);\n    }\n\n    /**\n     * Loads a bundle or multiple bundles of assets. Bundles are collections of related assets\n     * that can be loaded together.\n     * @param bundleIds - Single bundle ID or array of bundle IDs to load\n     * @param onProgress - Optional callback for load progress (0.0 to 1.0)\n     * @returns Promise that resolves with the loaded bundle assets\n     * @example\n     * ```ts\n     * // Define bundles in your manifest\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}', // use an array of individual assets\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * // Initialize with manifest\n     * await Assets.init({ manifest });\n     *\n     * // Or add bundles programmatically\n     * Assets.addBundle('load-screen', [...]);\n     * Assets.loadBundle('load-screen');\n     *\n     * // Load a single bundle\n     * await Assets.loadBundle('load-screen');\n     * const bg = Sprite.from('background'); // Uses alias from bundle\n     *\n     * // Load multiple bundles\n     * await Assets.loadBundle([\n     *     'load-screen',\n     *     'game-screen'\n     * ]);\n     *\n     * // Load with progress tracking\n     * await Assets.loadBundle('game-screen', (progress) => {\n     *     console.log(`Loading: ${Math.round(progress * 100)}%`);\n     * });\n     * ```\n     * @remarks\n     * - Bundle assets are cached automatically\n     * - Bundles can be pre-loaded using `backgroundLoadBundle`\n     * - Assets in bundles can be accessed by their aliases\n     * - Progress callback receives values from 0.0 to 1.0\n     * @throws {Error} If the bundle ID doesn't exist in the manifest\n     * @see {@link Assets.addBundle} For adding bundles programmatically\n     * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n     * @see {@link Assets.unloadBundle} For unloading bundles\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public async loadBundle(bundleIds: ArrayOr<string>, onProgress?: ProgressCallback): Promise<any>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        let singleAsset = false;\n\n        if (typeof bundleIds === 'string')\n        {\n            singleAsset = true;\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const out: Record<string, Record<string, any>> = {};\n\n        const keys = Object.keys(resolveResults);\n        let total = 0;\n        const counts: number[] = [];\n        const _onProgress = () =>\n        {\n            onProgress?.(counts.reduce((a, b) => a + b, 0) / total);\n        };\n        const promises = keys.map((bundleId, i) =>\n        {\n            const resolveResult = resolveResults[bundleId];\n            const values = Object.values(resolveResult);\n            const totalAssetsToLoad = [...new Set(values.flat())] as ResolvedAsset[];\n\n            const progressSize = totalAssetsToLoad.reduce((sum, asset) => sum + (asset.progressSize || 1), 0);\n\n            counts.push(0);\n            total += progressSize;\n\n            return this._mapLoadToResolve(resolveResult, (e) =>\n            {\n                counts[i] = e * progressSize;\n                _onProgress();\n            })\n                .then((resolveResult) =>\n                {\n                    out[bundleId] = resolveResult;\n                });\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Initiates background loading of assets. This allows assets to be loaded passively while other operations\n     * continue, making them instantly available when needed later.\n     *\n     * Background loading is useful for:\n     * - Preloading game levels while in a menu\n     * - Loading non-critical assets during gameplay\n     * - Reducing visible loading screens\n     * @param urls - Single URL/alias or array of URLs/aliases to load in the background\n     * @example\n     * ```ts\n     * // Basic background loading\n     * Assets.backgroundLoad('images/level2-assets.png');\n     *\n     * // Background load multiple assets\n     * Assets.backgroundLoad([\n     *     'images/sprite1.png',\n     *     'images/sprite2.png',\n     *     'images/background.png'\n     * ]);\n     *\n     * // Later, when you need the assets\n     * const textures = await Assets.load([\n     *     'images/sprite1.png',\n     *     'images/sprite2.png'\n     * ]); // Resolves immediately if background loading completed\n     * ```\n     * @remarks\n     * - Background loading happens one asset at a time to avoid blocking the main thread\n     * - Loading can be interrupted safely by calling `Assets.load()`\n     * - Assets are cached as they complete loading\n     * - No progress tracking is available for background loading\n     */\n    public async backgroundLoad(urls: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        const resolveResults = this.resolver.resolve(urls);\n\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n\n    /**\n     * Initiates background loading of asset bundles. Similar to backgroundLoad but works with\n     * predefined bundles of assets.\n     *\n     * Perfect for:\n     * - Preloading level bundles during gameplay\n     * - Loading UI assets during splash screens\n     * - Preparing assets for upcoming game states\n     * @param bundleIds - Single bundle ID or array of bundle IDs to load in the background\n     * @example\n     * ```ts\n     * // Define bundles in your manifest\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [\n     *             {\n     *               name: 'home',\n     *               assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'images/home-bg.png',\n     *                 },\n     *                 {\n     *                     alias: 'logo',\n     *                     src: 'images/logo.png',\n     *                 }\n     *              ]\n     *            },\n     *            {\n     *             name: 'level-1',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'images/level1/bg.png',\n     *                 },\n     *                 {\n     *                     alias: 'sprites',\n     *                     src: 'images/level1/sprites.json'\n     *                 }\n     *             ]\n     *         }]\n     *     }\n     * });\n     *\n     * // Load the home screen assets right away\n     * await Assets.loadBundle('home');\n     * showHomeScreen();\n     *\n     * // Start background loading while showing home screen\n     * Assets.backgroundLoadBundle('level-1');\n     *\n     * // When player starts level, load completes faster\n     * await Assets.loadBundle('level-1');\n     * hideHomeScreen();\n     * startLevel();\n     * ```\n     * @remarks\n     * - Bundle assets are loaded one at a time\n     * - Loading can be interrupted safely by calling `Assets.loadBundle()`\n     * - Assets are cached as they complete loading\n     * - Requires bundles to be registered via manifest or `addBundle`\n     * @see {@link Assets.addBundle} For adding bundles programmatically\n     * @see {@link Assets.loadBundle} For immediate bundle loading\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public async backgroundLoadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof bundleIds === 'string')\n        {\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        Object.values(resolveResults).forEach((resolveResult) =>\n        {\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n\n    /**\n     * Only intended for development purposes.\n     * This will wipe the resolver and caches.\n     * You will need to reinitialize the Asset\n     * @internal\n     */\n    public reset(): void\n    {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n\n        this._initialized = false;\n    }\n\n    /**\n     * Instantly gets an asset already loaded from the cache. Returns undefined if the asset hasn't been loaded yet.\n     * @param keys - The key or keys for the assets to retrieve\n     * @returns The cached asset(s) or undefined if not loaded\n     * @example\n     * ```ts\n     * // Get a single cached asset\n     * const texture = Assets.get('hero');\n     * if (texture) {\n     *     const sprite = new Sprite(texture);\n     * }\n     *\n     * // Get multiple cached assets\n     * const textures = Assets.get([\n     *     'hero',\n     *     'background',\n     *     'enemy'\n     * ]);\n     *\n     * // Safe pattern with loading fallback\n     * let texture = Assets.get('hero');\n     * if (!texture) {\n     *     texture = await Assets.load('hero');\n     * }\n     *\n     * // Working with bundles\n     * await Assets.loadBundle('game-ui');\n     * const uiAssets = Assets.get([\n     *     'button',\n     *     'panel',\n     *     'icons'\n     * ]);\n     * ```\n     * @remarks\n     * - Returns undefined if asset isn't loaded\n     * - No automatic loading - use `Assets.load()` for that\n     * - Cached assets are shared instances\n     * - Faster than `load()` for already cached assets\n     *\n     * > [!TIP]\n     * > When in doubt, use `Assets.load()` instead. It will return cached\n     * > assets instantly if they're already loaded.\n     * @see {@link Assets.load} For loading assets that aren't cached\n     * @see {@link Assets.cache} For direct cache access\n     */\n    public get<T = any>(keys: string): T;\n    public get<T = any>(keys: string[]): Record<string, T>;\n    public get<T = any>(keys: ArrayOr<string>): T | Record<string, T>\n    {\n        if (typeof keys === 'string')\n        {\n            return Cache.get(keys);\n        }\n\n        const assets: Record<string, T> = {};\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            assets[i] = Cache.get(keys[i]);\n        }\n\n        return assets;\n    }\n\n    /**\n     * helper function to map resolved assets back to loaded assets\n     * @param resolveResults - the resolve results from the resolver\n     * @param progressOrLoadOptions - the progress callback or load options\n     */\n    private async _mapLoadToResolve<T>(\n        resolveResults: ResolvedAsset | Record<string, ResolvedAsset>,\n        progressOrLoadOptions?: ProgressCallback | LoadOptions,\n    ): Promise<Record<string, T>>\n    {\n        const resolveArray = [...new Set(Object.values(resolveResults))] as ResolvedAsset[];\n\n        // pause background loader...\n        this._backgroundLoader.active = false;\n\n        const loadedAssets = await this.loader.load<T>(resolveArray, progressOrLoadOptions);\n\n        // resume background loader...\n        this._backgroundLoader.active = true;\n\n        // remap to the keys used..\n\n        const out: Record<string, T> = {};\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            const asset = loadedAssets[resolveResult.src];\n\n            const keys = [resolveResult.src];\n\n            if (resolveResult.alias)\n            {\n                keys.push(...resolveResult.alias);\n            }\n\n            keys.forEach((key) =>\n            {\n                out[key] = asset;\n            });\n\n            Cache.set(keys, asset);\n        });\n\n        return out;\n    }\n\n    /**\n     * Unloads assets and releases them from memory. This method ensures proper cleanup of\n     * loaded assets when they're no longer needed.\n     * @param urls - Single URL/alias or array of URLs/aliases to unload\n     * @example\n     * ```ts\n     * // Unload a single asset\n     * await Assets.unload('images/sprite.png');\n     *\n     * // Unload using an alias\n     * await Assets.unload('hero'); // Unloads the asset registered with 'hero' alias\n     *\n     * // Unload multiple assets\n     * await Assets.unload([\n     *     'images/background.png',\n     *     'images/character.png',\n     *     'hero'\n     * ]);\n     *\n     * // Unload and handle creation of new instances\n     * await Assets.unload('hero');\n     * const newHero = await Assets.load('hero'); // Will load fresh from source\n     * ```\n     * @remarks\n     * > [!WARNING]\n     * > Make sure assets aren't being used before unloading:\n     * > - Remove sprites using the texture\n     * > - Clear any references to the asset\n     * > - Textures will be destroyed and can't be used after unloading\n     * @throws {Error} If the asset is not found in cache\n     */\n    public async unload(\n        urls: ArrayOr<string> | ResolvedAsset | ResolvedAsset[]\n    ): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const urlArray = convertToList<string | ResolvedAsset>(urls)\n            .map((url) =>\n                ((typeof url !== 'string') ? url.src : url));\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        await this._unloadFromResolved(resolveResults);\n    }\n\n    /**\n     * Unloads all assets in a bundle. Use this to free memory when a bundle's assets\n     * are no longer needed, such as when switching game levels.\n     * @param bundleIds - Single bundle ID or array of bundle IDs to unload\n     * @example\n     * ```ts\n     * // Define and load a bundle\n     * Assets.addBundle('level-1', {\n     *     background: 'level1/bg.png',\n     *     sprites: 'level1/sprites.json',\n     *     music: 'level1/music.mp3'\n     * });\n     *\n     * // Load the bundle\n     * const level1 = await Assets.loadBundle('level-1');\n     *\n     * // Use the assets\n     * const background = Sprite.from(level1.background);\n     *\n     * // When done with the level, unload everything\n     * await Assets.unloadBundle('level-1');\n     * // background sprite is now invalid!\n     *\n     * // Unload multiple bundles\n     * await Assets.unloadBundle([\n     *     'level-1',\n     *     'level-2',\n     *     'ui-elements'\n     * ]);\n     * ```\n     * @remarks\n     * > [!WARNING]\n     * > - All assets in the bundle will be destroyed\n     * > - Bundle needs to be reloaded to use assets again\n     * > - Make sure no sprites or other objects are using the assets\n     * @throws {Error} If the bundle is not found\n     * @see {@link Assets.addBundle} For adding bundles\n     * @see {@link Assets.loadBundle} For loading bundles\n     */\n    public async unloadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const promises = Object.keys(resolveResults).map((bundleId) =>\n            this._unloadFromResolved(resolveResults[bundleId]));\n\n        await Promise.all(promises);\n    }\n\n    private async _unloadFromResolved(resolveResult: ResolvedAsset | Record<string, ResolvedAsset>)\n    {\n        const resolveArray = Object.values(resolveResult);\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            Cache.remove(resolveResult.src);\n        });\n\n        await this.loader.unload(resolveArray);\n    }\n\n    /**\n     * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n     * the users preferred formats order.\n     * @param options - the options to use when detecting formats\n     * @param options.preferredFormats - the preferred formats to use\n     * @param options.skipDetections - if we should skip the detections altogether\n     * @param options.detections - the detections to use\n     * @returns - the detected formats\n     */\n    private async _detectFormats(options: {\n        preferredFormats: string | string[],\n        skipDetections: boolean,\n        detections: FormatDetectionParser[]\n    }): Promise<string[]>\n    {\n        let formats: string[] = [];\n\n        // set preferred formats\n        if (options.preferredFormats)\n        {\n            formats = Array.isArray(options.preferredFormats)\n                ? options.preferredFormats : [options.preferredFormats];\n        }\n\n        // we should add any formats that are supported by the browser\n        for (const detection of options.detections)\n        {\n            if (options.skipDetections || await detection.test())\n            {\n                formats = await detection.add(formats);\n            }\n            else if (!options.skipDetections)\n            {\n                formats = await detection.remove(formats);\n            }\n        }\n\n        // remove any duplicates\n        formats = formats.filter((format, index) => formats.indexOf(format) === index);\n\n        return formats;\n    }\n\n    /**\n     * All the detection parsers currently added to the Assets class.\n     * @advanced\n     */\n    public get detections(): FormatDetectionParser[]\n    {\n        return this._detections;\n    }\n\n    /**\n     * Sets global preferences for asset loading behavior. This method configures how assets\n     * are loaded and processed across all parsers.\n     * @param preferences - Asset loading preferences\n     * @example\n     * ```ts\n     * // Basic preferences\n     * Assets.setPreferences({\n     *     crossOrigin: 'anonymous',\n     *     parseAsGraphicsContext: false\n     * });\n     * ```\n     * @remarks\n     * Preferences are applied to all compatible parsers and affect future asset loading.\n     * Common preferences include:\n     * - `crossOrigin`: CORS setting for loaded assets\n     * - `preferWorkers`: Whether to use web workers for loading textures\n     * - `preferCreateImageBitmap`: Use `createImageBitmap` for texture creation. Turning this off will use the `Image` constructor instead.\n     * @see {@link AssetsPreferences} For all available preferences\n     */\n    public setPreferences(preferences: Partial<AssetsPreferences>): void\n    {\n        // Find matching config keys in loaders with preferences\n        // and set the values\n        this.loader.parsers.forEach((parser) =>\n        {\n            if (!parser.config) return;\n\n            (Object.keys(parser.config) as (keyof AssetsPreferences)[])\n                .filter((key) => key in preferences)\n                .forEach((key) =>\n                {\n                    parser.config[key] = preferences[key];\n                });\n        });\n    }\n}\n\n/**\n * The global Assets class is a singleton that manages loading, caching, and unloading of all resources\n * in your PixiJS application.\n *\n * Key responsibilities:\n * - **URL Resolution**: Maps URLs/keys to browser-compatible resources\n * - **Resource Loading**: Handles loading and transformation of assets\n * - **Asset Caching**: Manages a global cache to prevent duplicate loads\n * - **Memory Management**: Provides unloading capabilities to free memory\n *\n * Advanced Features:\n * - **Asset Bundles**: Group and manage related assets together\n * - **Background Loading**: Load assets before they're needed over time\n * - **Format Detection**: Automatically select optimal asset formats\n *\n * Supported Asset Types:\n * | Type                | Extensions                                                       | Loaders                                                               |\n * | ------------------- | ---------------------------------------------------------------- | --------------------------------------------------------------------- |\n * | Textures            | `.png`, `.jpg`, `.gif`, `.webp`, `.avif`, `.svg`                 | {@link loadTextures}, {@link loadSvg}                                 |\n * | Video Textures      | `.mp4`, `.m4v`, `.webm`, `.ogg`, `.ogv`, `.h264`, `.avi`, `.mov` | {@link loadVideoTextures}                                             |\n * | Sprite Sheets       | `.json`                                                          | {@link spritesheetAsset}                                              |\n * | Bitmap Fonts        | `.fnt`, `.xml`, `.txt`                                           | {@link loadBitmapFont}                                                |\n * | Web Fonts           | `.ttf`, `.otf`, `.woff`, `.woff2`                                | {@link loadWebFont}                                                   |\n * | JSON                | `.json`                                                          | {@link loadJson}                                                      |\n * | Text                | `.txt`                                                           | {@link loadTxt}                                                       |\n * | Compressed Textures | `.basis`, `.dds`, `.ktx`, `.ktx2`                                | {@link loadBasis}, {@link loadDDS}, {@link loadKTX}, {@link loadKTX2} |\n * > [!NOTE] Some loaders allow for custom configuration, please refer to the specific loader documentation for details.\n * @example\n * ```typescript\n * import { Assets } from 'pixi.js';\n *\n * // Initialize with options (optional). You can call Assets.load directly without init.\n * await Assets.init({\n *     // Base path for all asset URLs\n *     basePath: 'https://my-cdn.com/assets/',\n *     // Manifest object that defines all assets\n *     manifest: {\n *        bundles: [{ name: 'gameAssets', assets: [] }, ...],\n *     }, *\n *     // Preferred texture settings\n *     texturePreference: {\n *         resolution: window.devicePixelRatio,\n *         format: ['avif', 'webp', 'png']\n *     }\n * });\n *\n * // Basic loading\n * const texture = await Assets.load('images/sprite.png');\n *\n * // Load multiple assets\n * const assets = await Assets.load([\n *     'images/bg.png',\n *     'images/character.png',\n *     'fonts/game.fnt'\n * ]);\n *\n * // Using aliases + multiple formats\n * await Assets.load({ alias: 'hero', src: 'images/hero.{webp,png}' });\n * const sprite = Sprite.from('hero'); // Uses the best available format\n *\n * // background loading\n * Assets.backgroundLoad(['images/level1.json', 'images/level2.json']); // Loads in the background one at a time\n *\n * // Load a bundle of assets from the manifest\n * const levelAssets = await Assets.loadBundle('gameAssets');\n * // Background loading of a bundle. This will load assets in the background one at a time.\n * // Can be interrupted at any time by calling Assets.loadBundle('gameAssets') again.\n * Assets.backgroundLoadBundle('resultsAssets');\n *\n * // Memory management\n * await Assets.unload('hero');\n * await Assets.unloadBundle('levelOne');\n * ```\n * @remarks\n * - Assets are cached automatically and only loaded once\n * - Background loading helps eliminate loading screens\n * - Format detection ensures optimal asset delivery\n * - Bundle management simplifies resource organization\n *\n * > [!IMPORTANT]\n * > When unloading assets, ensure they aren't being used elsewhere\n * > in your application to prevent missing texture references.\n * @see {@link AssetInitOptions} For initialization options\n * @see {@link AssetsPreferences} For advanced preferences\n * @see {@link BackgroundLoader} For background loading capabilities\n * @see {@link AssetsManifest} For manifest-based asset management\n * @see {@link Loader} For the underlying loading system\n * @see {@link Cache} For the caching system\n * @see {@link Resolver} For URL resolution details\n * @category assets\n * @class\n * @standard\n */\nexport const Assets = new AssetsClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.LoadParser, Assets.loader.parsers)\n    .handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers)\n    .handleByList(ExtensionType.CacheParser, Assets.cache.parsers)\n    .handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(\n    cacheTextureArray,\n\n    detectDefaults,\n    detectAvif,\n    detectWebp,\n    detectMp4,\n    detectOgv,\n    detectWebm,\n\n    loadJson,\n    loadTxt,\n    loadWebFont,\n    loadSvg,\n    loadTextures,\n    loadVideoTextures,\n    loadBitmapFont,\n\n    bitmapFontCachePlugin,\n\n    resolveTextureUrl,\n    resolveJsonUrl\n);\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n"],"names":["resolveResult"],"mappings":"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"}}]
}