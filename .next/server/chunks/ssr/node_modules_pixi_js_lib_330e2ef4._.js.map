{"version":3,"sources":["../../../../node_modules/pixi.js/src/rendering/renderers/shared/system/SystemRunner.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/const.ts","../../../../node_modules/pixi.js/src/utils/browser/unsafeEvalSupported.ts","../../../../node_modules/pixi.js/src/environment/autoDetectEnvironment.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/system/AbstractRenderer.ts","../../../../node_modules/pixi.js/src/utils/const.ts","../../../../node_modules/pixi.js/src/utils/global/globalHooks.ts","../../../../node_modules/pixi.js/src/filters/mask/MaskFilter.ts","../../../../node_modules/pixi.js/src/rendering/batcher/shared/BatcherPipe.ts","../../../../node_modules/pixi.js/src/rendering/high-shader/shader-bits/textureBit.ts","../../../../node_modules/pixi.js/src/rendering/mask/color/ColorMaskPipe.ts","../../../../node_modules/pixi.js/src/rendering/mask/stencil/StencilMaskPipe.ts","../../../../node_modules/pixi.js/src/rendering/mask/alpha/AlphaMaskPipe.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStencilModesToPixi.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/ensureAttributes.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uboSyncFunctions.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uniformParsers.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/createUboSyncFunction.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/shader/UboSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/calculateProjection.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/getCanvasTexture.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/isRenderingToScreen.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTarget.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTargetSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/buffer/BufferResource.ts","../../../../node_modules/pixi.js/src/scene/container/utils/validateRenderables.ts","../../../../node_modules/pixi.js/src/scene/container/utils/clearList.ts","../../../../node_modules/pixi.js/src/scene/container/utils/executeInstructions.ts","../../../../node_modules/pixi.js/src/scene/sprite/SpritePipe.ts","../../../../node_modules/pixi.js/src/scene/container/CustomRenderPipe.ts","../../../../node_modules/pixi.js/src/scene/container/utils/updateRenderGroupTransforms.ts","../../../../node_modules/pixi.js/src/scene/container/RenderGroupPipe.ts","../../../../node_modules/pixi.js/src/scene/container/RenderGroupSystem.ts","../../../../node_modules/pixi.js/src/utils/data/clean.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/GCSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureGCSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderableGCSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/SchedulerSystem.ts","../../../../node_modules/pixi.js/src/utils/sayHello.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderTexture.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/startup/HelloSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/background/BackgroundSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/extract/ExtractSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/blendModes/BlendModePipe.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/GlobalUniformSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/extract/GenerateTextureSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/view/ViewSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/system/SharedSystems.ts"],"sourcesContent":["/**\n * SystemRunner is used internally by the renderers as an efficient way for systems to\n * be notified about what the renderer is up to during the rendering phase.\n *\n * ```ts\n * import { SystemRunner } from 'pixi.js';\n *\n * const myObject = {\n *     loaded: new SystemRunner('loaded')\n * }\n *\n * const listener = {\n *     loaded: function(){\n *         // thin\n *     }\n * }\n *\n * myObject.loaded.add(listener);\n *\n * myObject.loaded.emit();\n * ```\n *\n * Or for handling calling the same function on many items\n * ```ts\n * import { SystemRunner } from 'pixi.js';\n *\n * const myGame = {\n *     update: new SystemRunner('update')\n * }\n *\n * const gameObject = {\n *     update: function(time){\n *         // update my gamey state\n *     }\n * }\n *\n * myGame.update.add(gameObject);\n *\n * myGame.update.emit(time);\n * ```\n * @category rendering\n * @internal\n */\nexport class SystemRunner\n{\n    public items: any[];\n    private _name: string;\n\n    /**\n     * @param name - The function name that will be executed on the listeners added to this Runner.\n     */\n    constructor(name: string)\n    {\n        this.items = [];\n        this._name = name;\n    }\n\n    /* jsdoc/check-param-names */\n    /**\n     * Dispatch/Broadcast Runner to all listeners added to the queue.\n     * @param {...any} params - (optional) parameters to pass to each listener\n     */\n    /* jsdoc/check-param-names */\n    public emit(a0?: unknown, a1?: unknown, a2?: unknown, a3?: unknown,\n        a4?: unknown, a5?: unknown, a6?: unknown, a7?: unknown): this\n    {\n        const { name, items } = this;\n\n        for (let i = 0, len = items.length; i < len; i++)\n        {\n            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add a listener to the Runner\n     *\n     * Runners do not need to have scope or functions passed to them.\n     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n     * as the name provided to the Runner when it was created.\n     *\n     * Eg A listener passed to this Runner will require a 'complete' function.\n     *\n     * ```ts\n     * import { Runner } from 'pixi.js';\n     *\n     * const complete = new Runner('complete');\n     * ```\n     *\n     * The scope used will be the object itself.\n     * @param {any} item - The object that will be listening.\n     */\n    public add(item: unknown): this\n    {\n        if ((item as any)[this._name])\n        {\n            this.remove(item);\n            this.items.push(item);\n        }\n\n        return this;\n    }\n\n    /**\n     * Remove a single listener from the dispatch queue.\n     * @param {any} item - The listener that you would like to remove.\n     */\n    public remove(item: unknown): this\n    {\n        const index = this.items.indexOf(item);\n\n        if (index !== -1)\n        {\n            this.items.splice(index, 1);\n        }\n\n        return this;\n    }\n\n    /**\n     * Check to see if the listener is already in the Runner\n     * @param {any} item - The listener that you would like to check.\n     */\n    public contains(item: unknown): boolean\n    {\n        return this.items.indexOf(item) !== -1;\n    }\n\n    /** Remove all listeners from the Runner */\n    public removeAll(): this\n    {\n        this.items.length = 0;\n\n        return this;\n    }\n\n    /** Remove all references, don't use after this. */\n    public destroy(): void\n    {\n        this.removeAll();\n        this.items = null;\n        this._name = null;\n    }\n\n    /**\n     * `true` if there are no this Runner contains no listeners\n     * @readonly\n     */\n    public get empty(): boolean\n    {\n        return this.items.length === 0;\n    }\n\n    /**\n     * The name of the runner.\n     * @readonly\n     */\n    public get name(): string\n    {\n        return this._name;\n    }\n}\n","/**\n * Constants used by the renderer for clearing the screen or render textures.\n * @category rendering\n * @advanced\n */\nexport enum CLEAR\n{\n    /** No clear operation. */\n    NONE = 0,\n    /** Clear the color buffer. */\n    COLOR = 16384,\n    /** Clear the stencil buffer. */\n    STENCIL = 1024,\n    /** Clear the depth buffer. */\n    DEPTH = 256,\n\n    /** Clear the color and depth buffers. */\n    COLOR_DEPTH = COLOR | DEPTH,\n    /** Clear the color and stencil buffers. */\n    COLOR_STENCIL = COLOR | STENCIL,\n    /** Clear the depth and stencil buffers. */\n    DEPTH_STENCIL = DEPTH | STENCIL,\n    /** Clear the color, depth, and stencil buffers. */\n    ALL = COLOR | DEPTH | STENCIL,\n\n}\n\n/**\n * Used for clearing render textures. true is the same as `ALL` false is the same as `NONE`\n * @category rendering\n * @advanced\n */\nexport type CLEAR_OR_BOOL = CLEAR | boolean;\n","// Cache the result to prevent running this over and over\nlet unsafeEval: boolean;\n\n/**\n * Not all platforms allow to generate function code (e.g., `new Function`).\n * this provides the platform-level detection.\n * @private\n * @returns {boolean} `true` if `new Function` is supported.\n */\nexport function unsafeEvalSupported(): boolean\n{\n    if (typeof unsafeEval === 'boolean')\n    {\n        return unsafeEval;\n    }\n\n    try\n    {\n        /* eslint-disable no-new-func */\n        const func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');\n        /* eslint-enable no-new-func */\n\n        unsafeEval = func({ a: 'b' }, 'a', 'b') === true;\n    }\n    catch (_e)\n    {\n        unsafeEval = false;\n    }\n\n    return unsafeEval;\n}\n","import { extensions, ExtensionType } from '../extensions/Extensions';\n\nconst environments: { name: string; value: { test: () => boolean; load: () => Promise<boolean> } }[] = [];\n\nextensions.handleByNamedList(ExtensionType.Environment, environments);\n\n/**\n * Automatically detects the environment and loads the appropriate extensions.\n * @param skip - whether to skip loading the default extensions\n * @category environment\n * @advanced\n */\nexport async function loadEnvironmentExtensions(skip: boolean): Promise<void>\n{\n    if (skip) return;\n\n    for (let i = 0; i < environments.length; i++)\n    {\n        const env = environments[i];\n\n        if (env.value.test())\n        {\n            await env.value.load();\n\n            return;\n        }\n    }\n}\n\n/**\n * @param add - whether to add the default imports to the bundle\n * @deprecated since 8.1.6. Use `loadEnvironmentExtensions` instead\n * @category environment\n * @advanced\n */\nexport async function autoDetectEnvironment(add: boolean): Promise<void>\n{\n    return loadEnvironmentExtensions(!add);\n}\n","import { Color } from '../../../../color/Color';\nimport { loadEnvironmentExtensions } from '../../../../environment/autoDetectEnvironment';\nimport { Container } from '../../../../scene/container/Container';\nimport { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { GlobalResourceRegistry } from '../../../../utils/pool/GlobalResourceRegistry';\nimport { EventEmitter } from '../../../../utils/utils';\nimport { CLEAR } from '../../gl/const';\nimport { SystemRunner } from './SystemRunner';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { Renderer } from '../../types';\nimport type { BackgroundSystem } from '../background/BackgroundSystem';\nimport type { GenerateTextureOptions, GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport type { PipeConstructor } from '../instructions/RenderPipe';\nimport type { RenderSurface } from '../renderTarget/RenderTargetSystem';\nimport type { Texture } from '../texture/Texture';\nimport type { ViewSystem, ViewSystemDestroyOptions } from '../view/ViewSystem';\nimport type { SharedRendererOptions } from './SharedSystems';\nimport type { System, SystemConstructor } from './System';\n\n/**\n * The configuration for the renderer.\n * This is used to define the systems and render pipes that will be used by the renderer.\n * @category rendering\n * @advanced\n */\nexport interface RendererConfig\n{\n    type: number;\n    name: string;\n    runners?: string[];\n    systems: {name: string, value: SystemConstructor}[];\n    renderPipes: {name: string, value: PipeConstructor}[];\n    renderPipeAdaptors: {name: string, value: any}[];\n}\n\n/**\n * The options for rendering a view.\n * @category rendering\n * @standard\n */\nexport interface RenderOptions extends ClearOptions\n{\n    /** The container to render. */\n    container: Container;\n    /** the transform to apply to the container. */\n    transform?: Matrix;\n}\n\n/**\n * The options for clearing the render target.\n * @category rendering\n * @advanced\n */\nexport interface ClearOptions\n{\n    /**\n     * The render target to render. if this target is a canvas and  you are using the WebGL renderer,\n     * please ensure you have set `multiView` to `true` on renderer.\n     */\n    target?: RenderSurface;\n    /** The color to clear with. */\n    clearColor?: ColorSource;\n    /** The clear mode to use. */\n    clear?: CLEAR_OR_BOOL\n}\n\n/**\n * Options for destroying the renderer.\n * This can be a boolean or an object.\n * @category rendering\n * @standard\n */\nexport type RendererDestroyOptions = TypeOrBool<ViewSystemDestroyOptions & {\n    /** Whether to clean up global resource pools/caches */\n    releaseGlobalResources?: boolean;\n}>;\n\nconst defaultRunners = [\n    'init',\n    'destroy',\n    'contextChange',\n    'resolutionChange',\n    'resetState',\n    'renderEnd',\n    'renderStart',\n    'render',\n    'update',\n    'postrender',\n    'prerender'\n] as const;\n\ntype DefaultRunners = typeof defaultRunners[number];\ntype Runners = {[key in DefaultRunners]: SystemRunner} & {\n    [K: ({} & string) | ({} & symbol)]: SystemRunner;\n};\n\n/* eslint-disable max-len */\n/**\n * The base class for a PixiJS Renderer. It contains the shared logic for all renderers.\n *\n * You should not use this class directly, but instead use {@link WebGLRenderer}\n * or {@link WebGPURenderer}.\n * Alternatively, you can also use {@link autoDetectRenderer} if you want us to\n * determine the best renderer for you.\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a renderer:\n *\n *\n * | Generic Systems                      | Systems that manage functionality that all renderer types share               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link ViewSystem}              | This manages the main view of the renderer usually a Canvas              |\n * | {@link BackgroundSystem}        | This manages the main views background color and alpha                   |\n * | {@link EventSystem}           | This manages UI events.                                                       |\n * | {@link AccessibilitySystem} | This manages accessibility features. Requires `import 'pixi.js/accessibility'`|\n *\n * | Core Systems                   | Provide an optimised, easy to use API to work with WebGL/WebGPU               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link GlobalUniformSystem} | This manages shaders, programs that run on the GPU to calculate 'em pixels.   |\n * | {@link TextureGCSystem}     | This will automatically remove textures from the GPU if they are not used.    |\n *\n * | PixiJS High-Level Systems            | Set of specific systems designed to work with PixiJS objects                  |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link HelloSystem}               | Says hello, buy printing out the pixi version into the console log (along with the renderer type)       |\n * | {@link GenerateTextureSystem} | This adds the ability to generate textures from any Container       |\n * | {@link FilterSystem}          | This manages the filtering pipeline for post-processing effects.             |\n * | {@link PrepareSystem}               | This manages uploading assets to the GPU. Requires `import 'pixi.js/prepare'`|\n * | {@link ExtractSystem}               | This extracts image data from display objects.                               |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @abstract\n * @category rendering\n * @advanced\n * @property {HelloSystem} hello - HelloSystem instance.\n * @property {TextureGCSystem} textureGC - TextureGCSystem instance.\n * @property {FilterSystem} filter - FilterSystem instance.\n * @property {GlobalUniformSystem} globalUniforms - GlobalUniformSystem instance.\n * @property {TextureSystem} texture - TextureSystem instance.\n * @property {EventSystem} events - EventSystem instance.\n * @property {ExtractSystem} extract - ExtractSystem instance. Requires `import 'pixi.js/extract'`.\n * @property {PrepareSystem} prepare - PrepareSystem instance. Requires `import 'pixi.js/prepare'`.\n * @property {AccessibilitySystem} accessibility - AccessibilitySystem instance. Requires `import 'pixi.js/accessibility'`.\n */\nexport class AbstractRenderer<\n    PIPES, OPTIONS extends SharedRendererOptions, CANVAS extends ICanvas = HTMLCanvasElement\n> extends EventEmitter<{resize: [screenWidth: number, screenHeight: number, resolution: number]}>\n{\n    /** The default options for the renderer. */\n    public static defaultOptions = {\n        /**\n         * Default resolution / device pixel ratio of the renderer.\n         * @default 1\n         */\n        resolution: 1,\n        /**\n         * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n         * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n         * performance issues when using WebGL.\n         *\n         * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n         * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n         * driver version blacklisted by the\n         * browser.\n         *\n         * If your application requires high performance rendering, you may wish to set this to false.\n         * We recommend one of two options if you decide to set this flag to false:\n         *\n         * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n         *    not supported.\n         *\n         * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n         *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n         *    device & browser combination does not support high performance WebGL.\n         *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n         * @default false\n         */\n        failIfMajorPerformanceCaveat: false,\n        /**\n         * Should round pixels be forced when rendering?\n         * @default false\n         */\n        roundPixels: false\n    };\n\n    /** @internal */\n    public readonly type: number;\n    /** The name of the renderer. */\n    public readonly name: string;\n\n    /** The current tick of the renderer. */\n    public tick: number = 0;\n\n    /** @internal */\n    public readonly uid = uid('renderer');\n\n    /** @internal */\n    public _roundPixels: 0 | 1;\n\n    /** @internal */\n    public readonly runners: Runners = Object.create(null) as Runners;\n    /** @internal */\n    public readonly renderPipes = Object.create(null) as PIPES;\n    /** The view system manages the main canvas that is attached to the DOM */\n    public view!: ViewSystem;\n    /** The background system manages the background color and alpha of the main view. */\n    public background: BackgroundSystem;\n    /** System that manages the generation of textures from the renderer */\n    public textureGenerator: GenerateTextureSystem;\n\n    protected _initOptions: OPTIONS = {} as OPTIONS;\n    protected config: RendererConfig;\n\n    private _systemsHash: Record<string, System> = Object.create(null);\n    private _lastObjectRendered: Container;\n\n    /**\n     * Set up a system with a collection of SystemClasses and runners.\n     * Systems are attached dynamically to this class when added.\n     * @param config - the config for the system manager\n     */\n    constructor(config: RendererConfig)\n    {\n        super();\n        this.type = config.type;\n        this.name = config.name;\n        this.config = config;\n\n        const combinedRunners = [...defaultRunners, ...(this.config.runners ?? [])];\n\n        this._addRunners(...combinedRunners);\n        // Validation check that this environment support `new Function`\n        this._unsafeEvalCheck();\n    }\n\n    /**\n     * Initialize the renderer.\n     * @param options - The options to use to create the renderer.\n     */\n    public async init(options: Partial<OPTIONS> = {})\n    {\n        const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n\n        await loadEnvironmentExtensions(skip);\n\n        this._addSystems(this.config.systems);\n        this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n\n        // loop through all systems...\n        for (const systemName in this._systemsHash)\n        {\n            const system = this._systemsHash[systemName];\n\n            const defaultSystemOptions = (system.constructor as any).defaultOptions;\n\n            options = { ...defaultSystemOptions, ...options };\n        }\n\n        options = { ...AbstractRenderer.defaultOptions, ...options };\n        this._roundPixels = options.roundPixels ? 1 : 0;\n\n        // await emits..\n        for (let i = 0; i < this.runners.init.items.length; i++)\n        {\n            await this.runners.init.items[i].init(options);\n        }\n\n        // store options\n        this._initOptions = options as OPTIONS;\n    }\n\n    /**\n     * Renders the object to its view.\n     * @param options - The options to render with.\n     * @param options.container - The container to render.\n     * @param [options.target] - The target to render to.\n     */\n    public render(options: RenderOptions | Container): void;\n    /** @deprecated since 8.0.0 */\n    public render(container: Container, options: {renderTexture: any}): void;\n    public render(args: RenderOptions | Container, deprecated?: {renderTexture: any}): void\n    {\n        this.tick++;\n\n        let options = args;\n\n        if (options instanceof Container)\n        {\n            options = { container: options };\n\n            if (deprecated)\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'passing a second argument is deprecated, please use render options instead');\n                // #endif\n\n                options.target = deprecated.renderTexture;\n            }\n        }\n\n        options.target ||= this.view.renderTarget;\n\n        // TODO: we should eventually fix events so that it can handle multiple canvas elements\n        if (options.target === this.view.renderTarget)\n        {\n            // TODO get rid of this\n            this._lastObjectRendered = options.container;\n\n            options.clearColor ??= this.background.colorRgba;\n            options.clear ??= this.background.clearBeforeRender;\n        }\n\n        if (options.clearColor)\n        {\n            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n\n            options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();\n        }\n\n        if (!options.transform)\n        {\n            options.container.updateLocalTransform();\n            options.transform = options.container.localTransform;\n        }\n\n        // Check if the container is visible before proceeding with rendering\n        if (!options.container.visible)\n        {\n            return;\n        }\n\n        // lets ensure this object is a render group so we can render it!\n        // the renderer only likes to render - render groups.\n        options.container.enableRenderGroup();\n\n        this.runners.prerender.emit(options);\n        this.runners.renderStart.emit(options);\n        this.runners.render.emit(options);\n        this.runners.renderEnd.emit(options);\n        this.runners.postrender.emit(options);\n    }\n\n    /**\n     * Resizes the WebGL view to the specified width and height.\n     * @param desiredScreenWidth - The desired width of the screen.\n     * @param desiredScreenHeight - The desired height of the screen.\n     * @param resolution - The resolution / device pixel ratio of the renderer.\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution?: number): void\n    {\n        const previousResolution = this.view.resolution;\n\n        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n        this.emit('resize', this.view.screen.width, this.view.screen.height, this.view.resolution);\n        if (resolution !== undefined && resolution !== previousResolution)\n        {\n            this.runners.resolutionChange.emit(resolution);\n        }\n    }\n\n    /**\n     * Clears the render target.\n     * @param options - The options to use when clearing the render target.\n     * @param options.target - The render target to clear.\n     * @param options.clearColor - The color to clear with.\n     * @param options.clear - The clear mode to use.\n     * @advanced\n     */\n    public clear(options: ClearOptions = {}): void\n    {\n        // override!\n        const renderer = this as unknown as Renderer;\n\n        options.target ||= renderer.renderTarget.renderTarget;\n        options.clearColor ||= this.background.colorRgba;\n        options.clear ??= CLEAR.ALL;\n\n        const { clear, clearColor, target } = options;\n\n        Color.shared.setValue(clearColor ?? this.background.colorRgba);\n\n        renderer.renderTarget.clear(target, clear, Color.shared.toArray() as RgbaArray);\n    }\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.view.resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.view.resolution = value;\n        this.runners.resolutionChange.emit(value);\n    }\n\n    /**\n     * Same as view.width, actual number of pixels in the canvas by horizontal.\n     * @type {number}\n     * @readonly\n     * @default 800\n     */\n    get width(): number\n    {\n        return this.view.texture.frame.width;\n    }\n\n    /**\n     * Same as view.height, actual number of pixels in the canvas by vertical.\n     * @default 600\n     */\n    get height(): number\n    {\n        return this.view.texture.frame.height;\n    }\n\n    // NOTE: this was `view` in v7\n    /**\n     * The canvas element that everything is drawn to.\n     * @type {environment.ICanvas}\n     */\n    get canvas(): CANVAS\n    {\n        return this.view.canvas as CANVAS;\n    }\n\n    /**\n     * the last object rendered by the renderer. Useful for other plugins like interaction managers\n     * @readonly\n     */\n    get lastObjectRendered(): Container\n    {\n        return this._lastObjectRendered;\n    }\n\n    /**\n     * Flag if we are rendering to the screen vs renderTexture\n     * @readonly\n     * @default true\n     */\n    get renderingToScreen(): boolean\n    {\n        const renderer = this as unknown as Renderer;\n\n        return renderer.renderTarget.renderingToScreen;\n    }\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    get screen(): Rectangle\n    {\n        return this.view.screen;\n    }\n\n    /**\n     * Create a bunch of runners based of a collection of ids\n     * @param runnerIds - the runner ids to add\n     */\n    private _addRunners(...runnerIds: string[]): void\n    {\n        runnerIds.forEach((runnerId) =>\n        {\n            this.runners[runnerId] = new SystemRunner(runnerId);\n        });\n    }\n\n    private _addSystems(systems: RendererConfig['systems']): void\n    {\n        let i: keyof typeof systems;\n\n        for (i in systems)\n        {\n            const val = systems[i];\n\n            this._addSystem(val.value, val.name);\n        }\n    }\n\n    /**\n     * Add a new system to the renderer.\n     * @param ClassRef - Class reference\n     * @param name - Property name for system, if not specified\n     *        will use a static `name` property on the class itself. This\n     *        name will be assigned as s property on the Renderer so make\n     *        sure it doesn't collide with properties on Renderer.\n     * @returns Return instance of renderer\n     */\n    private _addSystem(ClassRef: SystemConstructor, name: string): this\n    {\n        const system = new ClassRef(this as unknown as Renderer);\n\n        if ((this as any)[name])\n        {\n            throw new Error(`Whoops! The name \"${name}\" is already in use`);\n        }\n\n        (this as any)[name] = system;\n\n        this._systemsHash[name] = system;\n\n        for (const i in this.runners)\n        {\n            this.runners[i].add(system);\n        }\n\n        return this;\n    }\n\n    private _addPipes(pipes: RendererConfig['renderPipes'], pipeAdaptors: RendererConfig['renderPipeAdaptors']): void\n    {\n        const adaptors = pipeAdaptors.reduce((acc, adaptor) =>\n        {\n            acc[adaptor.name] = adaptor.value;\n\n            return acc;\n        }, {} as Record<string, any>);\n\n        pipes.forEach((pipe) =>\n        {\n            const PipeClass = pipe.value;\n            const name = pipe.name;\n\n            const Adaptor = adaptors[name];\n\n            // sorry typescript..\n            (this.renderPipes as any)[name] = new PipeClass(\n                this as unknown as Renderer,\n                Adaptor ? new Adaptor() : null\n            );\n\n            this.runners.destroy.add((this.renderPipes as any)[name]);\n        });\n    }\n\n    public destroy(options: RendererDestroyOptions = false): void\n    {\n        this.runners.destroy.items.reverse();\n        this.runners.destroy.emit(options);\n\n        if (options === true || (typeof options === 'object' && options.releaseGlobalResources))\n        {\n            GlobalResourceRegistry.release();\n        }\n\n        // destroy all runners\n        Object.values(this.runners).forEach((runner) =>\n        {\n            runner.destroy();\n        });\n\n        this._systemsHash = null;\n\n        // destroy all pipes\n        (this.renderPipes as null) = null;\n    }\n\n    /**\n     * Generate a texture from a container.\n     * @param options - options or container target to use when generating the texture\n     * @returns a texture\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): Texture\n    {\n        return this.textureGenerator.generateTexture(options);\n    }\n\n    /**\n     * Whether the renderer will round coordinates to whole pixels when rendering.\n     * Can be overridden on a per scene item basis.\n     */\n    get roundPixels(): boolean\n    {\n        return !!this._roundPixels;\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     * @ignore\n     */\n    public _unsafeEvalCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n               + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n    /**\n     * Resets the rendering state of the renderer.\n     * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state\n     * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi\n     * render will reset all internal caches and ensure it executes correctly.\n     *\n     * This is particularly useful when combining PixiJS with other rendering engines like Three.js:\n     * ```js\n     * // Reset Three.js state\n     * threeRenderer.resetState();\n     *\n     * // Render a Three.js scene\n     * threeRenderer.render(threeScene, threeCamera);\n     *\n     * // Reset PixiJS state since Three.js modified the WebGL context\n     * pixiRenderer.resetState();\n     *\n     * // Now render Pixi content\n     * pixiRenderer.render(pixiScene);\n     * ```\n     * @advanced\n     */\n    public resetState(): void\n    {\n        this.runners.resetState.emit();\n    }\n}\n","import EventEmitter from 'eventemitter3';\n\n/**\n * Regexp for data URI.\n * Based on: {@link https://github.com/ragingwind/data-uri-regex}\n * @type {RegExp}\n * @default /(?:^data:image\\/([\\w+]+);(?:[\\w=]+|charset=[\\w-]+)?(?:;base64)?,)/i\n * @example\n * import { DATA_URI } from 'pixi.js';\n *\n * DATA_URI.test('data:image/png;base64,foobar'); // => true\n * @category utils\n * @advanced\n */\nexport const DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\n\n// export the event emitter so we can use it in external modules\nexport { EventEmitter };\n\n/**\n * The current version of PixiJS. This is automatically replaced by the build process.\n * @internal\n */\nexport const VERSION = '$_VERSION';\n","import { type ExtensionMetadata, ExtensionType } from '../../extensions/Extensions';\nimport { VERSION } from '../const';\n\nimport type { Application } from '../../app/Application';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../rendering/renderers/types';\n\ndeclare global\n{\n    /* eslint-disable no-var */\n    var __PIXI_APP_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n    var __PIXI_RENDERER_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n    /* eslint-enable no-var */\n}\n\n/**\n * Calls global __PIXI_APP_INIT__ hook with the application instance, after the application is initialized.\n * @category app\n * @internal\n */\nexport class ApplicationInitHook\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n    public static init(): void\n    {\n        globalThis.__PIXI_APP_INIT__?.(this as unknown as Application, VERSION);\n    }\n    public static destroy(): void\n    {\n        // nothing to do\n    }\n}\n\n/**\n * Calls global __PIXI_RENDERER_INIT__ hook with the renderer instance, after the renderer is initialized.\n * @category rendering\n * @internal\n */\nexport class RendererInitHook implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'initHook',\n        priority: -10,\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n    public init(): void\n    {\n        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);\n    }\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { Matrix } from '../../maths/matrix/Matrix';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix';\nimport { Filter } from '../Filter';\nimport fragment from './mask.frag';\nimport vertex from './mask.vert';\nimport source from './mask.wgsl';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Sprite } from '../../scene/sprite/Sprite';\nimport type { FilterOptions } from '../Filter';\nimport type { FilterSystem } from '../FilterSystem';\n\n/** @internal */\nexport interface MaskFilterOptions extends FilterOptions\n{\n    sprite: Sprite,\n    inverse?: boolean;\n    scale?: number | { x: number, y: number },\n}\n\n/** @internal */\nexport class MaskFilter extends Filter\n{\n    public sprite: Sprite;\n    private readonly _textureMatrix: TextureMatrix;\n\n    constructor(options: MaskFilterOptions)\n    {\n        const { sprite, ...rest } = options;\n\n        const textureMatrix = new TextureMatrix(sprite.texture);\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uMaskClamp: { value: textureMatrix.uClampFrame, type: 'vec4<f32>' },\n            uAlpha: { value: 1, type: 'f32' },\n            uInverse: { value: options.inverse ? 1 : 0, type: 'f32' },\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'mask-filter',\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            clipToViewport: false,\n            resources: {\n                filterUniforms,\n                uMaskTexture: sprite.texture.source,\n            },\n        });\n\n        this.sprite = sprite;\n\n        this._textureMatrix = textureMatrix;\n    }\n\n    set inverse(value: boolean)\n    {\n        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n    }\n\n    get inverse(): boolean\n    {\n        return this.resources.filterUniforms.uniforms.uInverse === 1;\n    }\n\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        // will trigger an update if the texture changed..\n        this._textureMatrix.texture = this.sprite.texture;\n\n        filterManager.calculateSpriteMatrix(\n            this.resources.filterUniforms.uniforms.uFilterMatrix as Matrix,\n            this.sprite\n        ).prepend(this._textureMatrix.mapCoord);\n\n        this.resources.uMaskTexture = this.sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n","import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { DefaultBatcher } from './DefaultBatcher';\n\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Renderer } from '../../renderers/types';\nimport type { Batch, BatchableElement, Batcher } from './Batcher';\n\n/** @internal */\nexport interface BatcherAdaptor\n{\n    start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    init?(batchPipe: BatcherPipe): void;\n    execute(batchPipe: BatcherPipe, batch: Batch): void\n    contextChange?(): void;\n}\n\n/**\n * A pipe that batches elements into batches and sends them to the renderer.\n *\n * You can install new Batchers using ExtensionType.Batcher. Each render group will\n * have a default batcher and any required ones will be created on demand.\n * @category rendering\n * @advanced\n */\nexport class BatcherPipe implements InstructionPipe<Batch>, BatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'batch',\n    } as const;\n\n    public state: State = State.for2d();\n    public renderer: Renderer;\n\n    private readonly _batchersByInstructionSet: Record<number, Record<string, Batcher>> = Object.create(null);\n\n    private _adaptor: BatcherAdaptor;\n\n    /** A record of all active batchers, keyed by their names */\n    private _activeBatches: Record<string, Batcher> = Object.create(null);\n\n    /** The currently active batcher being used to batch elements */\n    private _activeBatch: Batcher;\n\n    public static _availableBatchers: Record<string, new () => Batcher> = Object.create(null);\n\n    public static getBatcher(name: string): Batcher\n    {\n        return new this._availableBatchers[name as keyof typeof this._availableBatchers]();\n    }\n\n    constructor(renderer: Renderer, adaptor: BatcherAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init?.(this);\n    }\n\n    public buildStart(instructionSet: InstructionSet)\n    {\n        let batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        if (!batchers)\n        {\n            batchers = this._batchersByInstructionSet[instructionSet.uid] = Object.create(null);\n            batchers.default ||= new DefaultBatcher({\n                maxTextures: this.renderer.limits.maxBatchableTextures,\n            });\n        }\n\n        this._activeBatches = batchers;\n\n        this._activeBatch = this._activeBatches.default;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].begin();\n        }\n    }\n\n    public addToBatch(batchableObject: BatchableElement, instructionSet: InstructionSet)\n    {\n        if (this._activeBatch.name !== batchableObject.batcherName)\n        {\n            this._activeBatch.break(instructionSet);\n\n            let batch = this._activeBatches[batchableObject.batcherName];\n\n            if (!batch)\n            {\n                batch = this._activeBatches[batchableObject.batcherName]\n                    = BatcherPipe.getBatcher(batchableObject.batcherName);\n                batch.begin();\n            }\n\n            this._activeBatch = batch;\n        }\n\n        this._activeBatch.add(batchableObject);\n    }\n\n    public break(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n    }\n\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n\n        const batches = this._activeBatches;\n\n        for (const i in batches)\n        {\n            const batch = batches[i as keyof typeof batches];\n            const geometry = batch.geometry;\n\n            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n\n            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n        }\n    }\n\n    public upload(instructionSet: InstructionSet)\n    {\n        const batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        for (const i in batchers)\n        {\n            const batcher = batchers[i as keyof typeof batchers];\n            const geometry = batcher.geometry;\n\n            if (batcher.dirty)\n            {\n                batcher.dirty = false;\n\n                geometry.buffers[0].update(batcher.attributeSize * 4);\n            }\n        }\n    }\n\n    public execute(batch: Batch)\n    {\n        if (batch.action === 'startBatch')\n        {\n            const batcher = batch.batcher;\n            const geometry = batcher.geometry;\n            const shader = batcher.shader;\n\n            this._adaptor.start(this, geometry, shader);\n        }\n\n        this._adaptor.execute(this, batch);\n    }\n\n    public destroy()\n    {\n        this.state = null;\n        this.renderer = null;\n\n        this._adaptor = null;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].destroy();\n        }\n\n        this._activeBatches = null;\n    }\n}\n\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\n\nextensions.add(DefaultBatcher);\n","/** @internal */\nexport const textureBit = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* wgsl */`\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `,\n        main: /* wgsl */`\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `,\n        main: /* wgsl */`\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    }\n};\n\n/** @internal */\nexport const textureBitGl = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureMatrix;\n        `,\n        main: /* glsl */`\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n        uniform sampler2D uTexture;\n\n\n        `,\n        main: /* glsl */`\n            outColor = texture(uTexture, vUV);\n        `\n    }\n};\n\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { ColorMask } from './ColorMask';\n\n/** @internal */\nexport interface ColorMaskInstruction extends Instruction\n{\n    renderPipeId: 'colorMask',\n    colorMask: number,\n}\n\n/** @internal */\nexport class ColorMaskPipe implements InstructionPipe<ColorMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private _colorStack: number[] = [];\n    private _colorStackIndex = 0;\n    private _currentColor = 0;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public buildStart()\n    {\n        this._colorStack[0] = 0xF;\n        this._colorStackIndex = 1;\n        this._currentColor = 0xF;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & (mask as ColorMask).mask;\n\n        const currentColor = this._colorStack[this._colorStackIndex];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n\n        this._colorStackIndex++;\n    }\n\n    public pop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        this._colorStackIndex--;\n\n        const currentColor = colorStack[this._colorStackIndex - 1];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n    }\n\n    public execute(instruction: ColorMaskInstruction)\n    {\n        const renderer = this._renderer;\n\n        renderer.colorMask.setMask(instruction.colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorStack = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { CLEAR } from '../../renderers/gl/const';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMask } from './StencilMask';\n\n/** @internal */\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\n/** @internal */\nexport interface StencilMaskInstruction extends Instruction\n{\n    renderPipeId: 'stencilMask',\n    action: MaskMode,\n    inverse: boolean,\n    mask: StencilMask,\n}\n\n/** @internal */\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n\n    // used when building and also when executing..\n    private _maskStackHash: Record<number, number> = {};\n\n    private _maskHash = new WeakMap<StencilMask, {\n        instructionsStart: number,\n        instructionsLength: number,\n    }>();\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskContainer = effect.mask;\n\n        maskContainer.includeInBuild = true;\n\n        if (!this._maskHash.has(effect))\n        {\n            this._maskHash.set(effect, {\n                instructionsStart: 0,\n                instructionsLength: 0,\n            });\n        }\n\n        const maskData = this._maskHash.get(effect);\n\n        maskData.instructionsStart = instructionSet.instructionSize;\n\n        maskContainer.collectRenderables(\n            instructionSet,\n            renderer,\n            null\n        );\n\n        maskContainer.includeInBuild = false;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskEnd',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n\n        maskData.instructionsLength = instructionsLength;\n\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        this._maskStackHash[renderTargetUid] ??= 0;\n    }\n\n    public pop(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        // stencil is stored based on current render target..\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskBegin',\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskData = this._maskHash.get(mask as StencilMask);\n\n        for (let i = 0; i < maskData.instructionsLength; i++)\n        {\n            // eslint-disable-next-line max-len\n            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        }\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        let maskStackIndex = this._maskStackHash[renderTargetUid] ??= 0;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            // we create the depth and stencil buffers JIT\n            // as no point allocating the memory if we don't use it\n            renderer.renderTarget.ensureDepthStencil();\n\n            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n\n            maskStackIndex++;\n\n            renderer.colorMask.setMask(0);\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n        else if (instruction.action === 'popMaskBegin')\n        {\n            renderer.colorMask.setMask(0);\n\n            if (maskStackIndex !== 0)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.renderTarget.clear(null, CLEAR.STENCIL);\n                renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n            }\n\n            maskStackIndex--;\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter';\nimport { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../renderers/types';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { Renderer } from '../../renderers/types';\nimport type { AlphaMask } from './AlphaMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nconst tempBounds = new Bounds();\n\n/** @internal */\nclass AlphaMaskEffect extends FilterEffect implements PoolItem\n{\n    constructor()\n    {\n        super();\n\n        this.filters = [new MaskFilter({\n            sprite: new Sprite(Texture.EMPTY),\n            inverse: false,\n            resolution: 'inherit',\n            antialias: 'inherit'\n        })];\n    }\n\n    get sprite(): Sprite\n    {\n        return (this.filters[0] as MaskFilter).sprite;\n    }\n\n    set sprite(value: Sprite)\n    {\n        (this.filters[0] as MaskFilter).sprite = value;\n    }\n\n    get inverse(): boolean\n    {\n        return (this.filters[0] as MaskFilter).inverse;\n    }\n\n    set inverse(value: boolean)\n    {\n        (this.filters[0] as MaskFilter).inverse = value;\n    }\n\n    public init: () => void;\n}\n\n/** @internal */\nexport interface AlphaMaskInstruction extends Instruction\n{\n    renderPipeId: 'alphaMask',\n    action: MaskMode,\n    mask: AlphaMask,\n    inverse: boolean;\n    maskedContainer: Container,\n    renderMask: boolean,\n}\n\n/** @internal */\nexport interface AlphaMaskData\n{\n    filterEffect: AlphaMaskEffect,\n    maskedContainer: Container,\n    previousRenderTarget?: RenderTarget,\n    filterTexture?: Texture,\n}\n\n/** @internal */\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'alphaMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _activeMaskStage: AlphaMaskData[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n            maskedContainer\n        } as AlphaMaskInstruction);\n\n        (mask as AlphaMask).inverse = maskedContainer._maskOptions.inverse;\n\n        if ((mask as AlphaMask).renderMaskToTexture)\n        {\n            const maskContainer = (mask as AlphaMask).mask;\n\n            maskContainer.includeInBuild = true;\n\n            maskContainer.collectRenderables(\n                instructionSet,\n                renderer,\n                null\n            );\n\n            maskContainer.includeInBuild = false;\n        }\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskEnd',\n            mask,\n            maskedContainer,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public pop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'popMaskEnd',\n            mask,\n            inverse: _maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public execute(instruction: AlphaMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const filterEffect = BigPool.get(AlphaMaskEffect);\n\n            filterEffect.inverse = instruction.inverse;\n\n            if (renderMask)\n            {\n                instruction.mask.mask.measurable = true;\n\n                const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n                instruction.mask.mask.measurable = false;\n\n                bounds.ceil();\n\n                const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n                const filterTexture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    colorTextureSource._resolution,\n                    colorTextureSource.antialias\n                );\n\n                renderer.renderTarget.push(filterTexture, true);\n\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 0xFFFFFFFF\n                });\n\n                const sprite = filterEffect.sprite;\n\n                sprite.texture = filterTexture;\n\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture,\n                });\n            }\n            else\n            {\n                filterEffect.sprite = instruction.mask.mask as Sprite;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                });\n            }\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n\n            if (renderMask)\n            {\n                // WebGPU blit's automatically, but WebGL does not!\n                if (renderer.type === RendererType.WEBGL)\n                {\n                    renderer.renderTarget.finishRenderPass();\n                }\n\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n\n            renderer.filter.push({\n                renderPipeId: 'filter',\n                action: 'pushFilter',\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false,\n            });\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.filter.pop();\n\n            const maskData = this._activeMaskStage.pop();\n\n            if (renderMask)\n            {\n                TexturePool.returnTexture(maskData.filterTexture);\n            }\n\n            BigPool.return(maskData.filterEffect);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n","import { STENCIL_MODES } from '../../shared/state/const';\n\n/**\n * The stencil state for the GPU renderer.\n * This is used to define how the stencil buffer should be configured.\n * @category rendering\n * @advanced\n */\nexport interface StencilState\n{\n    stencilWriteMask?: number\n    stencilReadMask?: number;\n    stencilFront?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    },\n    stencilBack?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    }\n}\n\n/** @internal */\nexport const GpuStencilModesToPixi: StencilState[] = [];\n\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = undefined;\n\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n    stencilWriteMask: 0,\n    stencilReadMask: 0,\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'not-equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'not-equal',\n        passOp: 'keep',\n    },\n};\n","import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in any gaps. We do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of the time users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way,\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n * @internal\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n","import type { UNIFORM_TYPES_SINGLE } from '../types';\n\nfunction loopMatrix(col: number, row: number)\n{\n    const total = col * row;\n\n    return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\n\n/** @internal */\nexport const uboSyncFunctionsSTD40: Record<UNIFORM_TYPES_SINGLE, string> = {\n    f32: `\n        data[offset] = v;`,\n    i32: `\n        dataInt32[offset] = v;`,\n    'vec2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n    'vec3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n    'vec4<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n    'vec2<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n    'vec3<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n    'vec4<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n    'mat3x3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n    'mat4x4<f32>': `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n    'mat3x2<f32>': loopMatrix(3, 2),\n    'mat4x2<f32>': loopMatrix(4, 2),\n    'mat2x3<f32>': loopMatrix(2, 3),\n    'mat4x3<f32>': loopMatrix(4, 3),\n    'mat2x4<f32>': loopMatrix(2, 4),\n    'mat3x4<f32>': loopMatrix(3, 4),\n};\n\n/** @internal */\nexport const uboSyncFunctionsWGSL: Record<UNIFORM_TYPES_SINGLE, string> = {\n    ...uboSyncFunctionsSTD40,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `,\n};\n","// Parsers, each one of these will take a look at the type of shader property and uniform.\n// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.\n// Shader upload code is automagically generated with these parsers.\n// If no parser is valid then the default upload functions are used.\n// exposing Parsers means that custom upload logic can be added to pixi's shaders.\n// A good example would be a pixi rectangle can be directly set on a uniform.\n// If the shader sees it it knows how to upload the rectangle structure as a vec4\n// format is as follows:\n//\n// {\n//     test: (data, uniform) => {} <--- test is this code should be used for this uniform\n//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform\n//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the\n//                                         uniform to a uniform buffer\n// }\n// import { Texture } from '../../texture/Texture';\n\nimport type { Color } from '../../../../../color/Color';\nimport type { Matrix } from '../../../../../maths/matrix/Matrix';\nimport type { PointLike } from '../../../../../maths/point/PointLike';\nimport type { Rectangle } from '../../../../../maths/shapes/Rectangle';\nimport type { UNIFORM_TYPES, UniformData } from '../types';\n\ninterface UniformParserDefinition\n{\n    type: UNIFORM_TYPES;\n    test(data: UniformData): boolean;\n    ubo?: string;\n    uboWgsl?: string;\n    uboStd40?: string;\n    uniform?: string;\n}\n\n/** @internal */\nexport const uniformParsers: UniformParserDefinition[] = [\n    // uploading pixi matrix object to mat3\n    {\n        type: 'mat3x3<f32>',\n        test: (data: UniformData): boolean =>\n        {\n            const value = data.value as Matrix;\n\n            return value.a !== undefined;\n        },\n        ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n        uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n    },\n    // uploading a pixi rectangle as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Rectangle).width !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n    },\n    // uploading a pixi point as a vec2\n    {\n        type: 'vec2<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec2<f32>' && data.size === 1 && (data.value as PointLike).x !== undefined,\n        ubo:  `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n    },\n    // uploading a pixi color as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n    },\n    // uploading a pixi color as a vec3\n    {\n        type: 'vec3<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec3<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n    },\n];\n","import { uniformParsers } from './uniformParsers';\n\nimport type { UboElement, UNIFORM_TYPES_SINGLE, UniformsSyncCallback } from '../types';\n\n/**\n * @param uboElements\n * @param parserCode\n * @param arrayGenerationFunction\n * @param singleSettersMap\n * @internal\n */\nexport function createUboSyncFunction(\n    uboElements: UboElement[],\n    parserCode: 'uboWgsl' | 'uboStd40',\n    arrayGenerationFunction: (uboElement: UboElement, offsetToAdd: number) => string,\n    singleSettersMap: Record<UNIFORM_TYPES_SINGLE, string>,\n): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n\n    let prev = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n        let offset = 0;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.test(uboElement.data))\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(\n                    `name = \"${name}\";`,\n                    `offset += ${offset - prev};`,\n                    uniformParsers[j][parserCode] || uniformParsers[j].ubo);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n            }\n            else\n            {\n                const template = singleSettersMap[uboElement.data.type as UNIFORM_TYPES_SINGLE];\n\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(/* wgsl */`\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `);\n            }\n        }\n\n        prev = offset;\n    }\n\n    const fragmentSrc = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function(\n        'uv',\n        'data',\n        'dataInt32',\n        'offset',\n        fragmentSrc,\n    ) as UniformsSyncCallback;\n}\n","import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { Buffer } from '../buffer/Buffer';\nimport { BufferUsage } from '../buffer/const';\n\nimport type { System } from '../system/System';\nimport type { UboElement, UboLayout, UniformData, UniformsSyncCallback } from './types';\nimport type { UniformGroup } from './UniformGroup';\n\n/** @internal */\nexport interface UboAdaptor\n{\n    createUboElements: (uniformData: UniformData[]) => UboLayout;\n    generateUboSync: (uboElements: UboElement[]) => UniformsSyncCallback;\n}\n\n/**\n * System plugin to the renderer to manage uniform buffers.\n * @category rendering\n * @advanced\n */\nexport class UboSystem implements System\n{\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    private _syncFunctionHash: Record<string, {\n        layout: UboLayout,\n        syncFunction: (uniforms: Record<string, any>, data: Float32Array, dataInt32: Int32Array, offset: number) => void\n    }> = Object.create(null);\n\n    private readonly _adaptor: UboAdaptor;\n\n    constructor(adaptor: UboAdaptor)\n    {\n        this._adaptor = adaptor;\n\n        // Validation check that this environment support `new Function`\n        this._systemCheck();\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     */\n    private _systemCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n                 + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n\n    public ensureUniformGroup(uniformGroup: UniformGroup): void\n    {\n        const uniformData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n    }\n\n    public getUniformGroupData(uniformGroup: UniformGroup)\n    {\n        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n    }\n\n    private _initUniformGroup(uniformGroup: UniformGroup)\n    {\n        const uniformGroupSignature = uniformGroup._signature;\n\n        let uniformData = this._syncFunctionHash[uniformGroupSignature];\n\n        if (!uniformData)\n        {\n            const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n\n            const layout = this._adaptor.createUboElements(elements);\n\n            const syncFunction = this._generateUboSync(layout.uboElements);\n\n            uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n                layout,\n                syncFunction\n            };\n        }\n\n        return this._syncFunctionHash[uniformGroupSignature];\n    }\n\n    private _generateUboSync(\n        uboElements: UboElement[],\n    ): UniformsSyncCallback\n    {\n        return this._adaptor.generateUboSync(uboElements);\n    }\n\n    public syncUniformGroup(uniformGroup: UniformGroup, data?: Float32Array, offset?: number): boolean\n    {\n        const uniformGroupData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformGroupData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n\n        let dataInt32: Int32Array = null;\n\n        if (!data)\n        {\n            data = uniformGroup.buffer.data as Float32Array;\n            dataInt32 = uniformGroup.buffer.dataInt32;\n        }\n        offset ||= 0;\n\n        uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n\n        return true;\n    }\n\n    public updateUniformGroup(uniformGroup: UniformGroup): boolean\n    {\n        if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n        uniformGroup._dirtyId = 0;\n\n        const synced = this.syncUniformGroup(uniformGroup);\n\n        uniformGroup.buffer.update();\n\n        return synced;\n    }\n\n    public destroy(): void\n    {\n        this._syncFunctionHash = null;\n    }\n}\n","import type { Matrix } from '../../../../maths/matrix/Matrix';\n\n/**\n * @param pm\n * @param x\n * @param y\n * @param width\n * @param height\n * @param flipY\n * @internal\n */\nexport function calculateProjection(\n    pm: Matrix,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    flipY: boolean\n): Matrix\n{\n    const sign = flipY ? 1 : -1;\n\n    pm.identity();\n\n    pm.a = (1 / width * 2);\n    pm.d = sign * (1 / height * 2);\n\n    pm.tx = -1 - (x * pm.a);\n    pm.ty = -sign - (y * pm.d);\n\n    return pm;\n}\n","import { GlobalResourceRegistry } from '../../../../../utils/pool/GlobalResourceRegistry';\nimport { CanvasSource } from '../sources/CanvasSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\n\nconst canvasCache: Map<ICanvas, Texture<CanvasSource>> = new Map();\n\nGlobalResourceRegistry.register(canvasCache);\n\n/**\n * @param canvas\n * @param options\n * @internal\n */\nexport function getCanvasTexture(canvas: ICanvas, options?: CanvasSourceOptions): Texture<CanvasSource>\n{\n    if (!canvasCache.has(canvas))\n    {\n        const texture = new Texture({\n            source: new CanvasSource({\n                resource: canvas,\n                ...options,\n            })\n        });\n\n        const onDestroy = () =>\n        {\n            if (canvasCache.get(canvas) === texture)\n            {\n                canvasCache.delete(canvas);\n            }\n        };\n\n        texture.once('destroy', onDestroy);\n        texture.source.once('destroy', onDestroy);\n\n        canvasCache.set(canvas, texture);\n    }\n\n    return canvasCache.get(canvas);\n}\n\n/**\n * @param canvas\n * @internal\n */\nexport function hasCachedCanvasTexture(canvas: ICanvas): boolean\n{\n    return canvasCache.has(canvas);\n}\n","/* eslint-disable no-restricted-globals */\nimport type { RenderTarget } from './RenderTarget';\n\n/**\n * Checks if the render target is viewable on the screen\n * Basically, is it a canvas element and is that canvas element in the DOM\n * @param renderTarget - the render target to check\n * @returns true if the render target is viewable on the screen\n * @internal\n */\nexport function isRenderingToScreen(renderTarget: RenderTarget): boolean\n{\n    const resource = renderTarget.colorTexture.source.resource;\n\n    return ((globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement) && document.body.contains(resource));\n}\n","// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @category rendering\n * @advanced\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @category rendering\n * @advanced\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    /** unique id for this render target */\n    public readonly uid: number = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    private readonly _managedColorTextures: boolean = false;\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            this._managedColorTextures = true;\n\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this._managedColorTextures)\n        {\n            this.colorTextures.forEach((texture) =>\n            {\n                texture.destroy();\n            });\n        }\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { CLEAR } from '../../gl/const';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection';\nimport { SystemRunner } from '../system/SystemRunner';\nimport { CanvasSource } from '../texture/sources/CanvasSource';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\nimport { isRenderingToScreen } from './isRenderingToScreen';\nimport { RenderTarget } from './RenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { GlRenderTarget } from '../../gl/GlRenderTarget';\nimport type { GpuRenderTarget } from '../../gpu/renderTarget/GpuRenderTarget';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * A render surface is a texture, canvas, or render target\n * @category rendering\n * @see environment.ICanvas\n * @see Texture\n * @see RenderTarget\n * @advanced\n */\nexport type RenderSurface = ICanvas | BindableTexture | RenderTarget;\n\n/**\n * stores a render target and its frame\n * @ignore\n */\ninterface RenderTargetAndFrame\n{\n    /** the render target */\n    renderTarget: RenderTarget;\n    /** the frame to use when using the render target */\n    frame: Rectangle\n}\n\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @ignore\n */\nexport interface RenderTargetAdaptor<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget>\n{\n    init(\n        /** the renderer */\n        renderer: Renderer,\n        /** the render target system */\n        renderTargetSystem: RenderTargetSystem<RENDER_TARGET>\n    ): void\n\n    /** A function copies the contents of a render surface to a texture */\n    copyToTexture(\n        /** the render surface to copy from  */\n        sourceRenderSurfaceTexture: RenderTarget,\n        /** the texture to copy to */\n        destinationTexture: Texture,\n        /** the origin of the copy */\n        originSrc: { x: number; y: number },\n        /** the size of the copy */\n        size: { width: number; height: number },\n        /** the destination origin (top left to paste from!) */\n        originDest?: { x: number; y: number },\n    ): Texture\n\n    /** starts a render pass on the render target */\n    startRenderPass(\n        /** the render target to start the render pass on */\n        renderTarget: RenderTarget,\n        /* the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111* */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** clears the current render target to the specified color */\n    clear(\n        /** the render target to clear */\n        renderTarget: RenderTarget,\n        /** the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111 */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to   */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** finishes the current render pass */\n    finishRenderPass(renderTarget: RenderTarget): void\n\n    /** called after the render pass is finished */\n    postrender?(renderTarget: RenderTarget): void;\n\n    /** called before the render main pass is started */\n    prerender?(renderTarget: RenderTarget): void;\n\n    /**\n     * initializes a gpu render target. Both renderers use this function to initialize a gpu render target\n     * Its different type of object depending on the renderer.\n     */\n    initGpuRenderTarget(\n        /** the render target to initialize */\n        renderTarget: RenderTarget\n    ): RENDER_TARGET\n\n    /** called when a render target is resized */\n    resizeGpuRenderTarget(\n        /** the render target to resize */\n        renderTarget: RenderTarget\n    ): void\n\n    /** destroys the gpu render target */\n    destroyGpuRenderTarget(\n        /** the render target to destroy */\n        gpuRenderTarget: RENDER_TARGET\n    ): void\n}\n\n/**\n * A system that manages render targets. A render target is essentially a place where the shaders can color in the pixels.\n * The render target system is responsible for binding the render target to the renderer, and managing the viewport.\n * Render targets can be pushed and popped.\n *\n * To make it easier, you can also bind textures and canvases too. This will automatically create a render target for you.\n * The render target itself is a lot more powerful than just a texture or canvas,\n * as it can have multiple textures attached to it.\n * It will also give ou fine grain control over the stencil buffer / depth texture.\n * @example\n *\n * ```js\n *\n * // create a render target\n * const renderTarget = new RenderTarget({\n *   colorTextures: [new TextureSource({ width: 100, height: 100 })],\n * });\n *\n * // bind the render target\n * renderer.renderTarget.bind(renderTarget);\n *\n * // draw something!\n * ```\n * @category rendering\n * @advanced\n */\nexport class RenderTargetSystem<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget> implements System\n{\n    /** When rendering of a scene begins, this is where the root render surface is stored */\n    public rootRenderTarget: RenderTarget;\n    /** This is the root viewport for the render pass*/\n    public rootViewPort = new Rectangle();\n    /** A boolean that lets the dev know if the current render pass is rendering to the screen. Used by some plugins */\n    public renderingToScreen: boolean;\n    /** the current active render target */\n    public renderTarget: RenderTarget;\n    /** the current active render surface that the render target is created from */\n    public renderSurface: RenderSurface;\n    /** the current viewport that the gpu is using */\n    public readonly viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    public readonly onRenderTargetChange = new SystemRunner('onRenderTargetChange');\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    public readonly projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    public readonly defaultClearColor: RgbaArray = [0, 0, 0, 0];\n    /** a reference to the adaptor that interfaces with WebGL / WebGP */\n    public readonly adaptor: RenderTargetAdaptor<RENDER_TARGET>;\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    private readonly _renderSurfaceToRenderTargetHash: Map<RenderSurface, RenderTarget>\n        = new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    private _gpuRenderTargetHash: Record<number, RENDER_TARGET> = Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    private readonly _renderTargetStack: RenderTargetAndFrame[] = [];\n    /** A reference to the renderer */\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuRenderTargetHash');\n    }\n\n    /** called when dev wants to finish a render pass */\n    public finishRenderPass()\n    {\n        this.adaptor.finishRenderPass(this.renderTarget);\n    }\n\n    /**\n     * called when the renderer starts to render a scene.\n     * @param options\n     * @param options.target - the render target to render to\n     * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param options.clearColor - the color to clear to\n     * @param options.frame - the frame to render to\n     */\n    public renderStart({\n        target,\n        clear,\n        clearColor,\n        frame\n    }: {\n        target: RenderSurface;\n        clear: CLEAR_OR_BOOL;\n        clearColor: RgbaArray;\n        frame?: Rectangle\n    }): void\n    {\n        // TODO no need to reset this - use optimised index instead\n        this._renderTargetStack.length = 0;\n\n        this.push(\n            target,\n            clear,\n            clearColor,\n            frame\n        );\n\n        this.rootViewPort.copyFrom(this.viewport);\n        this.rootRenderTarget = this.renderTarget;\n        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n\n        this.adaptor.prerender?.(this.rootRenderTarget);\n    }\n\n    public postrender()\n    {\n        this.adaptor.postrender?.(this.rootRenderTarget);\n    }\n\n    /**\n     * Binding a render surface! This is the main function of the render target system.\n     * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n     * Once bound all draw calls will be rendered to the render surface.\n     *\n     * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n     * @param renderSurface - the render surface to bind\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to render to\n     * @returns the render target that was bound\n     */\n    public bind(\n        renderSurface: RenderSurface,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    ): RenderTarget\n    {\n        const renderTarget = this.getRenderTarget(renderSurface);\n\n        const didChange = this.renderTarget !== renderTarget;\n\n        this.renderTarget = renderTarget;\n        this.renderSurface = renderSurface;\n\n        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.pixelWidth !== gpuRenderTarget.width\n            || renderTarget.pixelHeight !== gpuRenderTarget.height)\n        {\n            this.adaptor.resizeGpuRenderTarget(renderTarget);\n\n            gpuRenderTarget.width = renderTarget.pixelWidth;\n            gpuRenderTarget.height = renderTarget.pixelHeight;\n        }\n\n        const source = renderTarget.colorTexture;\n        const viewport = this.viewport;\n\n        const pixelWidth = source.pixelWidth;\n        const pixelHeight = source.pixelHeight;\n\n        if (!frame && renderSurface instanceof Texture)\n        {\n            frame = renderSurface.frame;\n        }\n\n        if (frame)\n        {\n            const resolution = source._resolution;\n\n            viewport.x = ((frame.x * resolution) + 0.5) | 0;\n            viewport.y = ((frame.y * resolution) + 0.5) | 0;\n            viewport.width = ((frame.width * resolution) + 0.5) | 0;\n            viewport.height = ((frame.height * resolution) + 0.5) | 0;\n        }\n        else\n        {\n            viewport.x = 0;\n            viewport.y = 0;\n            viewport.width = pixelWidth;\n            viewport.height = pixelHeight;\n        }\n\n        calculateProjection(\n            this.projectionMatrix,\n            0, 0,\n            viewport.width / source.resolution,\n            viewport.height / source.resolution,\n            !renderTarget.isRoot\n        );\n\n        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n\n        if (didChange)\n        {\n            this.onRenderTargetChange.emit(renderTarget);\n        }\n\n        return renderTarget;\n    }\n\n    public clear(\n        target?: RenderSurface,\n        clear: CLEAR_OR_BOOL = CLEAR.ALL,\n        clearColor?: RgbaArray,\n    )\n    {\n        if (!clear) return;\n\n        if (target)\n        {\n            target = this.getRenderTarget(target);\n        }\n\n        this.adaptor.clear(\n            (target as RenderTarget) || this.renderTarget,\n            clear,\n            clearColor,\n            this.viewport\n        );\n    }\n\n    protected contextChange(): void\n    {\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    /**\n     * Push a render surface to the renderer. This will bind the render surface to the renderer,\n     * @param renderSurface - the render surface to push\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to use when rendering to the render surface\n     */\n    public push(\n        renderSurface: RenderSurface,\n        clear: CLEAR | boolean = CLEAR.ALL,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    )\n    {\n        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n\n        this._renderTargetStack.push({\n            renderTarget,\n            frame,\n        });\n\n        return renderTarget;\n    }\n\n    /** Pops the current render target from the renderer and restores the previous render target. */\n    public pop()\n    {\n        this._renderTargetStack.pop();\n\n        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n\n        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n    }\n\n    /**\n     * Gets the render target from the provide render surface. Eg if its a texture,\n     * it will return the render target for the texture.\n     * If its a render target, it will return the same render target.\n     * @param renderSurface - the render surface to get the render target for\n     * @returns the render target for the render surface\n     */\n    public getRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        if (((renderSurface as Texture).isTexture))\n        {\n            renderSurface = (renderSurface as Texture).source;\n        }\n\n        return this._renderSurfaceToRenderTargetHash.get(renderSurface)\n        ?? this._initRenderTarget(renderSurface);\n    }\n\n    /**\n     * Copies a render surface to another texture.\n     *\n     * NOTE:\n     * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n     *\n     * The following is not valid:\n     * @example\n     * const canvas = document.createElement('canvas')\n     * canvas.width = 200;\n     * canvas.height = 200;\n     *\n     * const ctx = canvas2.getContext('2d')!\n     * ctx.fillStyle = 'red'\n     * ctx.fillRect(0, 0, 200, 200);\n     *\n     * const texture = RenderTexture.create({\n     *   width: 200,\n     *   height: 200,\n     * })\n     * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n     *\n     * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n     *\n     * The best way to copy a canvas is to create a texture from it. Then render with that.\n     *\n     * Parsing in a RenderTarget canvas context (with a 2d context)\n     * @param sourceRenderSurfaceTexture - the render surface to copy from\n     * @param destinationTexture - the texture to copy to\n     * @param originSrc - the origin of the copy\n     * @param originSrc.x - the x origin of the copy\n     * @param originSrc.y - the y origin of the copy\n     * @param size - the size of the copy\n     * @param size.width - the width of the copy\n     * @param size.height - the height of the copy\n     * @param originDest - the destination origin (top left to paste from!)\n     * @param originDest.x - the x origin of the paste\n     * @param originDest.y - the y origin of the paste\n     */\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest: { x: number; y: number; },\n    )\n    {\n        // fit the size to the source we don't want to go out of bounds\n\n        if (originSrc.x < 0)\n        {\n            size.width += originSrc.x;\n            originDest.x -= originSrc.x;\n            originSrc.x = 0;\n        }\n\n        if (originSrc.y < 0)\n        {\n            size.height += originSrc.y;\n            originDest.y -= originSrc.y;\n            originSrc.y = 0;\n        }\n\n        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n\n        size.width = Math.min(size.width, pixelWidth - originSrc.x);\n        size.height = Math.min(size.height, pixelHeight - originSrc.y);\n\n        return this.adaptor.copyToTexture(\n            sourceRenderSurfaceTexture,\n            destinationTexture,\n            originSrc,\n            size,\n            originDest\n        );\n    }\n\n    /**\n     * ensures that we have a depth stencil buffer available to render to\n     * This is used by the mask system to make sure we have a stencil buffer.\n     */\n    public ensureDepthStencil()\n    {\n        if (!this.renderTarget.stencil)\n        {\n            this.renderTarget.stencil = true;\n\n            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n        }\n    }\n\n    /** nukes the render target system */\n    public destroy()\n    {\n        (this._renderer as null) = null;\n\n        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) =>\n        {\n            if (renderTarget !== key)\n            {\n                renderTarget.destroy();\n            }\n        });\n\n        this._renderSurfaceToRenderTargetHash.clear();\n\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    private _initRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        let renderTarget: RenderTarget = null;\n\n        if (CanvasSource.test(renderSurface))\n        {\n            renderSurface = getCanvasTexture(renderSurface as ICanvas).source;\n        }\n\n        if (renderSurface instanceof RenderTarget)\n        {\n            renderTarget = renderSurface;\n        }\n        else if (renderSurface instanceof TextureSource)\n        {\n            renderTarget = new RenderTarget({\n                colorTextures: [renderSurface],\n            });\n\n            if (renderSurface.source instanceof CanvasSource)\n            {\n                renderTarget.isRoot = true;\n            }\n\n            // TODO add a test for this\n            renderSurface.once('destroy', () =>\n            {\n                renderTarget.destroy();\n\n                this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n\n                const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n\n                if (gpuRenderTarget)\n                {\n                    this._gpuRenderTargetHash[renderTarget.uid] = null;\n                    this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n                }\n            });\n        }\n\n        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n\n        return renderTarget;\n    }\n\n    public getGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        return this._gpuRenderTargetHash[renderTarget.uid]\n        || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n    }\n\n    public resetState(): void\n    {\n        this.renderTarget = null;\n        this.renderSurface = null;\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from './Buffer';\n\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @category rendering\n * @advanced\n */\nexport class BufferResource extends EventEmitter<{\n    change: BindResource,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    public readonly _resourceType = 'bufferResource';\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    public _touched = 0;\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    public _resourceId = uid('resource');\n\n    /** the underlying buffer that this resource is using */\n    public buffer: Buffer;\n    /** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n    public readonly offset: number;\n    /** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n    public readonly size: number;\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     */\n    public readonly _bufferResource = true;\n\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Create a new Buffer Resource.\n     * @param options - The options for the buffer resource\n     * @param options.buffer - The underlying buffer that this resource is using\n     * @param options.offset - The offset of the buffer this resource is using.\n     * If not provided, then it will use the offset of the buffer.\n     * @param options.size - The size of the buffer this resource is using.\n     * If not provided, then it will use the size of the buffer.\n     */\n    constructor({ buffer, offset, size }: { buffer: Buffer; offset?: number; size?: number; })\n    {\n        super();\n\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n\n        this.buffer.on('change', this.onBufferChange, this);\n    }\n\n    protected onBufferChange(): void\n    {\n        this._resourceId = uid('resource');\n\n        this.emit('change', this);\n    }\n\n    /**\n     * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n     * if you want to destroy it as well, or code will explode\n     * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n     */\n    public destroy(destroyBuffer = false): void\n    {\n        this.destroyed = true;\n\n        if (destroyBuffer)\n        {\n            this.buffer.destroy();\n        }\n\n        this.emit('change', this);\n\n        this.buffer = null;\n        this.removeAllListeners();\n    }\n}\n","import type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderPipes\n * @internal\n */\nexport function validateRenderables(renderGroup: RenderGroup, renderPipes: RenderPipes): boolean\n{\n    const { list } = renderGroup.childrenRenderablesToUpdate;\n\n    let rebuildRequired = false;\n\n    for (let i = 0; i < renderGroup.childrenRenderablesToUpdate.index; i++)\n    {\n        const container = list[i];\n\n        // note to self: there is no need to check if container.parentRenderGroup || !container.renderGroup\n        // exist here, as this function is only called if the structure did NOT change\n        // which means they have to be valid if this function is called\n\n        const renderable = container;\n        const pipe = renderPipes[renderable.renderPipeId as keyof RenderPipes] as RenderPipe<any>;\n\n        rebuildRequired = pipe.validateRenderable(container);\n\n        if (rebuildRequired)\n        {\n            break;\n        }\n    }\n\n    renderGroup.structureDidChange = rebuildRequired;\n\n    return rebuildRequired;\n}\n","/**\n * nulls all slots in an array from a certain index.\n * assume that when a null item is hit, the rest are also null.\n * Which will be the case for where this is used!\n * @param list - the array to clean\n * @param index - the index to start from\n * @category utils\n * @internal\n */\nexport function clearList(list: Array<unknown>, index?: number)\n{\n    index ||= 0;\n\n    for (let j = index; j < list.length; j++)\n    {\n        if (list[j])\n        {\n            list[j] = null;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n","import type { InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderer\n * @internal\n */\nexport function executeInstructions(renderGroup: RenderGroup, renderer: RenderPipes)\n{\n    const instructionSet = renderGroup.instructionSet;\n    const instructions = instructionSet.instructions;\n\n    for (let i = 0; i < instructionSet.instructionSize; i++)\n    {\n        const instruction = instructions[i];\n\n        (renderer[instruction.renderPipeId as keyof RenderPipes] as InstructionPipe<any>).execute(instruction);\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BatchableSprite } from './BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Sprite } from './Sprite';\n\n/** @internal */\nexport class SpritePipe implements RenderPipe<Sprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'sprite',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: Sprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        // TODO visibility\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: Sprite)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: Sprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture)\n        ;\n    }\n\n    private _updateBatchableSprite(sprite: Sprite, batchableSprite: BatchableSprite)\n    {\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: Sprite): BatchableSprite\n    {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: Sprite): BatchableSprite\n    {\n        const batchableSprite = new BatchableSprite();\n\n        batchableSprite.renderable = sprite;\n\n        batchableSprite.transform = sprite.groupTransform;\n        batchableSprite.texture = sprite._texture;\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        sprite._gpuData[this._renderer.uid] = batchableSprite;\n\n        return batchableSprite;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe, RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderContainer } from './RenderContainer';\n\n/**\n * The CustomRenderPipe is a render pipe that allows for custom rendering logic for your renderable objects.\n * @example\n * import { RenderContainer } from 'pixi.js';\n *\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * @category rendering\n * @internal\n */\nexport class CustomRenderPipe implements InstructionPipe<RenderContainer>, RenderPipe<RenderContainer>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'customRender',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public updateRenderable() { /** empty */ }\n    public destroyRenderable() { /** empty */ }\n    public validateRenderable() { return false; }\n\n    public addRenderable(container: RenderContainer, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add(container);\n    }\n\n    public execute(container: RenderContainer)\n    {\n        if (!container.isRenderable) return;\n\n        container.render(this._renderer);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_VISIBLE } from '../Container';\nimport { clearList } from './clearList';\nimport { multiplyColors } from './multiplyColors';\n\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { RenderGroup } from '../RenderGroup';\n\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\n\n/**\n * @param renderGroup\n * @param updateChildRenderGroups\n * @internal\n */\nexport function updateRenderGroupTransforms(renderGroup: RenderGroup, updateChildRenderGroups = false)\n{\n    updateRenderGroupTransform(renderGroup);\n\n    const childrenToUpdate = renderGroup.childrenToUpdate;\n\n    const updateTick = renderGroup.updateTick++;\n\n    for (const j in childrenToUpdate)\n    {\n        const renderGroupDepth = Number(j);\n\n        const childrenAtDepth = childrenToUpdate[j];\n\n        const list = childrenAtDepth.list;\n        const index = childrenAtDepth.index;\n\n        for (let i = 0; i < index; i++)\n        {\n            const child = list[i];\n\n            // check that these things match our layer and depth - if the renderGroup does not match,\n            // the child has been re-parented into another rendergroup since it asked to be updated so we can ignore it here\n            // secondly if the relativeRenderGroupDepth has changed, then the it means it will have been nested at a\n            // different different level in the render group - so we can wait for the update that does in fact match\n            if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth)\n            {\n                updateTransformAndChildren(child, updateTick, 0);\n            }\n        }\n\n        clearList(list, index);\n\n        childrenAtDepth.index = 0;\n    }\n\n    if (updateChildRenderGroups)\n    {\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n        }\n    }\n}\n\n/**\n * @param renderGroup\n * @internal\n */\nexport function updateRenderGroupTransform(renderGroup: RenderGroup)\n{\n    const root = renderGroup.root;\n\n    let worldAlpha;\n\n    if (renderGroup.renderGroupParent)\n    {\n        const renderGroupParent = renderGroup.renderGroupParent;\n\n        renderGroup.worldTransform.appendFrom(\n            root.relativeGroupTransform,\n            renderGroupParent.worldTransform,\n        );\n\n        renderGroup.worldColor = multiplyColors(\n            root.groupColor,\n            renderGroupParent.worldColor,\n        );\n\n        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n    }\n    else\n    {\n        renderGroup.worldTransform.copyFrom(root.localTransform);\n        renderGroup.worldColor = root.localColor;\n        worldAlpha = root.localAlpha;\n    }\n\n    // eslint-disable-next-line no-nested-ternary\n    worldAlpha = worldAlpha < 0 ? 0 : (worldAlpha > 1 ? 1 : worldAlpha);\n    renderGroup.worldAlpha = worldAlpha;\n\n    renderGroup.worldColorAlpha = renderGroup.worldColor\n            + (((worldAlpha * 255) | 0) << 24);\n}\n\n/**\n * @param container\n * @param updateTick\n * @param updateFlags\n * @internal\n */\nexport function updateTransformAndChildren(container: Container, updateTick: number, updateFlags: number)\n{\n    if (updateTick === container.updateTick) return;\n    container.updateTick = updateTick;\n\n    container.didChange = false;\n\n    const localTransform = container.localTransform;\n\n    container.updateLocalTransform();\n\n    const parent = container.parent;\n\n    if ((parent && !parent.renderGroup))\n    {\n        updateFlags |= container._updateFlags;\n\n        container.relativeGroupTransform.appendFrom(\n            localTransform,\n            parent.relativeGroupTransform,\n        );\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, parent, updateFlags);\n        }\n    }\n    else\n    {\n        updateFlags = container._updateFlags;\n\n        container.relativeGroupTransform.copyFrom(localTransform);\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, tempContainer, updateFlags);\n        }\n    }\n\n    // don't update children if its a layer..\n    if (!container.renderGroup)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            updateTransformAndChildren(children[i], updateTick, updateFlags);\n        }\n\n        const renderGroup = container.parentRenderGroup;\n        const renderable = container as ViewContainer;\n\n        if (renderable.renderPipeId && !renderGroup.structureDidChange)\n        {\n            renderGroup.updateRenderable(renderable);\n        }\n    }\n}\n\nfunction updateColorBlendVisibility(\n    container: Container,\n    parent: Container,\n    updateFlags: number,\n): void\n{\n    if (updateFlags & UPDATE_COLOR)\n    {\n        container.groupColor = multiplyColors(\n            container.localColor,\n            parent.groupColor\n        );\n\n        let groupAlpha = container.localAlpha * parent.groupAlpha;\n\n        // eslint-disable-next-line no-nested-ternary\n        groupAlpha = groupAlpha < 0 ? 0 : (groupAlpha > 1 ? 1 : groupAlpha);\n\n        container.groupAlpha = groupAlpha;\n        container.groupColorAlpha = container.groupColor + (((groupAlpha * 255) | 0) << 24);\n    }\n\n    if (updateFlags & UPDATE_BLEND)\n    {\n        container.groupBlendMode = container.localBlendMode === 'inherit' ? parent.groupBlendMode : container.localBlendMode;\n    }\n\n    if (updateFlags & UPDATE_VISIBLE)\n    {\n        container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n    }\n\n    container._updateFlags = 0;\n}\n\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\nimport { executeInstructions } from './utils/executeInstructions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The RenderGroupPipe is a render pipe for rendering RenderGroups.\n * @internal\n */\nexport class RenderGroupPipe implements InstructionPipe<RenderGroup>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderGroup(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n        }\n        else\n        {\n            this._addRenderableDirect(renderGroup, instructionSet);\n        }\n    }\n\n    public execute(renderGroup: RenderGroup)\n    {\n        if (!renderGroup.isRenderable) return;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._executeCacheAsTexture(renderGroup);\n        }\n        else\n        {\n            this._executeDirect(renderGroup);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n\n    private _addRenderableDirect(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        if (renderGroup._batchableRenderGroup)\n        {\n            BigPool.return(renderGroup._batchableRenderGroup);\n            renderGroup._batchableRenderGroup = null;\n        }\n\n        instructionSet.add(renderGroup);\n    }\n\n    private _addRenderableCacheAsTexture(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        const batchableRenderGroup = renderGroup._batchableRenderGroup ??= BigPool.get(BatchableSprite);\n\n        batchableRenderGroup.renderable = renderGroup.root;\n        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n        batchableRenderGroup.texture = renderGroup.texture;\n        batchableRenderGroup.bounds = renderGroup._textureBounds;\n\n        instructionSet.add(renderGroup);\n\n        this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);\n        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n        this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);\n    }\n\n    private _executeCacheAsTexture(renderGroup: RenderGroup): void\n    {\n        if (renderGroup.textureNeedsUpdate)\n        {\n            renderGroup.textureNeedsUpdate = false;\n\n            const worldTransformMatrix = tempMatrix\n                .identity()\n                .translate(\n                    -renderGroup._textureBounds.x,\n                    -renderGroup._textureBounds.y\n                );\n\n            this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n\n            this._renderer.globalUniforms.push({\n                worldTransformMatrix,\n                worldColor: 0xFFFFFFFF,\n                offset: { x: 0, y: 0 },\n            });\n\n            executeInstructions(renderGroup, this._renderer.renderPipes);\n\n            this._renderer.renderTarget.finishRenderPass();\n\n            this._renderer.renderTarget.pop();\n            this._renderer.globalUniforms.pop();\n        }\n\n        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n    }\n\n    private _executeDirect(renderGroup: RenderGroup): void\n    {\n        this._renderer.globalUniforms.push({\n            worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n            worldColor: renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(renderGroup, this._renderer.renderPipes);\n\n        this._renderer.globalUniforms.pop();\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { Bounds } from './bounds/Bounds';\nimport { clearList } from './utils/clearList';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer, RenderPipes } from '../../rendering/renderers/types';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @internal\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        // we need to save the parent and renderGroupParent, so we can restore them later\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        // we set the transforms and parents to null, so we can render the container without any transforms\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        const originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        //  this._assignTop(container.renderGroup, null);\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        this._updateCachedRenderGroups(container.renderGroup, null);\n\n        this._updateRenderGroups(container.renderGroup);\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        // now return the transforms back to normal..\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n\n    private _updateCachedRenderGroups(renderGroup: RenderGroup, closestCacheAsTexture: RenderGroup | null): void\n    {\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            // Early out as nothing further needs to be updated!\n            if (!renderGroup.textureNeedsUpdate) return;\n\n            closestCacheAsTexture = renderGroup;\n        }\n\n        // Update the closest cache reference for children if this render group is cached as texture\n        for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)\n        {\n            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        }\n\n        renderGroup.invalidateMatrices();\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            if (renderGroup.textureNeedsUpdate)\n            {\n                // lets get the texture ready for rendering\n                // but the rendering will not happen until the renderGroup is rendered!\n                // We also want to know now, what the bounds of the texture will be.\n                // as if the texture changes, we need to invalidate the parent render group!\n                const bounds = renderGroup.root.getLocalBounds();\n\n                bounds.ceil();\n\n                const lastTexture = renderGroup.texture;\n\n                if (renderGroup.texture)\n                {\n                    TexturePool.returnTexture(renderGroup.texture, true);\n                }\n\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n                const scaleMode = renderGroup.textureOptions.scaleMode ?? 'linear';\n                const texture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    resolution,\n                    antialias\n                );\n\n                texture._source.style = new TextureStyle({ scaleMode });\n                renderGroup.texture = texture;\n                renderGroup._textureBounds ||= new Bounds();\n                renderGroup._textureBounds.copyFrom(bounds);\n\n                if (lastTexture !== renderGroup.texture)\n                {\n                    if (renderGroup.renderGroupParent)\n                    {\n                        renderGroup.renderGroupParent.structureDidChange = true;\n                    }\n                }\n            }\n        }\n        else if (renderGroup.texture)\n        {\n            TexturePool.returnTexture(renderGroup.texture, true);\n            renderGroup.texture = null;\n        }\n    }\n\n    private _updateRenderGroups(renderGroup: RenderGroup): void\n    {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n\n        renderGroup.runOnRender(renderer);\n\n        renderGroup.instructionSet.renderPipes = renderPipes;\n\n        if (!renderGroup.structureDidChange)\n        {\n            // phase 1 - validate all the renderables\n            validateRenderables(renderGroup, renderPipes);\n        }\n        else\n        {\n            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n        }\n\n        // phase 2 - update all the transforms\n        // including updating the renderables..\n        updateRenderGroupTransforms(renderGroup);\n\n        if (renderGroup.structureDidChange)\n        {\n            renderGroup.structureDidChange = false;\n\n            // build the renderables\n            this._buildInstructions(renderGroup, renderer);\n        }\n        else\n        {\n            // update remaining renderables\n            this._updateRenderables(renderGroup);\n        }\n\n        // reset the renderables to update\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n\n        // upload all the things!\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n\n        // early out if it's a texture and it hasn't changed!\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n        }\n    }\n\n    private _updateRenderables(renderGroup: RenderGroup)\n    {\n        const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n        for (let i = 0; i < index; i++)\n        {\n            const container = list[i];\n\n            if (container.didViewUpdate)\n            {\n                renderGroup.updateRenderable(container as ViewContainer);\n            }\n        }\n\n        clearList(list, index);\n    }\n\n    /**\n     * @param renderGroup\n     * @param renderPipes\n     * @deprecated since 8.3.0\n     */\n    private _buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes): void;\n    private _buildInstructions(renderGroup: RenderGroup, renderer: Renderer): void;\n    private _buildInstructions(renderGroup: RenderGroup, rendererOrPipes: RenderPipes | Renderer): void\n    {\n    // rebuild the scene graph based on layers...\n        const root = renderGroup.root;\n        const instructionSet = renderGroup.instructionSet;\n\n        instructionSet.reset();\n\n        // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n        const renderer = (rendererOrPipes as Renderer).renderPipes\n            ? (rendererOrPipes as Renderer)\n            : (rendererOrPipes as RenderPipes).batch.renderer;\n        const renderPipes = renderer.renderPipes;\n\n        // TODO add some events / runners for build start\n        renderPipes.batch.buildStart(instructionSet);\n        renderPipes.blendMode.buildStart();\n        renderPipes.colorMask.buildStart();\n\n        if (root.sortableChildren)\n        {\n            root.sortChildren();\n        }\n\n        root.collectRenderablesWithEffects(instructionSet, renderer, null);\n\n        // TODO add some events / runners for build end\n        renderPipes.batch.buildEnd(instructionSet);\n        renderPipes.blendMode.buildEnd(instructionSet);\n    }\n}\n\n","/**\n * Takes a hash and removes all the `undefined`/`null` values from it.\n * In PixiJS, we tend to null properties instead of using 'delete' for performance reasons.\n * However, in some cases, this could be a problem if the hash grows too large over time,\n * this function can be used to clean a hash.\n * @param hash - The hash to clean.\n * @returns A new hash with all the `undefined`/`null` values removed.\n * @category utils\n * @internal\n */\nexport function cleanHash<T>(hash: Record<string, T>): Record<string, T>\n{\n    let clean = false;\n\n    for (const i in hash)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (hash[i] == undefined)\n        {\n            clean = true;\n            break;\n        }\n    }\n\n    if (!clean) return hash;\n\n    const cleanHash = Object.create(null);\n\n    for (const i in hash)\n    {\n        const value = hash[i];\n\n        if (value)\n        {\n            cleanHash[i] = value;\n        }\n    }\n\n    return cleanHash;\n}\n\n/**\n * Removes all `undefined`/`null` elements from the given array and compacts the array.\n *\n * This function iterates through the array, shifting non-undefined elements to the left\n * to fill gaps created by `undefined` elements. The length of the array is then adjusted\n * to remove the trailing `undefined` elements.\n * @param arr - The array to be cleaned.\n * @returns The cleaned array with all `undefined` elements removed.\n * @example\n * // Example usage:\n * const arr = [1, undefined, 2, undefined, 3];\n * const cleanedArr = cleanArray(arr);\n * console.log(cleanedArr); // Output: [1, 2, 3]\n * @category utils\n * @internal\n */\nexport function cleanArray<T>(arr: T[]): T[]\n{\n    let offset = 0;\n\n    for (let i = 0; i < arr.length; i++)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (arr[i] == undefined)\n        {\n            offset++;\n        }\n        else\n        {\n            arr[i - offset] = arr[i];\n        }\n    }\n\n    arr.length -= offset;\n\n    return arr;\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { type RenderGroup } from '../../../scene/container/RenderGroup';\nimport { type GPUDataOwner, type Renderer } from '../types';\nimport { type Renderable } from './Renderable';\nimport { type RenderOptions } from './system/AbstractRenderer';\n\nimport type EventEmitter from 'eventemitter3';\nimport type { System } from './system/System';\n\n/**\n * Data stored on a GC-managed resource.\n * @category rendering\n * @advanced\n */\nexport interface GCData\n{\n    /** Index in the managed resources array */\n    index?: number;\n    /** Type of the resource */\n    type: 'resource' | 'renderable';\n}\n\n/**\n * Interface for resources that can be garbage collected.\n * @category rendering\n * @advanced\n */\nexport interface GCable extends GPUDataOwner\n{\n    /** Timestamp of last use */\n    _gcLastUsed: number;\n    /** GC tracking data, null if not being tracked */\n    _gcData?: GCData | null;\n    /** If set to true, the resource will be garbage collected automatically when it is not used. */\n    autoGarbageCollect?: boolean;\n    /** An optional callback for when an item is touched */\n    _onTouch?(now: number): void;\n}\n\ntype GCableEventEmitter = GCable & Pick<EventEmitter, 'once' | 'off'>;\n\ninterface GCResourceHashEntry\n{\n    context: any;\n    hash: string;\n    type: GCData['type'];\n    priority: number;\n}\n\n/**\n * Options for the {@link GCSystem}.\n * @category rendering\n * @advanced\n */\nexport interface GCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector.\n     * @default true\n     */\n    gcActive: boolean;\n    /**\n     * The maximum time in milliseconds a resource can be unused before being garbage collected.\n     * @default 60000\n     */\n    gcMaxUnusedTime: number;\n    /**\n     * How frequently to run garbage collection in milliseconds.\n     * @default 30000\n     */\n    gcFrequency: number;\n}\n\n/**\n * A unified garbage collection system for managing GPU resources.\n * Resources register themselves with a cleanup callback and are automatically\n * cleaned up when they haven't been used for a specified amount of time.\n * @example\n * ```ts\n * // Register a resource for GC\n * gc.addResource(myResource, () => {\n *     // cleanup logic here\n *     myResource.unload();\n * });\n *\n * // Touch the resource when used (resets idle timer)\n * gc.touch(myResource);\n *\n * // Remove from GC tracking (e.g., on manual destroy)\n * gc.removeResource(myResource);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GCSystem implements System<GCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'gc',\n        priority: 0,\n    } as const;\n\n    /** Default options for the GCSystem */\n    public static defaultOptions: GCSystemOptions = {\n        /** Enable/disable the garbage collector */\n        gcActive: true,\n        /** Time in ms before an unused resource is collected (default 1 minute) */\n        gcMaxUnusedTime: 60000,\n        /** How often to run garbage collection in ms (default 30 seconds) */\n        gcFrequency: 30000,\n    };\n\n    /** Maximum time in ms a resource can be unused before being garbage collected */\n    public maxUnusedTime: number;\n\n    /** Reference to the renderer this system belongs to */\n    private _renderer: Renderer;\n\n    /** Array of resources being tracked for garbage collection */\n    private readonly _managedResources: GCableEventEmitter[] = [];\n    private readonly _managedResourceHashes: GCResourceHashEntry[] = [];\n\n    /** ID of the GC scheduler handler */\n    private _handler: number;\n\n    /** How frequently GC runs in ms */\n    private _frequency: number;\n\n    /** Current timestamp used for age calculations */\n    public now: number;\n\n    private _ready = false;\n\n    /**\n     * Creates a new GCSystem instance.\n     * @param renderer - The renderer this garbage collection system works for\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Initializes the garbage collection system with the provided options.\n     * @param options - Configuration options\n     */\n    public init(options: GCSystemOptions): void\n    {\n        options = { ...GCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.gcMaxUnusedTime;\n        this._frequency = options.gcFrequency;\n\n        this.enabled = options.gcActive;\n        this.now = performance.now();\n    }\n\n    /**\n     * Gets whether the garbage collection system is currently enabled.\n     * @returns True if GC is enabled, false otherwise\n     */\n    get enabled(): boolean\n    {\n        return !!this._handler;\n    }\n\n    /**\n     * Enables or disables the garbage collection system.\n     * When enabled, schedules periodic cleanup of resources.\n     * When disabled, cancels all scheduled cleanups.\n     */\n    set enabled(value: boolean)\n    {\n        if (this.enabled === value) return;\n\n        if (value)\n        {\n            this._handler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    this._ready = true;\n                },\n                this._frequency,\n                false\n            );\n        }\n        else\n        {\n            this._renderer.scheduler.cancel(this._handler);\n            this._handler = 0;\n        }\n    }\n\n    /**\n     * Called before rendering. Updates the current timestamp.\n     * @param options - The render options\n     * @param options.container - The container to render\n     */\n    protected prerender({ container }: RenderOptions): void\n    {\n        this.now = performance.now();\n        container.renderGroup.gcTick = this._renderer.tick++;\n\n        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n    }\n\n    /** Performs garbage collection after rendering. */\n    protected postrender(): void\n    {\n        if (!this._ready || !this.enabled) return;\n\n        this.run();\n        this._ready = false;\n    }\n\n    /**\n     * Updates the GC tick counter for a render group and its children.\n     * @param renderGroup - The render group to update\n     * @param gcTick - The new tick value\n     */\n    private _updateInstructionGCTick(renderGroup: RenderGroup, gcTick: number): void\n    {\n        renderGroup.instructionSet.gcTick = gcTick;\n\n        for (const child of renderGroup.renderGroupChildren)\n        {\n            this._updateInstructionGCTick(child, gcTick);\n        }\n    }\n\n    /**\n     * Registers a resource for garbage collection tracking.\n     * @param resource - The resource to track\n     * @param type - The type of resource to track\n     */\n    public addResource(resource: GCableEventEmitter, type: GCData['type']): void\n    {\n        // Already being tracked\n        if (resource._gcLastUsed !== -1)\n        {\n            resource._gcLastUsed = this.now;\n            resource._onTouch?.(this.now);\n\n            return;\n        }\n\n        const index = this._managedResources.length;\n\n        resource._gcData = {\n            index,\n            type,\n        };\n        resource._gcLastUsed = this.now;\n        resource._onTouch?.(this.now);\n        resource.once('unload', this.removeResource, this);\n\n        this._managedResources.push(resource);\n    }\n\n    /**\n     * Removes a resource from garbage collection tracking.\n     * Call this when manually destroying a resource.\n     * @param resource - The resource to stop tracking\n     */\n    public removeResource(resource: GCable): void\n    {\n        const gcData = resource._gcData;\n\n        if (!gcData) return;\n\n        const index = gcData.index;\n        const last = this._managedResources.length - 1;\n\n        // Swap with last element for O(1) removal\n        if (index !== last)\n        {\n            const lastResource = this._managedResources[last];\n\n            this._managedResources[index] = lastResource;\n            lastResource._gcData.index = index;\n        }\n\n        this._managedResources.length--;\n        resource._gcData = null;\n        resource._gcLastUsed = -1;\n    }\n\n    /**\n     * Registers a hash-based resource collection for garbage collection tracking.\n     * Resources in the hash will be automatically tracked and cleaned up when unused.\n     * @param context - The object containing the hash property\n     * @param hash - The property name on context that holds the resource hash\n     * @param type - The type of resources in the hash ('resource' or 'renderable')\n     * @param priority - Processing priority (lower values are processed first)\n     */\n    public addResourceHash(context: any, hash: string, type: GCData['type'], priority: number = 0): void\n    {\n        this._managedResourceHashes.push({\n            context,\n            hash,\n            type,\n            priority,\n        });\n\n        this._managedResourceHashes.sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Performs garbage collection by cleaning up unused resources.\n     * Removes resources that haven't been used for longer than maxUnusedTime.\n     */\n    public run(): void\n    {\n        const now = performance.now();\n        const managedResourceHashes = this._managedResourceHashes;\n\n        for (const hashEntry of managedResourceHashes)\n        {\n            this.runOnHash(hashEntry, now);\n        }\n\n        let writeIndex = 0;\n\n        for (let i = 0; i < this._managedResources.length; i++)\n        {\n            const resource = this._managedResources[i];\n\n            writeIndex = this.runOnResource(resource, now, writeIndex);\n        }\n\n        this._managedResources.length = writeIndex;\n    }\n\n    protected updateRenderableGCTick(renderable: Renderable & GCable, now: number): void\n    {\n        const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n        const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n\n        // Update last used time if the renderable's group was rendered this tick\n        if ((renderGroup?.gcTick ?? 0) === currentTick)\n        {\n            renderable._gcLastUsed = now;\n            renderable._onTouch?.(now);\n        }\n    }\n\n    protected runOnResource(resource: GCableEventEmitter, now: number, writeIndex: number): number\n    {\n        const gcData = resource._gcData;\n\n        // special case for renderables as we do not check every frame if they are being used\n        if (gcData.type === 'renderable')\n        {\n            this.updateRenderableGCTick(resource as Renderable, now);\n        }\n\n        const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n\n        if (isRecentlyUsed || !resource.autoGarbageCollect)\n        {\n            this._managedResources[writeIndex] = resource;\n            gcData.index = writeIndex;\n            writeIndex++;\n        }\n        else\n        {\n            // Call the cleanup function\n            resource.unload();\n            resource._gcData = null;\n            resource._gcLastUsed = -1;\n            resource.off('unload', this.removeResource, this);\n        }\n\n        return writeIndex;\n    }\n\n    /**\n     * Creates a clone of the hash, copying all non-null entries up to (but not including) the stop key.\n     * @param hashValue - The original hash to clone from\n     * @param stopKey - The key to stop at (exclusive)\n     * @returns A new hash object with copied entries\n     */\n    private _createHashClone(hashValue: Record<string, GCable>, stopKey: string): Record<string, GCable>\n    {\n        const hashClone: Record<string, GCable> = Object.create(null);\n\n        for (const k in hashValue)\n        {\n            if (k === stopKey) break;\n            if (hashValue[k] !== null) hashClone[k] = hashValue[k];\n        }\n\n        return hashClone;\n    }\n\n    protected runOnHash(hashEntry: GCResourceHashEntry, now: number): void\n    {\n        const { context, hash, type } = hashEntry;\n\n        const hashValue = context[hash] as Record<string, GCable>;\n        let hashClone: Record<string, GCable> | null = null;\n        let nullCount = 0;\n\n        for (const key in hashValue)\n        {\n            const resource = hashValue[key];\n\n            // check if the value is null\n            if (resource === null)\n            {\n                nullCount++;\n\n                // Lazily create the clone to clean up null entries when threshold is reached\n                if (nullCount === 10000 && !hashClone)\n                {\n                    hashClone = this._createHashClone(hashValue, key);\n                }\n\n                continue;\n            }\n\n            // If no GC data, then the resource has been added since the last garbage collection\n            if (resource._gcLastUsed === -1)\n            {\n                resource._gcLastUsed = now;\n                resource._onTouch?.(now);\n\n                if (hashClone) hashClone[key] = resource;\n\n                continue;\n            }\n\n            // special case for renderables as we do not check every frame if they are being used\n            if (type === 'renderable')\n            {\n                this.updateRenderableGCTick(resource as Renderable, now);\n            }\n\n            const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n\n            if (!isRecentlyUsed && resource.autoGarbageCollect)\n            {\n                // Lazily create the clone only when we need to remove something\n                if (!hashClone)\n                {\n                    // we can set the value to null here to avoid having to create a new hash object\n                    // only when it crosses the 10000 threshold do we need to create a new hash object\n                    if (nullCount + 1 !== 10000)\n                    {\n                        hashValue[key] = null;\n                        nullCount++;\n                    }\n                    else\n                    {\n                        hashClone = this._createHashClone(hashValue, key);\n                    }\n                }\n\n                // Call the cleanup function\n                resource.unload();\n                resource._gcData = null;\n                resource._gcLastUsed = -1;\n            }\n            else if (hashClone)\n            {\n                hashClone[key] = resource;\n            }\n        }\n\n        // Only replace the hash if something was removed\n        if (hashClone)\n        {\n            context[hash] = hashClone;\n        }\n    }\n\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n    public destroy(): void\n    {\n        this.enabled = false;\n\n        this._managedResources.forEach((resource) =>\n        {\n            resource.off('unload', this.removeResource, this);\n        });\n        this._managedResources.length = 0;\n        this._managedResourceHashes.length = 0;\n        this._renderer = null as any as Renderer;\n    }\n}\n\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { deprecation } from '../../../../utils/logging/deprecation';\nimport { type Renderer } from '../../types';\n\nimport type { System } from '../system/System';\n\n/**\n * Options for the {@link TextureGCSystem}.\n * @category rendering\n * @advanced\n * @deprecated since 8.15.0\n * @see {@link GCSystem}\n */\nexport interface TextureGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     * @deprecated since 8.15.0\n     */\n    textureGCActive: boolean;\n    /**\n     * @deprecated since 8.3.0\n     * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n     */\n    textureGCAMaxIdle: number;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     * @deprecated since 8.15.0\n     */\n    textureGCMaxIdle: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     * @deprecated since 8.15.0\n     */\n    textureGCCheckCountMax: number;\n}\n/**\n * System plugin to the renderer to manage texture garbage collection on the GPU,\n * ensuring that it does not get clogged up with textures that are no longer being used.\n * @category rendering\n * @advanced\n * @deprecated since 8.15.0\n * @see {@link GCSystem}\n */\nexport class TextureGCSystem implements System<TextureGCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGC',\n    } as const;\n\n    /**\n     * Default options for the TextureGCSystem\n     * @deprecated since 8.15.0\n     */\n    public static defaultOptions: TextureGCSystemOptions = {\n        /**\n         * If set to true, this will enable the garbage collector on the GPU.\n         * @default true\n         */\n        textureGCActive: true,\n        /**\n         * @deprecated since 8.3.0\n         * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n         */\n        textureGCAMaxIdle: null,\n        /**\n         * The maximum idle frames before a texture is destroyed by garbage collection.\n         * @default 60 * 60\n         */\n        textureGCMaxIdle: 60 * 60,\n        /**\n         * Frames between two garbage collections.\n         * @default 600\n         */\n        textureGCCheckCountMax: 600,\n    };\n\n    /**\n     * Frame count since started.\n     * @readonly\n     * @deprecated since 8.15.0\n     */\n    public get count() { return this._renderer.tick; }\n\n    /**\n     * Frame count since last garbage collection.\n     * @readonly\n     * @deprecated since 8.15.0\n     */\n    public get checkCount() { return this._checkCount; }\n    public set checkCount(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._checkCount = value;\n    }\n    private _checkCount: number;\n\n    /**\n     * Maximum idle frames before a texture is destroyed by garbage collection.\n     * @see TextureGCSystem.defaultMaxIdle\n     * @deprecated since 8.15.0\n     */\n    public get maxIdle() { return (this._renderer.gc.maxUnusedTime / 1000) * 60; }\n    public set maxIdle(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.maxUnusedTime = (value / 60) * 1000;\n    }\n\n    /**\n     * Frames between two garbage collections.\n     * @see TextureGCSystem.defaultCheckCountMax\n     * @deprecated since 8.15.0\n     */\n    // eslint-disable-next-line dot-notation\n    public get checkCountMax() { return Math.floor(this._renderer.gc['_frequency'] / 1000); }\n    public set checkCountMax(_value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n    }\n\n    /**\n     * Current garbage collection mode.\n     * @see TextureGCSystem.defaultMode\n     * @deprecated since 8.15.0\n     */\n    public get active() { return this._renderer.gc.enabled; }\n    public set active(value: boolean)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.enabled = value;\n    }\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._checkCount = 0;\n    }\n\n    public init(options: TextureGCSystemOptions): void\n    {\n        if (options.textureGCActive !== TextureGCSystem.defaultOptions.textureGCActive)\n        { this.active = options.textureGCActive; }\n        if (options.textureGCMaxIdle !== TextureGCSystem.defaultOptions.textureGCMaxIdle)\n        { this.maxIdle = options.textureGCMaxIdle; }\n        if (options.textureGCCheckCountMax !== TextureGCSystem.defaultOptions.textureGCCheckCountMax)\n        { this.checkCountMax = options.textureGCCheckCountMax; }\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     * @deprecated since 8.15.0\n     */\n    public run(): void\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.run();\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type RenderGroup } from '../../../../scene/container/RenderGroup';\nimport { cleanArray, cleanHash } from '../../../../utils/data/clean';\nimport { type RenderOptions } from '../system/AbstractRenderer';\n\nimport type { Container } from '../../../../scene/container/Container';\nimport type { Renderer } from '../../types';\nimport type { RenderPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { System } from '../system/System';\n\nlet renderableGCTick = 0;\n\n/**\n * Options for the {@link RenderableGCSystem}.\n * @category rendering\n * @property {boolean} [renderableGCActive=true] - If set to true, this will enable the garbage collector on the renderables.\n * @property {number} [renderableGCAMaxIdle=60000] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [renderableGCCheckCountMax=60000] - time between two garbage collections.\n * @advanced\n */\nexport interface RenderableGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     */\n    renderableGCActive: boolean;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     */\n    renderableGCMaxUnusedTime: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     */\n    renderableGCFrequency: number;\n}\n\n/**\n * The RenderableGCSystem is responsible for cleaning up GPU resources that are no longer being used.\n *\n * When rendering objects like sprites, text, etc - GPU resources are created and managed by the renderer.\n * If these objects are no longer needed but not properly destroyed (via sprite.destroy()), their GPU resources\n * would normally leak. This system prevents that by automatically cleaning up unused GPU resources.\n *\n * Key features:\n * - Runs every 30 seconds by default to check for unused resources\n * - Cleans up resources not rendered for over 1 minute\n * - Works independently of rendering - will clean up even when not actively rendering\n * - When cleaned up resources are needed again, new GPU objects are quickly assigned from a pool\n * - Can be disabled with renderableGCActive:false for manual control\n *\n * Best practices:\n * - Always call destroy() explicitly when done with renderables (e.g. sprite.destroy())\n * - This system is a safety net, not a replacement for proper cleanup\n * - Adjust frequency and timeouts via options if needed\n * @example\n * ```js\n * // Sprite created but reference lost without destroy\n * let sprite = new Sprite(texture);\n *\n * // internally the renderer will assign a resource to the sprite\n * renderer.render(sprite);\n *\n * sprite = null; // Reference lost but GPU resources still exist\n *\n * // After 1 minute of not being rendered:\n * // - RenderableGC will clean up the sprite's GPU resources\n * // - JS garbage collector can then clean up the sprite itself\n * ```\n * @category rendering\n * @advanced\n */\nexport class RenderableGCSystem implements System<RenderableGCSystemOptions>\n{\n    /**\n     * Extension metadata for registering this system with the renderer.\n     * @ignore\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'renderableGC',\n        priority: 0\n    } as const;\n\n    /**\n     * Default configuration options for the garbage collection system.\n     * These can be overridden when initializing the renderer.\n     */\n    public static defaultOptions: RenderableGCSystemOptions = {\n        /** Enable/disable the garbage collector */\n        renderableGCActive: true,\n        /** Time in ms before an unused resource is collected (default 1 minute) */\n        renderableGCMaxUnusedTime: 60000,\n        /** How often to run garbage collection in ms (default 30 seconds) */\n        renderableGCFrequency: 30000,\n    };\n\n    /** Maximum time in ms a resource can be unused before being garbage collected */\n    public maxUnusedTime: number;\n\n    /** Reference to the renderer this system belongs to */\n    private _renderer: Renderer;\n\n    /** Array of renderables being tracked for garbage collection */\n    private readonly _managedRenderables: Renderable[] = [];\n    /** ID of the main GC scheduler handler */\n    private _handler: number;\n    /** How frequently GC runs in ms */\n    private _frequency: number;\n    /** Current timestamp used for age calculations */\n    private _now: number;\n\n    /** Array of hash objects being tracked for cleanup */\n    private readonly _managedHashes: {context: any, hash: string}[] = [];\n    /** ID of the hash cleanup scheduler handler */\n    private _hashHandler: number;\n\n    /** Array of arrays being tracked for cleanup */\n    private readonly _managedArrays: {context: any, hash: string}[] = [];\n    /** ID of the array cleanup scheduler handler */\n    private _arrayHandler: number;\n\n    /**\n     * Creates a new RenderableGCSystem instance.\n     * @param renderer - The renderer this garbage collection system works for\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Initializes the garbage collection system with the provided options.\n     * @param options - Configuration options for the renderer\n     */\n    public init(options: RenderableGCSystemOptions): void\n    {\n        options = { ...RenderableGCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n        this._frequency = options.renderableGCFrequency;\n\n        this.enabled = options.renderableGCActive;\n    }\n\n    /**\n     * Gets whether the garbage collection system is currently enabled.\n     * @returns True if GC is enabled, false otherwise\n     */\n    get enabled(): boolean\n    {\n        return !!this._handler;\n    }\n\n    /**\n     * Enables or disables the garbage collection system.\n     * When enabled, schedules periodic cleanup of resources.\n     * When disabled, cancels all scheduled cleanups.\n     */\n    set enabled(value: boolean)\n    {\n        if (this.enabled === value) return;\n\n        if (value)\n        {\n            // Schedule periodic garbage collection\n            this._handler = this._renderer.scheduler.repeat(\n                () => this.run(),\n                this._frequency,\n                false\n            );\n\n            // Schedule periodic hash table cleanup\n            this._hashHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const hash of this._managedHashes)\n                    {\n                        hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n                    }\n                },\n                this._frequency\n            );\n\n            // Schedule periodic array cleanup\n            this._arrayHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const array of this._managedArrays)\n                    {\n                        cleanArray(array.context[array.hash]);\n                    }\n                },\n                this._frequency\n            );\n        }\n        else\n        {\n            // Cancel all scheduled cleanups\n            this._renderer.scheduler.cancel(this._handler);\n            this._renderer.scheduler.cancel(this._hashHandler);\n            this._renderer.scheduler.cancel(this._arrayHandler);\n        }\n    }\n\n    /**\n     * Adds a hash table to be managed by the garbage collector.\n     * @param context - The object containing the hash table\n     * @param hash - The property name of the hash table\n     */\n    public addManagedHash<T>(context: T, hash: string): void\n    {\n        this._managedHashes.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Adds an array to be managed by the garbage collector.\n     * @param context - The object containing the array\n     * @param hash - The property name of the array\n     */\n    public addManagedArray<T>(context: T, hash: string): void\n    {\n        this._managedArrays.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Updates the GC timestamp and tracking before rendering.\n     * @param options - The render options\n     * @param options.container - The container to render\n     */\n    public prerender({\n        container\n    }: RenderOptions): void\n    {\n        this._now = performance.now();\n\n        // The gcTick is a monotonically increasing counter that tracks render cycles\n        // Each time we render, we increment the global renderableGCTick counter\n        // and assign the new tick value to the render group being rendered.\n        // This lets us know which render groups were rendered in the current frame\n        // versus ones that haven't been rendered recently.\n        // The instruction set also gets updated with this tick value to track\n        // when its renderables were last used.\n        container.renderGroup.gcTick = renderableGCTick++;\n\n        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n    }\n\n    /**\n     * Starts tracking a renderable for garbage collection.\n     * @param renderable - The renderable to track\n     */\n    public addRenderable(renderable: Renderable): void\n    {\n        if (!this.enabled) return;\n\n        if (renderable._lastUsed === -1)\n        {\n            this._managedRenderables.push(renderable);\n            renderable.once('destroyed', this._removeRenderable, this);\n        }\n\n        renderable._lastUsed = this._now;\n    }\n\n    /**\n     * Performs garbage collection by cleaning up unused renderables.\n     * Removes renderables that haven't been used for longer than maxUnusedTime.\n     */\n    public run(): void\n    {\n        const now = this._now;\n        const managedRenderables = this._managedRenderables;\n        const renderPipes = this._renderer.renderPipes;\n        let offset = 0;\n\n        for (let i = 0; i < managedRenderables.length; i++)\n        {\n            const renderable = managedRenderables[i];\n\n            if (renderable === null)\n            {\n                offset++;\n                continue;\n            }\n\n            const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n            const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n\n            // Update last used time if the renderable's group was rendered this tick\n            if ((renderGroup?.gcTick ?? 0) === currentTick)\n            {\n                renderable._lastUsed = now;\n            }\n\n            // Clean up if unused for too long\n            if (now - renderable._lastUsed > this.maxUnusedTime)\n            {\n                if (!renderable.destroyed)\n                {\n                    const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n                    if (renderGroup)renderGroup.structureDidChange = true;\n\n                    rp[renderable.renderPipeId].destroyRenderable(renderable);\n                }\n\n                renderable._lastUsed = -1;\n                offset++;\n                renderable.off('destroyed', this._removeRenderable, this);\n            }\n            else\n            {\n                managedRenderables[i - (offset)] = renderable;\n            }\n        }\n\n        managedRenderables.length -= offset;\n    }\n\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n    public destroy(): void\n    {\n        this.enabled = false;\n        this._renderer = null as any as Renderer;\n        this._managedRenderables.length = 0;\n        this._managedHashes.length = 0;\n        this._managedArrays.length = 0;\n    }\n\n    /**\n     * Removes a renderable from being tracked when it's destroyed.\n     * @param renderable - The renderable to stop tracking\n     */\n    private _removeRenderable(renderable: Container): void\n    {\n        const index = this._managedRenderables.indexOf(renderable as Renderable);\n\n        if (index >= 0)\n        {\n            renderable.off('destroyed', this._removeRenderable, this);\n            this._managedRenderables[index] = null;\n        }\n    }\n\n    /**\n     * Updates the GC tick counter for a render group and its children.\n     * @param renderGroup - The render group to update\n     * @param gcTick - The new tick value\n     */\n    private _updateInstructionGCTick(renderGroup: RenderGroup, gcTick: number): void\n    {\n        renderGroup.instructionSet.gcTick = gcTick;\n\n        for (const child of renderGroup.renderGroupChildren)\n        {\n            this._updateInstructionGCTick(child, gcTick);\n        }\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Ticker } from '../../../ticker/Ticker';\n\nimport type { System } from './system/System';\n\n// start at one too keep it positive!\nlet uid = 1;\n\n/**\n * The SchedulerSystem manages scheduled tasks with specific intervals.\n * @category rendering\n * @advanced\n */\nexport class SchedulerSystem implements System<null>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'scheduler',\n        priority: 0,\n    } as const;\n\n    private readonly _tasks: {\n        func: (elapsed: number) => void;\n        duration: number;\n        offset: number\n        start: number;\n        last: number;\n        repeat: boolean;\n        id: number;\n    }[] = [];\n\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    private _offset = 0;\n\n    /** Initializes the scheduler system and starts the ticker. */\n    public init(): void\n    {\n        Ticker.system.add(this._update, this);\n    }\n\n    /**\n     * Schedules a repeating task.\n     * @param func - The function to execute.\n     * @param duration - The interval duration in milliseconds.\n     * @param useOffset - this will spread out tasks so that they do not all run at the same time\n     * @returns The unique identifier for the scheduled task.\n     */\n    public repeat(func: (elapsed: number) => void, duration: number, useOffset = true): number\n    {\n        const id = uid++;\n\n        let offset = 0;\n\n        if (useOffset)\n        {\n            this._offset += 1000;\n            offset = this._offset;\n        }\n\n        this._tasks.push({\n            func,\n            duration,\n            start: performance.now(),\n            offset,\n            last: performance.now(),\n            repeat: true,\n            id\n        });\n\n        return id;\n    }\n\n    /**\n     * Cancels a scheduled task.\n     * @param id - The unique identifier of the task to cancel.\n     */\n    public cancel(id: number): void\n    {\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            if (this._tasks[i].id === id)\n            {\n                this._tasks.splice(i, 1);\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * Updates and executes the scheduled tasks.\n     * @private\n     */\n    private _update(): void\n    {\n        const now = performance.now();\n\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            const task = this._tasks[i];\n\n            if ((now - task.offset) - task.last >= task.duration)\n            {\n                const elapsed = now - task.start;\n\n                task.func(elapsed);\n                task.last = now;\n            }\n        }\n    }\n\n    /**\n     * Destroys the scheduler system and removes all tasks.\n     * @internal\n     */\n    public destroy(): void\n    {\n        Ticker.system.remove(this._update, this);\n\n        this._tasks.length = 0;\n    }\n}\n","import { DOMAdapter } from '../environment/adapter';\nimport { VERSION } from './const';\n\nlet saidHello = false;\n\n/**\n * Prints out the version and renderer information for this running instance of PixiJS.\n * @param type - The name of the renderer this instance is using.\n * @returns {void}\n * @category utils\n * @advanced\n */\nexport function sayHello(type: string): void\n{\n    if (saidHello)\n    {\n        return;\n    }\n\n    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf('chrome') > -1)\n    {\n        const args = [\n            `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\\n\\n`,\n            'background: #E72264; padding:5px 0;',\n            'background: #6CA2EA; padding:5px 0;',\n            'background: #B5D33D; padding:5px 0;',\n            'background: #FED23F; padding:5px 0;',\n            'color: #FFFFFF; background: #E72264; padding:5px 0;',\n            'color: #E72264; background: #FFFFFF; padding:5px 0;',\n        ];\n\n        globalThis.console.log(...args);\n    }\n    else if (globalThis.console)\n    {\n        globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n    }\n\n    saidHello = true;\n}\n","import { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\n/**\n * A render texture, extends `Texture`.\n * @see {@link Texture}\n * @category rendering\n * @advanced\n */\nexport class RenderTexture extends Texture\n{\n    /**\n     * Creates a RenderTexture. Pass `dynamic: true` in options to allow resizing after creation.\n     * @param options - Options for the RenderTexture, including width, height, and dynamic.\n     * @returns A new RenderTexture instance.\n     * @example\n     * const rt = RenderTexture.create({ width: 100, height: 100, dynamic: true });\n     * rt.resize(500, 500);\n     */\n    public static create(options: TextureSourceOptions): RenderTexture\n    {\n        // Pass dynamic to the RenderTexture constructor if present in options\n        const { dynamic, ...rest } = options;\n\n        return new RenderTexture({\n            source: new TextureSource(rest),\n            dynamic: dynamic ?? false,\n        });\n    }\n\n    /**\n     * Resizes the render texture.\n     * @param width - The new width of the render texture.\n     * @param height - The new height of the render texture.\n     * @param resolution - The new resolution of the render texture.\n     * @returns This texture.\n     */\n    public resize(width: number, height: number, resolution?: number): this\n    {\n        this.source.resize(width, height, resolution);\n\n        return this;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { sayHello } from '../../../../utils/sayHello';\nimport { type Renderer, RendererType } from '../../types';\n\nimport type { WebGLRenderer } from '../../gl/WebGLRenderer';\nimport type { System } from '../system/System';\n\n/**\n * Options for the startup system.\n * @property {boolean} [hello=false] - Whether to log the version and type information of renderer to console.\n * @category rendering\n * @advanced\n */\nexport interface HelloSystemOptions\n{\n    /**\n     * Whether to log the version and type information of renderer to console.\n     * @default false\n     */\n    hello: boolean;\n}\n\n/**\n * A simple system responsible for initiating the renderer.\n * @category rendering\n * @advanced\n */\nexport class HelloSystem implements System<HelloSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'hello',\n        priority: -2,\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: HelloSystemOptions = {\n        /** {@link WebGLOptions.hello} */\n        hello: false,\n    };\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * It all starts here! This initiates every system, passing in the options for any system by name.\n     * @param options - the config for the renderer and all its systems\n     */\n    public init(options: HelloSystemOptions): void\n    {\n        if (options.hello)\n        {\n            let name = this._renderer.name;\n\n            if (this._renderer.type === RendererType.WEBGL)\n            {\n                name += ` ${(this._renderer as WebGLRenderer).context.webGLVersion}`;\n            }\n\n            sayHello(name);\n        }\n    }\n}\n","import { Color } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { System } from '../system/System';\n/**\n * Options for the background system.\n * @category rendering\n * @advanced\n */\nexport interface BackgroundSystemOptions\n{\n    /**\n     * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n     * @default 'black'\n     */\n    backgroundColor: ColorSource;\n    /** Alias for `backgroundColor` */\n    background?: ColorSource\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * This value determines whether the canvas is initialized with alpha transparency support.\n     * Note: This cannot be changed after initialization. If set to `1`, the canvas will remain opaque,\n     * even if a transparent background color is set later.\n     * @default 1\n     */\n    backgroundAlpha?: number;\n    /**\n     * Whether to clear the canvas before new render passes.\n     * @default true\n     */\n    clearBeforeRender?: boolean;\n}\n\n/**\n * The background system manages the background color and alpha of the main view.\n * @category rendering\n * @advanced\n */\nexport class BackgroundSystem implements System<BackgroundSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'background',\n        priority: 0,\n    } as const;\n\n    /** default options used by the system */\n    public static defaultOptions: BackgroundSystemOptions = {\n        /**\n         * {@link WebGLOptions.backgroundAlpha}\n         * @default 1\n         */\n        backgroundAlpha: 1,\n        /**\n         * {@link WebGLOptions.backgroundColor}\n         * @default 0x000000\n         */\n        backgroundColor: 0x0,\n        /**\n         * {@link WebGLOptions.clearBeforeRender}\n         * @default true\n         */\n        clearBeforeRender: true,\n    };\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every\n     * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect\n     * to clear the canvas every frame. Disable this by setting this to false. For example, if\n     * your game has a canvas filling background image you often don't need this set.\n     */\n    public clearBeforeRender: boolean;\n\n    private readonly _backgroundColor: Color;\n\n    constructor()\n    {\n        this.clearBeforeRender = true;\n\n        this._backgroundColor = new Color(0x000000);\n\n        this.color = this._backgroundColor; // run bg color setter\n        this.alpha = 1;\n    }\n\n    /**\n     * initiates the background system\n     * @param options - the options for the background colors\n     */\n    public init(options: BackgroundSystemOptions): void\n    {\n        options = { ...BackgroundSystem.defaultOptions, ...options };\n\n        this.clearBeforeRender = options.clearBeforeRender;\n        this.color = options.background || options.backgroundColor || this._backgroundColor; // run bg color setter\n        this.alpha = options.backgroundAlpha;\n\n        this._backgroundColor.setAlpha(options.backgroundAlpha);\n    }\n\n    /** The background color to fill if not transparent */\n    get color(): Color\n    {\n        return this._backgroundColor;\n    }\n\n    set color(value: ColorSource)\n    {\n        // #if _DEBUG\n\n        const incoming = Color.shared.setValue(value);\n\n        if (incoming.alpha < 1 && this._backgroundColor.alpha === 1)\n        {\n            warn(\n                'Cannot set a transparent background on an opaque canvas. '\n                + 'To enable transparency, set backgroundAlpha < 1 when initializing your Application.'\n            );\n        }\n        // #endif\n        this._backgroundColor.setValue(value);\n    }\n\n    /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n    get alpha(): number\n    {\n        return this._backgroundColor.alpha;\n    }\n\n    set alpha(value: number)\n    {\n        this._backgroundColor.setAlpha(value);\n    }\n\n    /** The background color as an [R, G, B, A] array. */\n    get colorRgba(): RgbaArray\n    {\n        return this._backgroundColor.toArray() as RgbaArray;\n    }\n\n    /**\n     * destroys the background system\n     * @internal\n     */\n    public destroy(): void\n    {\n        // No cleanup required\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Container } from '../../../../scene/container/Container';\nimport { Texture } from '../texture/Texture';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { GetPixelsOutput } from '../texture/GenerateCanvas';\nimport type { GenerateTextureOptions } from './GenerateTextureSystem';\n\nconst imageTypes = {\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    webp: 'image/webp',\n};\n\ntype Formats = keyof typeof imageTypes;\n\n/**\n * Options for creating an image from a renderer.\n * Controls the output format and quality of extracted images.\n * @example\n * ```ts\n * // Extract as PNG (default)\n * const pngImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // Extract as JPEG with quality setting\n * const jpgImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'jpg',\n *     quality: 0.8\n * });\n *\n * // Extract as WebP for better compression\n * const webpImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'webp',\n *     quality: 0.9\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface ImageOptions\n{\n    /**\n     * The format of the extracted image.\n     * - 'png': Lossless format, best for images with text or sharp edges\n     * - 'jpg': Lossy format, smaller file size, good for photos\n     * - 'webp': Modern format with better compression\n     * @example\n     * ```ts\n     * // Extract as PNG\n     * const pngImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'png'\n     * });\n     * // Extract as JPEG\n     * const jpgImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'jpg',\n     * });\n     * ```\n     * @default 'png'\n     */\n    format?: Formats;\n\n    /**\n     * The quality of the extracted image, between 0 and 1.\n     * Only applies to lossy formats (jpg, webp).\n     * - 1: Maximum quality\n     * - 0: Maximum compression\n     * @example\n     * ```ts\n     * // Extract as JPEG with 80% quality\n     * const jpgImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'jpg',\n     *     quality: 0.8\n     * });\n     * // Extract as WebP with 90% quality\n     * const webpImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'webp',\n     *     quality: 0.9\n     * });\n     * ```\n     * @default 1\n     */\n    quality?: number;\n}\n\n/**\n * Options for extracting content from a renderer.\n * These options control how content is extracted and processed from the renderer.\n * @example\n * ```ts\n * // Basic extraction\n * const pixels = renderer.extract.pixels({\n *     target: sprite,\n * });\n *\n * // Extract with custom region and resolution\n * const canvas = renderer.extract.canvas({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n * });\n *\n * // Extract with background color and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface BaseExtractOptions\n{\n    /**\n     * The target to extract. Can be a Container or Texture.\n     * @example\n     * ```ts\n     * // Extract from a sprite\n     * const sprite = new Sprite(texture);\n     * renderer.extract.pixels({ target: sprite });\n     *\n     * // Extract from a texture directly\n     * renderer.extract.pixels({ target: texture });\n     * ```\n     */\n    target: Container | Texture;\n\n    /**\n     * The region of the target to extract. If not specified, extracts the entire target.\n     * @example\n     * ```ts\n     * // Extract a specific region\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     frame: new Rectangle(10, 10, 100, 100)\n     * });\n     * ```\n     */\n    frame?: Rectangle;\n\n    /**\n     * The resolution of the extracted content. Higher values create sharper images.\n     * @default 1\n     * @example\n     * ```ts\n     * // Extract at 2x resolution for retina displays\n     * renderer.extract.image({\n     *     target: sprite,\n     *     resolution: 2\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * The color used to clear the extracted content before rendering.\n     * Can be a hex number, string, or array of numbers.\n     * @example\n     * ```ts\n     * // Clear with red background\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Clear with semi-transparent black\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     clearColor: [0, 0, 0, 0.5]\n     * });\n     * ```\n     */\n    clearColor?: ColorSource;\n\n    /**\n     * Whether to enable anti-aliasing during extraction.\n     * Improves quality but may affect performance.\n     * @default false\n     * @example\n     * ```ts\n     * // Enable anti-aliasing for smoother edges\n     * renderer.extract.image({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     */\n    antialias?: boolean;\n}\n/**\n * Options for extracting an HTMLImage from the renderer.\n * Combines base extraction options with image-specific settings.\n * @example\n * ```ts\n * // Basic PNG extraction\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // High-quality JPEG with custom region\n * const image = await renderer.extract.image({\n *     target: container,\n *     format: 'jpg',\n *     quality: 0.9,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // WebP with background and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     format: 'webp',\n *     quality: 0.8,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - {@link ImageOptions} for image format and quality settings\n *\n * Common use cases:\n * - Capturing game screenshots\n * - Saving rendered content\n * - Creating image thumbnails\n * - Exporting canvas content\n * @see {@link ExtractSystem.image} For the method that uses these options\n * @see {@link ExtractSystem.base64} For base64 encoding\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractImageOptions = BaseExtractOptions & ImageOptions;\n/**\n * Options for extracting and downloading content from a renderer.\n * Combines base extraction options with download-specific settings.\n * @example\n * ```ts\n * // Basic download with default filename\n * renderer.extract.download({\n *     target: sprite\n * });\n *\n * // Download with custom filename and region\n * renderer.extract.download({\n *     target: container,\n *     filename: 'screenshot.png',\n *     frame: new Rectangle(0, 0, 100, 100)\n * });\n *\n * // Download with high resolution and background\n * renderer.extract.download({\n *     target: stage,\n *     filename: 'hd-capture.png',\n *     resolution: 2,\n *     clearColor: '#ff0000'\n * });\n *\n * // Download with anti-aliasing\n * renderer.extract.download({\n *     target: graphics,\n *     filename: 'smooth.png',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - Additional download-specific options\n *\n * Common use cases:\n * - Saving game screenshots\n * - Exporting rendered content\n * - Creating downloadable assets\n * - Saving canvas state\n * @see {@link ExtractSystem.download} For the method that uses these options\n * @see {@link ExtractSystem.image} For creating images without download\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractDownloadOptions = BaseExtractOptions & {\n    /**\n     * The filename to use when downloading the content.\n     * Should include the desired file extension (e.g., .png).\n     * @default 'image.png'\n     * @example\n     * ```ts\n     * renderer.extract.download({\n     *     target: sprite,\n     *     filename: 'my-screenshot.png'\n     * });\n     * ```\n     */\n    filename: string;\n};\n/**\n * Options for extracting content from a renderer. Represents a union of all possible extraction option types.\n * Used by various extraction methods to support different output formats and configurations.\n * @example\n * ```ts\n * // Basic canvas extraction\n * const canvas = renderer.extract.canvas({\n *     target: sprite\n * });\n *\n * // Image extraction with format\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png',\n *     quality: 1\n * });\n *\n * // Download with filename\n * renderer.extract.download({\n *     target: sprite,\n *     filename: 'screenshot.png'\n * });\n *\n * // Advanced extraction with multiple options\n * const image = await renderer.extract.image({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     format: 'webp',\n *     quality: 0.8\n * });\n * ```\n *\n * Supports three types of options:\n * - {@link BaseExtractOptions} - Basic extraction settings\n * - {@link ExtractImageOptions} - Image-specific settings with format and quality\n * - {@link ExtractDownloadOptions} - Download settings with filename\n *\n * Common use cases:\n * - Extracting raw pixels\n * - Creating canvas elements\n * - Generating downloadable images\n * - Taking screenshots\n * - Creating thumbnails\n * @see {@link ExtractSystem.canvas} For canvas extraction\n * @see {@link ExtractSystem.image} For image extraction\n * @see {@link ExtractSystem.download} For downloading content\n * @category rendering\n * @advanced\n */\nexport type ExtractOptions = BaseExtractOptions | ExtractImageOptions | ExtractDownloadOptions;\n\n/**\n * System for exporting content from a renderer. It provides methods to extract content as images,\n * canvases, or raw pixel data. Available through `renderer.extract`.\n * @example\n * ```ts\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application\n * const app = new Application();\n * await app.init();\n *\n * // Draw something to extract\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill(0xFF0000);\n *\n * // Basic extraction examples\n * const image = await app.renderer.extract.image(graphics);    // As IImage (HTMLImageElement)\n * const canvas = app.renderer.extract.canvas(graphics);        // As Canvas\n * const pixels = app.renderer.extract.pixels(graphics);        // As pixel data\n * const base64 = await app.renderer.extract.base64(graphics); // As base64 string\n *\n * // Advanced extraction with options\n * const customImage = await app.renderer.extract.image({\n *     target: graphics,\n *     format: 'png',\n *     resolution: 2,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     clearColor: '#00000000'\n * });\n *\n * // Download content\n * app.renderer.extract.download({\n *     target: graphics,\n *     filename: 'my-image.png'\n * });\n *\n * // Debug visualization\n * app.renderer.extract.log(graphics);\n * ```\n *\n * Features:\n * - Extract as various formats (PNG, JPEG, WebP)\n * - Control output quality and resolution\n * - Extract specific regions\n * - Download extracted content\n * - Debug visualization\n *\n * Common Use Cases:\n * - Creating thumbnails\n * - Saving game screenshots\n * - Processing visual content\n * - Debugging renders\n * - Creating textures from rendered content\n *\n * Performance Considerations:\n * - Extraction operations are relatively expensive\n * - Consider caching results for frequently used content\n * - Be mindful of resolution and format choices\n * - Large extractions may impact performance\n * @category rendering\n * @standard\n */\nexport class ExtractSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'extract',\n    } as const;\n\n    /**\n     * Default options for image extraction.\n     * @example\n     * ```ts\n     * // Customize default options\n     * ExtractSystem.defaultImageOptions.format = 'webp';\n     * ExtractSystem.defaultImageOptions.quality = 0.8;\n     *\n     * // Use defaults\n     * const image = await renderer.extract.image(sprite);\n     * ```\n     */\n    public static defaultImageOptions: ImageOptions = {\n        format: 'png' as Formats,\n        quality: 1,\n    };\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    private _normalizeOptions<T extends ExtractOptions>(\n        options: ExtractImageOptions | Container | Texture,\n        defaults: Partial<T> = {},\n    ): T\n    {\n        if (options instanceof Container || options instanceof Texture)\n        {\n            return {\n                target: options,\n                ...defaults\n            } as T;\n        }\n\n        return {\n            ...defaults,\n            ...options,\n        } as T;\n    }\n\n    /**\n     * Creates an IImage from a display object or texture.\n     * @param options - Options for creating the image, or the target to extract\n     * @returns Promise that resolves with the generated IImage\n     * @example\n     * ```ts\n     * // Basic usage with a sprite\n     * const sprite = new Sprite(texture);\n     * const image = await renderer.extract.image(sprite);\n     * document.body.appendChild(image);\n     *\n     * // Advanced usage with options\n     * const image = await renderer.extract.image({\n     *     target: container,\n     *     format: 'webp',\n     *     quality: 0.8,\n     *     frame: new Rectangle(0, 0, 100, 100),\n     *     resolution: 2,\n     *     clearColor: '#ff0000',\n     *     antialias: true\n     * });\n     *\n     * // Extract directly from a texture\n     * const texture = Texture.from('myTexture.png');\n     * const image = await renderer.extract.image(texture);\n     * ```\n     * @see {@link ExtractImageOptions} For detailed options\n     * @see {@link ExtractSystem.base64} For base64 string output\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ImageLike} For the image interface\n     * @category rendering\n     */\n    public async image(options: ExtractImageOptions | Container | Texture): Promise<ImageLike>\n    {\n        const image = DOMAdapter.get().createImage();\n\n        image.src = await this.base64(options);\n\n        return image;\n    }\n\n    /**\n     * Converts the target into a base64 encoded string.\n     *\n     * This method works by first creating\n     * a canvas using `Extract.canvas` and then converting it to a base64 string.\n     * @param options - The options for creating the base64 string, or the target to extract\n     * @returns Promise that resolves with the base64 encoded string\n     * @example\n     * ```ts\n     * // Basic usage with a sprite\n     * const sprite = new Sprite(texture);\n     * const base64 = await renderer.extract.base64(sprite);\n     * console.log(base64); // data:image/png;base64,...\n     *\n     * // Advanced usage with options\n     * const base64 = await renderer.extract.base64({\n     *     target: container,\n     *     format: 'webp',\n     *     quality: 0.8,\n     *     frame: new Rectangle(0, 0, 100, 100),\n     *     resolution: 2\n     * });\n     * ```\n     * @throws Will throw an error if the platform doesn't support any of:\n     * - ICanvas.toDataURL\n     * - ICanvas.toBlob\n     * - ICanvas.convertToBlob\n     * @see {@link ExtractImageOptions} For detailed options\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ExtractSystem.image} For HTMLImage output\n     * @category rendering\n     */\n    public async base64(options: ExtractImageOptions | Container | Texture): Promise<string>\n    {\n        options = this._normalizeOptions<ExtractImageOptions>(\n            options,\n            ExtractSystem.defaultImageOptions\n        );\n\n        const { format, quality } = options;\n\n        const canvas = this.canvas(options);\n\n        if (canvas.toBlob !== undefined)\n        {\n            return new Promise<string>((resolve, reject) =>\n            {\n                canvas.toBlob!((blob) =>\n                {\n                    if (!blob)\n                    {\n                        reject(new Error('ICanvas.toBlob failed!'));\n\n                        return;\n                    }\n\n                    const reader = new FileReader();\n\n                    reader.onload = () => resolve(reader.result as string);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }, imageTypes[format], quality);\n            });\n        }\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(imageTypes[format], quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n\n            return new Promise<string>((resolve, reject) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, '\n            + 'or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders the target to it and returns it.\n     * This method is useful for creating static images or when you need direct canvas access.\n     * @param options - The options for creating the canvas, or the target to extract\n     * @returns A Canvas element with the texture rendered on\n     * @example\n     * ```ts\n     * // Basic canvas extraction from a sprite\n     * const sprite = new Sprite(texture);\n     * const canvas = renderer.extract.canvas(sprite);\n     * document.body.appendChild(canvas);\n     *\n     * // Extract with custom region\n     * const canvas = renderer.extract.canvas({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const canvas = renderer.extract.canvas({\n     *     target: sprite,\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Extract directly from a texture\n     * const texture = Texture.from('myTexture.png');\n     * const canvas = renderer.extract.canvas(texture);\n     *\n     * // Extract with anti-aliasing\n     * const canvas = renderer.extract.canvas({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link ExtractSystem.image} For HTMLImage output\n     * @see {@link ExtractSystem.pixels} For raw pixel data\n     * @category rendering\n     */\n    public canvas(options: ExtractOptions | Container | Texture): ICanvas\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n\n        if (target instanceof Texture)\n        {\n            return renderer.texture.generateCanvas(target);\n        }\n\n        const texture = renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const canvas = renderer.texture.generateCanvas(texture);\n\n        texture.destroy(true);\n\n        return canvas;\n    }\n\n    /**\n     * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n     * with integer values between 0 and 255 (inclusive).\n     * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n     * @param options - The options for extracting the image, or the target to extract\n     * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n     * @example\n     * ```ts\n     * // Basic pixel extraction\n     * const sprite = new Sprite(texture);\n     * const pixels = renderer.extract.pixels(sprite);\n     * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n     *\n     * // Extract with custom region\n     * const pixels = renderer.extract.pixels({\n     *     target: sprite,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const pixels = renderer.extract.pixels({\n     *     target: sprite,\n     *     resolution: 2\n     * });\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ExtractSystem.image} For image output\n     * @category rendering\n     */\n    public pixels(options: ExtractOptions | Container | Texture): GetPixelsOutput\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n        const texture = target instanceof Texture\n            ? target\n            : renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const pixelInfo = renderer.texture.getPixels(texture);\n\n        if (target instanceof Container)\n        {\n            // destroy generated texture\n            texture.destroy(true);\n        }\n\n        return pixelInfo;\n    }\n\n    /**\n     * Creates a texture from a display object or existing texture.\n     *\n     * This is useful for creating\n     * reusable textures from rendered content or making copies of existing textures.\n     * > [!NOTE] The returned texture should be destroyed when no longer needed\n     * @param options - The options for creating the texture, or the target to extract\n     * @returns A new texture containing the extracted content\n     * @example\n     * ```ts\n     * // Basic texture extraction from a sprite\n     * const sprite = new Sprite(texture);\n     * const extractedTexture = renderer.extract.texture(sprite);\n     *\n     * // Extract with custom region\n     * const regionTexture = renderer.extract.texture({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const hiResTexture = renderer.extract.texture({\n     *     target: sprite,\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Create a new sprite from extracted texture\n     * const newSprite = new Sprite(\n     *     renderer.extract.texture({\n     *         target: graphics,\n     *         antialias: true\n     *     })\n     * );\n     *\n     * // Clean up when done\n     * extractedTexture.destroy(true);\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link Texture} For texture management\n     * @see {@link GenerateTextureSystem} For texture generation\n     * @category rendering\n     */\n    public texture(options: ExtractOptions | Container | Texture): Texture\n    {\n        options = this._normalizeOptions(options);\n\n        if (options.target instanceof Texture) return options.target;\n\n        return this._renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n    }\n\n    /**\n     * Extracts and downloads content from the renderer as an image file.\n     * This is a convenient way to save screenshots or export rendered content.\n     * > [!NOTE] The download will use PNG format regardless of the filename extension\n     * @param options - The options for downloading and extracting the image, or the target to extract\n     * @example\n     * ```ts\n     * // Basic download with default filename\n     * const sprite = new Sprite(texture);\n     * renderer.extract.download(sprite); // Downloads as 'image.png'\n     *\n     * // Download with custom filename\n     * renderer.extract.download({\n     *     target: sprite,\n     *     filename: 'screenshot.png'\n     * });\n     *\n     * // Download with custom region\n     * renderer.extract.download({\n     *     target: container,\n     *     filename: 'region.png',\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Download with high resolution and background\n     * renderer.extract.download({\n     *     target: stage,\n     *     filename: 'hd-screenshot.png',\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Download with anti-aliasing\n     * renderer.extract.download({\n     *     target: graphics,\n     *     filename: 'smooth.png',\n     *     antialias: true\n     * });\n     * ```\n     * @see {@link ExtractDownloadOptions} For detailed options\n     * @see {@link ExtractSystem.image} For creating images without download\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @category rendering\n     */\n    public download(options: ExtractDownloadOptions | Container | Texture)\n    {\n        /* eslint-disable no-restricted-globals */\n        options = this._normalizeOptions<ExtractDownloadOptions>(options);\n\n        const canvas = this.canvas(options);\n\n        const link = document.createElement('a');\n\n        link.download = options.filename ?? 'image.png';\n        link.href = canvas.toDataURL('image/png');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        /* eslint-enable no-restricted-globals */\n    }\n\n    /**\n     * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n     * The image will be displayed in the browser's console using CSS background images.\n     * @param options - The options for logging the image, or the target to log\n     * @param options.width - The width of the logged image preview in the console (in pixels)\n     * @example\n     * ```ts\n     * // Basic usage\n     * const sprite = new Sprite(texture);\n     * renderer.extract.log(sprite);\n     * ```\n     * @see {@link ExtractSystem.canvas} For getting raw canvas output\n     * @see {@link ExtractSystem.pixels} For raw pixel data\n     * @category rendering\n     * @advanced\n     */\n    public log(options: (ExtractOptions & {width?: number}) | Container | Texture)\n    {\n        const width = options.width ?? 200;\n\n        options = this._normalizeOptions(options);\n\n        const canvas = this.canvas(options);\n\n        const base64 = canvas.toDataURL();\n\n        // eslint-disable-next-line no-console\n        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n\n        const style = [\n            'font-size: 1px;',\n            `padding: ${width}px ${300}px;`,\n            `background: url(${base64}) no-repeat;`,\n            'background-size: contain;',\n        ].join(' ');\n\n        // eslint-disable-next-line no-console\n        console.log('%c ', style);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { FilterEffect } from '../../../../filters/FilterEffect';\nimport { RenderGroup } from '../../../../scene/container/RenderGroup';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { BlendModeFilter } from '../../../../filters/blend-modes/BlendModeFilter';\nimport type { FilterInstruction } from '../../../../filters/FilterSystem';\nimport type { Renderer } from '../../types';\nimport type { Instruction } from '../instructions/Instruction';\nimport type { InstructionSet } from '../instructions/InstructionSet';\nimport type { InstructionPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { BLEND_MODES } from '../state/const';\n\ninterface AdvancedBlendInstruction extends Instruction\n{\n    renderPipeId: 'blendMode',\n    blendMode: BLEND_MODES,\n    activeBlend: Renderable[],\n}\n\n// class map\nconst BLEND_MODE_FILTERS: Partial<Record<BLEND_MODES, new () => BlendModeFilter>> = {} as const;\n\nextensions.handle(ExtensionType.BlendMode, (value) =>\n{\n    if (!value.name)\n    {\n        throw new Error('BlendMode extension must have a name property');\n    }\n    BLEND_MODE_FILTERS[value.name as BLEND_MODES] = value.ref;\n}, (value) =>\n{\n    delete BLEND_MODE_FILTERS[value.name as BLEND_MODES];\n});\n\n/**\n * This Pipe handles the blend mode switching of the renderer.\n * It will insert instructions into the {@link InstructionSet} to switch the blend mode according to the\n * blend modes of the scene graph.\n *\n * This pipe is were wwe handle Advanced blend modes. Advanced blend modes essentially wrap the renderables\n * in a filter that applies the blend mode.\n *\n * You only need to use this class if you are building your own render instruction set rather than letting PixiJS build\n * the instruction set for you by traversing the scene graph\n * @category rendering\n * @internal\n */\nexport class BlendModePipe implements InstructionPipe<AdvancedBlendInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'blendMode',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _renderableList?: Renderable[];\n    private _activeBlendMode: BLEND_MODES;\n    private readonly _blendModeStack: BLEND_MODES[] = [];\n\n    private _isAdvanced = false;\n\n    private _filterHash: Partial<Record<BLEND_MODES, FilterEffect>> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.prerender.add(this);\n    }\n\n    public prerender()\n    {\n        // make sure we reset the blend modes to normal\n        // this way the next render will register any changes\n        this._activeBlendMode = 'normal';\n        this._isAdvanced = false;\n    }\n\n    /**\n     * Push a blend mode onto the internal stack and apply it to the instruction set if needed.\n     * @param renderable - The renderable or {@link RenderGroup} associated with the change.\n     * @param blendMode - The blend mode to activate.\n     * @param instructionSet - The instruction set being built.\n     */\n    public pushBlendMode(renderable: Renderable | RenderGroup, blendMode: BLEND_MODES, instructionSet: InstructionSet): void\n    {\n        this._blendModeStack.push(blendMode);\n\n        this.setBlendMode(renderable, blendMode, instructionSet);\n    }\n\n    /**\n     * Pop the last blend mode from the stack and apply the new top-of-stack mode.\n     * @param instructionSet - The instruction set being built.\n     */\n    public popBlendMode(instructionSet: InstructionSet): void\n    {\n        this._blendModeStack.pop();\n        const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? 'normal';\n\n        this.setBlendMode(null, blendMode, instructionSet);\n    }\n\n    /**\n     * Ensure a blend mode switch is added to the instruction set when the mode changes.\n     * If an advanced blend mode is active, subsequent renderables will be collected so they can be\n     * rendered within a single filter pass.\n     * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.\n     * @param blendMode - The target blend mode.\n     * @param instructionSet - The instruction set being built.\n     */\n    public setBlendMode(\n        renderable: Renderable | RenderGroup | null,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet\n    )\n    {\n        const isRenderGroup = renderable instanceof RenderGroup;\n\n        if (this._activeBlendMode === blendMode)\n        {\n            if (this._isAdvanced && renderable && !isRenderGroup)\n            {\n                this._renderableList?.push(renderable);\n            }\n\n            return;\n        }\n\n        if (this._isAdvanced) this._endAdvancedBlendMode(instructionSet);\n\n        this._activeBlendMode = blendMode;\n\n        if (!renderable) return;\n\n        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n\n        if (this._isAdvanced) this._beginAdvancedBlendMode(renderable, instructionSet);\n    }\n\n    private _beginAdvancedBlendMode(renderable: Renderable | RenderGroup, instructionSet: InstructionSet)\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const blendMode = this._activeBlendMode;\n\n        if (!BLEND_MODE_FILTERS[blendMode])\n        {\n            // #if _DEBUG\n            warn(`Unable to assign BlendMode: '${blendMode}'. `\n                + `You may want to include: import 'pixi.js/advanced-blend-modes'`);\n            // #endif\n\n            return;\n        }\n\n        const filterEffect = this._ensureFilterEffect(blendMode);\n        const isRenderGroup = renderable instanceof RenderGroup;\n        const instruction: FilterInstruction = {\n            renderPipeId: 'filter',\n            action: 'pushFilter',\n            filterEffect,\n            renderables: isRenderGroup ? null : [renderable],\n            container: isRenderGroup ? renderable.root : null,\n            canBundle: false\n        };\n\n        this._renderableList = instruction.renderables;\n\n        instructionSet.add(instruction);\n    }\n\n    private _ensureFilterEffect(blendMode: BLEND_MODES): FilterEffect\n    {\n        let filterEffect: FilterEffect = this._filterHash[blendMode];\n\n        if (!filterEffect)\n        {\n            filterEffect = this._filterHash[blendMode] = new FilterEffect();\n            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS]()];\n        }\n\n        return filterEffect;\n    }\n\n    private _endAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._isAdvanced = false;\n        this._renderableList = null;\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    /**\n     * called when the instruction build process is starting this will reset internally to the default blend mode\n     * @internal\n     */\n    public buildStart()\n    {\n        this._isAdvanced = false;\n    }\n\n    /**\n     * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n     * active, we add the final render instructions added to the instruction set\n     * @param instructionSet - The instruction set we are adding to\n     * @internal\n     */\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        if (!this._isAdvanced) return;\n\n        this._endAdvancedBlendMode(instructionSet);\n    }\n\n    /** @internal */\n    public destroy()\n    {\n        this._renderer = null;\n        this._renderableList = null;\n\n        for (const i in this._filterHash)\n        {\n            this._filterHash[i as BLEND_MODES].destroy();\n        }\n\n        this._filterHash = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Point } from '../../../../maths/point/Point';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { type Renderer, RendererType } from '../../types';\nimport { UniformGroup } from '../shader/UniformGroup';\n\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { GlRenderTargetSystem } from '../../gl/renderTarget/GlRenderTargetSystem';\nimport type { GpuRenderTargetSystem } from '../../gpu/renderTarget/GpuRenderTargetSystem';\nimport type { WebGPURenderer } from '../../gpu/WebGPURenderer';\nimport type { UboSystem } from '../shader/UboSystem';\nimport type { System } from '../system/System';\n\n/**\n * Type definition for the global uniforms used in the renderer.\n * This includes projection matrix, world transform matrix, world color, and resolution.\n * @category rendering\n * @advanced\n */\nexport type GlobalUniformGroup = UniformGroup<{\n    uProjectionMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldTransformMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldColorAlpha: { value: Float32Array; type: 'vec4<f32>' }\n    uResolution: { value: number[]; type: 'vec2<f32>' }\n}>;\n\n/**\n * Options for the global uniforms system.\n * This includes size, projection matrix, world transform matrix, world color, and offset.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformOptions\n{\n    size?: number[],\n    projectionMatrix?: Matrix,\n    worldTransformMatrix?: Matrix\n    worldColor?: number\n    offset?: PointData\n}\n\n/**\n * Data structure for the global uniforms used in the renderer.\n * This includes the projection matrix, world transform matrix, world color, resolution, and bind group.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformData\n{\n    projectionMatrix: Matrix\n    worldTransformMatrix: Matrix\n    worldColor: number\n    resolution: number[]\n    offset: PointData\n    bindGroup: BindGroup\n}\n\n/** @internal */\nexport interface GlobalUniformRenderer\n{\n    renderTarget: GlRenderTargetSystem | GpuRenderTargetSystem\n    renderPipes: Renderer['renderPipes'];\n    ubo: UboSystem;\n    type: RendererType;\n}\n\n/**\n * System plugin to the renderer to manage global uniforms for the renderer.\n * @category rendering\n * @advanced\n */\nexport class GlobalUniformSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'globalUniforms',\n    } as const;\n\n    private readonly _renderer: GlobalUniformRenderer;\n\n    private _stackIndex = 0;\n    private _globalUniformDataStack: GlobalUniformData[] = [];\n\n    private readonly _uniformsPool: GlobalUniformGroup[] = [];\n    private readonly _activeUniforms: GlobalUniformGroup[] = [];\n\n    private readonly _bindGroupPool: BindGroup[] = [];\n    private readonly _activeBindGroups: BindGroup[] = [];\n\n    private _currentGlobalUniformData: GlobalUniformData;\n\n    constructor(renderer: GlobalUniformRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public reset()\n    {\n        this._stackIndex = 0;\n\n        for (let i = 0; i < this._activeUniforms.length; i++)\n        {\n            this._uniformsPool.push(this._activeUniforms[i]);\n        }\n\n        for (let i = 0; i < this._activeBindGroups.length; i++)\n        {\n            this._bindGroupPool.push(this._activeBindGroups[i]);\n        }\n\n        this._activeUniforms.length = 0;\n        this._activeBindGroups.length = 0;\n    }\n\n    public start(options: GlobalUniformOptions): void\n    {\n        this.reset();\n\n        this.push(options);\n    }\n\n    public bind({\n        size,\n        projectionMatrix,\n        worldTransformMatrix,\n        worldColor,\n        offset,\n    }: GlobalUniformOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.renderTarget;\n\n        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n            projectionData: renderTarget,\n            worldTransformMatrix: new Matrix(),\n            worldColor: 0xFFFFFFFF,\n            offset: new Point(),\n        };\n\n        const globalUniformData: GlobalUniformData = {\n            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n            resolution: size || renderTarget.size,\n            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n            worldColor: worldColor || currentGlobalUniformData.worldColor,\n            offset: offset || currentGlobalUniformData.offset,\n            bindGroup: null,\n        };\n\n        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n\n        this._activeUniforms.push(uniformGroup);\n\n        const uniforms = uniformGroup.uniforms;\n\n        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n\n        uniforms.uResolution = globalUniformData.resolution;\n\n        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n\n        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n\n        color32BitToUniform(\n            globalUniformData.worldColor,\n            uniforms.uWorldColorAlpha,\n            0\n        );\n\n        uniformGroup.update();\n\n        let bindGroup: BindGroup;\n\n        if ((this._renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            bindGroup = (this._renderer as WebGPURenderer).renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n        }\n        else\n        {\n            bindGroup = this._bindGroupPool.pop() || new BindGroup();\n            this._activeBindGroups.push(bindGroup);\n            bindGroup.setResource(uniformGroup, 0);\n        }\n\n        globalUniformData.bindGroup = bindGroup;\n\n        this._currentGlobalUniformData = globalUniformData;\n    }\n\n    public push(options: GlobalUniformOptions)\n    {\n        this.bind(options);\n\n        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n    }\n\n    public pop()\n    {\n        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n\n        // for webGL we need to update the uniform group here\n        // as we are not using bind groups\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            (this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup).update();\n        }\n    }\n\n    get bindGroup(): BindGroup\n    {\n        return this._currentGlobalUniformData.bindGroup;\n    }\n\n    get globalUniformData()\n    {\n        return this._currentGlobalUniformData;\n    }\n\n    get uniformGroup()\n    {\n        return this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup;\n    }\n\n    private _createUniforms(): GlobalUniformGroup\n    {\n        const globalUniforms = new UniformGroup({\n            uProjectionMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uWorldTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n            uWorldColorAlpha: { value: new Float32Array(4), type: 'vec4<f32>' },\n            uResolution: { value: [0, 0], type: 'vec2<f32>' },\n        }, {\n            isStatic: true,\n        });\n\n        return globalUniforms;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._globalUniformDataStack.length = 0;\n        this._uniformsPool.length = 0;\n        this._activeUniforms.length = 0;\n        this._bindGroupPool.length = 0;\n        this._activeBindGroups.length = 0;\n        this._currentGlobalUniformData = null;\n    }\n}\n","import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\n\n/**\n * Options for generating a texture source.\n * @category rendering\n * @advanced\n * @interface\n */\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * Used to create reusable textures from display objects, which can improve performance\n * when the same content needs to be rendered multiple times.\n * @example\n * ```ts\n * // Basic texture generation\n * const sprite = new Sprite(texture);\n * const generatedTexture = renderer.generateTexture({\n *     target: sprite\n * });\n *\n * // Generate with custom region and resolution\n * const texture = renderer.generateTexture({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // Generate with background color and anti-aliasing\n * const highQualityTexture = renderer.generateTexture({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     textureSourceOptions: {\n *         scaleMode: 'linear'\n *     }\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport type GenerateTextureOptions = {\n    /**\n     * The container to generate the texture from.\n     * This can be any display object like Sprite, Container, or Graphics.\n     * @example\n     * ```ts\n     * const graphics = new Graphics()\n     *     .circle(0, 0, 50)\n     *     .fill('red');\n     *\n     * const texture = renderer.generateTexture({\n     *     target: graphics\n     * });\n     * ```\n     */\n    target: Container;\n\n    /**\n     * The region of the container that should be rendered.\n     * If not specified, defaults to the local bounds of the container.\n     * @example\n     * ```ts\n     * // Extract only a portion of the container\n     * const texture = renderer.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(10, 10, 100, 100)\n     * });\n     * ```\n     */\n    frame?: Rectangle;\n\n    /**\n     * The resolution of the texture being generated.\n     * Higher values create sharper textures at the cost of memory.\n     * @default renderer.resolution\n     * @example\n     * ```ts\n     * // Generate a high-resolution texture\n     * const hiResTexture = renderer.generateTexture({\n     *     target: sprite,\n     *     resolution: 2 // 2x resolution\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * The color used to clear the texture before rendering.\n     * Can be a hex number, string, or array of numbers.\n     * @example\n     * ```ts\n     * // Clear with red background\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Clear with semi-transparent black\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: [0, 0, 0, 0.5]\n     * });\n     * ```\n     */\n    clearColor?: ColorSource;\n\n    /**\n     * Whether to enable anti-aliasing. This may affect performance.\n     * @default false\n     * @example\n     * ```ts\n     * // Generate a smooth texture\n     * const texture = renderer.generateTexture({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     */\n    antialias?: boolean;\n\n    /**\n     * Advanced options for configuring the texture source.\n     * Controls texture properties like scale mode and filtering.\n     * @advanced\n     * @example\n     * ```ts\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     textureSourceOptions: {\n     *         scaleMode: 'linear',\n     *     }\n     * });\n     * ```\n     */\n    textureSourceOptions?: GenerateTextureSourceOptions;\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from display objects in the renderer.\n * This system is responsible for creating reusable textures from containers, sprites, and other display objects.\n * Available through `renderer.textureGenerator`.\n * @example\n * ```ts\n * import { Application, Sprite, Graphics } from 'pixi.js';\n *\n * const app = new Application();\n * await app.init();\n *\n * // Create a complex display object\n * const container = new Container();\n *\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill('red');\n *\n * const sprite = new Sprite(texture);\n * sprite.x = 100;\n *\n * container.addChild(graphics, sprite);\n *\n * // Generate a texture from the container\n * const generatedTexture = app.renderer.textureGenerator.generateTexture({\n *     target: container,\n *     resolution: 2,\n *     antialias: true\n * });\n *\n * // Use the generated texture\n * const newSprite = new Sprite(generatedTexture);\n * app.stage.addChild(newSprite);\n *\n * // Clean up when done\n * generatedTexture.destroy(true);\n * ```\n *\n * Features:\n * - Convert any display object to a texture\n * - Support for custom regions and resolutions\n * - Anti-aliasing support\n * - Background color configuration\n * - Texture source options customization\n *\n * Common Use Cases:\n * - Creating texture atlases dynamically\n * - Caching complex container content\n * - Generating thumbnails\n * - Creating reusable textures from rendered content\n *\n * Performance Considerations:\n * - Generating textures is relatively expensive\n * - Cache results when possible\n * - Be mindful of resolution and size\n * - Clean up unused textures\n * @see {@link GenerateTextureOptions} For detailed texture generation options\n * @see {@link AbstractRenderer.generateTexture} For the main renderer method\n * @see {@link RenderTexture} For the resulting texture type\n * @category rendering\n * @standard\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Creates a texture from a display object that can be used for creating sprites and other textures.\n     * This is particularly useful for optimizing performance when a complex container needs to be reused.\n     * @param options - Generate texture options or a container to convert to texture\n     * @returns A new RenderTexture containing the rendered display object\n     * @example\n     * ```ts\n     * // Basic usage with a container\n     * const container = new Container();\n     * container.addChild(\n     *     new Graphics()\n     *         .circle(0, 0, 50)\n     *         .fill('red')\n     * );\n     *\n     * const texture = renderer.textureGenerator.generateTexture(container);\n     *\n     * // Advanced usage with options\n     * const texture = renderer.textureGenerator.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n     *     resolution: 2,                        // High DPI\n     *     clearColor: '#ff0000',               // Red background\n     *     antialias: true                      // Smooth edges\n     * });\n     *\n     * // Create a sprite from the generated texture\n     * const sprite = new Sprite(texture);\n     *\n     * // Clean up when done\n     * texture.destroy(true);\n     * ```\n     * @see {@link GenerateTextureOptions} For detailed texture generation options\n     * @see {@link RenderTexture} For the type of texture created\n     * @category rendering\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): RenderTexture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        target.source.updateMipmaps();\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { type RendererOptions } from '../../types';\nimport { RenderTarget } from '../renderTarget/RenderTarget';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { System } from '../system/System';\nimport type { CanvasSource } from '../texture/sources/CanvasSource';\nimport type { Texture } from '../texture/Texture';\n\n/**\n * Options passed to the ViewSystem\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemOptions\n{\n    /**\n     * The width of the screen.\n     * @default 800\n     */\n    width?: number;\n    /**\n     * The height of the screen.\n     * @default 600\n     */\n    height?: number;\n    /** The canvas to use as a view, optional. */\n    canvas?: ICanvas;\n    /**\n     * Alias for `canvas`.\n     * @deprecated since 8.0.0\n     */\n    view?: ICanvas;\n    /**\n     * Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n     *\n     * This is only supported for HTMLCanvasElement\n     * and will be ignored if the canvas is an OffscreenCanvas.\n     */\n    autoDensity?: boolean;\n    /** The resolution / device pixel ratio of the renderer. */\n    resolution?: number;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n    /** Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer. */\n    depth?: boolean;\n}\n\n/**\n * Options for destroying the ViewSystem.\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemDestroyOptions\n{\n    /** Whether to remove the view element from the DOM. Defaults to `false`. */\n    removeView?: boolean;\n}\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @advanced\n */\nexport class ViewSystem implements System<ViewSystemOptions, TypeOrBool<ViewSystemDestroyOptions> >\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'view',\n        priority: 0,\n    } as const;\n\n    /** The default options for the view system. */\n    public static defaultOptions: ViewSystemOptions = {\n        /**\n         * {@link WebGLOptions.width}\n         * @default 800\n         */\n        width: 800,\n        /**\n         * {@link WebGLOptions.height}\n         * @default 600\n         */\n        height: 600,\n        /**\n         * {@link WebGLOptions.autoDensity}\n         * @default false\n         */\n        autoDensity: false,\n        /**\n         * {@link WebGLOptions.antialias}\n         * @default false\n         */\n        antialias: false,\n    };\n\n    /** The canvas element that everything is drawn to. */\n    public canvas!: ICanvas;\n\n    /** The texture that is used to draw the canvas to the screen. */\n    public texture: Texture<CanvasSource>;\n\n    /**\n     * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n     * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n     * @type {boolean}\n     */\n    public get autoDensity(): boolean\n    {\n        return this.texture.source.autoDensity;\n    }\n    public set autoDensity(value: boolean)\n    {\n        this.texture.source.autoDensity = value;\n    }\n\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    public antialias: boolean;\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    public screen: Rectangle;\n    /** The render target that the view is drawn to. */\n    public renderTarget: RenderTarget;\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.texture.source._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.texture.source.resize(\n            this.texture.source.width,\n            this.texture.source.height,\n            value\n        );\n    }\n\n    /**\n     * initiates the view system\n     * @param options - the options for the view\n     */\n    public init(options: ViewSystemOptions): void\n    {\n        options = {\n            ...ViewSystem.defaultOptions,\n            ...options,\n        };\n\n        if (options.view)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'ViewSystem.view has been renamed to ViewSystem.canvas');\n            // #endif\n\n            options.canvas = options.view;\n        }\n\n        this.screen = new Rectangle(0, 0, options.width, options.height);\n        this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n        this.antialias = !!options.antialias;\n        this.texture = getCanvasTexture(this.canvas, options);\n        this.renderTarget = new RenderTarget({\n            colorTextures: [this.texture],\n            depth: !!options.depth,\n            isRoot: true,\n        });\n\n        this.texture.source.transparent = (options as RendererOptions).backgroundAlpha < 1;\n        this.resolution = options.resolution;\n    }\n\n    /**\n     * Resizes the screen and canvas to the specified dimensions.\n     * @param desiredScreenWidth - The new width of the screen.\n     * @param desiredScreenHeight - The new height of the screen.\n     * @param resolution\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution: number): void\n    {\n        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n\n        this.screen.width = this.texture.frame.width;\n        this.screen.height = this.texture.frame.height;\n    }\n\n    /**\n     * Destroys this System and optionally removes the canvas from the dom.\n     * @param {options | false} options - The options for destroying the view, or \"false\".\n     * @example\n     * viewSystem.destroy();\n     * viewSystem.destroy(true);\n     * viewSystem.destroy({ removeView: true });\n     */\n    public destroy(options: TypeOrBool<ViewSystemDestroyOptions> = false): void\n    {\n        const removeView = typeof options === 'boolean' ? options : !!options?.removeView;\n\n        if (removeView && this.canvas.parentNode)\n        {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n\n        this.texture.destroy();\n\n        // note: don't nullify the element\n        //       other systems may need to unbind from it during the destroy iteration (eg. GLContextSystem)\n    }\n}\n","import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe';\nimport { BackgroundSystem } from '../background/BackgroundSystem';\nimport { BlendModePipe } from '../blendModes/BlendModePipe';\nimport { ExtractSystem } from '../extract/ExtractSystem';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport { GCSystem } from '../GCSystem';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem';\nimport { SchedulerSystem } from '../SchedulerSystem';\nimport { HelloSystem } from '../startup/HelloSystem';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem';\nimport { TextureGCSystem } from '../texture/TextureGCSystem';\nimport { ViewSystem } from '../view/ViewSystem';\n\nimport type { ExtractRendererOptions } from './utils/typeUtils';\n\n/**\n * Shared systems for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedSystems = [\n    BackgroundSystem,\n    GlobalUniformSystem,\n    HelloSystem,\n    ViewSystem,\n    RenderGroupSystem,\n    GCSystem,\n    TextureGCSystem,\n    GenerateTextureSystem,\n    ExtractSystem,\n    RendererInitHook,\n    RenderableGCSystem,\n    SchedulerSystem,\n];\n\n/**\n * Shared render pipes for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedRenderPipes = [\n    BlendModePipe,\n    BatcherPipe,\n    SpritePipe,\n    RenderGroupPipe,\n    AlphaMaskPipe,\n    StencilMaskPipe,\n    ColorMaskPipe,\n    CustomRenderPipe\n];\n\n/**\n * Options for the shared systems of a renderer.\n * @category rendering\n * @advanced\n */\nexport interface SharedRendererOptions extends ExtractRendererOptions<typeof SharedSystems>, PixiMixins.RendererOptions\n{\n    /**\n     * Whether to stop PixiJS from dynamically importing default extensions for the renderer.\n     * It is false by default, and means PixiJS will load all the default extensions, based\n     * on the environment e.g browser/webworker.\n     * If you set this to true, then you will need to manually import the systems and extensions you need.\n     *\n     * e.g.\n     * ```js\n     * import 'accessibility';\n     * import 'app';\n     * import 'events';\n     * import 'spritesheet';\n     * import 'graphics';\n     * import 'mesh';\n     * import 'text';\n     * import 'text-bitmap';\n     * import 'text-html';\n     * import { autoDetectRenderer } from 'pixi.js';\n     *\n     * const renderer = await autoDetectRenderer({\n     *   width: 800,\n     *   height: 600,\n     *   skipExtensionImports: true,\n     * });\n     * ```\n     * @default false\n     */\n    skipExtensionImports?: boolean;\n    /**\n     * @default true\n     * @deprecated since 8.1.6\n     * @see `skipExtensionImports`\n     */\n    manageImports?: boolean;\n}\n"],"names":["CLEAR","cleanHash"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17,18,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47]}