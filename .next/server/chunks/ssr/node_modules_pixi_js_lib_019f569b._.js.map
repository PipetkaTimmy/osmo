{"version":3,"sources":["../../../../node_modules/pixi.js/src/scene/mesh/gpu/GpuMeshAdapter.ts","../../../../node_modules/pixi.js/src/scene/graphics/gpu/GpuGraphicsAdaptor.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/BindGroupSystem.ts","../../../../node_modules/pixi.js/src/rendering/batcher/gpu/GpuBatchAdaptor.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/buffer/GpuBufferSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/GpuLimitsSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/GpuEncoderSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/GpuColorMaskSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/GpuStencilSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/GpuUboSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/GpuDeviceSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/buffer/UboBatch.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTarget.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuBlendModesToPixi.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuShaderSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStateSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/GpuUniformBatchPipe.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/pipeline/PipelineSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/texture/GpuTextureSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gpu/WebGPURenderer.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * The WebGL adaptor for the mesh system. Allows the Mesh System to be used with the WebGl renderer\n * @category rendering\n * @ignore\n */\nexport class GpuMeshAdapter implements MeshAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBit,\n                textureBit,\n                roundPixelsBit,\n            ]\n        });\n\n        this._shader = new Shader({\n            gpuProgram,\n            resources: {\n                uTexture: Texture.EMPTY._source,\n                uSampler: Texture.EMPTY._source.style,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh)\n    {\n        const renderer = meshPipe.renderer as WebGPURenderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n        }\n        else if (!shader.gpuProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no gpuProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        const gpuProgram = shader.gpuProgram;\n        // GPU..\n\n        if (gpuProgram.autoAssignGlobalUniforms)\n        {\n            shader.groups[0] = renderer.globalUniforms.bindGroup;\n        }\n\n        if (gpuProgram.autoAssignLocalUniforms)\n        {\n            const localUniforms = meshPipe.localUniforms;\n\n            shader.groups[1] = (renderer as WebGPURenderer)\n                .renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n        }\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { type Renderer } from '../../../rendering/renderers/types';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { GpuEncoderSystem } from '../../../rendering/renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses the GPU to render graphics.\n * @category rendering\n * @ignore\n */\nexport class GpuGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    private _maxTextures = 0;\n\n    public contextChange(renderer: Renderer): void\n    {\n        const localUniforms = new UniformGroup({\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        this._maxTextures = renderer.limits.maxBatchableTextures;\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'graphics',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(this._maxTextures),\n\n                localUniformBitGroup2,\n                roundPixelsBit\n            ]\n        });\n\n        this.shader = new Shader({\n            gpuProgram,\n            resources: {\n                // added on the fly!\n                localUniforms,\n            },\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGPURenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            batcher, instructions\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGPU specific...\n\n        // TODO perf test this a bit...\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n\n        const localBindGroup = (renderer as WebGPURenderer)\n            .renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n\n        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        let topology: Topology = null;\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.topology !== topology)\n            {\n                topology = batch.topology;\n\n                encoder.setPipelineFromGeometryProgramAndState(\n                    batcher.geometry,\n                    shader.gpuProgram,\n                    graphicsPipe.state,\n                    batch.topology\n                );\n            }\n\n            shader.groups[1] = batch.bindGroup;\n\n            if (!batch.gpuBindGroup)\n            {\n                const textureBatch = batch.textures;\n\n                batch.bindGroup = getTextureBatchBindGroup(\n                    textureBatch.textures,\n                    textureBatch.count,\n                    this._maxTextures\n                );\n\n                batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n                    batch.bindGroup, shader.gpuProgram, 1\n                );\n            }\n\n            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n\n            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { BufferResource } from '../shared/buffer/BufferResource';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { System } from '../shared/system/System';\nimport type { TextureSource } from '../shared/texture/sources/TextureSource';\nimport type { TextureStyle } from '../shared/texture/TextureStyle';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { BindResource } from './shader/BindResource';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the WebGPU bind groups. this is how data is bound to a shader when rendering\n * @category rendering\n * @advanced\n */\nexport class BindGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'bindGroup',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _hash: Record<string, GPUBindGroup> = Object.create(null);\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getBindGroup(bindGroup: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        bindGroup._updateKey();\n\n        const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n\n        return gpuBindGroup;\n    }\n\n    private _createBindGroup(group: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        const device = this._gpu.device;\n        const groupLayout = program.layout[groupIndex];\n        const entries: GPUBindGroupEntry[] = [];\n        const renderer = this._renderer;\n\n        for (const j in groupLayout)\n        {\n            const resource: BindResource = group.resources[j] ?? group.resources[groupLayout[j]];\n            let gpuResource: GPUSampler | GPUTextureView | GPUExternalTexture | GPUBufferBinding;\n            // TODO make this dynamic..\n\n            if (resource._resourceType === 'uniformGroup')\n            {\n                const uniformGroup = resource as UniformGroup;\n\n                renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n\n                const buffer = uniformGroup.buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'buffer')\n            {\n                const buffer = resource as Buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'bufferResource')\n            {\n                const bufferResource = resource as BufferResource;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n                    offset: bufferResource.offset,\n                    size: bufferResource.size,\n                };\n            }\n            else if (resource._resourceType === 'textureSampler')\n            {\n                const sampler = resource as TextureStyle;\n\n                gpuResource = renderer.texture.getGpuSampler(sampler);\n            }\n            else if (resource._resourceType === 'textureSource')\n            {\n                const texture = resource as TextureSource;\n\n                gpuResource = renderer.texture.getGpuSource(texture).createView();\n            }\n\n            entries.push({\n                binding: groupLayout[j],\n                resource: gpuResource,\n            });\n        }\n\n        const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n\n        const gpuBindGroup = device.createBindGroup({\n            layout,\n            entries,\n        });\n\n        this._hash[group._key] = gpuBindGroup;\n\n        return gpuBindGroup;\n    }\n\n    public destroy(): void\n    {\n        this._hash = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup';\n\nimport type { GpuEncoderSystem } from '../../renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\nconst tempState = State.for2d();\n\n/**\n * A BatcherAdaptor that uses the GPU to render batches.\n * @category rendering\n * @ignore\n */\nexport class GpuBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private _shader: Shader;\n    private _geometry: Geometry;\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n        const program = shader.gpuProgram;\n\n        this._shader = shader;\n        this._geometry = geometry;\n\n        encoder.setGeometry(geometry, program);\n\n        tempState.blendMode = 'normal';\n\n        // this just initiates the pipeline, so we can then set bind groups on it\n        renderer.pipeline.getPipeline(\n            geometry,\n            program,\n            tempState\n        );\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        // low level - we need to reset the bind group at location 1 to null\n        // this is because we directly manipulate the bound buffer in the execute function for\n        // performance reasons.\n        // setting it to null ensures that the next bind group we set at location 1 will\n        // be the one we want.\n        encoder.resetBindGroup(1);\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, program);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const program = this._shader.gpuProgram;\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        if (!batch.bindGroup)\n        {\n            const textureBatch = batch.textures;\n\n            batch.bindGroup = getTextureBatchBindGroup(\n                textureBatch.textures,\n                textureBatch.count,\n                renderer.limits.maxBatchableTextures\n            );\n        }\n\n        tempState.blendMode = batch.blendMode;\n\n        const gpuBindGroup = renderer.bindGroup.getBindGroup(\n            batch.bindGroup, program, 1\n        );\n\n        const pipeline = renderer.pipeline.getPipeline(\n            this._geometry,\n            program,\n            tempState,\n            batch.topology\n        );\n\n        batch.bindGroup._touch(renderer.gc.now, renderer.tick);\n\n        encoder.setPipeline(pipeline);\n\n        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type GPUData } from '../../../../scene/view/ViewContainer';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash';\nimport { uid } from '../../../../utils/data/uid';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/** @internal */\nexport class GpuBufferData implements GPUData\n{\n    public gpuBuffer: GPUBuffer;\n\n    constructor(gpuBuffer: GPUBuffer)\n    {\n        this.gpuBuffer = gpuBuffer;\n    }\n\n    public destroy()\n    {\n        this.gpuBuffer.destroy();\n        this.gpuBuffer = null;\n    }\n}\n\n/**\n * System plugin to the renderer to manage buffers.\n * @category rendering\n * @advanced\n */\nexport class GpuBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    protected CONTEXT_UID: number;\n    private readonly _renderer: WebGPURenderer;\n    private readonly _managedBuffers: GCManagedHash<Buffer>;\n\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        this._managedBuffers = new GCManagedHash({\n            renderer,\n            type: 'resource',\n            onUnload: this.onBufferUnload.bind(this),\n            name: 'gpuBuffer'\n        });\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        buffer._gcLastUsed = this._renderer.gc.now;\n\n        return (buffer._gpuData[this._renderer.uid] as GpuBufferData)?.gpuBuffer || this.createGPUBuffer(buffer);\n    }\n\n    public updateBuffer(buffer: Buffer): GPUBuffer\n    {\n        const gpuBuffer = this.getGPUBuffer(buffer);\n\n        const data = buffer.data;\n\n        // TODO this can be better...\n        if (buffer._updateID && data)\n        {\n            buffer._updateID = 0;\n\n            // make sure\n            this._gpu.device.queue.writeBuffer(\n                gpuBuffer, 0, data.buffer, 0,\n                // round to the nearest 4 bytes\n                ((buffer._updateSize || data.byteLength) + 3) & ~3\n            );\n        }\n\n        return gpuBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        this._managedBuffers.removeAll();\n    }\n\n    protected onBufferUnload(buffer: Buffer): void\n    {\n        buffer.off('update', this.updateBuffer, this);\n        buffer.off('change', this.onBufferChange, this);\n    }\n\n    public createGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n\n        buffer._updateID = 0;\n        buffer._resourceId = uid('resource');\n\n        if (buffer.data)\n        {\n            // TODO if data is static, this can be mapped at creation\n            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n\n            gpuBuffer.unmap();\n        }\n\n        buffer._gpuData[this._renderer.uid] = new GpuBufferData(gpuBuffer);\n        if (this._managedBuffers.add(buffer))\n        {\n            buffer.on('update', this.updateBuffer, this);\n            buffer.on('change', this.onBufferChange, this);\n        }\n\n        return gpuBuffer;\n    }\n\n    protected onBufferChange(buffer: Buffer)\n    {\n        this._managedBuffers.remove(buffer);\n        buffer._updateID = 0;\n        this.createGPUBuffer(buffer);\n    }\n\n    public destroy(): void\n    {\n        this._managedBuffers.destroy();\n        (this._renderer as null) = null;\n        this._gpu = null;\n    }\n}\n\n","import type { UboElement, UboLayout, UNIFORM_TYPES, UniformData } from '../../../shared/shader/types';\n\n/** @internal */\nexport const WGSL_ALIGN_SIZE_DATA: Record<UNIFORM_TYPES | string, {align: number, size: number}> = {\n    i32: { align: 4, size: 4 },\n    u32: { align: 4, size: 4 },\n    f32: { align: 4, size: 4 },\n    f16: { align: 2, size: 2 },\n    'vec2<i32>': { align: 8, size: 8 },\n    'vec2<u32>': { align: 8, size: 8 },\n    'vec2<f32>': { align: 8, size: 8 },\n    'vec2<f16>': { align: 4, size: 4 },\n    'vec3<i32>': { align: 16, size: 12 },\n    'vec3<u32>': { align: 16, size: 12 },\n    'vec3<f32>': { align: 16, size: 12 },\n    'vec3<f16>': { align: 8, size: 6 },\n    'vec4<i32>': { align: 16, size: 16 },\n    'vec4<u32>': { align: 16, size: 16 },\n    'vec4<f32>': { align: 16, size: 16 },\n    'vec4<f16>': { align: 8, size: 8 },\n    'mat2x2<f32>': { align: 8, size: 16 },\n    'mat2x2<f16>': { align: 4, size: 8 },\n    'mat3x2<f32>': { align: 8, size: 24 },\n    'mat3x2<f16>': { align: 4, size: 12 },\n    'mat4x2<f32>': { align: 8, size: 32 },\n    'mat4x2<f16>': { align: 4, size: 16 },\n    'mat2x3<f32>': { align: 16, size: 32 },\n    'mat2x3<f16>': { align: 8, size: 16 },\n    'mat3x3<f32>': { align: 16, size: 48 },\n    'mat3x3<f16>': { align: 8, size: 24 },\n    'mat4x3<f32>': { align: 16, size: 64 },\n    'mat4x3<f16>': { align: 8, size: 32 },\n    'mat2x4<f32>': { align: 16, size: 32 },\n    'mat2x4<f16>': { align: 8, size: 16 },\n    'mat3x4<f32>': { align: 16, size: 48 },\n    'mat3x4<f16>': { align: 8, size: 24 },\n    'mat4x4<f32>': { align: 16, size: 64 },\n    'mat4x4<f16>': { align: 8, size: 32 },\n};\n\n/**\n * @param uniformData\n * @internal\n */\nexport function createUboElementsWGSL(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n        const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n\n        if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type])\n        {\n            throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, align) * uboElement.data.size;\n        }\n\n        offset = Math.ceil((offset) / align) * align;\n\n        // TODO deal with Arrays\n        uboElement.size = size;\n\n        uboElement.offset = offset;\n\n        offset += size;\n    }\n\n    // must align to 16 bits!\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n","import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the wgsl layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n * @internal\n */\nexport function generateArraySyncWGSL(uboElement: UboElement, offsetToAdd: number): string\n{\n    // this is in byte..\n    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n\n    const remainder = (align - size) / 4;\n    const data = uboElement.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';\n\n    return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ''}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 ${data}[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n         }\n     `;\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { type System } from '../shared/system/System';\nimport { type WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The GpuLimitsSystem provides information about the capabilities and limitations of the underlying GPU.\n * These limits, such as the maximum number of textures that can be used in a shader\n * (`maxTextures`) or the maximum number of textures that can be batched together (`maxBatchableTextures`),\n * are determined by the specific graphics hardware and driver.\n *\n * The values for these limits are not available immediately upon instantiation of the class.\n * They are populated when the WebGPU Device rendering context is successfully initialized and ready,\n * which occurs after the `renderer.init()` method has completed.\n * Attempting to access these properties before the context is ready will result in undefined or default values.\n *\n * This system allows the renderer to adapt its behavior and resource allocation strategies\n * to stay within the supported boundaries of the GPU, ensuring optimal performance and stability.\n * @example\n * ```ts\n * const renderer = new WebGPURenderer();\n * await renderer.init(); // GPU limits are populated after this call\n *\n * console.log(renderer.limits.maxTextures);\n * console.log(renderer.limits.maxBatchableTextures);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GpuLimitsSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'limits',\n    } as const;\n\n    /** The maximum number of textures that can be used by a shader */\n    public maxTextures: number;\n    /** The maximum number of batchable textures */\n    public maxBatchableTextures: number;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public contextChange(): void\n    {\n        this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;\n        this.maxBatchableTextures = this.maxTextures;\n    }\n\n    public destroy(): void\n    {\n        // boom!\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { GpuRenderTarget } from './renderTarget/GpuRenderTarget';\nimport type { GpuRenderTargetAdaptor } from './renderTarget/GpuRenderTargetAdaptor';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles encoding commands for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'encoder',\n        priority: 1\n    } as const;\n\n    public commandEncoder: GPUCommandEncoder;\n    public renderPassEncoder: GPURenderPassEncoder;\n    public commandFinished: Promise<void>;\n\n    private _resolveCommandFinished: (value: void) => void;\n\n    private _gpu: GPU;\n    private _boundBindGroup: Record<number, BindGroup> = Object.create(null);\n    private _boundVertexBuffer: Record<number, Buffer> = Object.create(null);\n    private _boundIndexBuffer: Buffer;\n    private _boundPipeline: GPURenderPipeline;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public renderStart(): void\n    {\n        this.commandFinished = new Promise((resolve) =>\n        {\n            this._resolveCommandFinished = resolve;\n        });\n\n        // generate a render pass description..\n        // create an encoder..\n        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    }\n\n    public beginRenderPass(gpuRenderTarget: GpuRenderTarget)\n    {\n        this.endRenderPass();\n\n        this._clearCache();\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n    }\n\n    public endRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n        }\n\n        this.renderPassEncoder = null;\n    }\n\n    public setViewport(viewport: Rectangle): void\n    {\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    }\n\n    public setPipelineFromGeometryProgramAndState(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: any,\n        topology?: Topology,\n    ): void\n    {\n        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n\n        this.setPipeline(pipeline);\n    }\n\n    public setPipeline(pipeline: GPURenderPipeline)\n    {\n        if (this._boundPipeline === pipeline) return;\n        this._boundPipeline = pipeline;\n\n        this.renderPassEncoder.setPipeline(pipeline);\n    }\n\n    private _setVertexBuffer(index: number, buffer: Buffer)\n    {\n        if (this._boundVertexBuffer[index] === buffer) return;\n\n        this._boundVertexBuffer[index] = buffer;\n\n        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n    }\n\n    private _setIndexBuffer(buffer: Buffer)\n    {\n        if (this._boundIndexBuffer === buffer) return;\n\n        this._boundIndexBuffer = buffer;\n\n        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? 'uint16' : 'uint32';\n\n        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n    }\n\n    public resetBindGroup(index: number)\n    {\n        this._boundBindGroup[index] = null;\n    }\n\n    public setBindGroup(index: number, bindGroup: BindGroup, program: GpuProgram)\n    {\n        if (this._boundBindGroup[index] === bindGroup) return;\n        this._boundBindGroup[index] = bindGroup;\n\n        bindGroup._touch(this._renderer.gc.now, this._renderer.tick);\n\n        // TODO getting the bind group works as it looks at th e assets and generates a key\n        // should this just be hidden behind a dirty flag?\n        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n\n        // mark each item as having been used..\n        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n    }\n\n    public setGeometry(geometry: Geometry, program: GpuProgram)\n    {\n        // when binding a buffers for geometry, there is no need to bind a buffer more than once if it is interleaved.\n        // which is often the case for Pixi. This is a performance optimisation.\n        // Instead of looping through the attributes, we instead call getBufferNamesToBind\n        // which returns a list of buffer names that need to be bound.\n        // we can then loop through this list and bind the buffers.\n        // essentially only binding a single time for any buffers that are interleaved.\n        const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n\n        for (const i in buffersToBind)\n        {\n            this._setVertexBuffer(parseInt(i, 10), geometry.attributes[buffersToBind[i]].buffer);\n        }\n\n        if (geometry.indexBuffer)\n        {\n            this._setIndexBuffer(geometry.indexBuffer);\n        }\n    }\n\n    private _setShaderBindGroups(shader: Shader, skipSync?: boolean)\n    {\n        for (const i in shader.groups)\n        {\n            const bindGroup = shader.groups[i] as BindGroup;\n\n            // update any uniforms?\n            if (!skipSync)\n            {\n                this._syncBindGroup(bindGroup);\n            }\n\n            this.setBindGroup(i as unknown as number, bindGroup, shader.gpuProgram);\n        }\n    }\n\n    private _syncBindGroup(bindGroup: BindGroup)\n    {\n        for (const j in bindGroup.resources)\n        {\n            const resource = bindGroup.resources[j];\n\n            if ((resource as UniformGroup).isUniformGroup)\n            {\n                this._renderer.ubo.updateUniformGroup(resource as UniformGroup);\n            }\n        }\n    }\n\n    public draw(options: {\n        geometry: Geometry;\n        shader: Shader;\n        state?: State;\n        topology?: Topology;\n        size?: number;\n        start?: number;\n        instanceCount?: number;\n        skipSync?: boolean;\n    })\n    {\n        const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n\n        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n        this.setGeometry(geometry, shader.gpuProgram);\n        this._setShaderBindGroups(shader, skipSync);\n\n        if (geometry.indexBuffer)\n        {\n            this.renderPassEncoder.drawIndexed(\n                size || geometry.indexBuffer.data.length,\n                instanceCount ?? geometry.instanceCount,\n                start || 0\n            );\n        }\n        else\n        {\n            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);\n        }\n    }\n\n    public finishRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n            this.renderPassEncoder = null;\n        }\n    }\n\n    public postrender()\n    {\n        this.finishRenderPass();\n\n        this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n\n        this._resolveCommandFinished();\n\n        this.commandEncoder = null;\n    }\n\n    // restores a render pass if finishRenderPass was called\n    // not optimised as really used for debugging!\n    // used when we want to stop drawing and log a texture..\n    public restoreRenderPass()\n    {\n        const descriptor = (this._renderer.renderTarget.adaptor as GpuRenderTargetAdaptor).getDescriptor(\n            this._renderer.renderTarget.renderTarget,\n            false,\n            [0, 0, 0, 1],\n        );\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n\n        const boundPipeline = this._boundPipeline;\n        const boundVertexBuffer = { ...this._boundVertexBuffer };\n        const boundIndexBuffer = this._boundIndexBuffer;\n        const boundBindGroup = { ...this._boundBindGroup };\n\n        this._clearCache();\n\n        const viewport = this._renderer.renderTarget.viewport;\n\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n        // reinstate the cache...\n\n        this.setPipeline(boundPipeline);\n\n        for (const i in boundVertexBuffer)\n        {\n            this._setVertexBuffer(i as unknown as number, boundVertexBuffer[i]);\n        }\n\n        for (const i in boundBindGroup)\n        {\n            this.setBindGroup(i as unknown as number, boundBindGroup[i], null);\n        }\n\n        this._setIndexBuffer(boundIndexBuffer);\n    }\n\n    private _clearCache()\n    {\n        for (let i = 0; i < 16; i++)\n        {\n            this._boundBindGroup[i] = null;\n            this._boundVertexBuffer[i] = null;\n        }\n\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._gpu = null;\n        this._boundBindGroup = null;\n        this._boundVertexBuffer = null;\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles color masking for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.pipeline.setColorMask(colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorMaskCache = null;\n    }\n}\n","import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\n/**\n * @param uboElements\n * @internal\n */\nexport function createUboSyncFunctionWGSL(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboWgsl',\n        generateArraySyncWGSL,\n        uboSyncFunctionsWGSL,\n    );\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @category rendering\n * @advanced\n */\nexport class GpuStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        this._activeRenderTarget = renderTarget;\n\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        const renderer = this._renderer;\n\n        renderer.pipeline.setStencilMode(stencilMode);\n        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n    }\n\n    public destroy()\n    {\n        this._renderer.renderTarget.onRenderTargetChange.remove(this);\n\n        (this._renderer as null) = null;\n\n        this._activeRenderTarget = null;\n        this._renderTargetStencilState = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL';\n\n/**\n * System plugin to the renderer to manage uniform buffers. With a WGSL twist!\n * @category rendering\n * @advanced\n */\nexport class GpuUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsWGSL,\n            generateUboSync: createUboSyncFunctionWGSL,\n        });\n    }\n}\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { GpuPowerPreference } from '../types';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The GPU object.\n * Contains the GPU adapter and device.\n * @category rendering\n * @advanced\n */\nexport interface GPU\n{\n    /** The GPU adapter */\n    adapter: GPUAdapter;\n    /** The GPU device */\n    device: GPUDevice;\n}\n\n/**\n * Options for the WebGPU context.\n * @property {GpuPowerPreference} [powerPreference=default] - An optional hint indicating what configuration of GPU\n * is suitable for the WebGPU context, can be `'high-performance'` or `'low-power'`.\n * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n * while setting to `'low-power'` will prioritize power saving over rendering performance.\n * @property {boolean} [forceFallbackAdapter=false] - Force the use of the fallback adapter\n * @category rendering\n * @advanced\n */\nexport interface GpuContextOptions\n{\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @default undefined\n     */\n    powerPreference?: GpuPowerPreference;\n    /**\n     * Force the use of the fallback adapter\n     * @default false\n     */\n    forceFallbackAdapter: boolean;\n    /** Using shared device and adaptor from other engine */\n    gpu?: GPU;\n}\n\n/**\n * System plugin to the renderer to manage the context.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GpuDeviceSystem implements System<GpuContextOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'device',\n    } as const;\n\n    /** The default options for the GpuDeviceSystem. */\n    public static defaultOptions: GpuContextOptions = {\n        /**\n         * {@link WebGPUOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * Force the use of the fallback adapter\n         * @default false\n         */\n        forceFallbackAdapter: false,\n    };\n\n    /** The GPU device */\n    public gpu: GPU;\n\n    private _renderer: WebGPURenderer;\n    private _initPromise: Promise<void>;\n\n    /**\n     * @param {WebGPURenderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public async init(options: GpuContextOptions): Promise<void>\n    {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options))\n            .then((gpu) =>\n            {\n                this.gpu = gpu;\n\n                this._renderer.runners.contextChange.emit(this.gpu);\n            });\n\n        return this._initPromise;\n    }\n\n    /**\n     * Handle the context change event\n     * @param gpu\n     */\n    protected contextChange(gpu: GPU): void\n    {\n        this._renderer.gpu = gpu;\n    }\n\n    /**\n     * Helper class to create a WebGL Context\n     * @param {object} options - An options object that gets passed in to the canvas element containing the\n     *    context attributes\n     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n     * @returns {WebGLRenderingContext} the WebGL context\n     */\n    private async _createDeviceAndAdaptor(options: GpuContextOptions): Promise<GPU>\n    {\n        // TODO we only need one of these..\n        const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({\n            powerPreference: options.powerPreference,\n            forceFallbackAdapter: options.forceFallbackAdapter,\n        });\n\n        const requiredFeatures = [\n            'texture-compression-bc',\n            'texture-compression-astc',\n            'texture-compression-etc2',\n        ].filter((feature) => adapter.features.has(feature)) as GPUFeatureName[];\n\n        // TODO and one of these!\n        const device = await adapter.requestDevice({\n            requiredFeatures\n        });\n\n        return { adapter, device };\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n        this._renderer = null;\n    }\n}\n","/** @internal */\nexport class UboBatch\n{\n    public data: Float32Array;\n    private readonly _minUniformOffsetAlignment: number = 256;\n\n    public byteIndex = 0;\n\n    constructor({ minUniformOffsetAlignment }: {minUniformOffsetAlignment: number})\n    {\n        this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n        this.data = new Float32Array(65535);\n    }\n\n    public clear(): void\n    {\n        this.byteIndex = 0;\n    }\n\n    public addEmptyGroup(size: number): number\n    {\n        // update the buffer.. only float32 for now!\n        if (size > this._minUniformOffsetAlignment / 4)\n        {\n            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n        }\n\n        const start = this.byteIndex;\n\n        let newSize = start + (size * 4);\n\n        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n\n        if (newSize > this.data.length * 4)\n        {\n            // TODO push a new buffer\n            throw new Error('UniformBufferBatch: ubo batch got too big');\n        }\n\n        this.byteIndex = newSize;\n\n        return start;\n    }\n\n    public addGroup(array: Float32Array): number\n    {\n        const offset = this.addEmptyGroup(array.length);\n\n        for (let i = 0; i < array.length; i++)\n        {\n            this.data[(offset / 4) + i] = array[i];\n        }\n\n        return offset;\n    }\n\n    public destroy()\n    {\n        this.data = null;\n    }\n}\n","/**\n * A class which generates mipmaps for a GPUTexture.\n * Thanks to toji for the original implementation\n * https://github.com/toji/web-texture-tool/blob/main/src/webgpu-mipmap-generator.js\n * @category rendering\n * @ignore\n */\nexport class GpuMipmapGenerator\n{\n    public device: GPUDevice;\n    public sampler: GPUSampler;\n    public pipelines: Record<string, GPURenderPipeline>;\n\n    public mipmapShaderModule: any;\n\n    constructor(device: GPUDevice)\n    {\n        this.device = device;\n        this.sampler = device.createSampler({ minFilter: 'linear' });\n        // We'll need a new pipeline for every texture format used.\n        this.pipelines = {};\n    }\n\n    private _getMipmapPipeline(format: GPUTextureFormat)\n    {\n        let pipeline = this.pipelines[format];\n\n        if (!pipeline)\n        {\n            // Shader modules is shared between all pipelines, so only create once.\n            if (!this.mipmapShaderModule)\n            {\n                this.mipmapShaderModule = this.device.createShaderModule({\n                    code: /* wgsl */ `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `,\n                });\n            }\n\n            pipeline = this.device.createRenderPipeline({\n                layout: 'auto',\n                vertex: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'vertexMain',\n                },\n                fragment: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'fragmentMain',\n                    targets: [{ format }],\n                }\n            });\n\n            this.pipelines[format] = pipeline;\n        }\n\n        return pipeline;\n    }\n\n    /**\n     * Generates mipmaps for the given GPUTexture from the data in level 0.\n     * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n     * @returns {module:External.GPUTexture} - The originally passed texture\n     */\n    public generateMipmap(texture: GPUTexture)\n    {\n        const pipeline = this._getMipmapPipeline(texture.format);\n\n        if (texture.dimension === '3d' || texture.dimension === '1d')\n        {\n            throw new Error('Generating mipmaps for non-2d textures is currently unsupported!');\n        }\n\n        let mipTexture = texture;\n        const arrayLayerCount = texture.depthOrArrayLayers || 1; // Only valid for 2D textures.\n\n        // If the texture was created with RENDER_ATTACHMENT usage we can render directly between mip levels.\n        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n\n        if (!renderToSource)\n        {\n            // Otherwise we have to use a separate texture to render into. It can be one mip level smaller than the source\n            // texture, since we already have the top level.\n            const mipTextureDescriptor = {\n                size: {\n                    width: Math.ceil(texture.width / 2),\n                    height: Math.ceil(texture.height / 2),\n                    depthOrArrayLayers: arrayLayerCount,\n                },\n                format: texture.format,\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n                mipLevelCount: texture.mipLevelCount - 1,\n            };\n\n            mipTexture = this.device.createTexture(mipTextureDescriptor);\n        }\n\n        const commandEncoder = this.device.createCommandEncoder({});\n        // TODO: Consider making this static.\n        const bindGroupLayout = pipeline.getBindGroupLayout(0);\n\n        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer)\n        {\n            let srcView = texture.createView({\n                baseMipLevel: 0,\n                mipLevelCount: 1,\n                dimension: '2d',\n                baseArrayLayer: arrayLayer,\n                arrayLayerCount: 1,\n            });\n\n            let dstMipLevel = renderToSource ? 1 : 0;\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                const dstView = mipTexture.createView({\n                    baseMipLevel: dstMipLevel++,\n                    mipLevelCount: 1,\n                    dimension: '2d',\n                    baseArrayLayer: arrayLayer,\n                    arrayLayerCount: 1,\n                });\n\n                const passEncoder = commandEncoder.beginRenderPass({\n                    colorAttachments: [{\n                        view: dstView,\n                        storeOp: 'store',\n                        loadOp: 'clear',\n                        clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    }],\n                });\n\n                const bindGroup = this.device.createBindGroup({\n                    layout: bindGroupLayout,\n                    entries: [{\n                        binding: 0,\n                        resource: this.sampler,\n                    }, {\n                        binding: 1,\n                        resource: srcView,\n                    }],\n                });\n\n                passEncoder.setPipeline(pipeline);\n                passEncoder.setBindGroup(0, bindGroup);\n                passEncoder.draw(3, 1, 0, 0);\n\n                passEncoder.end();\n\n                srcView = dstView;\n            }\n        }\n\n        // If we didn't render to the source texture, finish by copying the mip results from the temporary mipmap texture\n        // to the source.\n        if (!renderToSource)\n        {\n            const mipLevelSize = {\n                width: Math.ceil(texture.width / 2),\n                height: Math.ceil(texture.height / 2),\n                depthOrArrayLayers: arrayLayerCount,\n            };\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                commandEncoder.copyTextureToTexture({\n                    texture: mipTexture,\n                    mipLevel: i - 1,\n                }, {\n                    texture,\n                    mipLevel: i,\n                }, mipLevelSize);\n\n                mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n                mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n            }\n        }\n\n        this.device.queue.submit([commandEncoder.finish()]);\n\n        if (!renderToSource)\n        {\n            mipTexture.destroy();\n        }\n\n        return texture;\n    }\n}\n","import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const blockDataMap: Record<string, {blockBytes: number, blockWidth: number, blockHeight: number}> = {\n    'bc1-rgba-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'bc2-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc3-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc7-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'etc1-rgb-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'etc2-rgba8unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'astc-4x4-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n};\n\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n/** @internal */\nexport const gpuUploadCompressedTextureResource = {\n\n    type: 'compressed',\n\n    upload(source: CompressedSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const blockData = blockDataMap[source.format] || defaultBlockData;\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n\n            gpu.device.queue.writeTexture(\n                {\n                    texture: gpuTexture,\n                    mipLevel: i\n                },\n                levelBuffer,\n                {\n                    offset: 0,\n                    bytesPerRow,\n                },\n                {\n                    width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n                    height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n                    depthOrArrayLayers: 1,\n                }\n            );\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GpuTextureUploader<CompressedSource>;\n\n","import type { TextureSource } from '../../shared/texture/sources/TextureSource';\n\n/**\n * A class which holds the canvas contexts and textures for a render target.\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTarget\n{\n    public contexts: GPUCanvasContext[] = [];\n    public msaaTextures: TextureSource[] = [];\n    public msaa: boolean;\n    public msaaSamples = 1;\n    public colorTargetCount: number;\n    public width: number;\n    public height: number;\n    public descriptor: GPURenderPassDescriptor;\n}\n","import type { BLEND_MODES } from '../../shared/state/const';\n\n/** @internal */\nexport const GpuBlendModesToPixi: Partial<Record<BLEND_MODES, GPUBlendState>> = {};\n\nGpuBlendModesToPixi.normal = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.add = {\n    alpha: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.multiply = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'dst',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.screen = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.overlay = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.none = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'zero',\n        operation: 'add',\n    },\n};\n\n// not-premultiplied blend modes\nGpuBlendModesToPixi['normal-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['add-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['screen-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.erase = {\n    alpha: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.min = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n};\n\nGpuBlendModesToPixi.max = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n};\n\n// composite operations\n// GpuBlendModesToPixi[BLEND_MODES.SRC_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OVER] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.XOR] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// TODO - fix me\n// GLBlendModesToPixi[BLEND_MODES.SUBTRACT] = {\n//     alpha: {\n//         srcFactor: 'one',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n","import type { BufferImageSource } from '../../../shared/texture/sources/BufferImageSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadBufferImageResource = {\n\n    type: 'image',\n\n    upload(source: BufferImageSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource;\n\n        const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n\n        const bytesPerPixel = resource.byteLength / total;\n\n        gpu.device.queue.writeTexture(\n            { texture: gpuTexture },\n            resource,\n            {\n                offset: 0,\n                rowsPerImage: source.pixelHeight,\n                bytesPerRow: source.pixelWidth * bytesPerPixel,\n            },\n            {\n                width: source.pixelWidth,\n                height: source.pixelHeight,\n                depthOrArrayLayers: 1,\n            }\n        );\n    }\n} as GpuTextureUploader<BufferImageSource>;\n\n","import { gpuUploadImageResource } from './gpuUploadImageSource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadVideoResource = {\n\n    type: 'video',\n\n    upload(source: VideoSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        gpuUploadImageResource.upload(source, gpuTexture, gpu);\n    }\n} as GpuTextureUploader<VideoSource>;\n\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuProgram } from './GpuProgram';\n\n/**\n * Data structure for GPU program layout.\n * Contains bind group layouts and pipeline layout.\n * @category rendering\n * @advanced\n */\nexport interface GPUProgramData\n{\n    bindGroups: GPUBindGroupLayout[]\n    pipeline: GPUPipelineLayout\n}\n\n/**\n * A system that manages the rendering of GpuPrograms.\n * @category rendering\n * @advanced\n */\nexport class GpuShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    private _gpu: GPU;\n\n    private readonly _gpuProgramData: Record<number, GPUProgramData> = Object.create(null);\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getProgramData(program: GpuProgram)\n    {\n        return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n    }\n\n    private _createGPUProgramData(program: GpuProgram)\n    {\n        const device = this._gpu.device;\n\n        const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n\n        const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n\n        this._gpuProgramData[program._layoutKey] = {\n            bindGroups,\n            pipeline: device.createPipelineLayout(pipelineLayoutDesc),\n        };\n\n        // generally we avoid having to make this automatically\n        // keeping this for a reminder, if any issues popup\n        // program._gpuLayout = {\n        //     bindGroups: null,\n        //     pipeline: 'auto',\n        // };\n\n        return this._gpuProgramData[program._layoutKey];\n    }\n\n    public destroy(): void\n    {\n        // TODO destroy the _gpuProgramData\n        this._gpu = null;\n        (this._gpuProgramData as null) = null;\n    }\n}\n","import { DOMAdapter } from '../../../../../environment/adapter';\nimport { warn } from '../../../../../utils/logging/warn';\n\nimport type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadImageResource = {\n\n    type: 'image',\n\n    upload(source: TextureSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource as ImageBitmap | HTMLCanvasElement | OffscreenCanvas | HTMLImageElement;\n\n        if (!resource) return;\n\n        // WebGPU does not support HTMLImageElement\n        // so we need to convert it to a canvas\n        if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        {\n            const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);\n            const context = canvas.getContext('2d');\n\n            context.drawImage(resource, 0, 0, resource.width, resource.height);\n\n            // replace with the canvas - for future uploads\n            source.resource = canvas;\n\n            // #if _DEBUG\n            warn('ImageSource: Image element passed, converting to canvas and replacing resource.');\n            // #endif\n        }\n\n        const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n        const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        gpu.device.queue.copyExternalImageToTexture(\n            { source: resource },\n            { texture: gpuTexture, premultipliedAlpha },\n            {\n                width,\n                height,\n            }\n        );\n    }\n} as GpuTextureUploader<TextureSource>;\n\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor';\n\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuRenderTarget } from './GpuRenderTarget';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @category rendering\n * @advanced\n */\nexport class GpuRenderTargetSystem extends RenderTargetSystem<GpuRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GpuRenderTargetAdaptor();\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n","import { CLEAR } from '../../gl/const';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport { GpuRenderTarget } from './GpuRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * The WebGPU adaptor for the render target system. Allows the Render Target System to\n * be used with the WebGPU renderer\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTargetAdaptor implements RenderTargetAdaptor<GpuRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GpuRenderTarget>;\n    private _renderer: WebGPURenderer<HTMLCanvasElement>;\n\n    public init(renderer: WebGPURenderer, renderTargetSystem: RenderTargetSystem<GpuRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderer = this._renderer;\n\n        const baseGpuTexture = this._getGpuColorTexture(\n            sourceRenderSurfaceTexture\n        );\n\n        const backGpuTexture = renderer.texture.getGpuSource(\n            destinationTexture.source\n        );\n\n        renderer.encoder.commandEncoder.copyTextureToTexture(\n            {\n                texture: baseGpuTexture,\n                origin: originSrc,\n            },\n            {\n                texture: backGpuTexture,\n                origin: originDest,\n            },\n            size\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n        gpuRenderTarget.descriptor = descriptor;\n\n        // TODO we should not finish a render pass each time we bind\n        // for example filters - we would want to push / pop render targets\n        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n        this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n        this._renderer.encoder.setViewport(viewport);\n    }\n\n    public finishRenderPass()\n    {\n        this._renderer.encoder.endRenderPass();\n    }\n\n    /**\n     * returns the gpu texture for the first color texture in the render target\n     * mainly used by the filter manager to get copy the texture for blending\n     * @param renderTarget\n     * @returns a gpu texture\n     */\n    private _getGpuColorTexture(renderTarget: RenderTarget): GPUTexture\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (gpuRenderTarget.contexts[0])\n        {\n            return gpuRenderTarget.contexts[0].getCurrentTexture();\n        }\n\n        return this._renderer.texture.getGpuSource(\n            renderTarget.colorTextures[0].source\n        );\n    }\n\n    public getDescriptor(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearValue: RgbaArray\n    ): GPURenderPassDescriptor\n    {\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const colorAttachments = renderTarget.colorTextures.map(\n            (texture, i) =>\n            {\n                const context = gpuRenderTarget.contexts[i];\n\n                let view: GPUTextureView;\n                let resolveTarget: GPUTextureView;\n\n                if (context)\n                {\n                    const currentTexture = context.getCurrentTexture();\n\n                    const canvasTextureView = currentTexture.createView();\n\n                    view = canvasTextureView;\n                }\n                else\n                {\n                    view = this._renderer.texture.getGpuSource(texture).createView({\n                        mipLevelCount: 1,\n                    });\n                }\n\n                if (gpuRenderTarget.msaaTextures[i])\n                {\n                    resolveTarget = view;\n                    view = this._renderer.texture.getTextureView(\n                        gpuRenderTarget.msaaTextures[i]\n                    );\n                }\n\n                const loadOp = ((clear as CLEAR) & CLEAR.COLOR ? 'clear' : 'load') as GPULoadOp;\n\n                clearValue ??= renderTargetSystem.defaultClearColor;\n\n                return {\n                    view,\n                    resolveTarget,\n                    clearValue,\n                    storeOp: 'store',\n                    loadOp\n                };\n            }\n        ) as GPURenderPassColorAttachment[];\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment;\n\n        // if we have a depth or stencil buffer, we need to ensure we have a texture for it\n        // this is WebGPU specific - as WebGL does not require textures to run a depth / stencil buffer\n        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture)\n        {\n            renderTarget.ensureDepthStencilTexture();\n            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n        }\n\n        if (renderTarget.depthStencilTexture)\n        {\n            const stencilLoadOp = (clear & CLEAR.STENCIL ? 'clear' : 'load') as GPULoadOp;\n            const depthLoadOp = (clear & CLEAR.DEPTH ? 'clear' : 'load') as GPULoadOp;\n\n            depthStencilAttachment = {\n                view: this._renderer.texture\n                    .getGpuSource(renderTarget.depthStencilTexture.source)\n                    .createView(),\n                stencilStoreOp: 'store',\n                stencilLoadOp,\n                depthClearValue: 1.0,\n                depthLoadOp,\n                depthStoreOp: 'store',\n            };\n        }\n\n        const descriptor: GPURenderPassDescriptor = {\n            colorAttachments,\n            depthStencilAttachment,\n        };\n\n        return descriptor;\n    }\n\n    public clear(renderTarget: RenderTarget, clear: CLEAR_OR_BOOL = true, clearColor?: RgbaArray, viewport?: Rectangle)\n    {\n        if (!clear) return;\n\n        const { gpu, encoder } = this._renderer;\n\n        const device = gpu.device;\n\n        const standAlone = encoder.commandEncoder === null;\n\n        if (standAlone)\n        {\n            const commandEncoder = device.createCommandEncoder();\n            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n            passEncoder.end();\n\n            const gpuCommands = commandEncoder.finish();\n\n            device.queue.submit([gpuCommands]);\n        }\n        else\n        {\n            this.startRenderPass(renderTarget, clear, clearColor, viewport);\n        }\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GpuRenderTarget\n    {\n        // always true for WebGPU\n        renderTarget.isRoot = true;\n\n        const gpuRenderTarget = new GpuRenderTarget();\n\n        gpuRenderTarget.colorTargetCount = renderTarget.colorTextures.length;\n\n        // create a context...\n        // is a canvas...\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (colorTexture instanceof CanvasSource)\n            {\n                const context = colorTexture.resource.getContext(\n                    'webgpu'\n                ) as unknown as GPUCanvasContext;\n\n                const alphaMode = (colorTexture as CanvasSource).transparent ? 'premultiplied' : 'opaque';\n\n                try\n                {\n                    context.configure({\n                        device: this._renderer.gpu.device,\n                        usage: GPUTextureUsage.TEXTURE_BINDING\n                            | GPUTextureUsage.COPY_DST\n                            | GPUTextureUsage.RENDER_ATTACHMENT\n                            | GPUTextureUsage.COPY_SRC,\n                        format: 'bgra8unorm',\n                        alphaMode,\n                    });\n                }\n                catch (e)\n                {\n                    console.error(e);\n                }\n\n                gpuRenderTarget.contexts[i] = context;\n            }\n\n            gpuRenderTarget.msaa = colorTexture.source.antialias;\n\n            if (colorTexture.source.antialias)\n            {\n                const msaaTexture = new TextureSource({\n                    width: 0,\n                    height: 0,\n                    sampleCount: 4,\n                });\n\n                gpuRenderTarget.msaaTextures[i] = msaaTexture;\n            }\n        });\n\n        if (gpuRenderTarget.msaa)\n        {\n            gpuRenderTarget.msaaSamples = 4;\n\n            if (renderTarget.depthStencilTexture)\n            {\n                renderTarget.depthStencilTexture.source.sampleCount = 4;\n            }\n        }\n\n        return gpuRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GpuRenderTarget)\n    {\n        gpuRenderTarget.contexts.forEach((context) =>\n        {\n            context.unconfigure();\n        });\n\n        gpuRenderTarget.msaaTextures.forEach((texture) =>\n        {\n            texture.destroy();\n        });\n\n        gpuRenderTarget.msaaTextures.length = 0;\n        gpuRenderTarget.contexts.length = 0;\n    }\n\n    public ensureDepthStencilTexture(renderTarget: RenderTarget)\n    {\n        // TODO This function will be more useful once we cache the descriptors\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa)\n        {\n            renderTarget.depthStencilTexture.source.sampleCount = 4;\n        }\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        gpuRenderTarget.width = renderTarget.width;\n        gpuRenderTarget.height = renderTarget.height;\n\n        if (gpuRenderTarget.msaa)\n        {\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const msaaTexture = gpuRenderTarget.msaaTextures[i];\n\n                msaaTexture?.resize(\n                    colorTexture.source.width,\n                    colorTexture.source.height,\n                    colorTexture.source._resolution\n                );\n            });\n        }\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { State } from '../../shared/state/State';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\n\n/**\n * System plugin to the renderer to manage WebGL state machines.\n * @category rendering\n * @advanced\n */\nexport class GpuStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'state',\n    } as const;\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @type {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gpu: GPU;\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    constructor()\n    {\n        this.defaultState = new State();\n        this.defaultState.blend = true;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this.gpu = gpu;\n    }\n\n    /**\n     * Gets the blend mode data for the current state\n     * @param state - The state to get the blend mode from\n     * @param count - The number of color targets to create\n     */\n    public getColorTargets(state: State, count: number): GPUColorTargetState[]\n    {\n        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n\n        const targets: GPUColorTargetState[] = [];\n        const target = {\n            format: 'bgra8unorm',\n            writeMask: 0,\n            blend,\n        } as GPUColorTargetState;\n\n        for (let i = 0; i < count; i++)\n        {\n            targets[i] = target;\n        }\n\n        return targets;\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Buffer } from '../shared/buffer/Buffer';\nimport { BufferResource } from '../shared/buffer/BufferResource';\nimport { BufferUsage } from '../shared/buffer/const';\nimport { UboBatch } from './buffer/UboBatch';\nimport { BindGroup } from './shader/BindGroup';\n\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\nconst minUniformOffsetAlignment = 128;// 256 / 2;\n\n/** @internal */\nexport class GpuUniformBatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'uniformBatch',\n    } as const;\n\n    private _renderer: WebGPURenderer;\n\n    private _bindGroupHash: Record<number, BindGroup> = Object.create(null);\n    private readonly _batchBuffer: UboBatch;\n\n    // number of buffers..\n    private _buffers: Buffer[] = [];\n\n    private _bindGroups: BindGroup[] = [];\n    private _bufferResources: BufferResource[] = [];\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n\n        const totalBuffers = (256 / minUniformOffsetAlignment);\n\n        for (let i = 0; i < totalBuffers; i++)\n        {\n            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n\n            if (i === 0) usage |= BufferUsage.COPY_SRC;\n\n            this._buffers.push(new Buffer({\n                data: this._batchBuffer.data,\n                usage\n            }));\n        }\n    }\n\n    public renderEnd()\n    {\n        this._uploadBindGroups();\n        this._resetBindGroups();\n    }\n\n    private _resetBindGroups()\n    {\n        this._bindGroupHash = Object.create(null);\n        this._batchBuffer.clear();\n    }\n\n    // just works for single bind groups for now\n    public getUniformBindGroup(group: UniformGroup<any>, duplicate: boolean): BindGroup\n    {\n        if (!duplicate && this._bindGroupHash[group.uid])\n        {\n            return this._bindGroupHash[group.uid];\n        }\n\n        this._renderer.ubo.ensureUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addEmptyGroup(data.length);\n\n        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n\n        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n\n        return this._bindGroupHash[group.uid];\n    }\n\n    public getUboResource(group: UniformGroup<any>): BufferResource\n    {\n        this._renderer.ubo.updateUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBufferResource(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBindGroup(data: Float32Array): BindGroup\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBindGroup(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBufferResource(data: Float32Array): BufferResource\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        const index = offset / minUniformOffsetAlignment;\n\n        return this._getBufferResource(index);\n    }\n\n    private _getBufferResource(index: number): BufferResource\n    {\n        if (!this._bufferResources[index])\n        {\n            const buffer = this._buffers[index % 2];\n\n            this._bufferResources[index] = new BufferResource({\n                buffer,\n                offset: ((index / 2) | 0) * 256,\n                size: minUniformOffsetAlignment\n            });\n        }\n\n        return this._bufferResources[index];\n    }\n\n    private _getBindGroup(index: number): BindGroup\n    {\n        if (!this._bindGroups[index])\n        {\n            // even!\n            const bindGroup = new BindGroup({\n                0: this._getBufferResource(index),\n            });\n\n            this._bindGroups[index] = bindGroup;\n        }\n\n        return this._bindGroups[index];\n    }\n\n    private _uploadBindGroups()\n    {\n        const bufferSystem = this._renderer.buffer;\n\n        const firstBuffer = this._buffers[0];\n\n        firstBuffer.update(this._batchBuffer.byteIndex);\n\n        bufferSystem.updateBuffer(firstBuffer);\n\n        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n\n        for (let i = 1; i < this._buffers.length; i++)\n        {\n            const buffer = this._buffers[i];\n\n            commandEncoder.copyBufferToBuffer(\n                bufferSystem.getGPUBuffer(firstBuffer),\n                minUniformOffsetAlignment,\n                bufferSystem.getGPUBuffer(buffer),\n                0,\n                this._batchBuffer.byteIndex\n            );\n        }\n\n        // TODO make a system that will que up all commands in to one array?\n        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this._bindGroups.length; i++)\n        {\n            this._bindGroups[i]?.destroy();\n        }\n\n        this._bindGroups = null;\n        this._bindGroupHash = null;\n\n        for (let i = 0; i < this._buffers.length; i++)\n        {\n            this._buffers[i].destroy();\n        }\n        this._buffers = null;\n\n        for (let i = 0; i < this._bufferResources.length; i++)\n        {\n            this._bufferResources[i].destroy();\n        }\n\n        this._bufferResources = null;\n\n        this._batchBuffer.destroy();\n\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes';\nimport { STENCIL_MODES } from '../../shared/state/const';\nimport { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { State } from '../../shared/state/State';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuRenderTarget } from '../renderTarget/GpuRenderTarget';\nimport type { GpuProgram } from '../shader/GpuProgram';\nimport type { StencilState } from '../state/GpuStencilModesToPixi';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\nconst topologyStringToId = {\n    'point-list': 0,\n    'line-list': 1,\n    'line-strip': 2,\n    'triangle-list': 3,\n    'triangle-strip': 4,\n};\n\n// geometryLayouts = 256; // 8 bits // 256 states // value 0-255;\n// shaderKeys = 256; // 8 bits // 256 states // value 0-255;\n// state = 64; // 6 bits // 64 states // value 0-63;\n// blendMode = 32; // 5 bits // 32 states // value 0-31;\n// topology = 8; // 3 bits // 8 states // value 0-7;\nfunction getGraphicsStateKey(\n    geometryLayout: number,\n    shaderKey: number,\n    state: number,\n    blendMode: number,\n    topology: number,\n): number\n{\n    return (geometryLayout << 24) // Allocate the 8 bits for geometryLayouts at the top\n         | (shaderKey << 16) // Next 8 bits for shaderKeys\n         | (state << 10) // 6 bits for state\n         | (blendMode << 5) // 5 bits for blendMode\n         | topology; // And 3 bits for topology at the least significant position\n}\n\n// colorMask = 16;// 4 bits // 16 states // value 0-15;\n// stencilState = 8; // 3 bits // 8 states // value 0-7;\n// renderTarget = 1; // 2 bit // 3 states // value 0-3; // none, stencil, depth, depth-stencil\n// multiSampleCount = 1; // 1 bit // 2 states // value 0-1;\n// colorTargetCount = 4; // 2 bits // 4 states // value 0-3; // supports 1-4 color targets\nfunction getGlobalStateKey(\n    stencilStateId: number,\n    multiSampleCount: number,\n    colorMask: number,\n    renderTarget: number,\n    colorTargetCount: number,\n): number\n{\n    return (colorMask << 8) // Allocate the 4 bits for colorMask at the top\n         | (stencilStateId << 5) // Next 3 bits for stencilStateId\n         | (renderTarget << 3) // 2 bits for renderTarget\n         | (colorTargetCount << 1) // 2 bits for colorTargetCount\n         | multiSampleCount; // And 1 bit for multiSampleCount at the least significant position\n}\n\ntype PipeHash = Record<number, GPURenderPipeline>;\n\n/**\n * A system that creates and manages the GPU pipelines.\n *\n * Caching Mechanism: At its core, the system employs a two-tiered caching strategy to minimize\n * the redundant creation of GPU pipelines (or \"pipes\"). This strategy is based on generating unique\n * keys that represent the state of the graphics settings and the specific requirements of the\n * item being rendered. By caching these pipelines, subsequent draw calls with identical configurations\n * can reuse existing pipelines instead of generating new ones.\n *\n * State Management: The system differentiates between \"global\" state properties (like color masks\n * and stencil masks, which do not change frequently) and properties that may vary between draw calls\n * (such as geometry, shaders, and blend modes). Unique keys are generated for both these categories\n * using getStateKey for global state and getGraphicsStateKey for draw-specific settings. These keys are\n * then then used to caching the pipe. The next time we need a pipe we can check\n * the cache by first looking at the state cache and then the pipe cache.\n * @category rendering\n * @advanced\n */\nexport class PipelineSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'pipeline',\n    } as const;\n    private readonly _renderer: WebGPURenderer;\n\n    protected CONTEXT_UID: number;\n\n    private _moduleCache: Record<string, GPUShaderModule> = Object.create(null);\n    private _bufferLayoutsCache: Record<number, GPUVertexBufferLayout[]> = Object.create(null);\n    private readonly _bindingNamesCache: Record<string, Record<string, string>> = Object.create(null);\n\n    private _pipeCache: PipeHash = Object.create(null);\n    private readonly _pipeStateCaches: Record<number, PipeHash> = Object.create(null);\n\n    private _gpu: GPU;\n    private _stencilState: StencilState;\n\n    private _stencilMode: STENCIL_MODES;\n    private _colorMask = 0b1111;\n    private _multisampleCount = 1;\n    private _colorTargetCount = 1;\n    private _depthStencilAttachment: 0 | 1;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n        this.setStencilMode(STENCIL_MODES.DISABLED);\n\n        this._updatePipeHash();\n    }\n\n    public setMultisampleCount(multisampleCount: number): void\n    {\n        if (this._multisampleCount === multisampleCount) return;\n\n        this._multisampleCount = multisampleCount;\n\n        this._updatePipeHash();\n    }\n\n    public setRenderTarget(renderTarget: GpuRenderTarget)\n    {\n        this._multisampleCount = renderTarget.msaaSamples;\n        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n        this._colorTargetCount = renderTarget.colorTargetCount;\n        this._updatePipeHash();\n    }\n\n    public setColorMask(colorMask: number): void\n    {\n        if (this._colorMask === colorMask) return;\n\n        this._colorMask = colorMask;\n\n        this._updatePipeHash();\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES): void\n    {\n        if (this._stencilMode === stencilMode) return;\n\n        this._stencilMode = stencilMode;\n        this._stencilState = GpuStencilModesToPixi[stencilMode];\n\n        this._updatePipeHash();\n    }\n\n    public setPipeline(geometry: Geometry, program: GpuProgram, state: State, passEncoder: GPURenderPassEncoder): void\n    {\n        const pipeline = this.getPipeline(geometry, program, state);\n\n        passEncoder.setPipeline(pipeline);\n    }\n\n    public getPipeline(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: State,\n        topology?: Topology,\n    ): GPURenderPipeline\n    {\n        if (!geometry._layoutKey)\n        {\n            ensureAttributes(geometry, program.attributeData);\n\n            // prepare the geometry for the pipeline\n            this._generateBufferKey(geometry);\n        }\n\n        topology ||= geometry.topology;\n\n        // now we have set the Ids - the key is different...\n        const key = getGraphicsStateKey(\n            geometry._layoutKey,\n            program._layoutKey,\n            state.data,\n            state._blendModeId,\n            topologyStringToId[topology],\n        );\n\n        if (this._pipeCache[key]) return this._pipeCache[key];\n\n        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n\n        return this._pipeCache[key];\n    }\n\n    private _createPipeline(geometry: Geometry, program: GpuProgram, state: State, topology: Topology): GPURenderPipeline\n    {\n        const device = this._gpu.device;\n\n        const buffers = this._createVertexBufferLayouts(geometry, program);\n\n        const blendModes = this._renderer.state.getColorTargets(state, this._colorTargetCount);\n\n        // Apply write mask to all color targets\n        const writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n\n        for (let i = 0; i < blendModes.length; i++)\n        {\n            blendModes[i].writeMask = writeMask;\n        }\n\n        const layout = this._renderer.shader.getProgramData(program).pipeline;\n\n        const descriptor: GPURenderPipelineDescriptor = {\n            // TODO later check if its helpful to create..\n            // layout,\n            vertex: {\n                module: this._getModule(program.vertex.source),\n                entryPoint: program.vertex.entryPoint,\n                // geometry..\n                buffers,\n            },\n            fragment: {\n                module: this._getModule(program.fragment.source),\n                entryPoint: program.fragment.entryPoint,\n                targets: blendModes,\n            },\n            primitive: {\n                topology,\n                cullMode: state.cullMode,\n            },\n            layout,\n            multisample: {\n                count: this._multisampleCount,\n            },\n            // depthStencil,\n            label: `PIXI Pipeline`,\n        };\n\n        // only apply if the texture has stencil or depth\n        if (this._depthStencilAttachment)\n        {\n            // mask states..\n            descriptor.depthStencil = {\n                ...this._stencilState,\n                format: 'depth24plus-stencil8',\n                depthWriteEnabled: state.depthTest,\n                depthCompare: state.depthTest ? 'less' : 'always',\n            };\n        }\n\n        const pipeline = device.createRenderPipeline(descriptor);\n\n        return pipeline;\n    }\n\n    private _getModule(code: string): GPUShaderModule\n    {\n        return this._moduleCache[code] || this._createModule(code);\n    }\n\n    private _createModule(code: string): GPUShaderModule\n    {\n        const device = this._gpu.device;\n\n        this._moduleCache[code] = device.createShaderModule({\n            code,\n        });\n\n        return this._moduleCache[code];\n    }\n\n    private _generateBufferKey(geometry: Geometry): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(geometry.attributes).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = geometry.attributes[attributeKeys[i]];\n\n            keyGen[index++] = attribute.offset;\n            keyGen[index++] = attribute.format;\n            keyGen[index++] = attribute.stride;\n            keyGen[index++] = attribute.instance;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        geometry._layoutKey = createIdFromString(stringKey, 'geometry');\n\n        return geometry._layoutKey;\n    }\n\n    private _generateAttributeLocationsKey(program: GpuProgram): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(program.attributeData).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = program.attributeData[attributeKeys[i]];\n\n            keyGen[index++] = attribute.location;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        program._attributeLocationsKey = createIdFromString(stringKey, 'programAttributes');\n\n        return program._attributeLocationsKey;\n    }\n\n    /**\n     * Returns a hash of buffer names mapped to bind locations.\n     * This is used to bind the correct buffer to the correct location in the shader.\n     * @param geometry - The geometry where to get the buffer names\n     * @param program - The program where to get the buffer names\n     * @returns An object of buffer names mapped to the bind location.\n     */\n    public getBufferNamesToBind(geometry: Geometry, program: GpuProgram): Record<string, string>\n    {\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bindingNamesCache[key]) return this._bindingNamesCache[key];\n\n        const data = this._createVertexBufferLayouts(geometry, program);\n\n        // now map the data to the buffers..\n        const bufferNamesToBind: Record<string, string> = Object.create(null);\n\n        const attributeData = program.attributeData;\n\n        for (let i = 0; i < data.length; i++)\n        {\n            const attributes = Object.values(data[i].attributes);\n\n            const shaderLocation = attributes[0].shaderLocation;\n\n            for (const j in attributeData)\n            {\n                if (attributeData[j].location === shaderLocation)\n                {\n                    bufferNamesToBind[i] = j;\n                    break;\n                }\n            }\n        }\n\n        this._bindingNamesCache[key] = bufferNamesToBind;\n\n        return bufferNamesToBind;\n    }\n\n    private _createVertexBufferLayouts(geometry: Geometry, program: GpuProgram): GPUVertexBufferLayout[]\n    {\n        if (!program._attributeLocationsKey) this._generateAttributeLocationsKey(program);\n\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bufferLayoutsCache[key])\n        {\n            return this._bufferLayoutsCache[key];\n        }\n\n        const vertexBuffersLayout: GPUVertexBufferLayout[] = [];\n\n        geometry.buffers.forEach((buffer) =>\n        {\n            const bufferEntry: GPUVertexBufferLayout = {\n                arrayStride: 0,\n                stepMode: 'vertex',\n                attributes: [],\n            };\n\n            const bufferEntryAttributes = bufferEntry.attributes as GPUVertexAttribute[];\n\n            for (const i in program.attributeData)\n            {\n                const attribute = geometry.attributes[i];\n\n                if ((attribute.divisor ?? 1) !== 1)\n                {\n                    // TODO: Maybe emulate divisor with storage_buffers/float_textures?\n                    // For now just issue a warning\n                    warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. `\n                        + 'WebGPU only supports a divisor value of 1');\n                }\n\n                if (attribute.buffer === buffer)\n                {\n                    bufferEntry.arrayStride = attribute.stride;\n                    bufferEntry.stepMode = attribute.instance ? 'instance' : 'vertex';\n\n                    bufferEntryAttributes.push({\n                        shaderLocation: program.attributeData[i].location,\n                        offset: attribute.offset,\n                        format: attribute.format,\n                    });\n                }\n            }\n\n            if (bufferEntryAttributes.length)\n            {\n                vertexBuffersLayout.push(bufferEntry);\n            }\n        });\n\n        this._bufferLayoutsCache[key] = vertexBuffersLayout;\n\n        return vertexBuffersLayout;\n    }\n\n    private _updatePipeHash(): void\n    {\n        const key = getGlobalStateKey(\n            this._stencilMode,\n            this._multisampleCount,\n            this._colorMask,\n            this._depthStencilAttachment,\n            this._colorTargetCount,\n        );\n\n        if (!this._pipeStateCaches[key])\n        {\n            this._pipeStateCaches[key] = Object.create(null);\n        }\n\n        this._pipeCache = this._pipeStateCaches[key];\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        this._bufferLayoutsCache = null;\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { type GPUData } from '../../../../scene/view/ViewContainer';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { CanvasPool } from '../../shared/texture/CanvasPool';\nimport { BindGroup } from '../shader/BindGroup';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource';\nimport { blockDataMap, gpuUploadCompressedTextureResource } from './uploaders/gpuUploadCompressedTextureResource';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture, Texture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuTextureUploader } from './uploaders/GpuTextureUploader';\n\n/**\n * Stores GPU-specific data for a Texture instance in WebGL context.\n * @internal\n */\nexport class GPUTextureGpuData implements GPUData\n{\n    public gpuTexture: GPUTexture;\n    public textureView: GPUTextureView = null;\n\n    constructor(gpuTexture: GPUTexture)\n    {\n        this.gpuTexture = gpuTexture;\n    }\n\n    /** Destroys this GPU data instance. */\n    public destroy(): void\n    {\n        this.gpuTexture.destroy();\n        this.textureView = null;\n        this.gpuTexture = null;\n    }\n}\n\n/**\n * The system that handles textures for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    protected CONTEXT_UID: number;\n    private _gpuSamplers: Record<string, GPUSampler> = Object.create(null);\n    private _bindGroupHash: Record<string, BindGroup> = Object.create(null);\n\n    private readonly _uploads: Record<string, GpuTextureUploader> = {\n        image: gpuUploadImageResource,\n        buffer: gpuUploadBufferImageResource,\n        video: gpuUploadVideoResource,\n        compressed: gpuUploadCompressedTextureResource\n    };\n\n    private _gpu: GPU;\n    private _mipmapGenerator?: GpuMipmapGenerator;\n\n    private readonly _renderer: WebGPURenderer;\n    private readonly _managedTextures: GCManagedHash<TextureSource>;\n    /**\n     * @deprecated since 8.15.0\n     */\n    public get managedTextures(): Readonly<TextureSource[]> { return Object.values(this._managedTextures.items); }\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_bindGroupHash');\n        this._managedTextures = new GCManagedHash({\n            renderer,\n            type: 'resource',\n            onUnload: this.onSourceUnload.bind(this),\n            name: 'gpuTextureSource'\n        });\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    /**\n     * Initializes a texture source, if it has already been initialized nothing will happen.\n     * @param source - The texture source to initialize.\n     * @returns The initialized texture source.\n     */\n    public initSource(source: TextureSource): GPUTexture\n    {\n        return (source._gpuData[this._renderer.uid] as GPUTextureGpuData)?.gpuTexture || this._initSource(source);\n    }\n\n    private _initSource(source: TextureSource): GPUTexture\n    {\n        if (source.autoGenerateMipmaps)\n        {\n            const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n\n        if (source.uploadMethodId !== 'compressed')\n        {\n            usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n            usage |= GPUTextureUsage.COPY_SRC;\n        }\n\n        const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n        const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n        const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n\n        const textureDescriptor: GPUTextureDescriptor = {\n            label: source.label,\n            size: { width, height },\n            format: source.format,\n            sampleCount: source.sampleCount,\n            mipLevelCount: source.mipLevelCount,\n            dimension: source.dimension,\n            usage\n        };\n\n        const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n\n        source._gpuData[this._renderer.uid] = new GPUTextureGpuData(gpuTexture);\n\n        const added = this._managedTextures.add(source);\n\n        if (added)\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceResize, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n        }\n\n        this.onSourceUpdate(source);\n\n        return gpuTexture;\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gpuTexture = this.getGpuSource(source);\n\n        // destroyed!\n        if (!gpuTexture) return;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source);\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource): void\n    {\n        if (!this._mipmapGenerator)\n        {\n            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n        }\n\n        const gpuTexture = this.getGpuSource(source);\n\n        this._mipmapGenerator.generateMipmap(gpuTexture);\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        source.off('update', this.onSourceUpdate, this);\n        source.off('resize', this.onSourceResize, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n    }\n\n    protected onSourceResize(source: TextureSource): void\n    {\n        source._gcLastUsed = this._renderer.gc.now;\n\n        const gpuData = source._gpuData[this._renderer.uid] as GPUTextureGpuData;\n        const gpuTexture = gpuData?.gpuTexture;\n\n        if (!gpuTexture)\n        {\n            this.initSource(source);\n        }\n        else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight)\n        {\n            gpuData.destroy();\n            this._bindGroupHash[source.uid] = null;\n            source._gpuData[this._renderer.uid] = null;\n            this.initSource(source);\n        }\n    }\n\n    private _initSampler(sampler: TextureStyle): GPUSampler\n    {\n        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n\n        return this._gpuSamplers[sampler._resourceId];\n    }\n\n    public getGpuSampler(sampler: TextureStyle): GPUSampler\n    {\n        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGpuSource(source: TextureSource): GPUTexture\n    {\n        source._gcLastUsed = this._renderer.gc.now;\n\n        return (source._gpuData[this._renderer.uid] as GPUTextureGpuData)?.gpuTexture || this.initSource(source);\n    }\n\n    /**\n     * this returns s bind group for a specific texture, the bind group contains\n     * - the texture source\n     * - the texture style\n     * - the texture matrix\n     * This is cached so the bind group should only be created once per texture\n     * @param texture - the texture you want the bindgroup for\n     * @returns the bind group for the texture\n     */\n    public getTextureBindGroup(texture: Texture)\n    {\n        return this._bindGroupHash[texture.uid] || this._createTextureBindGroup(texture);\n    }\n\n    private _createTextureBindGroup(texture: Texture)\n    {\n        const source = texture.source;\n\n        this._bindGroupHash[texture.uid] = new BindGroup({\n            0: source,\n            1: source.style,\n            2: new UniformGroup({\n                uTextureMatrix: { type: 'mat3x3<f32>', value: texture.textureMatrix.mapCoord },\n            })\n        });\n\n        return this._bindGroupHash[texture.uid];\n    }\n\n    public getTextureView(texture: BindableTexture)\n    {\n        const source = texture.source;\n\n        source._gcLastUsed = this._renderer.gc.now;\n        let gpuData = source._gpuData[this._renderer.uid] as GPUTextureGpuData;\n        let textureView: GPUTextureView = null;\n\n        if (!gpuData)\n        {\n            this.initSource(source);\n            gpuData = source._gpuData[this._renderer.uid] as GPUTextureGpuData;\n        }\n\n        textureView = gpuData.textureView || gpuData.gpuTexture.createView();\n\n        return textureView;\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const renderer = this._renderer;\n\n        const commandEncoder = renderer.gpu.device.createCommandEncoder();\n\n        // create canvas\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = texture.source.pixelWidth;\n        canvas.height = texture.source.pixelHeight;\n\n        const context = canvas.getContext('webgpu') as unknown as GPUCanvasContext;\n\n        context.configure({\n            device: renderer.gpu.device,\n\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n            format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),\n            alphaMode: 'premultiplied',\n        });\n\n        commandEncoder.copyTextureToTexture({\n            texture: renderer.texture.getGpuSource(texture.source),\n            origin: {\n                x: 0,\n                y: 0,\n            },\n        }, {\n            texture: context.getCurrentTexture(),\n        }, {\n            width: canvas.width,\n            height: canvas.height,\n        });\n\n        renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const webGPUCanvas = this.generateCanvas(texture);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n\n        const context = canvasAndContext.context;\n\n        context.drawImage(webGPUCanvas, 0, 0);\n\n        const { width, height } = webGPUCanvas;\n\n        const imageData = context.getImageData(0, 0, width, height);\n\n        const pixels = new Uint8ClampedArray(imageData.data.buffer);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return { pixels, width, height };\n    }\n\n    public destroy(): void\n    {\n        this._managedTextures.destroy();\n        for (const k of Object.keys(this._bindGroupHash))\n        {\n            const key = Number(k);\n            const bindGroup = this._bindGroupHash[key];\n\n            bindGroup?.destroy();\n        }\n\n        (this._renderer as null) = null;\n        this._gpu = null;\n        this._mipmapGenerator = null;\n        this._gpuSamplers = null;\n        this._bindGroupHash = null;\n    }\n}\n","import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { BindGroupSystem } from './BindGroupSystem';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem';\nimport { type GPU, GpuDeviceSystem } from './GpuDeviceSystem';\nimport { GpuEncoderSystem } from './GpuEncoderSystem';\nimport { GpuLimitsSystem } from './GpuLimitsSystem';\nimport { GpuStencilSystem } from './GpuStencilSystem';\nimport { GpuUboSystem } from './GpuUboSystem';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe';\nimport { PipelineSystem } from './pipeline/PipelineSystem';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem';\nimport { GpuStateSystem } from './state/GpuStateSystem';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\n\nconst DefaultWebGPUSystems = [\n    ...SharedSystems,\n    GpuUboSystem,\n    GpuEncoderSystem,\n    GpuDeviceSystem,\n    GpuLimitsSystem,\n    GpuBufferSystem,\n    GpuTextureSystem,\n    GpuRenderTargetSystem,\n    GpuShaderSystem,\n    GpuStateSystem,\n    PipelineSystem,\n    GpuColorMaskSystem,\n    GpuStencilSystem,\n    BindGroupSystem,\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\n\n/**\n * The default WebGPU systems. These are the systems that are added by default to the WebGPURenderer.\n * @category rendering\n * @standard\n * @interface\n */\nexport type WebGPUSystems = ExtractSystemTypes<typeof DefaultWebGPUSystems> &\nPixiMixins.RendererSystems &\nPixiMixins.WebGPUSystems;\n\n/**\n * The WebGPU renderer pipes. These are used to render the scene.\n * @see {@link WebGPURenderer}\n * @internal\n */\nexport type WebGPUPipes = ExtractSystemTypes<typeof DefaultWebGPUPipes> &\nPixiMixins.RendererPipes &\nPixiMixins.WebGPUPipes;\n\n/**\n * Options for WebGPURenderer.\n * @category rendering\n * @standard\n */\nexport interface WebGPUOptions extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGPUSystems>,\n    PixiMixins.WebGPUOptions{}\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>,\n    WebGPUSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGPU PixiJS Renderer. This renderer allows you to use the next-generation graphics API, WebGPU.\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGPURenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n * ```ts\n * import { autoDetectRenderer } from 'pixi.js';\n * // Create a new renderer\n * const renderer = await autoDetectRenderer();\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGPU renderer:\n *\n * | WebGPU Core Systems                      | Systems that are specific to the WebGL renderer                               |\n * | ---------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link GpuUboSystem}           | This manages WebGPU uniform buffer objects feature for shaders                |\n * | {@link GpuEncoderSystem}       | This manages the WebGPU command encoder                                       |\n * | {@link GpuDeviceSystem}        | This manages the WebGPU Device and its extensions                             |\n * | {@link GpuBufferSystem}        | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link GpuTextureSystem}       | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link GpuRenderTargetSystem}  | This manages what we render too. For example the screen, or another texture   |\n * | {@link GpuShaderSystem}        | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link GpuStateSystem}         | This manages the state of the WebGPU Pipelines. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link PipelineSystem}         | This manages the WebGPU pipelines, used for rendering                         |\n * | {@link GpuColorMaskSystem}     | This manages the color mask. Used for color masking                           |\n * | {@link GpuStencilSystem}       | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link BindGroupSystem}        | This manages the WebGPU bind groups. this is how data is bound to a shader when rendering |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @category rendering\n * @standard\n * @property {GpuUboSystem} ubo - UboSystem instance.\n * @property {GpuEncoderSystem} encoder - EncoderSystem instance.\n * @property {GpuDeviceSystem} device - DeviceSystem instance.\n * @property {GpuBufferSystem} buffer - BufferSystem instance.\n * @property {GpuTextureSystem} texture - TextureSystem instance.\n * @property {GpuRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {GpuShaderSystem} shader - ShaderSystem instance.\n * @property {GpuStateSystem} state - StateSystem instance.\n * @property {PipelineSystem} pipeline - PipelineSystem instance.\n * @property {GpuColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @property {GpuStencilSystem} stencil - StencilSystem instance.\n * @property {BindGroupSystem} bindGroup - BindGroupSystem instance.\n * @extends AbstractRenderer\n */\nexport class WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>\n    implements WebGPUSystems\n{\n    /** The WebGPU Device. */\n    public gpu: GPU;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgpu',\n            type: RendererType.WEBGPU,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,15,16,17,18,19,20,21,22,23,24,25,26,27,28]}